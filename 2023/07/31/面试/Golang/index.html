

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Feng Tao">
  <meta name="keywords" content="">
  
    <meta name="description" content="Golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang">
<meta property="og:url" content="http://example.com/2023/07/31/%E9%9D%A2%E8%AF%95/Golang/index.html">
<meta property="og:site_name" content="胤凯">
<meta property="og:description" content="Golang">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/go.png">
<meta property="article:published_time" content="2023-07-31T07:48:05.000Z">
<meta property="article:modified_time" content="2023-08-07T14:35:30.766Z">
<meta property="article:author" content="Feng Tao">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/go.png">
  
  
  
  <title>Golang - 胤凯</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extension.css">
<link rel="stylesheet" href="/css/test.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"🎉","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"n0H6ZjcwsAdPc2zfOJM4bxV4-gzGzoHsz","app_key":"rwjeQIHfYJqQvjh2iWuPkYev","server_url":"https://n0h6zjcw.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>胤凯</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/test/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/example/">
                <i class="iconfont icon-brush"></i>
                <span>校园生活</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/none.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Golang"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-31 15:48" pubdate>
          2023年7月31日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          298 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Golang</h1>
            
            
              <div class="markdown-body">
                
                <p>Golang<span id="more"></span></p>
<h1 id="基础相关："><a href="#基础相关：" class="headerlink" title="基础相关："></a>基础相关：</h1><h4 id="1、相比于其他语言，Go-有什么优势或者特点？"><a href="#1、相比于其他语言，Go-有什么优势或者特点？" class="headerlink" title="1、相比于其他语言，Go 有什么优势或者特点？"></a>1、相比于其他语言，Go 有什么优势或者特点？</h4><ul>
<li>Go 允许跨平台编译，编译出来的二进制文件，直接部署在对应系统上即可运行</li>
<li>Go 在语言层次上天生支持高并发，通过 goroutine 和 channel 实现。channel 的理论依据是 CSP 并发模型，即所谓的 <code>通过通信来共享内存</code>；Go 在 routime 运行时里实现了属于自己的调度机制：GMP，降低了内核态的用户态的切换成本</li>
<li>GO 的语法简单，代码风格比较统一</li>
</ul>
<h4 id="2、golang-中-make-和-new-的区别？"><a href="#2、golang-中-make-和-new-的区别？" class="headerlink" title="2、golang 中 make 和 new 的区别？"></a>2、golang 中 make 和 new 的区别？</h4><ul>
<li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据。</li>
<li>new 分配返回的是指针，即类型 *Type。make 返回的数据类型本身，即 Type。</li>
<li>new 分配的空间被清零。make 分配空间后，会进行初始化。</li>
</ul>
<blockquote>
<p>new 对于普通类型，会将其值赋值为零值；对于 slice、map、chan 会将其赋值为 nil。</p>
<p>make 会将 slice、map、chan 赋值为零值。</p>
</blockquote>
<h4 id="3、数组和切片的区别，切片怎么扩容？"><a href="#3、数组和切片的区别，切片怎么扩容？" class="headerlink" title="3、数组和切片的区别，切片怎么扩容？"></a>3、数组和切片的区别，切片怎么扩容？</h4><p>区别：</p>
<ul>
<li>数组是值类型，长度固定</li>
<li>切片是引用类型，长度不固定，可以动态扩容。</li>
</ul>
<p>切片扩容：</p>
<ul>
<li>1.17 及以前<ul>
<li>期望容量大于当前容量的两倍，就会直接使用期望容量</li>
<li>如果当前切片的容量小于 1024 就会将容量翻倍</li>
<li>如果当前切片的容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量</li>
</ul>
</li>
<li>1.18 之后<ul>
<li>期望容量大于当前容量的两倍，就会直接使用期望容量</li>
<li>如果当前容量小于 256 就会将容量翻倍</li>
<li>如果当前容量大于等于 256，则根据公式扩容，直至预估容量 &gt;&#x3D; 期望容量</li>
</ul>
</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">扩容公式：<br><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = oldcap + (oldcap + <span class="hljs-number">3</span>*<span class="hljs-number">256</span>) / <span class="hljs-number">4</span> = <span class="hljs-number">1.25</span> * oldcap + <span class="hljs-number">192</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>为什么代码中测试扩容大小和策略对不上？</p>
<p>​	在源码中，有一个 <code>growslice</code> 函数，它就是用来实现上述的扩容机制的，但是这只是一部分，实际上还有更进一步的优化，比如内存对齐等，靠的是 <code>roundupsize</code> 这个函数，在计算完 newcap 这个值之后，还会有一个步骤计算最终的容量。</p>
<p>​	在计算新的容量的时候，<code>roundupsize</code> 这个函数会根据需要扩容的大小和当前切片的容量选择不同的计算方式。（下属描述的大小是指字节，最后的容量大小需要除以 8）【追问再说下面】</p>
<ul>
<li>如果当前容量比较小（小于32760字节），会根据需要扩容的大小计算新的容量，并将其映射到一个固定的大小类别中，再根据类别查找对应的容量</li>
<li>如果当前容量比较大，会采用位运算的方式将需要扩容的大小向上取整到 2 的幂次方，然后乘 2 作为新的容量</li>
</ul>
</blockquote>
<h4 id="4、for-range-的时候，它的地址会发生变化吗？"><a href="#4、for-range-的时候，它的地址会发生变化吗？" class="headerlink" title="4、for range 的时候，它的地址会发生变化吗？"></a>4、for range 的时候，它的地址会发生变化吗？</h4><ul>
<li>地址不会发生改变，但是地址指向的值是变化的，每遍历到一个元素，就把该元素的值写到该地址。</li>
</ul>
<p>追加：for range 循环遍历 slice 有什么问题？</p>
<blockquote>
<p>​	for range 在遍历的时候，它的底层实现是这样：会对原数组进行一次拷贝，<strong>确定其值和长度</strong>，然后遍历数组中每个元素的时候，都会这个值<strong>赋值给同一个临时变量</strong>，所以每次遍历拿到的是同一个地址，但是值不同。</p>
</blockquote>
<ul>
<li>对于 slice 用 for range 遍历不能直接取到每个元素的地址</li>
<li>对于 slice 用 for range 遍历，遍历过程中追加的元素不会遍历到</li>
</ul>
<h4 id="5、defer-底层实现，go-defer，defer-的执行顺序，defer-在什么时机修改返回值？（defer和return），defer-recover-的问题？"><a href="#5、defer-底层实现，go-defer，defer-的执行顺序，defer-在什么时机修改返回值？（defer和return），defer-recover-的问题？" class="headerlink" title="5、defer 底层实现，go defer，defer 的执行顺序，defer 在什么时机修改返回值？（defer和return），defer recover 的问题？"></a>5、defer 底层实现，go defer，defer 的执行顺序，defer 在什么时机修改返回值？（defer和return），defer recover 的问题？</h4><h5 id="5-1-defer底层实现"><a href="#5-1-defer底层实现" class="headerlink" title="5.1 defer底层实现"></a>5.1 defer底层实现</h5><ul>
<li>defer 的底层实现是由很多 _defer 结构组成的链表，defer 函数在注册的时候，创建的 _defer 结构会依次插入到 __defer 链表的表头</li>
<li>在当前函数 return 的时候，依次从 _defer 链表的表头取出 _defer 结构执行里面的 fn 函数，所以执行顺序是 LIFO（先进后出）</li>
</ul>
<h5 id="5-2-defer-的执行顺序"><a href="#5-2-defer-的执行顺序" class="headerlink" title="5.2 defer 的执行顺序"></a>5.2 defer 的执行顺序</h5><ul>
<li>defer 的执行顺序类似于栈，是 LIFO，先调用的 defer 语句后执行。</li>
</ul>
<h5 id="5-3-defer-在什么时机修改返回值"><a href="#5-3-defer-在什么时机修改返回值" class="headerlink" title="5.3 defer 在什么时机修改返回值"></a>5.3 defer 在什么时机修改返回值</h5><ul>
<li>return 的过程可以被分解为以下三步：<ul>
<li>设置返回值</li>
<li>执行 defer 语句</li>
<li>将结果返回</li>
</ul>
</li>
</ul>
<h5 id="5-4-defer-recover"><a href="#5-4-defer-recover" class="headerlink" title="5.4 defer recover"></a>5.4 defer recover</h5><ul>
<li>用 recover 捕获异常时，只能捕获当前 goroutine 的 panic ，不能捕获其他 goroutine 发生的 panic</li>
<li>一个 recover 只能捕获一次 panic，且一一对应</li>
</ul>
<h4 id="6、unit-类型溢出"><a href="#6、unit-类型溢出" class="headerlink" title="6、unit 类型溢出"></a>6、unit 类型溢出</h4><table>
<thead>
<tr>
<th>类型</th>
<th>有无符号</th>
<th>占用存储内存</th>
<th>表述范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>有</td>
<td>32位系统 4个字节<br/>64位系统 8个字节</td>
<td>-2^31 ~ 2^31-1<br />-2^63 ~ 2^63-1</td>
<td></td>
</tr>
<tr>
<td>uint</td>
<td>无</td>
<td>32位系统 4个字节<br />64位系统 8个字节</td>
<td>0 ~ 2^32-1<br />0 ~ 2^64-1</td>
<td></td>
</tr>
<tr>
<td>rune</td>
<td>有</td>
<td>与int32一样</td>
<td>-2^31 ~ 2^31-1</td>
<td>等价于 int32，表示 Unicode 码</td>
</tr>
<tr>
<td>byte</td>
<td>无</td>
<td>与uint8等价</td>
<td>0~255</td>
<td>当要存储字符时选用byte</td>
</tr>
</tbody></table>
<p>uint8 大小为 1 个字节，占 8 位，byte 其实就是 uint8 的别名，uint8 的溢出情况举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">uint8</span> = <span class="hljs-number">255</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span><br>a + b = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>



<h4 id="7、介绍-rune-类型"><a href="#7、介绍-rune-类型" class="headerlink" title="7、介绍 rune 类型"></a>7、介绍 rune 类型</h4><ul>
<li>rune 类型是 Go 语言的一种特殊数字类型。在源码中，它的定义是 <code>type rune = int32</code></li>
<li>官方对它的解释是：rune 是类型 int32 的别名，在所有方面都等价于它，用来区分字符值跟整数值。</li>
<li>使用单引号定义，返回采用 UTF-8 编码的 Unicode 码点。Go语言通过 rune 处理中文，支持国际多语言。</li>
</ul>
<h4 id="8、Go-中两个-Nil-可能不相等吗？"><a href="#8、Go-中两个-Nil-可能不相等吗？" class="headerlink" title="8、Go 中两个 Nil 可能不相等吗？"></a>8、Go 中两个 Nil 可能不相等吗？</h4><blockquote>
<p>​	两个数据要进行比较，首先得明白数据类型，对于两个 nil的比较同样如此，这里主要得注意 interface 类型，因为interface 类型是类型 T 和值 V 二者的综合，只有在类型 T 和 值 V 都相等的的情况下，两个 interface 才相等</p>
</blockquote>
<ul>
<li>Go 中两个 Nil 可能不相等，当一个接口类型的变量为 Nil 和一个非接口类型的变量也为 Nil 的时候，虽然两者都为 Nil，但是却不相等。</li>
</ul>
<h4 id="9、golang-中反射原理是什么？"><a href="#9、golang-中反射原理是什么？" class="headerlink" title="9、golang 中反射原理是什么？"></a>9、golang 中反射原理是什么？</h4><h5 id="9-1解析-tag-是怎么实现的？"><a href="#9-1解析-tag-是怎么实现的？" class="headerlink" title="9.1解析 tag 是怎么实现的？"></a>9.1解析 tag 是怎么实现的？</h5><blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span> <span class="hljs-comment">//名字</span><br>    Age <span class="hljs-type">uint</span> <span class="hljs-string">`key3:&quot;value3&quot;`</span> <span class="hljs-comment">//年龄</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	go 语言中的 tag 就是结构体中的各个字段的一个标签， <code>Tag</code> 本身是一个字符串，它是 <strong>以空格分隔的 key:value 对</strong></p>
<p>​	key：必须是非空字符串，不能包含空格、控制字符、引号、冒号</p>
<p>​	value：以双引号标记的字符串</p>
<p>​	冒号前后不能有空格</p>
<p><strong>&#96;&#96;</strong> 之间的就是一个 tag，一般通过反射来实现。</p>
</blockquote>
<ul>
<li>Go 语言中解析 tag 是通过反射来实现的。</li>
</ul>
<h5 id="9-2-反射的原理"><a href="#9-2-反射的原理" class="headerlink" title="9.2 反射的原理"></a>9.2 反射的原理</h5><ul>
<li>反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力</li>
<li>Go 语言反射是通过接口实现的，通过隐式转换，普通的类型被转换为 inerface 类型，这个过程涉及到类型转换的过程，首先从 Golang 类型转换为 interface 类型，再从 interface 类型转换为反射类型，再从反射类型得到想要的类型和值的信息。</li>
</ul>
<h4 id="10、-go-语言中-struct-能不能比较"><a href="#10、-go-语言中-struct-能不能比较" class="headerlink" title="10、 go 语言中 struct 能不能比较"></a>10、 go 语言中 struct 能不能比较</h4><ul>
<li>对于不同类型的 struct 无法进行比较；而同一个 struct 的两个实例可比较也不比较（struct 包含不可比较类型、指针类型的成员变量执行的内容不可比较、接口类型的动态值不可比较）</li>
<li>在 Go 中，Slice、map、func 无法比较，当一个 struct 的成员是这三个类型中的任意一个，就无法比较，反之可以进行比较。</li>
</ul>
<h4 id="11、结构体打印时，-v-和-v、-v的区别"><a href="#11、结构体打印时，-v-和-v、-v的区别" class="headerlink" title="11、结构体打印时， %v 和 %+v、%#v的区别"></a>11、结构体打印时， <code>%v</code> 和 <code>%+v</code>、<code>%#v</code>的区别</h4><ul>
<li><code>%v</code> 输出结构体各成员的值</li>
<li><code>%+v</code> 输出结构体各成员的名称和值</li>
<li><code>%#v</code> 输出结构体名称和结构体各成员的名称和值</li>
</ul>
<h4 id="12、空-struct-占用空间吗？"><a href="#12、空-struct-占用空间吗？" class="headerlink" title="12、空 struct{} 占用空间吗？"></a>12、空 struct{} 占用空间吗？</h4><blockquote>
<p>可以用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数</p>
<p>fmt.Println(unsafe.Sizeof(struct{}{})) &#x2F;&#x2F; 0</p>
</blockquote>
<ul>
<li>空结构体 struct{} 实例不占据任何内存空间</li>
</ul>
<h4 id="13、go-语言中空-struct-的用途"><a href="#13、go-语言中空-struct-的用途" class="headerlink" title="13、go 语言中空 struct{} 的用途"></a>13、go 语言中空 struct{} 的用途</h4><blockquote>
<p>由于 struct{} 不占空间，于是可以利用空 struct 作为下述各种场景的占位符</p>
<ol>
<li><p>将 map 作为集合（Set）使用，可以将值类型定义为空结构体，仅作为占用符使用即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span></span> Has(key <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>	_, ok := s[key]<br>	<span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span></span> Add(key <span class="hljs-type">string</span>) &#123;<br>	s[key] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span></span> Delete(key <span class="hljs-type">string</span>) &#123;<br>	<span class="hljs-built_in">delete</span>(s, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	s := <span class="hljs-built_in">make</span>(Set)<br>	s.Add(<span class="hljs-string">&quot;Tom&quot;</span>)<br>	s.Add(<span class="hljs-string">&quot;Sam&quot;</span>)<br>	fmt.Println(s.Has(<span class="hljs-string">&quot;Tom&quot;</span>))<br>	fmt.Println(s.Has(<span class="hljs-string">&quot;Jack&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>不发送数据的信道：使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>	&lt;-ch<br>	fmt.Println(<span class="hljs-string">&quot;do something&quot;</span>)<br>	<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(ch)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>	<span class="hljs-keyword">go</span> worker(ch)<br>	ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>	time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>结构体只包含方法，不包含任何的字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>      <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br>      <br><span class="hljs-keyword">type</span> Door <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br>      <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Door)</span></span> Open() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;Open the door&quot;</span>)<br>&#125;<br>      <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Door)</span></span> Close() &#123;<br>	fmt.Println(<span class="hljs-string">&quot;Close the door&quot;</span>)<br>&#125;<br>      <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	d := Door&#123;&#125;<br>	d.Open()<br>	d.Close()<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<ul>
<li>将 map 作为集合（Set）使用，可以将值类型定义为空结构体，仅作为占用符使用</li>
<li>使用在不发送的信道上，使用 channel 不需要发送任何数据，只用来通知子协程执行任何或只用来控制协程并发度</li>
<li>用作接口的实现，结构体只包含方法，不包含任何字段</li>
</ul>
<h4 id="14、go-中-“-”-的作用"><a href="#14、go-中-“-”-的作用" class="headerlink" title="14、go 中 “_” 的作用"></a>14、go 中 “_” 的作用</h4><blockquote>
<p>在不同的场景下的作用不一样，在回答的时候需要凸显出在不同场景下，回答全面</p>
<ol>
<li><p>import 中的下划线</p>
<p>作用：当导入一个包的时候，不需要把所有的包都导入进来，只需要执行使用改包下的文件里所有的init()函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;hello/imp&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	imp.Print() <span class="hljs-comment">//编译报错：undefined:imp</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>下划线在代码中</p>
<p>作用：下划线在代码中是忽略这个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>      <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br>      <br>v1, v2, _ := function(...)<br></code></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<ul>
<li>import 中的下划线用于导入这个包中的所有init函数</li>
<li>代码体中的下划线用于忽略这个变量</li>
</ul>
<h4 id="15、Go-闭包"><a href="#15、Go-闭包" class="headerlink" title="15、Go 闭包"></a>15、Go 闭包</h4><ul>
<li>匿名函数也可以被称为闭包</li>
<li>闭包实际上就是函数 + 引用环境（捕获的变量）</li>
</ul>
<h4 id="16、Go-多返回值怎么实现的？"><a href="#16、Go-多返回值怎么实现的？" class="headerlink" title="16、Go 多返回值怎么实现的？"></a>16、Go 多返回值怎么实现的？</h4><ul>
<li>Go 函数传参是通过 fp + offset 来实现的，而多个返回值也是通过 fp + offset 存储在调用函数的栈帧中</li>
</ul>
<h4 id="17、Go-语言中不能比较的类型如何比较是否相等"><a href="#17、Go-语言中不能比较的类型如何比较是否相等" class="headerlink" title="17、Go 语言中不能比较的类型如何比较是否相等"></a>17、Go 语言中不能比较的类型如何比较是否相等</h4><blockquote>
<p>考察对reflect.DeepEqual的了解：</p>
<p>​	基本类型都可以用 &#x3D;&#x3D; 来比较，但不能涉及不能比较的类型，比如 slice、map等</p>
</blockquote>
<ul>
<li>像 string、int、float、interface 等可以通过reflect.DeepEqual和等号进行比较</li>
<li>像slice、struct、map 则一般使用 reflect.DeepEqual 来检测是否相等</li>
</ul>
<h4 id="18、Go-中-init-函数的特征"><a href="#18、Go-中-init-函数的特征" class="headerlink" title="18、Go 中 init 函数的特征"></a>18、Go 中 init 函数的特征</h4><ul>
<li>每个包下可以有很多个 init 函数，每个文件也可以有很多个 init 函数。多个 init 函数按照它们的文件名顺序（导入顺序）逐个初始化</li>
<li>应用初始时初始化的工作顺序是：从北道荣包的最深层开始进行初始化，层层递出最后到 main 包<ul>
<li>不管包被导入多少次，包内的 init 函数只会执行一次</li>
<li>而且包级别的变量的初始化优于 init 函数的执行</li>
</ul>
</li>
</ul>
<h4 id="19、Go-中-uintptr-和-unsafe-Pointer-的区别"><a href="#19、Go-中-uintptr-和-unsafe-Pointer-的区别" class="headerlink" title="19、Go 中 uintptr 和 unsafe.Pointer 的区别"></a>19、Go 中 uintptr 和 unsafe.Pointer 的区别</h4><blockquote>
<p>考察对 go 语言中指针的了解，go 语言中指针分为普通指针类型，unsafe.Pointer, uintptr（本质不是指针），三者的功能各不相同。</p>
<ol>
<li>*类型：普通指针类型，用于传递对象地址，不能进行指针运算</li>
<li>unsafe.Pointer：通用指针类型，用于转换为不同类型的指针，不能进行指针运算，不能读取内存存储的指（必须转换为某一类型的普通指针）</li>
<li>uintptr：用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象，uintptr 类型的目标会被回收</li>
</ol>
<p>回答 uintptr 和 unsafe.Pointer 的时候，重点突出指针运算上，unsafe.Pointer 用于指针类型转换，不能参与于指针运算，而 uintptr 可以。</p>
</blockquote>
<ul>
<li><p>unsafe.Pointer 是通用指针类型，它不能参与指针运算，任何类型的指针都可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为任意类型的指针</p>
<ul>
<li><p>当我们想让通用指针类型进行转换的时候，就需要 unsafe.Pointer 作为中间指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> b *<span class="hljs-type">float64</span><br>	<span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br>	<span class="hljs-keyword">var</span> c *<span class="hljs-type">int</span> = &amp;a<br>	b = (*<span class="hljs-type">float64</span>)(unsafe.Pointer(c))<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 也可以转换为 uintptr。uintptr 是指针运算的工具，但它不能持有指针对象（它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算的桥梁。</p>
</li>
</ul>
<blockquote>
<p>​	很多人都认为uintptr是个指针，其实不然。不要对这个名字感到疑惑，它只不过是个 uint ，大小与当前平台的指针宽度一致。因为 unsafe.Pointer 可以跟 uintptr 互相转换，所以Go语言中可以把指针转换为 uintptr进行数值运算，然后转换回原类型，以此来模拟C语言中的指针运算。</p>
<p>​	unsafe.Pointer 类似于C语言中的 void*，虽然未指定元素类型，但是本身类型就是个指针。</p>
<p>​	如下例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MemoryPool <span class="hljs-keyword">struct</span> &#123;<br>    memStart <span class="hljs-type">uintptr</span><br>    memEnd   <span class="hljs-type">uintptr</span><br>    next     <span class="hljs-type">uintptr</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMemoryPool</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> *MemoryPool &#123;<br>    mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br>    <span class="hljs-keyword">return</span> &amp;MemoryPool&#123;<br>        memStart: <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;mem[<span class="hljs-number">0</span>])),<br>        memEnd:   <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;mem[size])),<br>        next:     <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;mem[<span class="hljs-number">0</span>])),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *MemoryPool)</span></span> Alloc(size <span class="hljs-type">int</span>) unsafe.Pointer &#123;<br>    <span class="hljs-keyword">if</span> p.next+<span class="hljs-type">uintptr</span>(size) &gt; p.memEnd &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    ptr := unsafe.Pointer(p.next)<br>    p.next += <span class="hljs-type">uintptr</span>(size)<br>    <span class="hljs-keyword">return</span> ptr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pool := NewMemoryPool(<span class="hljs-number">1024</span>)<br>    ptr1 := pool.Alloc(<span class="hljs-number">100</span>)<br>    ptr2 := pool.Alloc(<span class="hljs-number">200</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;ptr1: %p\n&quot;</span>, ptr1)<br>    fmt.Printf(<span class="hljs-string">&quot;ptr2: %p\n&quot;</span>, ptr2)<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h1 id="Context-相关"><a href="#Context-相关" class="headerlink" title="Context 相关"></a>Context 相关</h1><h4 id="1、context-结构体是什么样的？"><a href="#1、context-结构体是什么样的？" class="headerlink" title="1、context 结构体是什么样的？"></a>1、context 结构体是什么样的？</h4><ol>
<li><p>go 语言里的 context 实际上是一个接口，提供了四种方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)  <span class="hljs-comment">// 返回 还有多久到期、是否到期</span><br>Done() &lt;- <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 返回一个 只读channel，当这个 channel 被关闭时，说明这个 context 被取消</span><br>Err() <span class="hljs-type">error</span> <span class="hljs-comment">// 返回 一个错误，表示 channel 被关闭的原因，例如被取消还是超时关闭</span><br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// value 方法返回指定 key 对应的 value，这是 context 携带的值</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>有 emptyCtx、cancelCtx、timerCtx、valueCtx 四种实现</p>
<ul>
<li>emptyCtx：虽然实现了 context 接口，但是不具备任何功能，因为实现很简单，基本是直接返回空值<ul>
<li>我们一般用 context.Background() 和 context.TODO() 都是返回一个 *emptyCtx 的动态类型（通过静态类型 context.Context 传递）</li>
</ul>
</li>
<li>cancelCtx：同时实现 Contex 和 canceler 接口，通过取消函数 cancelFunc 实现退出通知。注意，其退出通知机制不但通知自己，同时也通知其 children 节点<ul>
<li>我们一半调用 context.WithCancel() 就会返回一个 *cancelCtx 和 cancelFunc</li>
</ul>
</li>
<li>timerCtx：timerCtx 是一个实现了 Context 接口的具体类型，其内部封装了 cancelCtx 类型实例，同时也有个 deadline 变量，用来实现定时退出通知<ul>
<li>我们一般调用 context.WithTimeout() 就会返回一个 *timerCtx 和 cancelFunc，不仅可以定时通知，也可以调用 cancelFunc 进行通知</li>
</ul>
</li>
<li>valueCtx：valueCtx 是一个实现了 Context 接口的具体类型，其内部封装了 Context 接口类型，同时也封装了一个 k&#x2F;v 的存储变量，其是一个实现了数据传递的<ul>
<li>我们一般 context.WithValue() 来得到要给 *valueCtx，valueCtx 可以继承它的 parent valueCtx 中的 {key, value}</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2、context-使用场景和用途？"><a href="#2、context-使用场景和用途？" class="headerlink" title="2、context 使用场景和用途？"></a>2、context 使用场景和用途？</h4><ol>
<li><p>context 主要用来 goroutine 之间传递上下文信息，比如传递请求的trace_id，以便追逐全局唯一请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;context&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	traceID := <span class="hljs-string">&quot;12345&quot;</span><br>	ctx := context.WithValue(context.Background(), <span class="hljs-string">&quot;trace_id&quot;</span>, traceID)<br>	fmt.Println(<span class="hljs-string">&quot;Trace ID:&quot;</span>, ctx.Value(<span class="hljs-string">&quot;trace_id&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>另一个用处是可以用来做取消控制，通过取消新信号和超时时间来控制子 goroutine 的退出，防止 goroutine 泄露</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            fmt.Println(<span class="hljs-string">&quot;Worker stopped&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;Working...&quot;</span>)<br>            time.Sleep(time.Second)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    timeout := <span class="hljs-number">5</span> * time.Second<br>    ctx, cancel := context.WithTimeout(context.Background(), timeout)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    <span class="hljs-keyword">go</span> worker(ctx)<br>    time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>包括：取消信号、超时时间、截至时间、k-v 等。</p>
<h1 id="Channel-相关"><a href="#Channel-相关" class="headerlink" title="Channel 相关"></a>Channel 相关</h1><h4 id="1、channel-是否线程安全？锁用在什么地方？"><a href="#1、channel-是否线程安全？锁用在什么地方？" class="headerlink" title="1、channel 是否线程安全？锁用在什么地方？"></a>1、channel 是否线程安全？锁用在什么地方？</h4><p><strong>回答</strong>：</p>
<ol>
<li>是线程安全的，hchan 的底层实现中，hchan 结构体中采用 Mutex 锁来保证数据读写安全。在对循环数组 buf 中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作 channel 数据</li>
</ol>
<h4 id="2、go-channel-的底层数据结构？"><a href="#2、go-channel-的底层数据结构？" class="headerlink" title="2、go channel 的底层数据结构？"></a>2、go channel 的底层数据结构？</h4><p><strong>回答：</strong></p>
<ol>
<li>对于包含缓冲的 channel，go 语言的 channel 底层是一个 hchan 的结构，里面包含一个执行循环数组的指针，这个循环数组就是用来存储数据的。当然还包含下次读取和下次发送数据的索引位置 recvx 和 sendx</li>
<li>还包含两个 goroutine 等待队列，在一个 goroutine 对这个 channel 读写阻塞的时候，会分情况放到这个两个队列里，发送数据阻塞就昂到 sendq 这个队列中，接收数据阻塞就放到 recvq 这个等待队列</li>
<li>为了保证 channel 的线程安全，hchan 结构体还有一个互斥锁，用作数据读写时候加锁，当前 close channel 也会用到这个互斥锁</li>
</ol>
<h4 id="3、nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？"><a href="#3、nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？" class="headerlink" title="3、nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？"></a>3、nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？</h4><p><strong>回答：</strong></p>
<table>
<thead>
<tr>
<th>操作 \ 状态</th>
<th>未初始化（nil）</th>
<th>关闭（close）</th>
<th>正常（normal）</th>
</tr>
</thead>
<tbody><tr>
<td>关闭</td>
<td>panic</td>
<td>panic</td>
<td>正常关闭</td>
</tr>
<tr>
<td>发送</td>
<td>永远阻塞可能导致死锁</td>
<td>panic</td>
<td>阻塞或成功发送</td>
</tr>
<tr>
<td>接收</td>
<td>永远阻塞可能导致死锁</td>
<td>缓冲区为空则为零值，否则可以继续读</td>
<td>阻塞或成功接收</td>
</tr>
</tbody></table>
<h4 id="4、向-channel-发送数据和从-channel-读取数据的流程是什么样的？"><a href="#4、向-channel-发送数据和从-channel-读取数据的流程是什么样的？" class="headerlink" title="4、向 channel 发送数据和从 channel 读取数据的流程是什么样的？"></a>4、向 channel 发送数据和从 channel 读取数据的流程是什么样的？</h4><p><strong>回答：</strong></p>
<ul>
<li>发送时<ul>
<li>如果 channel 的读等待队列存在接收者 goroutine，将数据直接发送给第一个等待的 goroutine，唤醒接收的 goroutine</li>
<li>如果 channel 的读等待队列不存在接收者 goroutine<ul>
<li>如果循环数组 buf 未满，那么将会把数据发送到循环数组 buf 的队尾</li>
<li>如果循环数组 buf 已满，那么这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并挂起等待唤醒</li>
</ul>
</li>
</ul>
</li>
<li>接收时<ul>
<li>如果 channel 的写等待队列存在发送者 goroutine<ul>
<li>如果是无缓冲 channel，直接从第一个发送者 goroutine 那里把数据拷贝给接收变量，唤醒发送的 goroutine</li>
<li>如果是有缓冲 channel（未满），将循环数组 buf 的队首元素拷贝给接收变量</li>
<li>如果是有缓冲 channel（已满），相比于未满会多一步，将第一个发送者 goroutine 的数据拷贝到 buf 循环数组，唤醒发送的 goroutine</li>
</ul>
</li>
<li>如果 channel 的写等待队列不存在发送者 goroutine<ul>
<li>如果循环数组 buf 非空，将循环数组 buf 的队首元素拷贝给接收变量</li>
<li>如果循环数组 buf 为空，这个时候就会走阻塞接受的流程，将当前 goroutine 加入到读等待队列，并挂起等待唤醒</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Map-相关"><a href="#Map-相关" class="headerlink" title="Map 相关"></a>Map 相关</h1><h4 id="1、map-使用的注意点，是否是并发安全的？"><a href="#1、map-使用的注意点，是否是并发安全的？" class="headerlink" title="1、map 使用的注意点，是否是并发安全的？"></a>1、map 使用的注意点，是否是并发安全的？</h4><p><strong>回答：</strong></p>
<ul>
<li>map 不是并发安全的。</li>
<li>如果某个任务正在对 map 进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除），否则会导致进程崩溃</li>
<li>在查找、赋值、遍历、删除的过程中都会检测写标志置位（等于1），则直接 fatal 退出程序。赋值和删除函数在检测完写标志是复位之后，先将写标志位置位，才会进行之后的操作。</li>
</ul>
<h4 id="2、map循环是有序的还是无序的？"><a href="#2、map循环是有序的还是无序的？" class="headerlink" title="2、map循环是有序的还是无序的？"></a>2、map循环是有序的还是无序的？</h4><p><strong>分析：</strong>突出随机桶号和槽位</p>
<p><strong>回答：</strong></p>
<p>​	map 的遍历是无序的，map 每次遍历，都会从一个随机值序号的桶开始，在每个桶中，再按照之前选定的随机槽位开始遍历，所以是无序的。</p>
<p><strong>补充问题：</strong>为什么 go 语言的 map 要这样设计，要随机选定桶号和槽位进行随机遍历？</p>
<p><strong>分析：</strong>突出扩容会带来 key 的位置发生变化</p>
<p><strong>回答：</strong></p>
<p>​	因为 map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 的位置就会发生改变。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大变化。这样，遍历 map 的结构就不可能按原来的顺序了。所以，go 语言强制每次遍历都随机开始。</p>
<h4 id="3、map-如何顺序读取？"><a href="#3、map-如何顺序读取？" class="headerlink" title="3、map 如何顺序读取？"></a>3、map 如何顺序读取？</h4><p><strong>分析：</strong>对 map 的 key 进行排序，然后按照这个排完序之后的 key 从 map 里出对应的数据即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	KeyList := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>	m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>		<span class="hljs-number">3</span>: <span class="hljs-number">200</span>,<br>		<span class="hljs-number">4</span>: <span class="hljs-number">200</span>,<br>		<span class="hljs-number">1</span>: <span class="hljs-number">100</span>,<br>		<span class="hljs-number">8</span>: <span class="hljs-number">800</span>,<br>		<span class="hljs-number">5</span>: <span class="hljs-number">500</span>,<br>		<span class="hljs-number">2</span>: <span class="hljs-number">200</span>,<br>	&#125;<br>	<span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> m &#123;<br>		KeyList = <span class="hljs-built_in">append</span>(KeyList, key)<br>	&#125;<br>	sort.Ints(KeyList)<br>	<span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> KeyList &#123;<br>		fmt.Println(m[key])<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>回答：</strong></p>
<p>​	如果想顺序遍历 map，先把 key 放到切片排序，再按照 key 的顺序遍历 map</p>
<h4 id="4、map-中删除一个-key，它的内存会释放吗？"><a href="#4、map-中删除一个-key，它的内存会释放吗？" class="headerlink" title="4、map 中删除一个 key，它的内存会释放吗？"></a>4、map 中删除一个 key，它的内存会释放吗？</h4><p><strong>分析：</strong></p>
<p>考察 map 中 key 的删除原理，map 删除 key 的时候是根据 hash 值找对对应的槽位，找到对应的 key 删除，将key置为空，并且将对应的 tophash 置为 emptyOne，如果后面没有任何数据了，则再将 emptyOne 状态置为emptyReset 。所以删除一个 key ，只是修改对应内存位置的值，并不会释放内存。</p>
<p><strong>回答：</strong></p>
<p>​	不会释放，删除一个 key，可以认为是标记删除，只是修改 key 对应位置的值为空，并不会释放内存，只有在置空这个 map 的时候，整个 map 的空间才会被垃圾回收后释放。</p>
<h4 id="5、怎么处理对-map-进行并发访问？有没有其他方案？区别是什么"><a href="#5、怎么处理对-map-进行并发访问？有没有其他方案？区别是什么" class="headerlink" title="5、怎么处理对 map 进行并发访问？有没有其他方案？区别是什么"></a>5、怎么处理对 map 进行并发访问？有没有其他方案？区别是什么</h4><p><strong>分析：</strong></p>
<p>使用线程安全的 map，一般有这两种方式：</p>
<ul>
<li>加锁</li>
<li>sync.map</li>
</ul>
<p>​	 性能来说，sync.map 在性能上要优于 map 加锁，因为 sync.map 在底层使用了两个 map，read 和 dirty 来提升性能，对 read 的操作时，原子操作不用加锁 ，只有在对 read 操作不能满足要求时才会加锁操作 dirty，这样就减少了加锁场景，锁竞争频率会减小很多，所以性能会高于单纯的 map 加锁，在回答的时候突出 sync.map 的read 和 dirty，以及锁竞争频率</p>
<p><strong>回答：</strong></p>
<p>​	对 map 进行加读写锁或者是使用 sync.map 这两种方式都可以对 map 进行并发访问</p>
<p>​	和 原始 map + RWLock 的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：它在底层使用了两个 map：read 和 dirty。可以无锁访问 read map，而且会优先操作 read map，倘若之操作 read map 就可以满足要求，那就不用去加锁操作 write map(dirty)，所以在某些特定场景中，它发生锁竞争的频率会远远小于 map + RWLock 的实现方式。</p>
<ul>
<li>优点：适合读多写少的场景</li>
<li>缺点：写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。</li>
</ul>
<h4 id="6、nil-map-和-空-map-有何不同？"><a href="#6、nil-map-和-空-map-有何不同？" class="headerlink" title="6、nil map 和 空 map 有何不同？"></a>6、nil map 和 空 map 有何不同？</h4><p><strong>分析：</strong>考察各种情况下的 map 的读写情况</p>
<p><strong>回答：</strong></p>
<ol>
<li><p>未初始化的 map 为 nil map</p>
<p>a. 往值为 nil 的 map 添加值，会触发 panic</p>
<p>b. 读取值为 nil 的 map，不会报错</p>
<p>c. 删除值为 nil 的 map，不会报错</p>
</li>
<li><p>已经初始化，没有任务元素的 map 为 空map，对 空map 增删改查不会报错</p>
</li>
</ol>
<h4 id="7、map-的数据结构是什么？是怎么实现扩容？"><a href="#7、map-的数据结构是什么？是怎么实现扩容？" class="headerlink" title="7、map 的数据结构是什么？是怎么实现扩容？"></a>7、map 的数据结构是什么？是怎么实现扩容？</h4><h5 id="7-1-数据结构是什么？"><a href="#7-1-数据结构是什么？" class="headerlink" title="7.1 数据结构是什么？"></a>7.1 数据结构是什么？</h5><p><strong>分析：</strong>回答突出 hmap、bmap、tophash，以及溢出指针 overflow</p>
<p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230803192609519.png" srcset="/img/loading.gif" lazyload alt="image-20230803192609519"></p>
<p><strong>回答：</strong></p>
<p>​	map 的底层数组实际上是一个哈希表。在运行时表现为一个指向 hmap 结构体的指针，hmap 中又记录了桶数组指针 buckets，溢出桶指针以及元素个数等字段。每个桶是一个 bmap 的数据结构，可以存储 8 个键值对和 8 个 tophash值以及指向下一个溢出桶的指针 overflow。为了内存紧凑，采用的是先存 8 个 key 过后再存 value。</p>
<h5 id="7-2-map-怎么实现扩容？"><a href="#7-2-map-怎么实现扩容？" class="headerlink" title="7.2 map 怎么实现扩容？"></a>7.2 map 怎么实现扩容？</h5><p><strong>分析：</strong>参考 map 的底层结构体，回答一定要涵盖 <strong>扩容策略</strong>、<strong>扩容时机</strong>、<strong>扩容方式</strong>（渐进式扩容）</p>
<p><strong>回答：</strong></p>
<ul>
<li><strong>扩容时机：</strong> <strong>写时扩容</strong>。向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容<ul>
<li>扩容条件：<ul>
<li>超过负载： map 元素个数 &gt; 6.5（负载因子） * 桶个数，触发双倍扩容</li>
<li>溢出桶太多，触发等量扩容<ul>
<li>当桶数 &lt; 2^15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，则认为溢出桶过多</li>
<li>当桶数 &gt; 2^15 时，如果溢出桶总数 &gt;&#x3D; 2^15，则认为溢出桶过多</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>扩容机制：</strong><ul>
<li>双倍扩容：新建一个 buckets 数组，新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。</li>
<li>等量扩容：并不扩大容量，buckets 数量维持不变，重新做一遍类似双倍扩容 搬迁动作，把松散的键值对重新排列一次，使得同一个 buckets 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</li>
</ul>
</li>
<li><strong>扩容方式：</strong><ul>
<li>扩容过程并不是一次性进行的，而是采用的渐进式扩容，在插入、修改、删除 key 的时候，都会尝试进行搬迁桶的工作，每次都会检查 oldbucket 是否 nil，如果不是 nil，则每次搬迁 2 个桶，蚂蚁搬家一样渐进式扩容</li>
</ul>
</li>
</ul>
<h4 id="8、map-的-key-为什么得是可比较类型的？"><a href="#8、map-的-key-为什么得是可比较类型的？" class="headerlink" title="8、map 的 key 为什么得是可比较类型的？"></a>8、map 的 key 为什么得是可比较类型的？</h4><p><strong>分析：</strong>考察 go 语言中如何通过一个 key 计算得到它在桶中的位置</p>
<ul>
<li><p>第一步：根据 key 来计算出一个 hash 值（64位的，当然与机器位数挂钩）</p>
</li>
<li><p>第二步：根据 hash 值的 低 B 位锁定桶号（找到对应的 bucket）</p>
</li>
<li><p>第三步：接着在桶中找到对应的槽位（根据 hash 值的高 8 位，找到对应的一个 cell）</p>
</li>
<li><p>但是这里会存在一个 hash 冲突的问题，并不是找到了这个槽位，就是当前 key 的位置，因为可能有其他的 key 和这个 key 计算出的 hash 值相同，那么显然槽位也就一样</p>
</li>
<li><p>所以还有第四步：进而比较 key 本身，来获取当前 key 的位置，所以 key 一定要是可比较的</p>
</li>
</ul>
<p><strong>回答：</strong></p>
<ul>
<li>首先 map 的 key、value 是存在 buckets 数组里的，而每个 bucket 又可以容纳 8 个 key 和 8 个 value</li>
<li>当要插入一个新的 key-value 时，会对 key 进行 hash 运算，得到一个 hash 值，然后根据 hash 值的低 B 位来决定命中哪个 bucket<ul>
<li>bucket 数量 &#x3D; 2^B</li>
</ul>
</li>
<li>在命中某个 bucket 后，又会根据 hash 值的高 8 位来决定是 8 个key里的哪个位置。如果不巧，发生了 hash冲突，即该位置上已经有其他 key 存在了，则会去其他空位置寻找插入。如果全满了，则使用 overflow 指针指向一个新的 bucket，重复刚刚的寻找操作。</li>
</ul>
<p>从上面的流程可以看出，在发生 hash 冲突，即该位置是否已经有其他 key 时，肯定是要进行比较的，所以 key 必须得是可比较类型。像 slice、map、function 就不能作为 key。</p>
<h1 id="Sync-map-相关"><a href="#Sync-map-相关" class="headerlink" title="Sync.map 相关"></a>Sync.map 相关</h1><h4 id="1、read-map-什么时候会更新？"><a href="#1、read-map-什么时候会更新？" class="headerlink" title="1、read map 什么时候会更新？"></a>1、read map 什么时候会更新？</h4><p><strong>分析：</strong> 考察 sync.map 的读写原理和设计思想，sync.map 底层采用两个 map：read 和 dirty，来保证 map 的执行效率和线程安全。</p>
<p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230803204551968.png" srcset="/img/loading.gif" lazyload alt="image-20230803204551968"></p>
<p>sync.map 的设计思想：</p>
<ul>
<li>当 dirty 非空时，dirty 要包含整个 map 中的所有有效 key</li>
<li>当 dirty 为空时，则 read 中包含整个 map 中的所有 key，所有的操作都优先只操作 read，操作 read 时不用加锁，用原子操作来保证效率，在操作 read 不能满足的情况下，再进行加锁操作 dirty</li>
<li>对某个 key 在 read 操作时，当整个 key 不存在于 read，去操作 dirty 的时候，会使 misses+1，当 misses 次数大于等于 dirty 长度时，会将 dirty 提升为新的 read，然后把 dirty 置空，misses 清零</li>
</ul>
<p>因为 read 和 dirty 中都保存有对应 key 的指针，所以当这个 key 存在于 read 的时候，要更新这个 key，就会在 read 中进行更新，然后根据这个 key 是否被标记删除，决定是否要同步到 dirty，如果是标记删除的 key，dirty 中不存在，要保证上文 sync.map 设计思想中提到的：当 dirty 非空时，dirty 要包含整个 map 中所有有效 key，在重新写入后，这个 key 会变成有效的，所以要同步到 dirty，如果不是标记删除的，那么这个 key 在dirty 中存在，就不用同步。</p>
<p>Store 更新操作：</p>
<ol>
<li>key 存在于 read中：<ol>
<li>p &#x3D;&#x3D; expunged，更新 read，并加锁同步 dirty</li>
<li>p &#x3D;&#x3D; nil，key 存在于 read，被标记删除，但还没有完成 dirty 的重塑，需要将该 key 更新到 dirty中</li>
<li>p &#x3D;&#x3D; &amp;value，正常更新 read</li>
</ol>
</li>
<li>key 不存在于 read：即为新增操作（只操作dirty）<ol>
<li>dirty 为 nil，根据 read 重建 dirty，将 read 中除 nil 外的所有 key-value 加入到 dirty 中，并把该 key 也加入</li>
<li>dirty 不为 nil，直接插入新的  dirty</li>
</ol>
</li>
</ol>
<p>Load 读操作：</p>
<ol>
<li>先到 read 中读，再到 dirty 中加锁读</li>
<li>读取过程中，如果不存在 read中，但存在 dirty 中，misses+1，若此时 misses 刚好达到 dirty 的长度时，就会重塑 read，拷贝 dirty 的数据到 read 中，将 dirty 提升为 read，并将 dirty 置为 nil</li>
</ol>
<p>Range 遍历：</p>
<ol>
<li>在遍历时，会先判断 read 中的 amended 字段，若该字段为 true ，表示 dirty 中有 read 中 没有的 key，则将 dirty 提升为 read，然后直接遍历 read，这样就避免了 访问 dirty 加锁导致性能下降</li>
<li>若 read 中 amended 为 false，则直接遍历 read 即可</li>
</ol>
<p><strong>回答：</strong></p>
<ul>
<li>delete 和 update 的时候， key 存在于 read，read 会更新</li>
<li>当 misses 次数大于等于 dirty 长度时，会将 dirty 提升为 read，read 会更新</li>
</ul>
<h4 id="2、dirty-map-什么时候会更新？"><a href="#2、dirty-map-什么时候会更新？" class="headerlink" title="2、dirty map 什么时候会更新？"></a>2、dirty map 什么时候会更新？</h4><p><strong>分析：</strong>根据上一个问题的分析，</p>
<ul>
<li>dirty 会在操作 read 不满足时进行操作，</li>
<li>在 dirty 提升为 read 之后，dirty 会被更新为 nil，此时若有一个新的 key 要插入，dirty 也会进行更新，会根据 read 重塑（将 read 中除 nil 外的 key 加入 dirty 中）</li>
</ul>
<p><strong>回答：</strong></p>
<ul>
<li>插入一个新的 key 的时候，会直接插入到 dirty</li>
<li>执行 store 操作的时候，当 read 中存在这个值，dirty 中不存在这个 key 的时候会更新，将这个 key-value 插入到 dirty</li>
<li>delete 的时候，当 read 中没有这个 key，而 dirty 中存在这个 key 的时候，会更新，将这个 key-value 直接从 dirty map 删除</li>
<li>当 misses 数量 大于等于 dirty 长度时，会将 dirty 提升为 read，将 dirty 中的所有 key-value 拷贝到 read 中，然后将 dirty 置为 nil</li>
<li>当 dirty 为 nil 的时候，此时插入一个新的 key，会重塑新的 key，会重塑 dirty，新建一个 dirty map，将 read 中的非 expunged 状态的 key-value copy 到 dirty</li>
</ul>
<h4 id="3、read-map-和-dirty-map-的删除逻辑有什么区别？"><a href="#3、read-map-和-dirty-map-的删除逻辑有什么区别？" class="headerlink" title="3、read map 和 dirty map 的删除逻辑有什么区别？"></a>3、read map 和 dirty map 的删除逻辑有什么区别？</h4><p><strong>分析：</strong>Delete 删除操作：</p>
<ol>
<li>key 只存在于 read 中，直接将 key 对应的 p 设置为 nil</li>
<li>key 只存在 dirty 中，直接在 dirty 中删除该 key</li>
<li>都存在，将 p 设置 nil，这种情况 read 与 dirty 指向一个 p，故都指向 nil</li>
</ol>
<p>回答中突出<strong>标记删除</strong>和直接删除</p>
<p><strong>回答：</strong></p>
<ul>
<li>read 删除是标记删除，并没有在 map 中实际删除这个 key，而只是将这个 key 对应的 value 设置为 nil，等到 misses 大于等于 dirty 长度的时候，将用 dirty 覆盖 read 的时候，才会真正删除这个 key，是延迟删除</li>
<li>dirty 中删除是直接将这个 key 从 dirty 这个 map 中删除掉，是直接删除</li>
</ul>
<h4 id="4、既然在删除-read-的时候没有删除这个-key，而在-dirty-覆盖的时候又只覆盖了-read，那么假如-dirty-中也存在这个-key，这个-key是不是会被遗漏，没有删掉，而导致内存泄漏？"><a href="#4、既然在删除-read-的时候没有删除这个-key，而在-dirty-覆盖的时候又只覆盖了-read，那么假如-dirty-中也存在这个-key，这个-key是不是会被遗漏，没有删掉，而导致内存泄漏？" class="headerlink" title="4、既然在删除 read 的时候没有删除这个 key，而在 dirty 覆盖的时候又只覆盖了 read，那么假如 dirty 中也存在这个 key，这个 key是不是会被遗漏，没有删掉，而导致内存泄漏？"></a>4、既然在删除 read 的时候没有删除这个 key，而在 dirty 覆盖的时候又只覆盖了 read，那么假如 dirty 中也存在这个 key，这个 key是不是会被遗漏，没有删掉，而导致内存泄漏？</h4><p><strong>分析：</strong>对上个问题的补充：</p>
<p>​	因为 read 中 key 只是标记删除了，此时 read 和 dirty 中的 p 指向的是同一个值，此时 dirty 也是标记删除状态，并未删除这个值，真正的删除在后面。当 misses 次数达到 dirty 长度的时候，会将 dirty 提升为 read，在重塑 dirty 的时候，这个 key 对应的 p 会被置为 expunged，后面再次发生 dirty 提升为 read 的时候，会过滤p 的值为 expunged 的 key，就不会存在这个 key 了，就删除成功了。</p>
<p><strong>回答：</strong></p>
<p>​	不会，因为在把 dirty 提升为 read，覆盖完 read 之后，会将 dirty 置为 nil，下一次重塑 dirty 的时候，dirty 中就没有这个 key 了，之后再进行一次 dirty 提升为 read 的时候，read 中的 key 就会被删除了。</p>
<h4 id="5、sync-Map-中的-read-和-dirty-有什么关系？"><a href="#5、sync-Map-中的-read-和-dirty-有什么关系？" class="headerlink" title="5、sync.Map 中的 read 和 dirty 有什么关系？"></a>5、sync.Map 中的 read 和 dirty 有什么关系？</h4><p><strong>分析：</strong>由前面的分析，可知</p>
<ol>
<li>当 dirty 非空时，dirty 要包含整个 map 中的所有有效 key</li>
<li>当 dirty 为空时，则 read 中包含整个 map 中的所有 key，并且在 missess 达到 dirty 长度时，会将 dirty 提升为 read，再置空 dirty。此时有新的 key 插入的时候，又要根据 read 重塑 dirty，所以可以认为 read 和 dirty 互为快照。</li>
</ol>
<p><strong>回答：</strong></p>
<p>read 可以看作是 dirty 的一个快照。</p>
<ul>
<li><p>在 dirty 不为空的时候，dirty 包含 map 中所有有效 key</p>
</li>
<li><p>在 dirty 为空的时候， read 包含 map 中所有有效 key</p>
</li>
<li><p>在read的misses达到dirty的长度的时候，会将dirty提升为read，用dirty中的所有key&#x2F;value覆盖read，之后dirty置<br>为nil</p>
</li>
<li><p>当dirty为nil的时候，插入一个新key，此时会根据read来重塑dirty，将read中非标记删除的key&#x2F;value都<br>copy到dirty</p>
</li>
</ul>
<h4 id="6、sync-Map-中的值是否一定是有效的？"><a href="#6、sync-Map-中的值是否一定是有效的？" class="headerlink" title="6、sync.Map 中的值是否一定是有效的？"></a>6、sync.Map 中的值是否一定是有效的？</h4><p><strong>分析：</strong>在 key 存在于 read 中的时执行删除操作，并不会真正删除这个 key，而是将其 value 置为 nil，标记删除。</p>
<p>​	故 sync.Map 中的 key 还可能是已经删除的状态，回答时突出还可能存在 <strong>标记删除</strong>状态</p>
<p><strong>回答：</strong></p>
<p> 不一定 sync.Map 中的值其实是由 emtry 中的一个 p 指针指向的，p 可能有三种状态，nil、正常值、expunged。</p>
<p>当 p 的状态为 expunged 和 nil 为标记删除状态，表示这个值是被删除了的，并不一定都是有效的。</p>
<h4 id="7、sync-Map-应用场景"><a href="#7、sync-Map-应用场景" class="headerlink" title="7、sync.Map 应用场景"></a>7、sync.Map 应用场景</h4><p><strong>分析：</strong></p>
<p>​	sync.Map 底层采用两个 map：read 和 dirty 来保证 map 的执行效率 和线程安全的。只有在操作 read 的时候是原子操作，不用加锁，执行效率高，在操作 dirty 的时候还是要加锁，所以影响 sync.Map 效率取决于操作 dirty 的频率。在写比较多的场景，要操作 dirty，故应该避免这种写操作。</p>
<p>​	故突出 <strong>读多写少</strong>这种场景</p>
<p><strong>回答：</strong></p>
<p>​	sync.Map 是适用于读多、更新多、删多、写少的情况。</p>
<blockquote>
<p>我们期望更多的流量在 read map 这一层拦截，从而避免加锁访问 dirty map</p>
<p>对于更新、删除、读取，read map 可以尽量通过一些原子操作，让整个操作变得无锁化，这样就可以避免进一步加锁访问 dirty map</p>
<p>倘若写操作过多，sync.Map 基本等价于一把互斥锁 + map</p>
</blockquote>
<h1 id="GMP-相关"><a href="#GMP-相关" class="headerlink" title="GMP 相关"></a>GMP 相关</h1><h4 id="1、什么是-GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）"><a href="#1、什么是-GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）" class="headerlink" title="1、什么是 GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）"></a>1、什么是 GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）</h4><h5 id="1-1-什么是GMP？"><a href="#1-1-什么是GMP？" class="headerlink" title="1.1 什么是GMP？"></a>1.1 什么是GMP？</h5><p><strong>分析：</strong> gmp 模型是 go 语言中的协程调度模型</p>
<p><strong>GMP 简单介绍</strong></p>
<p>G：Goroutine</p>
<p>M：内核线程，每个 m 都有 1 个特殊的协程 g0，这个 g0 主要负责协程调度和切换，goroutine 只有绑定到 m 上才能正常运行</p>
<p>P：逻辑处理器 Processor ，包含 goroutine 本地队列，队列长度为 256，当有 goroutine 要创建时，会被添加到 P 的本地队列上，如果 P 的本地队列已满，则会维护到全局队列里</p>
<p><strong>P 和 M 的创建时机</strong></p>
<p>P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p>
<p>M 何时创建：没有足够的 M 来关联 P 并允许其中可允许的 G时。比如所有的 M 此时都阻塞了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p>
<p><strong>回答：</strong></p>
<p>​	GMP 是 Go 语言协程调度模型，G 代表 Goroutine，M 代表内核线程，P 代表逻辑处理器，P 中包含本地队列 G，G 通过 P 绑定到 M，才能真正运行</p>
<h5 id="1-2-调度过程是怎样的？"><a href="#1-2-调度过程是怎样的？" class="headerlink" title="1.2 调度过程是怎样的？"></a>1.2 调度过程是怎样的？</h5><p><strong>分析：</strong></p>
<p>​	上面回答了 GMP 是 Go 语言的协程调度模型，这个问题是对上一个问题的补充提问，进一步回答协程怎样调度的。协程的调度是一个很复杂的过程，既然是调度，肯定设计到协程的上下文切换、调度策略、调度时机以及调度过程。</p>
<p><strong>协程的上下文切换：</strong></p>
<p>​	协程的调度主要是发生在 Goroutine 和 g0 之间</p>
<p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230804211222878.png" srcset="/img/loading.gif" lazyload alt="image-20230804211222878"></p>
<p>​	协程经过 g —-&gt; g0 —-&gt; g 的过程就完成了一次调度循环，一次协程调度过程跟线程调度一样，也会发生协程的上下文切换，同样需要保存协程的执行现场，这样才能够切回 g，接着上一次继续执行。</p>
<p>​	协程的执行现场主要是几个寄存器的值，分别是 rsp、rip、rbp。</p>
<p>rsp：指向函数调用的栈顶</p>
<p>rip：指向程序要指向的下一条指令</p>
<p>rbp：存储函数栈帧的起始地址</p>
<p>​	这些寄存器主要保存在 goroutine 的 sched 这个字段结构中，goroutine 的结构如下：</p>
<p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230804211709507.png" srcset="/img/loading.gif" lazyload alt="image-20230804211709507"></p>
<p><strong>调度策略：</strong></p>
<p>​	协程的调度过程可以认为是 m 寻找一个可以运行的 g 来运行的过程：</p>
<ul>
<li>优先从 P 的本地队列获取 goroutine 来执行；</li>
<li>如果本地队列没有，从全局队列获取</li>
<li>如果全局队列也没有，从网络轮询器重查找是否有 Goroutine 等待运行</li>
<li>如果还是没有，则会从其他的 P 上偷取 goroutine</li>
</ul>
<p>​	上述调度策略有一个问题：如果本地队列一直有 g 的话，那么全局队列的 g 可能完全没有机会执行？</p>
<ul>
<li>所以，Go 的调度器在每执行 61 次调度，就会优先从全局队列中获取一个 g 放到当前 p 队列。</li>
<li>如果本地队列已经满了，无法从全局运行队列调用并放入怎么办？<ul>
<li>此时调度器会将本地运行队列的一半放入全局队列。这保证了当程序中有很多协程时，每个协程都有执行的机会</li>
</ul>
</li>
</ul>
<p><strong>调度模式：</strong></p>
<p>​	调度模式一般有两种，抢占式 和 协作式。</p>
<ul>
<li>协作式调度：依靠被调度方主动弃权</li>
<li>抢占式调度：依靠调度器强制将被调度方被动中断</li>
</ul>
<p><strong>发生调度的时机：</strong></p>
<ul>
<li>等待读取或写入未缓冲的通道</li>
<li>由于 time.Sleep() 而等待</li>
<li>等待互斥量是否</li>
<li>发生系统调用</li>
</ul>
<p><strong>回答：</strong></p>
<p>​	协程在刚创建的时候，会优先加到当前 p  的本地队列中，等待被调度。</p>
<ul>
<li>当这个 p 队列满了的时候，本地队列满了时，会将本地队列的一半 G 和新创建的 G 打乱顺序，一起放入全局队列。</li>
</ul>
<p>​	每个 m 都有一个特殊的协程 g0 负责调度工作，每一轮调度的过程是这样的：M 优先执行其所绑定的 P 的本地运行队列中的 G，</p>
<ul>
<li><p>如果本地队列没有 G，则会从全局队列获取，为了提高效率和负载均衡，会从全局队列获取多个 G，而不是只取一个</p>
</li>
<li><p>当全局队列没有时，会从其他 M 的 P 上偷取 G 来运行，偷取的个数通常是其他 P 运行队列的一半</p>
</li>
<li><p>如果还没有获取到 g，则 m 就处于自旋状态（自旋状态就是当前 M 会一直尝试去全局、其他队列获取 G）</p>
</li>
</ul>
<h4 id="2、GMP-能不能去掉-P-层，为什么？"><a href="#2、GMP-能不能去掉-P-层，为什么？" class="headerlink" title="2、GMP 能不能去掉 P 层，为什么？"></a>2、GMP 能不能去掉 P 层，为什么？</h4><p><strong>分析：</strong> 考察对 P 的作用的理解。在起初的时候，是单纯的 GM 模型，是没有 P 的，为什么会被弃用呢？假设没有 P 的话，也就没有本地p 的 g队列，则所有的 M 都会去全局队列获取 g，这样势必<strong>有锁竞争问题</strong>，所以回答的时候抓住这个点分析即可</p>
<p><strong>回答：</strong></p>
<ul>
<li>每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争</li>
<li>每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法。如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源的利用率。</li>
</ul>
<h4 id="3、M-和-P-的数量问题？"><a href="#3、M-和-P-的数量问题？" class="headerlink" title="3、M 和 P 的数量问题？"></a>3、M 和 P 的数量问题？</h4><p><strong>分析：</strong></p>
<p>​	其实是上一个问题的补充问题，考察对 gmp 模型的了解深部深入</p>
<p><strong>回答：</strong> </p>
<p><strong>P 的数量：</strong></p>
<p>​	由启动时环境变量 <code>$GOMAXPROCS</code> 或者由<code>runtime</code> 的方法<code>GOMAXPROCS()</code> 决定</p>
<p><strong>M 的数量：</strong></p>
<p>​	go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000。</p>
<p>​	但是内核很难支持这么多的线程数 runtime&#x2F;debug 中的 SetMaxThreads 函数，设置 M 的最大数量</p>
<p>​	一个 M 阻塞了，会创建新的 M。</p>
<p><strong>G 的数量：</strong></p>
<p>​	理论上没有限制，受限于内存，但是 goroutine 过多会影响程序性能</p>
<h4 id="4、进程、线程、协程-有什么区别？"><a href="#4、进程、线程、协程-有什么区别？" class="headerlink" title="4、进程、线程、协程 有什么区别？"></a>4、进程、线程、协程 有什么区别？</h4><p><strong>分析：</strong> </p>
<p>​	进程、线程、协程都是并发单元，但是具体又有不同，在分析三者区别的时候，可以从大小、调度、资源分配以及用户态或者是内核态等几个方面进行分析</p>
<p><strong>回答：</strong></p>
<p>​	进程可以理解为一个动态的程序，进程是操作系统分配的基本单位。</p>
<p>​	线程是操作系统调度的基本单位，进程独占一个虚拟内存空间，而进程里的线程共享一个进程虚拟内存空间。线程的粒度更小，一个进程可以有多个线程。</p>
<p>​	协程可以理解为用户态线程，跟线程的区别主要有三个方面：</p>
<ol>
<li>大小：协程大小为 2 k，可以动态扩容，而线程大小为 2 m，协程更轻量</li>
<li>切换成本：线程切换需要用户态到内核态的切换，而协程的切换不用，只在用户态完成，线程切换需要保存各种寄存器，而协程切换只需要保存 rsp、rip、rbp 三个寄存器，协程切换消耗更小</li>
<li>调度：线程的调度由操作系统完成，而协程的调度由运行时的调度器完成</li>
</ol>
<h4 id="5、抢占式调度如何抢占的？"><a href="#5、抢占式调度如何抢占的？" class="headerlink" title="5、抢占式调度如何抢占的？"></a>5、抢占式调度如何抢占的？</h4><p><strong>分析：</strong> 考察对 go 语言的协程调度方式的了解，	调度模式一般有两种：抢占式 和 协作式。</p>
<ul>
<li>协作式调度：在一定情况下，使用权会被抢占</li>
<li>抢占式调度：会主动让渡使用权</li>
</ul>
<p>​	Go 语言的调度方式都是抢占式的，但是在 Go1.14之前 和 Go1.14 之后的具体抢占策略实现又有所不同，本题在回答的时候，要注意区分 go 的版本，对 Go1.14 之前 和 Go1.14之后的抢占策略熟悉，并且分析出 Go1.14 之后的抢占策略的优势</p>
<p><strong>Go 语言调度方式：</strong></p>
<p>​	Go 语言的调度模式在 Go1.14 之前是基于协作的抢占式调度，在 Go1.14及以后实现了基于信号的抢占式调度（异步抢占）</p>
<p><strong>Go1.14 之前：</strong></p>
<p>​	协作式调度就是 m 会主动让渡出 p，让 p 可以与其他的 m 绑定，以下情况会发生这种主动让渡（协作调度）：</p>
<ul>
<li>同一个 goroutine 运行超过 10 ms</li>
</ul>
<p>​	而下面情况下会发生抢占：</p>
<p>​	抢占的原理：</p>
<p>​	Go 会启动一个线程，一直运行着 “sysmon” 函数，该函数实现了抢占式调度（以及其他诸如使网络处理的等待状态变为非阻塞状态）的功能。sysmon 运行在 M （Machine，实际上是一个系统线程），且不需要 P（Processor）</p>
<p>​	当 sysmon 发现 M 已运行同一个（Goroutine） 10ms 以上，它会将该 G 的内部参数 <code>preemep</code> 设置为 true</p>
<p>​	当 G 进行函数调用时，G 会检查自己的 <code>preempt</code> 标志，如果它为 true，则它将自己与 M 分离并推入 goroutine 的全局队列，抢占完成。</p>
<p>​	但是通过上述过程可以看到，要发生抢占，有 1 个前提：那就是发生函数调用，如果没有函数调用，即使设置了抢占标志，也不会进行该标志的检查，自然也就不会执行抢占过程。所以下述代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">go</span> fmt.Println(<span class="hljs-string">&quot;hi&quot;</span>)<br>	<span class="hljs-keyword">for</span> &#123;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	设置单核情况下，在 go1.14之前，这个代码将正常运行，被阻塞住，因为不会发生调度，for 循环这个死循环不是函数调用，所以 <code>preempt</code> 标志检查这个阶段，不会发生抢占式调度，这个 goroutine 不会被抢占，一直阻塞。</p>
<p><strong>Go 1.14 之后</strong></p>
<p>​	sysmon 会检查到运行了 10ms 以上的  G。然后 sysmon 向运行 G 的 P 发送信号（SIGURG）。Go 的信号处理程序会调用 P 上的一个叫做 gsignal 的 goroutine 来处理该信号，将其映射到 M 而不是 G，并使其检查该信号。gsignal 看到抢占信号，停止正在运行的 G。</p>
<p>​	由于次机制会显示发出信号，因此无需调用函数，就能将正在运行死循环的 goroutine 切换到另一个 goroutine</p>
<p>​	通过使用信号的异步抢占机制，上面的代码现在就可以按预期工作。<code>GODEBUG=asyncpreemtpoff=1</code> 可用于禁用异步抢占。</p>
<p><strong>回答：</strong></p>
<p>​	<strong>Go1.14 之前是协作式抢占</strong>，Go 会启动一个线程，一直运行着 “sysmon” 函数，该函数实现了抢占式调度（以及其他注入使网络处理的等待状态转变为非阻塞状态）的功能。sysmon 运行在 M（Machine，实际上是一个系统线程），且不需要 P（Processor）</p>
<p>​	当 sysmon 发现 M 已经运行同一个 G 10ms 以上时，它会将该 G 的内部参数 <code>preempt</code> 设置为 true</p>
<p>​	当 G 进行函数调用时， G 会检查自己的 <code>preempt</code> 标志，如果它会 true，则它将自己与 M 分离并推入 goroutine 的全局队列，抢占完成</p>
<p>​	<strong>Go1.14之后是异步式抢占，基于信号</strong>：sysmon 会检测到运行了 10ms 以上的 G(goroutine)。然后 sysmon 向运行 G 的 P 发送信号（SIGURG）。Go 的信号处理程序会调用 P 上的一个叫做 gsignal 的 goroutine 来处理该信号，将其映射到 M 而不是 G，并使其检查该信号。gsignal 看到抢占信号，停止运行正在运行的 G。</p>
<p>​	基于信号量的抢占可以防止类似死循环这种没有发生函数调用的 goroutine 一直占用 CPU 导致程序阻塞，提高了程序的合理性。</p>
<h1 id="Sync-相关："><a href="#Sync-相关：" class="headerlink" title="Sync 相关："></a>Sync 相关：</h1><h4 id="1、除了-mutex-以外，还有哪些方式可以安全读写共享内存？"><a href="#1、除了-mutex-以外，还有哪些方式可以安全读写共享内存？" class="headerlink" title="1、除了 mutex 以外，还有哪些方式可以安全读写共享内存？"></a>1、除了 mutex 以外，还有哪些方式可以安全读写共享内存？</h4><p><strong>分析：</strong></p>
<p>​	考察 Go 语言中数据竞争的解决方案，在  Go 语言中有锁，信号量还有channel 三种实现方式，回答的时候出现信号量以及 channel 关键字</p>
<ol>
<li><p><strong>用信号量实现互斥功能</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;context&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;golang.org/x/sync/semaphore&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">()</span></span> &#123;<br>	num++<br>	fmt.Println(<span class="hljs-string">&quot;num is &quot;</span>, num)<br>	time.Sleep(time.Millisecond * <span class="hljs-number">50</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> (<br>	Limit  = <span class="hljs-number">1</span><br>	Weight = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	s := semaphore.NewWeighted(Limit)<br>	<span class="hljs-keyword">var</span> w sync.WaitGroup<br>	w.Add(<span class="hljs-number">10</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			s.Acquire(context.Background(), Weight)<br>			Add()<br>			s.Release(Weight)<br>			w.Done()<br>		&#125;()<br>	&#125;<br>	w.Wait()<br>	fmt.Println(<span class="hljs-string">&quot;end...&quot;</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 channel 实现互斥功能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>	num++<br>	fmt.Println(<span class="hljs-string">&quot;num is &quot;</span>, num)<br>	time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> w sync.WaitGroup<br>	w.Add(<span class="hljs-number">10</span>)<br>	chanLock := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			chanLock &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>			add()<br>			&lt;-chanLock<br>			w.Done()<br>		&#125;()<br>	&#125;<br>	w.Wait()<br>	fmt.Println(<span class="hljs-string">&quot;end... &quot;</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>mutex 实现互斥</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>	num++<br>	fmt.Println(<span class="hljs-string">&quot;num is &quot;</span>, num)<br>	time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> w sync.WaitGroup<br>	w.Add(<span class="hljs-number">10</span>)<br>	m := sync.Mutex&#123;&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			m.Lock()<br>			add()<br>			m.Unlock()<br>			w.Done()<br>		&#125;()<br>	&#125;<br>	w.Wait()<br>	fmt.Println(<span class="hljs-string">&quot;end... &quot;</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>回答：</strong></p>
<ul>
<li>将共享变量的读写放到一个 goroutine，其它 goroutine 通过 channel 进行读写操作</li>
<li>可以用个数为 1 的信号量（semaphore）实现互斥</li>
<li>通过 Mutex 锁实现</li>
</ul>
<h4 id="2、Go-如何实现原子操作"><a href="#2、Go-如何实现原子操作" class="headerlink" title="2、Go 如何实现原子操作"></a>2、Go 如何实现原子操作</h4><p><strong>分析：</strong></p>
<p>​	回答时突出 Go 语言实现的原子操作在 sync&#x2F;atomic 包下，提供了 store、add 等方法</p>
<p><strong>回答：</strong></p>
<p>​	原子操作是一组不可中断的指令序列，由底层硬件支持，Go 语言的原子操作由 sync&#x2F;atomic 包提供，主要提供了下面的一些方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddT</span><span class="hljs-params">(addr *T, delta T)</span></span>(<span class="hljs-built_in">new</span> T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Store</span><span class="hljs-params">(addr *T, val T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadT</span><span class="hljs-params">(adr *T)</span></span>(val T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapT</span><span class="hljs-params">(addr *T, <span class="hljs-built_in">new</span> T)</span></span>(old T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwap</span><span class="hljs-params">(addr *T, old, <span class="hljs-built_in">new</span> T)</span></span>(swapped <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure>

<h4 id="3、原子操作和锁的区别"><a href="#3、原子操作和锁的区别" class="headerlink" title="3、原子操作和锁的区别"></a>3、原子操作和锁的区别</h4><p><strong>分析：</strong></p>
<p>​	二者都可以用来保证线程安全，但是二者在实现原理和使用方式上都存在很大的区别。</p>
<p>​	可以从二者的实现方式、作用范围、使用场景以及锁类型等几个方面来分析</p>
<p><strong>回答：</strong></p>
<p>​	原子操作由底层硬件支持，而锁是基于原子操作 + 信号量完成的。若实现相同的功能，前者通常会更有效率</p>
<p>​	原子操作是单个指令的互斥操作；</p>
<p>​	互斥锁&#x2F;读写锁是一种数据结构，可以完成临界区（多个指令）的互斥操作，扩大原子操作的范围</p>
<p>​	原子操作是无锁操作，属于乐观锁；说起锁的时候，一般属于悲观锁</p>
<h4 id="4、Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"><a href="#4、Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？" class="headerlink" title="4、Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"></a>4、Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</h4><p><strong>分析：</strong></p>
<p>​	先明确什么是悲观锁、乐观锁：</p>
<ul>
<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作</li>
<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</li>
</ul>
<p>​	然后显然 Mutex 是悲观锁。</p>
<p><strong>回答：</strong></p>
<p>​	悲观锁和乐观锁是两种锁的思想，乐观锁假定别人不会修改数据。在操作数据的时候，查看一下数据，然后修改完真正生效的时候查看一下数据有没有发生变化，如果发生变化，则认为数据被修改，有并发问题，放弃操作，否则执行操作。而悲观锁就是时时刻刻认为有其他操作者修改数据，每次操作数据的时候，都尝试把数据锁住，在操作期间其他人不能修改数据，直至锁被释放。</p>
<p>​	Mutex 是悲观锁，Go sync 包提供了两种锁类型：互斥锁 sync.Mutex 和 读写锁 sync.RWMutex，都是属于悲观锁</p>
<h4 id="5、互斥锁-Mutex-底层是怎么实现的？"><a href="#5、互斥锁-Mutex-底层是怎么实现的？" class="headerlink" title="5、互斥锁 Mutex 底层是怎么实现的？"></a>5、互斥锁 Mutex 底层是怎么实现的？</h4><p><strong>分析：</strong></p>
<p>​	Mutex 的底层定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>	state <span class="hljs-type">int32</span> <span class="hljs-comment">// int32 类型，表示锁状态，例如是否被锁定</span><br>	sema <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>明确各个字段的含义以及作用：</p>
<p>​	state 是 32 位的整型变量，内部实现是把它分成了四份，用来记录 Mutex 的四种状态。Mutex 的内部布局</p>
<p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230805215842607.png" srcset="/img/loading.gif" lazyload alt="image-20230805215842607"></p>
<ul>
<li>Waiter：表示阻塞等待锁的线程个数，协程解锁时根据此值判断释放需要释放信号量</li>
<li>Starving：表示该 Mutex 是否处于饥饿状态，0：正常状态，1：饥饿状态，说明有协程阻塞超过 1 ms</li>
<li>Woken：表示是否有协程已被唤醒，0：没有协程唤醒，1：已有协程唤醒，正在加锁过程中</li>
<li>Locked：表示该 Mutex 是否被锁定，0：没有锁定，1：已被锁定</li>
</ul>
<p>​	sema 是一个 uint32 类型的整型，用于协程排队和唤醒，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待这个信号量的协程</p>
<p><strong>回答：</strong></p>
<p>​	mutex 底层是通过原子操作加信号量来实现的，通过 atomic 包中的一些原子操作来实现锁的锁定，通过信号量来实现协程的阻塞与唤醒</p>
<h4 id="6、Mutex-有几种模式？"><a href="#6、Mutex-有几种模式？" class="headerlink" title="6、Mutex 有几种模式？"></a>6、Mutex 有几种模式？</h4><p><strong>分析：</strong></p>
<p>​	对上一个问题的补充，通过 state 字段的倒数第三位 Starving 可以判断除锁释放处于饥饿模式。所以锁有两种模式：饥饿模式和正常模式。在不同模式下，获取锁的方式有所不同。</p>
<p><strong>回答：</strong></p>
<p>​	在正常模式下，锁的等待着会按照先进先出的顺序来获取锁，但是刚被唤醒的 Goroutine 与刚被创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的锁会被放入到等待队列的队首。如果一个等待的 Goroutine 超过 1ms 没有获取到锁，那么会将锁转变为饥饿模式。————不公平</p>
<p>​	在饥饿模式下，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁，也不会进入自旋状态尝试获取锁，它们会加入到等待队列的末尾。如果一个 GOroutine 获得了互斥锁并且它是处在队列的末尾或它获得锁之前等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。——–公平</p>
<h4 id="7、在-Mutex-上的自旋的-Goroutine-会占用太多资源吗？"><a href="#7、在-Mutex-上的自旋的-Goroutine-会占用太多资源吗？" class="headerlink" title="7、在 Mutex 上的自旋的 Goroutine 会占用太多资源吗？"></a>7、在 Mutex 上的自旋的 Goroutine 会占用太多资源吗？</h4><p><strong>分析：</strong></p>
<p>​	自旋状态：当一个线程在获取锁的时候，如果锁已经被其他线程获取了，那么该线程将循环等待，然后不断地判断释放能否成功获取，知道获取到锁才会退出循环。</p>
<p>​	从这里看出 goroutine 的自旋状态会消耗 CPU 资源，导致 CPU 一定时间的空转。所以长时间处于自旋状态肯定是不合理的。故自旋状态一定要满足一定的条件：</p>
<ul>
<li>次数不能过多</li>
<li>锁不能处于饥饿模式，不然其他 goroutine 很难获取到锁</li>
<li>处理器的个数，比如单核下自旋是没有意义的，因为同时只有一个线程可以运行，要获取锁只能等待当前线程释放，自旋自然没有意义</li>
</ul>
<p><strong>回答：</strong></p>
<p>​	goroutine 自旋要满足一定条件：</p>
<ul>
<li>自旋次数没有超过 4 次</li>
<li>锁已被占用，并锁不处于饥饿模式</li>
<li>多核处理器</li>
<li>GOMAXPROCS &gt; 1</li>
<li>p 上本地的 goroutine 队列为空</li>
</ul>
<p>​	mutex 会让当前的 goroutine 去空转 CPU，在空转完后再调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终进入 等待队列里，结束自旋</p>
<h4 id="8、读写锁是怎么实现的？"><a href="#8、读写锁是怎么实现的？" class="headerlink" title="8、读写锁是怎么实现的？"></a>8、读写锁是怎么实现的？</h4><p><strong>分析：</strong><br>    读写锁的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>	w           Mutex  <span class="hljs-comment">// 复用互斥锁</span><br>	writerSem   <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，用于写等待读</span><br>	readerSem   <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，用于读等待写</span><br>	readerCount <span class="hljs-type">int32</span>  <span class="hljs-comment">// 当前正在啊hi下的读操作 goroutine 数量</span><br>	readerWait  <span class="hljs-type">int32</span>  <span class="hljs-comment">// 写协程等待完成的读协程的数量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	从定义可以看出，读写锁里面有一个互斥锁 Mutex 存在，所以在实现上一定会基于 mutex，但是多余了其余的一些字段，用于记录读锁加锁次数，当前正在读的 goroutine 数量，以及写阻塞时等待完成的读 goroutine 数量。</p>
<p>​	加锁过程：</p>
<ul>
<li>加读锁：<ul>
<li>若锁处于空闲状态，那么直接获取读锁</li>
<li>若有协程持有锁，那么无法获取锁，当前 goroutine 空闲</li>
</ul>
</li>
<li>加写锁：<ul>
<li>获取写锁需要用到 mutex 和 readerWait，首先获取成功之后，若 readerWait 大于 0，此时 goroutine 占用了读锁，那么加写锁阻塞，</li>
<li>若没有 goroutine 占用读锁，加写锁成功</li>
</ul>
</li>
</ul>
<p>​	解锁过程：</p>
<ul>
<li>释放读锁：<ul>
<li>直接释放读锁；若有 goroutine 等待加读锁，则在释放读锁之后会将 readerWait 减 1；当 readerWait 减到 0 时，就唤醒被阻塞的写操作的 goroutine 了</li>
<li>修改 readerCount 值为正，解除互斥，然后唤醒所有的读 goroutine，最后释放互斥锁 mutex</li>
</ul>
</li>
</ul>
<p><strong>回答：</strong></p>
<p>​	读写锁是基于互斥锁实现的，这个互斥锁被读写共享，但是通过 readerWait、readerCount 进行控制。</p>
<p>​	readerWait 大于 0 时会阻塞加写锁，当 readerCount 为负时，锁处于互斥状态。</p>
<ul>
<li>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞</li>
<li>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞</li>
<li>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞</li>
<li>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以有用读锁</li>
</ul>
<h4 id="9、Mutex-以及被一个-Goroutine-获取了，等待它中的-Goroutine-们只能一直等待。那么等这个锁释放后，等待中的-Goroutine-中哪一个会优先获取-Mutex？"><a href="#9、Mutex-以及被一个-Goroutine-获取了，等待它中的-Goroutine-们只能一直等待。那么等这个锁释放后，等待中的-Goroutine-中哪一个会优先获取-Mutex？" class="headerlink" title="9、Mutex 以及被一个 Goroutine 获取了，等待它中的 Goroutine 们只能一直等待。那么等这个锁释放后，等待中的 Goroutine 中哪一个会优先获取 Mutex？"></a>9、Mutex 以及被一个 Goroutine 获取了，等待它中的 Goroutine 们只能一直等待。那么等这个锁释放后，等待中的 Goroutine 中哪一个会优先获取 Mutex？</h4><p><strong>回答：</strong><br>    对第 7 题的补充，通过第 7 题分析我们知道：在正常模式和饥饿模式下获取锁的策略是不同的，所以在回答的时候也要分为两种情况来回答：</p>
<ul>
<li>在饥饿模式下，新加入的 goroutine 不会获取锁，而是加入获取锁的 goroutine 队列排队，所以排在最前面的 goroutine 会优先获取锁</li>
<li>在正常模式下，则是新请求的 goroutine 更容易获取锁，为什么呢？可以联想到资源占用，新请求的 goroutine 正在 CPU 上运行，占用着 CPU 资源，更容易抢锁成功</li>
</ul>
<p><strong>回答：</strong></p>
<ul>
<li>正常模式下，当一个 Goroutine 获取到锁之后，其他的 Goroutine 开始进入自旋转（为了持有CPU）或者进入沉默阻塞状态（加入队列，等待信号量唤醒）。但是这里存在一个问题，新请求的 Goroutine 进入自旋时是仍然拥有 CPU 的，所以比等待信号量唤醒的 Goroutine 更容易获取锁。用官方话来说激素，新请求锁的 Goroutine 具有优势，它正在 CPU 上运行，而且能有好几个，所以刚刚唤醒  Goroutine 有很大可能在锁竞争中失败</li>
<li>而在饥饿状态下，新加入的 goroutine 不参与锁的竞争，会加入获取锁的 goroutine 等待队列末尾排队，所以是排在最前面的 goroutine 会优先获取锁</li>
</ul>
<h4 id="10、waitgroup-是怎样实现协程等待的？"><a href="#10、waitgroup-是怎样实现协程等待的？" class="headerlink" title="10、waitgroup 是怎样实现协程等待的？"></a>10、waitgroup 是怎样实现协程等待的？</h4><p><strong>分析：</strong>	</p>
<p>​	watigroup 的结构定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;<br>	noCopy noCopy<br><br>	<span class="hljs-comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span><br>	<span class="hljs-comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span><br>	<span class="hljs-comment">// compilers only guarantee that 64-bit fields are 32-bit aligned.</span><br>	<span class="hljs-comment">// For this reason on 32 bit architectures we need to check in state()</span><br>	<span class="hljs-comment">// if state1 is aligned or not, and dynamically &quot;swap&quot; the field order if</span><br>	<span class="hljs-comment">// needed.</span><br>	state1 <span class="hljs-type">uint64</span><br>	state2 <span class="hljs-type">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>state1：64 位值，高 32 位为计数器，就是协程组中运行着的协程个数，低32位为等待者计数，即等待者的个数。比如我们一般在主协程中执行 wait() 函数，那么等待者计数为 1</p>
<p>state2：信号量，用于协程排队和唤醒</p>
<p>waitgroup 对外提供了三个方法：Add(int)、Done()、Wait()</p>
<ul>
<li>Add：用来设置 WaitGroup 的计数值</li>
<li>Done：用来将 WaitGroup 的计数值减一，其实就是调用了 Add(-1)</li>
<li>Wait：其实就是检查 WaitGroup 的计数值，如果大于 0 ，就阻塞等待，知道 WaitGroup 的计数值变成 0，进入下一步</li>
</ul>
<p>​	主要就是通过这三个方法的配合来实现线程等待</p>
<p><strong>回答：</strong></p>
<p>​	waitgroup 内部维护了一个计数器，当调用了 <code>wg.Add(1)</code> ，就会增加对应的数量；当调用 <code>wg.Done()</code> 时，计数器就会减一。直到计数器的数量减到 0 时，就会调用 runtime_Semrelease 唤起之前因为 <code>wg.Wait()</code> 而阻塞住的 goroutine。</p>
<h4 id="11、sync-Once-的原理，是怎样保证代码段只执行-1-次？"><a href="#11、sync-Once-的原理，是怎样保证代码段只执行-1-次？" class="headerlink" title="11、sync.Once 的原理，是怎样保证代码段只执行 1 次？"></a>11、sync.Once 的原理，是怎样保证代码段只执行 1 次？</h4><p><strong>分析：</strong></p>
<p>​	直接看 sync.Once 源码，很简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>	done <span class="hljs-type">uint32</span> <span class="hljs-comment">// 标识位</span><br>	m    Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br>	<span class="hljs-comment">// 原子加载标识值，判断是否已被执行过    </span><br>	<span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>		o.doSlow(f)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;	<span class="hljs-comment">// 还没执行过函数</span><br>	o.m.Lock()<br>	<span class="hljs-keyword">defer</span> o.m.Unlock()<br>	<span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;	<span class="hljs-comment">// 再次判断下是否已被执行过函数</span><br>		<span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>) <span class="hljs-comment">// 原子操作：修改表示符</span><br>		f()	<span class="hljs-comment">// 执行函数</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	主要是通过一个标识位来判断逻辑是否已经执行过。</p>
<p><strong>回答：</strong></p>
<p>​	内部维护了 一个标识位，当它 &#x3D;&#x3D; 0 表示还没执行过函数，此时会加锁修改标志位，然后执行对应的函数。后续再执行时发现标识位 !&#x3D; 0，则不会再执行后续动作了。</p>
<blockquote>
<p><code>sync.Once</code> 主要用于以下场景：</p>
<ul>
<li>单例模式：确保全局只有一个实例对象，避免重复创建资源。</li>
<li>延迟初始化：在程序运行过程中需要用到某个资源时，通过 <code>sync.Once</code> 动态地初始化该资源。</li>
<li>只执行一次的操作：例如只需要执行一次的配置加载、数据清理等操作。</li>
</ul>
</blockquote>
<h1 id="并发相关："><a href="#并发相关：" class="headerlink" title="并发相关："></a>并发相关：</h1><h4 id="1、怎么控制并发数？"><a href="#1、怎么控制并发数？" class="headerlink" title="1、怎么控制并发数？"></a>1、怎么控制并发数？</h4><p>​	<strong>分析：</strong></p>
<p>​	这个问题其实是一个略带开放设计的问题，极有可能和高并发的接口设计配合使用，比如有个这样的场景:现在有一个请求接口，gps 达到 3w，接口用 go 语言来实现，不考虑消息队列等中间件的情况下，你会怎么设计?<br>其实核心就是考虑怎么控制并发的 goroutine 的数量，一个请求用 go func() 开一个协程显然不合理，会造成<br>goroutine 太多，反而会影响程序的性能。但是串行又不合理，那要怎么用一定数量的 goroutine 来实现并发呢?<br>可以结合 java 或者 c++ 语言中的池化技术，用协程池来外理。再结合之前的消息队列作用，用管道来缓冲请求</p>
<p><strong>回答：</strong></p>
<ul>
<li>有缓冲的 channel：利用缓冲满时发送阻塞的特性，处理端开一定数量的处理协程来消费</li>
<li>实现一个协程池，控制处理请求的 worker 的数量</li>
</ul>
<h4 id="2、多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？"><a href="#2、多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？" class="headerlink" title="2、多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？"></a>2、多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？</h4><p><strong>分析：</strong></p>
<p>​	考察对 go 语言中集中 error 的了解程度</p>
<p>​	Go 语言的错误分为三种 error、panic 和 fatal error：</p>
<ul>
<li>Error 就是我们常说的错误，一般通过函数返回值传递，需要使用 <code>if err != nil</code> 处理</li>
<li>Panic 大家有时也会叫异常，通常对标其他语言的 exception。数组越界、空指针引用等都会触发 panic，业务代码也可以主动触发 panic。这一类错误可以使用 recover 捕获</li>
<li>Fatal error 是由系统触发的严重错误，这类错误一般都是跟系统资源相关的。典型的 Fatal error 就是无法从系统申请内存。之所以说严重，是因为程序没法从这类错误中恢复正常。Fatal error 无法被 recover 捕获</li>
</ul>
<p><strong>回答：</strong></p>
<p>​	map 会检测是否存在并发写，如果检测到并发写会触发 Fatal error，Fatal error 是属于系统触发的严重错误，无法被 <code>recover()</code> 捕获</p>
<h4 id="3、如何优雅的实现一个-goroutine-池（百度-手写代码）"><a href="#3、如何优雅的实现一个-goroutine-池（百度-手写代码）" class="headerlink" title="3、如何优雅的实现一个 goroutine 池（百度 手写代码）"></a>3、如何优雅的实现一个 goroutine 池（百度 手写代码）</h4><p><strong>分析：</strong></p>
<p>​	明确协程池的作用，应该有哪些角色、怎么添加任务、以及获取 worker 的大小怎么限制。</p>
<p><strong>回答：</strong></p>
<p><strong>协程池模型</strong></p>
<p>​	协程池简单理解就是有一个池子一样的东西，里面装这个固定数量的 goroutine ，当有一个任务到来的时候，会将这人任务交给池子里的一人空闲的 goroutine 去外理，如果池子里没有空闲的 goroutine 了，任务就会阻塞等待。所以协程池有三个角色 Worker，Task，Pool。</p>
<p><strong>属性定义</strong></p>
<p>​	Worker：用于执行任务的 goroutine</p>
<p>​	Task：具体的任务</p>
<p>​	Pool：池子</p>
<p>​	下面看一下各个角色的定义</p>
<p><strong>Task</strong>：有一个成员函数，表示这个 task 具体的实现逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>	f  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>		<span class="hljs-comment">// 具体的执行逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Pool</strong>：有4个成员</p>
<ul>
<li><p>RunningWorkers</p>
</li>
<li><p>Capacity：表示池子里的 worker 的数量，即工作的 goroutine 的数量，</p>
</li>
<li><p>JobCh： 表示任务队列用于存放任务，goroutine 从这个 JobCh 获取任务，执行的逻辑</p>
</li>
<li><p>sync.Mutex</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>	RunningWorkers <span class="hljs-type">int64</span><br>    Capacity       <span class="hljs-type">int64</span><br>    JobCh		   <span class="hljs-keyword">chan</span> *Task<br>    sync.Mutex<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>worker</strong>：执行任务单元，简单理解就是干活的 goroutine，这个 worker 只做一件事，就是不断从任务列表里取出来任务执行，而 worker 的数量就是协程池里协程的数量，由 Pool 的参数 WorkerNum 指定</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> task := <span class="hljs-keyword">range</span> p.JobCh &#123;<br>	do ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法定义</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTask</span><span class="hljs-params">(funcArg <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>) *Task<br></code></pre></td></tr></table></figure>

<p>NewTask 用于创建一个任务，参数是一个函数，返回值是一个 Task 类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPool</span><span class="hljs-params">(Capacity <span class="hljs-type">int</span>, taskNum <span class="hljs-type">int</span>)</span></span> *Pool<br></code></pre></td></tr></table></figure>

<p>NewPool 返回一个写成数量固定为 taskNum 协程池对象指针，其任务列表的长度为 taskNum</p>
<p>接下来主要介绍协程池的各个方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> AddTask(task *Task)<br></code></pre></td></tr></table></figure>

<p>AddTask 方法是往协程池添加任务，如果当前运行着的 worker 数量小于协程池 worker 容量，则立即启动一个协程 worker 来处理任务，否则将任务添加到任务队列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Run()<br></code></pre></td></tr></table></figure>

<p>Run 方法将协程池跑起来，启动一个 worker 来处理任务</p>
<p><strong>完整代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>	<span class="hljs-string">&quot;sync/atomic&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Task 具体的任务</span><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>	f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// NewTask Task 的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTask</span><span class="hljs-params">(funcArg <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>) *Task &#123;<br>	<span class="hljs-keyword">return</span> &amp;Task&#123;<br>		f: funcArg,<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// Pool 协程池</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>	RunningWorkers <span class="hljs-type">int64</span>      <span class="hljs-comment">// 正在运行的 worker 数量</span><br>	Capacity       <span class="hljs-type">int64</span>      <span class="hljs-comment">// goroutine 数量</span><br>	JobCh          <span class="hljs-keyword">chan</span> *Task <span class="hljs-comment">// 用于 worker 取任务</span><br>	sync.Mutex                <span class="hljs-comment">// 互斥锁</span><br>&#125;<br><br><span class="hljs-comment">// NewPool 创建一个池子，指定容量 和 任务缓存列表大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPool</span><span class="hljs-params">(capacity <span class="hljs-type">int64</span>, taskNum <span class="hljs-type">int</span>)</span></span> *Pool &#123;<br>	<span class="hljs-keyword">return</span> &amp;Pool&#123;<br>		Capacity: capacity,<br>		JobCh:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, taskNum),<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// GetCap 获取缓存池容量大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> GetCap() <span class="hljs-type">int64</span> &#123;<br>	<span class="hljs-keyword">return</span> p.Capacity<br>&#125;<br><br><span class="hljs-comment">// 增加运行的 worker 数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> incRunning() &#123;<br>	atomic.AddInt64(&amp;p.RunningWorkers, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 减少运行的 worker 数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> decRunning() &#123;<br>	atomic.AddInt64(&amp;p.RunningWorkers, <span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-comment">// GetRunningWorkers 获取正在工作的 worker 数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> GetRunningWorkers() <span class="hljs-type">int64</span> &#123;<br>	<span class="hljs-keyword">return</span> atomic.LoadInt64(&amp;p.RunningWorkers)<br>&#125;<br><br><span class="hljs-comment">// 协程池开始工作：分配 worker 给 缓冲列表中的 goroutine</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> run() &#123;<br>	p.incRunning()<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			p.decRunning()<br>		&#125;()<br>		<span class="hljs-keyword">for</span> task := <span class="hljs-keyword">range</span> p.JobCh &#123; <span class="hljs-comment">// 从任务列表获取任务</span><br>			task.f()<br>		&#125;<br>	&#125;()<br>&#125;<br><br><span class="hljs-comment">// AddTask 往协程池添加任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> AddTask(task *Task) &#123;<br>	<span class="hljs-comment">// 加锁防止启动多个 worker</span><br>	p.Lock()<br>	<span class="hljs-keyword">defer</span> p.Unlock()<br><br>	<span class="hljs-comment">// 如果任务池满，则不再创建 worker</span><br>	<span class="hljs-keyword">if</span> p.GetRunningWorkers() &lt; p.GetCap() &#123;<br>		p.run()<br>	&#125;<br>	<span class="hljs-comment">// 将任务推入队列，等待消费，队列满时，会阻塞等待 worker 消费任务</span><br>	p.JobCh &lt;- task<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-comment">// 创建任务池</span><br>	pool := NewPool(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>		<span class="hljs-comment">// 任务放入池中</span><br>		pool.AddTask(NewTask(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>			fmt.Println(<span class="hljs-string">&quot;I am Task&quot;</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>		&#125;))<br>	&#125;<br>	time.Sleep(time.Second * <span class="hljs-number">5</span>) <span class="hljs-comment">// 等待执行</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4、select-可以用于什么？"><a href="#4、select-可以用于什么？" class="headerlink" title="4、select 可以用于什么？"></a>4、select 可以用于什么？</h4><p><strong>分析：</strong> 	</p>
<p>​	首先明确具体用法，然后根据这个用法去思考解决了什么问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> &lt;- ch1:<br>		<span class="hljs-comment">// 如果从 ch1 信道成功接收数据，则执行该分支代码</span><br>	<span class="hljs-keyword">case</span> ch2 &lt;- <span class="hljs-number">1</span>:<br>		<span class="hljs-comment">// 如果成功向 ch2 信道发送数据，则执行该分支代码</span><br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-comment">// 如果上面都没有成功，则进入 default 分支处理流程</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	select 主要用于配合 channel 来使用，当前可以从多个 channel 中获取数据或者向多个 channel 发送数据，类似于 io 多路复用</p>
<p>​	当 channel 数据没有准备好的时候，若有 default 的话，就会走 default 语句，不会阻塞在这里，这种方法就实现了非阻塞的 channel 数据读写</p>
<p><strong>回答：</strong></p>
<ol>
<li>select 可以让同一个 goroutine 监听多个 channel 的读写操作，实现单个 goroutine 的多路复用</li>
<li>配合 default 实现 goroutine 的非阻塞读写，当 channel 的数据没有准备好或者不能写入的时候，执行 default，并不会阻塞</li>
</ol>
<h4 id="5、主协程如何等待其余协程完再操作"><a href="#5、主协程如何等待其余协程完再操作" class="headerlink" title="5、主协程如何等待其余协程完再操作"></a>5、主协程如何等待其余协程完再操作</h4><p><strong>分析：</strong></p>
<p>​	sync.WaitGroup 和 channel 来实现协程等待</p>
<p><strong>回答：</strong></p>
<p>​	可以使用 sync.WaitGroup 和 channel 实现</p>
<ul>
<li><p>sync.WaitGroup 实现写等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">var</span> w sync.WaitGroup<br>	w.Add(<span class="hljs-number">10</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> &#123;<br>			fmt.Println(num)<br>			w.Done()<br>		&#125;(i)<br>	&#125;<br>	w.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>channel 实现写等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">10</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> &#123;<br>			fmt.Println(num)<br>			ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>		&#125;(i)<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		&lt;-ch<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="GC-相关"><a href="#GC-相关" class="headerlink" title="GC 相关"></a>GC 相关</h1><h4 id="1、go-gc-是怎么实现的？"><a href="#1、go-gc-是怎么实现的？" class="headerlink" title="1、go gc 是怎么实现的？"></a>1、go gc 是怎么实现的？</h4><p><strong>分析：</strong></p>
<p>​	Go 语言的 gc 经历了多个版本的迭代和逐步优化，在回答的时候突出三色标记法配合混合写屏障技术就可以了，但是对于问题的追问，其中设计到的细节要做到心中有数</p>
<p><strong>回答：</strong></p>
<p>​	go 语言的 gc 策略是采用三色标记法。但是单纯的三色标记法会带来 **STW(stop the world)**，导致执行效率不高，所以在 1.8 版本之后，采用了三色标记法配合混合写屏障技术来实现 gc。</p>
<p><strong>问题追问</strong></p>
<p><strong>Go gc 经历了哪几个版本？</strong></p>
<p>1.3 版本之前：普通标记清除法，整个 gc 过程需要启动 STW，效率极低</p>
<p>1.5 版本：三色标记法，堆空间启动写屏障（白色强制变成灰色），全部扫描之后，需要重写扫描一次栈（需要 STW，因为栈要求响应速度快，所以不引入写屏障），效率普通</p>
<p>1.8 版本：三色标记法，混合写屏障机制：栈空间不启动（根节点可到达对象和新加入的对象全部标记为黑色）</p>
<p>堆空间启动写屏障，整个过程不要 SWT，效率高。</p>
<p><strong>三色标记法过程是怎样的？有什么问题？</strong></p>
<p>第一步：应用程序开始运行时，所有对象默认标记为白色</p>
<p>第二步：从根节点遍历，把根节点遍历到的对象标记为灰色，放到灰色标记列表中</p>
<p>第三步：遍历灰度集合，将灰色对象标记为黑色，并由灰色标记移动到黑色标记中</p>
<p>将黑色引用对象引用的白色标记为灰色，放到灰色标记中</p>
<p>第四步：重复第三步，直到灰色标记为空</p>
<p>​	三色标记的整个过程都是跟业务逻辑并行的，这样就会带来一定的问题，可能会修改已标记为黑色对象的引用关系，比如会让黑色对象指向一个白色对象，所以标记过程中还是需要 STW，会影响程序的性能。</p>
<p><strong>针对三色标记的 STW，是怎么解决的？</strong></p>
<p>​	引入了屏障技术来解决 STW 的问题，屏障技术分为插入写屏障和删除写屏障，在 go1.8 之后是采用二者的一个综合，用混合写屏障来处理</p>
<p><strong>什么是插入写屏障？用插入写屏障解决 STW 会有什么问题</strong></p>
<p>​	插入屏障主要是针对插入新对象或者说是添加对象之间的引用关系，被插入的对象或者是被引用指向的对象标记为灰色，但是插入写屏障只能在堆上操作，不能在栈上操作，这是因为 go 在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万的 goroutine 的栈都进行屏障保护会有严重的性能问题</p>
<p><strong>删除写屏障是怎么工作的？</strong></p>
<p>​	删除写屏障主要是断开引用关系，被断开连接的下一个对象直接标记为灰色。（这种方式回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮的 GC 中被清理。）</p>
<p><strong>混合写屏障是怎么工作的？</strong></p>
<p>​	在 GC 刚开始的时候，会将栈上的可达对象全部标记为黑色，gc 过程中任务在栈上新创建的对象，均标记为黑色。这样就可以保证三色标记流程结束后，不需要再堆栈上重新进行一次 rescan。在堆上操作时：堆上被删除的对象标记为黑色，堆上新添加的对象标记为灰色。</p>
<h4 id="2、-GC-中-STW-时机，各个阶段是如何解决的？"><a href="#2、-GC-中-STW-时机，各个阶段是如何解决的？" class="headerlink" title="2、 GC 中 STW 时机，各个阶段是如何解决的？"></a>2、 GC 中 STW 时机，各个阶段是如何解决的？</h4><p><strong>分析：</strong></p>
<p>​	go 语言的整个 gc 流程大致可以分为下面 5 个步骤</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
<th>赋值器状态</th>
</tr>
</thead>
<tbody><tr>
<td>SweepTermination</td>
<td>清楚终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障</td>
<td>STW</td>
</tr>
<tr>
<td>Mark</td>
<td>扫描标记阶段，与赋值器并发执行，写屏障开启状态</td>
<td>并发</td>
</tr>
<tr>
<td>MarkTermination</td>
<td>标记终止阶段，保证一个周期内标记任务完成，停止写屏障</td>
<td>STW</td>
</tr>
<tr>
<td>GCoff</td>
<td>内存清除阶段，将需要回收的内存归还到堆中，写屏障关闭状态</td>
<td>并发</td>
</tr>
<tr>
<td>GCoff</td>
<td>内存归还阶段，将过多的内存归还给操作系统，写屏障关闭状态</td>
<td>并发</td>
</tr>
</tbody></table>
<p><strong>回答：</strong></p>
<p>​	虽然有了混合写屏障技术，go 语言的整个 gc 过程中还是有两次 STW，因为写屏障需要开启和关闭，在整个标记程序开始之前需要 STW，用于开启写屏障，为标记做准备，在标记终止阶段同样需要短暂的 STW 来暂停写屏障。</p>
<h4 id="3、GC-的触发时机？"><a href="#3、GC-的触发时机？" class="headerlink" title="3、GC 的触发时机？"></a>3、GC 的触发时机？</h4><p><strong>分析：</strong></p>
<p>​	go 的触发分为手动和被动两种</p>
<ol>
<li>主动触发，通过调用 runtime.GC() 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕</li>
<li>被动触发，分为两种方式<ul>
<li>go 后台有一系统监控线程，当超过两分钟没有产生任何 GC 时，强制触发 GC</li>
<li>内存使用增长一定比例时有可能会触发，每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认为 100%，即当内存扩大一倍时启用 GC<ul>
<li>我们可以通过 debug.SetGCPerceng(500) 来修改步调，这里表示当前堆大小超过了上次标记的堆大小的 500%，就会触发</li>
<li>而第一次 GC 的触发临界值是 4 MB</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>回答：</strong></p>
<ul>
<li>gc 可以在代码中通过调用 runtime.GC 手动触发</li>
<li>也可以由系统被动触发，当超过两分钟没有 gc 或者是内存分配达到了一定的阈值的时候就会强制触发 gc</li>
</ul>
<h4 id="4、GC-扫描的根节点由哪些？"><a href="#4、GC-扫描的根节点由哪些？" class="headerlink" title="4、GC 扫描的根节点由哪些？"></a>4、GC 扫描的根节点由哪些？</h4><p><strong>分析：</strong></p>
<p>​	gc 的标记是从根节点开始的，扫描的对象是在堆上的，所以要明确堆上的对象是怎么建立关联的。</p>
<p>​	举个例子，我们在程序中一般创建对象，假设创建在堆上，然后我们在函数内去操作这个对象，这里我们是通过在函数中的局部变量去操作这个堆上的对象的。所以这种情况下，堆上对象一定是和局部变量相关联的，局部变量是保存在栈上的，所以要找到堆中可达对象，栈上的对象可以作为根节点全部扫描一遍。</p>
<p>​	还有一种情况，对象不是在函数内部创建的，是以全局变量创建的，这种情况下，全局对象是不是也可以作为根节点呢？</p>
<p>​	所以在回答的时候要思考和联想堆中的对象是怎么关联的，来明确根节点有哪些</p>
<p><strong>回答：</strong></p>
<p>​	根节点包括：</p>
<ul>
<li>全局变量：程序在编译期间就能确定那些存在于程序整个生命周期的变量</li>
<li>执行在栈上的对象或指针：每个 goroutine 都包含自己的执行栈，这些执行栈上的对象包含栈上的变量及指向分配的堆内存区块的指针</li>
<li>寄存器中的变量：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块</li>
</ul>
<h1 id="内存相关："><a href="#内存相关：" class="headerlink" title="内存相关："></a>内存相关：</h1><h4 id="1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？"><a href="#1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？" class="headerlink" title="1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？"></a>1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？</h4><p><strong>分析：</strong></p>
<p>​	内存泄漏：就是程序中存在内存不能及时被有效释放，导致这部分内存不可用，随着越来越多的积累，可能出现内存泄漏，会出现内存用满，程序崩溃的情况。</p>
<p>​	思考 go 语言中编码哪些情况会出现这种情况？</p>
<p>​	最常见的就是 goroutine 的阻塞不能快速释放，导致这部分内存一直占用着，随着 goroutine 越来越多，就内存泄漏了</p>
<p><strong>回答：</strong></p>
<h5 id="1-1、什么是内存泄漏？"><a href="#1-1、什么是内存泄漏？" class="headerlink" title="1.1、什么是内存泄漏？"></a><strong>1.1</strong>、什么是内存泄漏？</h5><p>​	内存泄漏就是程序生命周期中一些对象不能被及时回收，一直占用内存，导致这部分内存不可用的情况</p>
<h5 id="1-2-go-语言内存泄漏原因"><a href="#1-2-go-语言内存泄漏原因" class="headerlink" title="1.2  go 语言内存泄漏原因"></a>1.2  <strong>go 语言内存泄漏原因</strong></h5><p><strong>分析</strong></p>
<p>​	go 语言中内存泄漏的场景有很多，像 time.NewTicker 资源未及时释放， select 阻塞等等，其实大部分情况都是由于阻塞或者程序空转，导致程序不能结束，一直占用内存。</p>
<p><strong>回答：</strong></p>
<p>​	go 语言的内存泄漏一般是由于程序阻塞或者空转导致程序不能及时结束导致的，常见的情况就是 goroutine 阻塞或者空转，比如 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一直处于阻塞状态，不能被 GC，还有一种就是一些资源句柄未释放，比如文件打开未关闭等等。然后就是 goroutine 内部的业务逻辑不合理，比如：</p>
<ul>
<li>Goroutine 内进行 channel&#x2F;mutex 等读操作一直被阻塞</li>
<li>Goroutine内的业务逻辑进入死循环，资源一直无法释放</li>
<li>Goroutine内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待</li>
</ul>
<h5 id="1-3-常见的-goroutine-泄漏场景"><a href="#1-3-常见的-goroutine-泄漏场景" class="headerlink" title="1.3 常见的 goroutine 泄漏场景"></a>1.3 常见的 goroutine 泄漏场景</h5><ul>
<li>channel 如果忘记初始化，无论是读还是写操作，都会阻塞</li>
<li>channel 发送数量超过 channel 接收数量，就会造成阻塞</li>
<li>channel 接收数量超过 channel 发送数量，也会造成阻塞</li>
<li>http request body 未关闭，goroutine 不会退出</li>
<li>互斥锁忘记解锁</li>
<li>sync.WaitGroup 使用不当</li>
<li>time.Ticker 是每个指定时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间</li>
</ul>
<h5 id="1-4-如何排查"><a href="#1-4-如何排查" class="headerlink" title="1.4 如何排查"></a>1.4 如何排查</h5><p><strong>分析：</strong></p>
<p>​	go 语言的性能分析，比如 CPU，内存一般使用 pprof 工具进行分析</p>
<p><strong>回答：</strong>	</p>
<p>​	单个函数：调用 runtime.NumGoroutine 方法打印 执行代码前后的 Goroutine 的运行数量，进行前后对比，就能知道有没有泄漏了。</p>
<p>​	生产&#x2F;测试环境：使用 PProf 实时监测 Goroutine 的数量</p>
<h1 id="未完成，可以查看该题的链接，进行深入学习"><a href="#未完成，可以查看该题的链接，进行深入学习" class="headerlink" title="未完成，可以查看该题的链接，进行深入学习"></a>未完成，可以查看该题的链接，进行深入学习</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Golang</div>
      <div>http://example.com/2023/07/31/面试/Golang/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Feng Tao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月31日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年8月7日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84value%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%AF%BB%E7%9A%84/" title="map的value本身的地址是不可寻的">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">map的value本身的地址是不可寻的</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%85%B6string%E6%96%B9%E6%B3%95/" title="类型自动使用其string方法">
                        <span class="hidden-mobile">类型自动使用其string方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"n0H6ZjcwsAdPc2zfOJM4bxV4-gzGzoHsz","appKey":"rwjeQIHfYJqQvjh2iWuPkYev","path":"window.location.pathname","placeholder":"匿名评论，畅所欲言","avatar":"robohash","meta":["nick","mail"],"requiredFields":[],"pageSize":20,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":true},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<!-- 雪花特效 -->
<script type="text/javascript" src="\js\snow.js"></script>