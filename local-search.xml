<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/08/09/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/08/09/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型<span id="more"></span></h1><h4 id="1、网络通信架构（OSI）-的-7-层模型"><a href="#1、网络通信架构（OSI）-的-7-层模型" class="headerlink" title="1、网络通信架构（OSI） 的 7 层模型"></a>1、网络通信架构（OSI） 的 7 层模型</h4><p>​分别为 <strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>、<strong>运输层</strong>、<strong>网络层</strong>、<strong>链路层</strong>、<strong>物理层</strong></p><ul><li>**应用层(数据)**：确定进程之间 <strong>通信的性质</strong> 以及满足用户需要、提供网络和用户应用，为应用进程提供服务，DNS、HTTP、HTTPS、DHCP、FTP、POP3(Post Office Protocol)、SMTP(Simple Mail Transfer Protocol) 都是这层的协议</li><li><strong>表示层(数据)<strong>：主要解决用户信息的语法表示问题，表示层提供各种 <strong>用于应用层数据的编码和转码功能</strong>，确保一个系统的应用层发送的数据能被另一个系统的应用层识别，如 <strong>数据转换</strong>、</strong>压缩和加密</strong>、<strong>解密</strong></li><li>**会话层(数据)**：负责 <strong>建立、管理和终止表示层实体之间的通信会话</strong> 。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。比如服务器验证用户登录就是会话层。</li><li>**传输层(段)**：实现网络不同主机上的用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制、拥塞控制。TCP、UDP 就在这层</li><li>**网络层(包)**：本层通过 <strong>IP 寻址</strong> 来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。IP 就是这层。</li><li>**数据链路层(帧)**：将上层数据封装成帧，用 <strong>MAC</strong> 地址访问媒介，并由错误检测和修正</li><li>**物理层(比特流)**：设备之间比特流的传输、物理接口、电器特性（常用设备有（各种物理设备）、中继器、调制解调器、网线、双绞线、同轴电缆。这邪恶都是物理层的传输介质。）</li></ul><h4 id="2、TCP-x2F-IP-的四层网络模型？"><a href="#2、TCP-x2F-IP-的四层网络模型？" class="headerlink" title="2、TCP&#x2F;IP 的四层网络模型？"></a>2、TCP&#x2F;IP 的四层网络模型？</h4><p>​TCP 四层模型是我们实践过程中发现比较合理的分层，虽然我们实际过程中都没有按 OSI 分为七层，但是 OSI 对我们实践过程有着指导性的意义。</p><table><thead><tr><th align="center">OSI 七层模型</th><th align="center">TCP&#x2F;IP 四层模型</th><th align="center">对应网络协议</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">应用层</td><td align="center">HTTP、TFTP、FTP、NFS、WAIS、SMTP</td></tr><tr><td align="center">表示层</td><td align="center">应用层</td><td align="center">Telnet、Rlogin、SNMP、Gopher</td></tr><tr><td align="center">会话层</td><td align="center">应用层</td><td align="center">SMTP、DNS</td></tr><tr><td align="center">传输层</td><td align="center">传输层</td><td align="center">TCP、UDP</td></tr><tr><td align="center">网络层</td><td align="center">网络层</td><td align="center">IP、ICMP、ARP、RARP、AKP、UUCP</td></tr><tr><td align="center">数据链路层</td><td align="center">数据链路层</td><td align="center">FDDI、Ethernet、Arpanet、PDN、SLIP、PPP</td></tr><tr><td align="center">物理层</td><td align="center">数据链路层</td><td align="center">IEEE 802.1A、IEEE 802.2 到 IEEE 802.11</td></tr></tbody></table><h4 id="3、五层因特网协议？"><a href="#3、五层因特网协议？" class="headerlink" title="3、五层因特网协议？"></a>3、五层因特网协议？</h4><p>​应用层、运输层、网络层、链路层、物理层</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h4 id="1、HTTP-和-HTTPS-的区别？"><a href="#1、HTTP-和-HTTPS-的区别？" class="headerlink" title="1、HTTP 和 HTTPS 的区别？"></a>1、HTTP 和 HTTPS 的区别？</h4><ul><li>HTTP 明文传输，数据都是未加密的，安全性较差；HTTPS（SSL + HTTP）数据传输过程是加密的，安全性较好</li><li>使用 HTTPS 协议需要到 CA 申请证书</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，而 HTTPS 除了 TCP 的三个包，还要加上 SSL 握手的消耗</li><li>用的端口不一样：前者是 80，后者是 443</li><li>HTTPS 其实就是构建在 SSL&#x2F;TLS 之上的 协议，所以 HTTPS 比 HTTP 要耗费服务器资源</li></ul><h4 id="2、HTTPS-的加密与认证过程"><a href="#2、HTTPS-的加密与认证过程" class="headerlink" title="2、HTTPS 的加密与认证过程"></a>2、HTTPS 的加密与认证过程</h4><h5 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h5><p>​首先，由客户端向服务端发起加密通信请求。客户端主要向服务器发送：</p><ul><li>客户端支持的 SSL&#x2F;TLS 协议版本</li><li>客户端产生的随机数（Client Random）</li><li>客户端支持的密码套件列表</li></ul><h5 id="ServerHello"><a href="#ServerHello" class="headerlink" title="ServerHello"></a>ServerHello</h5><p>服务器收到客户端请求后，向客户端发出响应。服务器回应的内容有：</p><ul><li>确认 SSL&#x2F;TLS 协议版本（如果浏览器不支持，则关闭加密通信）</li><li>服务器生成的随机数（Server Random）</li><li>确认的密码套件列表</li><li>服务器的数字证书</li></ul><h5 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h5><p>​客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务端的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务端的公钥，然后使用它加密报文，向服务端发送如下信息：</p><ul><li>一个随机数，该随机数会被服务端公钥加密</li><li>加密通信算法改变通知，表示随后的信息都将用 【会话密钥】 加密通信</li><li>客户端握手结束，表示客户端的握手阶段已经结束</li><li>之前所有的发送数据做个摘要，用来提供服务端校验</li></ul><p>​服务端和客户端有了三个随机数，接着用双方协商的加密算法，各自生成本次通信的会话密钥。</p><h5 id="服务端回应"><a href="#服务端回应" class="headerlink" title="服务端回应"></a>服务端回应</h5><p>​服务端收到客户端的第三个随机数之后，通过协商的加密算法，计算出本次通信的会话密钥。服务端向客户端发送最后的信息：</p><ul><li>加密通信算法改变通知，表示随后的信息都将用 【会话密钥】 加密</li><li>服务端握手结束通知，表示服务端的握手阶段已经结束</li><li>之前所有的发送数据做个摘要，用来供客户端校验</li></ul><p>​接下来客户端和服务器进入加密通信，就完全是使用普通的 HTTP 协议。</p><h4 id="4、HTTPS-一定安全可靠吗？"><a href="#4、HTTPS-一定安全可靠吗？" class="headerlink" title="4、HTTPS 一定安全可靠吗？"></a>4、HTTPS 一定安全可靠吗？</h4><p>​不一定安全，是因为用户点击接收了中间人服务器的证书。中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。如果用户点击【继续浏览此网站】，相当于接收了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>​HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不算 HTTPS 不够安全。</p><h4 id="5、HTTP-状态码的含义？"><a href="#5、HTTP-状态码的含义？" class="headerlink" title="5、HTTP 状态码的含义？"></a>5、HTTP 状态码的含义？</h4><p>**100 类 ** 状态码属于 <strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><ul><li>100（继续）：请求者应当继续提出请求。服务器返回此状态码表示已收到请求的第一部分，正在等待其余部分</li><li>101（切换协议）：请求者已要求服务器切换协议，服务器已确认并准备切换</li></ul><p><strong>200 类</strong> 状态码表示服务器<strong>成功</strong>处理了客户端的请求。</p><ul><li>200（成功）：表示服务器<strong>响应成功</strong>，也就是服务器找到了客户端请求的内容，并将内容返回给客户端。</li><li>204（已创建）：请求成功并且服务器创建了新的资源</li><li>206（部分内容）：服务器成功处理了部分 GET 请求</li></ul><p><strong>300 类</strong> 状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>301（永久移动）：代表永久性的重定向，<strong>值得注意的是，这种重定向跳转，从严格意义来讲不算服务器跳转，而是客户端跳转的。</strong>这个 ”跳“ 的动作是服务器通过返回状态码 301 来下达给客户端的，让客户端来完成跳转。</li><li>302（临时移动）：代表<strong>临时跳转</strong>。例如：URL 地址 A 可以向 URL 地址 B 上跳转，但这并不是永久性的，在经历一段时间后，URL 地址 A 还可能向 URL 地址 C 上跳转。</li><li>304（未修改）：服务器通过返回状态码 304 可以告诉客户端请求资源成功，但是这个资源不是由服务器提供返回给客户端的，而是客户端本地浏览器缓存中就有的这个资源，因为可以从缓存中获取这个资源，从而节省传输的开销。</li></ul><blockquote><p>提示：301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p></blockquote><p><strong>400 类</strong> 状态码表示客户端发送的报文有误，服务器无法处理。</p><ul><li>400（错误请求）：服务器不理解请求的语法</li><li>403（禁止）：代表请求的服务器资源 <strong>权限不够</strong>，也就是没有权限去访问服务器的资源，或者请求的 IP 地址被封掉了。</li><li>404（未找到）：代表服务器上 <strong>没有该资源</strong>，或者说服务器找不到客户端请求的资源，是最常见的请求错误码</li></ul><p><strong>500类</strong> 状态码表示客户端请求报文正确，但是服务器处理时间内部发生了错误，属于服务器端的错误码。</p><ul><li>500（服务器内部错误）：代表程序错误，也就是说请求的网页程序本身报错了。在服务端的网页程序出错。由于现在的浏览器都会对状态码 500 做一定的处理，所以一般情况下会返回一个定制的错误页面。</li><li>501（尚未执行）：服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502（错误网关）：通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li><li>503（服务不可用）：表示服务器当前很忙，暂时无法响应客户端</li><li>504（网关超时）：服务器作为网关或者代理，但是没有及时从上游服务器收到请求。</li><li>505（HTTP 版本不受支持）：服务器不支持请求中所用的 HTPP 协议版本。</li></ul><h4 id="6、HTTP-缓存有哪些实现方式？"><a href="#6、HTTP-缓存有哪些实现方式？" class="headerlink" title="6、HTTP 缓存有哪些实现方式？"></a>6、HTTP 缓存有哪些实现方式？</h4><ol><li><strong>强制缓存</strong>：强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器这边。</li><li><strong>协商缓存</strong>：服务器检查资源的状态，若资源没有变化则返回 304 响应码，表示该资源未修改，可以使用本地的缓存资源，通过服务端告知客户端是否可以使用缓存的方式是协商缓存。</li></ol><h4 id="7、HTTP-1-0、HTTP-1-1、HTTP-2-0-和-HTTP-3-0-的区别？"><a href="#7、HTTP-1-0、HTTP-1-1、HTTP-2-0-和-HTTP-3-0-的区别？" class="headerlink" title="7、HTTP 1.0、HTTP 1.1、HTTP 2.0 和 HTTP 3.0 的区别？"></a>7、HTTP 1.0、HTTP 1.1、HTTP 2.0 和 HTTP 3.0 的区别？</h4><h5 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h5><ul><li><strong>无连接</strong>：每次请求都要建立连接，需要使用 keep-alive 参数建立长连接，建立连接十分消耗资源</li><li><strong>队头阻塞</strong>：HTTP 1.0 规定下一个请求必须在前一个请求响应到达之后才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送了，后面的请求就阻塞了</li><li><strong>缓存</strong>：在 HTTP 1.0 中主要使用 header 里的协商缓存 last-modified&#x2F;if-modified-since，强制缓存 Expires 来做缓存判断的标准</li></ul><blockquote><p>提示：</p><p><strong>If-Modified-Since</strong>，上次获取资源的时间，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码304 Not Modified的响应。If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。</p><p><strong>Expires</strong> 是RFC 2616(HTTP 1.0）协议中和网页缓存相关字段。用来控制缓存的失效日期。Expires 字段声明了一个网页或 URL 地址不再被浏览器缓存的时间，一旦超过了这个时间，浏览器都应该联系原始服务器。RFC告诉我们：“由于推断的失效时间也许会降低语义透明度，应该被谨慎使用，同时我们鼓励原始服务器尽可能提供确切的失效时间。”</p></blockquote><h5 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h5><ul><li><strong>长连接</strong>：好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</li><li><strong>支持管道(pipeline) 网络传输</strong>：只要第一个请求发出去了，不必等待其回来，就可以发送第二个请求出去，可以减少整体的响应时间。</li><li><strong>缓存处理</strong>：HTTP 1.1 则引入更多的缓存控制策略，多个可供选择的缓存头来控制缓存策略</li><li><strong>断点续传</strong>：HTTP 1.1 则在请求头引入 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用宽带和连接。</li></ul><h5 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h5><ul><li><strong>header 压缩</strong>：HTTP 1 的header 带有大量信息，而且每次都要重复传送，HTTP 2.0 使用 encoder 来减少需要传输的 header  大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</li><li><strong>多路复用</strong>：使用多路复用技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP 1.1 大了好几个数量级</li><li><strong>新的二进制帧格式</strong>：HTTP 2.0 把请求在应用层切分成二进制帧并表上序号，服务器接收到二进制帧后组装成请求进行处理，从而达到并发发送请求的效果，对于服务器端，响应可以通过序号确定是哪个请求，从而不会出现混乱的问题。</li><li><strong>服务器推送</strong>：HTTP 2.0 引入 server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，服务端可以主动推送相关资源给浏览器，免得客户端再次创建连接发送请求到服务端获取。这样客户端可以直接在本地加载这些资源，不用再通过网络。</li></ul><h5 id="HTTP-3-0（QUIC）"><a href="#HTTP-3-0（QUIC）" class="headerlink" title="HTTP 3.0（QUIC）"></a>HTTP 3.0（QUIC）</h5><ul><li>HTTP&#x2F;3.0 直接放弃使用 TCP，将传输层协议改成 UDP，使用 UDP 实现可靠传输</li><li><strong>0-RTT</strong>：缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。(<strong>这是 QUIC 协议相比 HTTP2.0 的最大优势</strong>）</li><li><strong>多路复用</strong>：QUIC 基于 UDP，一个连接上的多个 stream 之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</li><li><strong>更好的移动端表现：</strong> QUIC 在移动端的表现比 TCP 好，因为 TCP 是基于 IP 识别连接，而 QUIC 是通过 ID 识别连接。无论网络环境如何变化，只要 ID 不变，就能迅速重新连上。</li><li><strong>加密认证的报文</strong>：TCP 协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。QUIC 的 packet 除了个别报文，所有报文头部都是经过认证的，报文 Body 都是经过加密的。只要对 QUIC 做任何更改，接收端都能及时发现，有效地降低了安全风险。</li><li><strong>向前纠错机制：</strong> 向前纠错（Foward Error Connec，FEC），每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的荣誉数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是带来的提升大于丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失，请求重传，等待数据包等步骤的时间消耗）。</li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>make初始化切片</title>
    <link href="/2023/08/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%87%E7%89%87/"/>
    <url>/2023/08/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(s ...<span class="hljs-type">int</span>)</span></span> &#123;<br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)<br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>slice[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>change(slice...)<br>fmt.Println(slice)<br>change(slice[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]...)<br>fmt.Println(slice)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1 2 0 0 0]<br>[1 2 3 0 0]<br></code></pre></td></tr></table></figure><p>知识点：可变函数、append()操作。</p><p>Go 提供的语法糖<code>...</code>，可以将 slice 传进可变函数，不会创建新的切片。第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变； 第二次调用change() 函数时，使用了操作符<code>[i,j]</code>获得一个新的切片，假定为 slice1，<br>它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for-range中数组是值引用</title>
    <link href="/2023/08/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E4%B8%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2023/08/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E4%B8%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">r =  [1 2 3 4 5]<br>a =  [1 12 13 4 5]<br></code></pre></td></tr></table></figure><p>range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a。就这个例子来说，假设 b 是 a 的副本，则 range 循环代码是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> b &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。</p><p>如果想要 r 和 a 一样输出，修复办法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> &amp;a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">r =  [1 12 13 4 5]<br>a =  [1 12 13 4 5]<br></code></pre></td></tr></table></figure><p>修复代码中，使用 *[5]int 作为 range 表达式，其副本依旧是一个指向原数组 a 的指针，因此后续所有循环中均是 &amp;a 指向的原数组亲自参与的，因此 v 能从 &amp;a 指向的原数组中取出 a 修改后的值。</p><p>reference: <a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer注册未初始化函数</title>
    <link href="/2023/08/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <url>/2023/08/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += n<br><span class="hljs-built_in">recover</span>()<br>&#125;()<br><br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">defer</span> f()<br>f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f(<span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案及解析"><a href="#答案及解析" class="headerlink" title="答案及解析"></a>答案及解析</h4><p>​输出 7 。</p><p>​知识点：在 defer 注册函数的时候，即使注册了未初始化的函数，也不会报错，会继续执行后面的语句。</p><p>​当函数返回时，执行 defer 函数的时候，如果执行到了 未初始化的函数，就会发生 panic，并继续执行完其他 defer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)<br><span class="hljs-comment">//recover() //恢复 panic</span><br>&#125;()<br><span class="hljs-keyword">defer</span> f() <span class="hljs-comment">// 注册一个未初始化的函数</span><br><br>fmt.Println(<span class="hljs-string">&quot;注册成功&quot;</span>)<br>f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Deferred function&quot;</span>)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;初始化成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在本题中，将参数 3 传入函数 f ，此时 n &#x3D; 3，注册两个 defer 函数，然后返回 n + 1，此时 r &#x3D; n  + 1 &#x3D; 4。</p><p>先执行  f() 函数，由于注册的时候该函数未进行初始化，故执行时发生 panic ，然后执行剩余的一个 defer 函数，此时 r &#x3D; n + r &#x3D; 7，然后 recover() 恢复了  panic ，使得函数能够执行最后一步，将 r 返回给 主函数 main，即 7。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同样的for-range，不同的知识</title>
    <link href="/2023/08/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%90%8C%E6%A0%B7%E7%9A%84for-range%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/08/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%90%8C%E6%A0%B7%E7%9A%84for-range%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> m = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i, v)<br>&#125;()<br>&#125;<br><br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">2 3<br>2 3<br>2 3<br></code></pre></td></tr></table></figure><p>​这里的for range 跟之前讲过的一样，变量 i、v 在每次循环体中都会被重用，而不是重新声明。</p><p> 各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个 goroutine 启动时的 i, v值。可以理解为闭包引用，使用的是上下文环境的值。两种可行的 fix 方法:</p><p>a.使用函数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,v <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(i, v)<br>&#125;(i,v)<br>&#125;<br></code></pre></td></tr></table></figure><p>b.使用临时变量保留当前值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br>i := i           <span class="hljs-comment">// 这里的 := 会重新声明变量，而不是重用</span><br>v := v<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i, v)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>​如果你简单得认为是上述那样，就错了。其实这样还有一个细节，就是这里每次输出都是一样的，是因为 切片内元素太少，导致 最开始创建的 goroutine 还没有开始执行，for range 就执行结束了。如果切片内的元素多一点，输出的结果就不一样了。</p><p>​所以这个题的本质，还是与之前的一样：for range 语句中定义的变量会被复用，而不是重新定义。</p><p>reference: <a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for-range</title>
    <link href="/2023/08/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range2/"/>
    <url>/2023/08/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否正常结束？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> v &#123;<br>v = <span class="hljs-built_in">append</span>(v, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​for-range 遍历切片，在底层实现的时候，会先将该切片进行浅拷贝，拷贝到 temp（假设），然后遍历的时候遍历这个 temp，故后续加入切片的元素不会被遍历到，因此不会出现死循环，能正常结束。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Asyncflow</title>
    <link href="/2023/08/04/%E9%9D%A2%E8%AF%95/Asyncflow/"/>
    <url>/2023/08/04/%E9%9D%A2%E8%AF%95/Asyncflow/</url>
    
    <content type="html"><![CDATA[<p>​Asyncflow<span id="more"></span></p><h1 id="立意"><a href="#立意" class="headerlink" title="立意"></a>立意</h1><h4 id="1、介绍一下你的项目。"><a href="#1、介绍一下你的项目。" class="headerlink" title="1、介绍一下你的项目。"></a>1、介绍一下你的项目。</h4><p><strong>分析：</strong>面试官此时完成不知道任何背景，切勿上来就说有什么模块，而应该从场景上，先说清楚这个项目是什么，解决什么问题，聊清楚之后再介绍一下架构，介绍过程中不需要说太对细节。</p><p><strong>回答：</strong></p><ul><li>从场景上说，Asyncflow 项目是一个 异步任务处理框架，抽象了异步任务中<strong>任务管理</strong>、自动重试、<strong>优先级</strong>等非业务能力，使得异步任务开发成本低并且高效</li><li>从架构上来说，Asyncflow 主要分为<strong>服务层 flow server</strong> 和 <strong>执行层 worker</strong>，flow server 是负责提供  <strong>任务创建</strong>、<strong>任务拉取</strong>、<strong>设置任务状态</strong> 等接口。worker 是负责调度的，也可以看作消费者，它会从 flow server 拉取任务，然后执行任务。</li></ul><h4 id="2、你为什么做这个框架？什么时候使用这个框架？"><a href="#2、你为什么做这个框架？什么时候使用这个框架？" class="headerlink" title="2、你为什么做这个框架？什么时候使用这个框架？"></a>2、你为什么做这个框架？什么时候使用这个框架？</h4><p><strong>分析：</strong> 这个问题很重要，一定要回答好。</p><p>​整体思路是 因为实验室&#x2F;实习&#x2F;工作&#x2F;项目，涉及到这种异步流程，所以想着抽象出来。</p><p><strong>回答</strong>：</p><p>​学校实验室招新，新生需要加入飞书，加入飞书之后需要自动给他们创建资源（个人信息等），然后给他们拉入一个统一的群，自动发消息欢迎他们加入实验室，整体上这个流程是有很多步的，中间也有耗时操作，所以适用于异步的流程。</p><p>​同时呢，之前有关注音视频场景，知道腾讯云提供这些音视频能力，比如审核、获取元信息、转码等，一系列流程需要这么一个任务管理框架来调度。</p><p>​于是就想着自己边学边做，实现这么一个框架。</p><h4 id="3、Asyncflow-和-消息队列有什么区别？"><a href="#3、Asyncflow-和-消息队列有什么区别？" class="headerlink" title="3、Asyncflow 和 消息队列有什么区别？"></a>3、Asyncflow 和 消息队列有什么区别？</h4><p><strong>分析：</strong>这是很容易问到的问题，因为异步场景最常见的解决方案就是消息队列。</p><p>​这里主要从定位来分析：</p><ul><li>消息队列定位于消息流转</li><li>我们的框架定位于任务管理</li></ul><p><strong>回答：</strong></p><p>​定位不一样，Asyncflow 是一个框架，消息队列是个组件。消息队列确实在异步场景用的比较多，本质上就是做消息的流转。但是 Asyncflow 还支持阶段性任务，也就是可以更新任务，以及 Asyncflow 还可以做完善的任务管理，这两点是消息队列比较缺失的。</p><h4 id="4、为什么不用业界已有的异步任务框架？"><a href="#4、为什么不用业界已有的异步任务框架？" class="headerlink" title="4、为什么不用业界已有的异步任务框架？"></a>4、为什么不用业界已有的异步任务框架？</h4><p><strong>分析：</strong>最难的问题之一，出发点从定位、轻量级来说</p><p><strong>回答：</strong></p><p>​业界比较有出名的任务框架，celery 和 machinery ，celery 是 python 编写的，machinery 是 go 模仿 celery 实现的。</p><p>​他们可能都更倾向于消息流转，而不是任务管理。这里我们需要的是一个能快速实现异步任务的轻量级框架，支持上下文更改，这是 celery 和 machinery 的定义不一样的。同时呢，像 machinery 功能很齐全，支持延迟任务机制、任务定义机制、任务回调机制、任务流模式等一系列机制，很多我们并用不上，我们想做的就是一个支持异步任务管理、调度的轻量级框架。</p><h4 id="5、这个项目是你一个人做的还是团队做的？你们是怎么协作的？"><a href="#5、这个项目是你一个人做的还是团队做的？你们是怎么协作的？" class="headerlink" title="5、这个项目是你一个人做的还是团队做的？你们是怎么协作的？"></a>5、这个项目是你一个人做的还是团队做的？你们是怎么协作的？</h4><p><strong>分析：</strong>了解你是不是真的做了这个项目，以及你在其中的定位</p><p><strong>回答：</strong></p><p>​由我牵头，和学校实验室的两个同学一起进行，我负责方案设计和主要调度逻辑 worker 调度、分表、分布式锁，他们只是负责 flower 对外接口的实现，比如创建任务、处理任务接口的实现，但是像设计这些都是我做的。</p><h4 id="6、你的使用场景是什么？"><a href="#6、你的使用场景是什么？" class="headerlink" title="6、你的使用场景是什么？"></a>6、你的使用场景是什么？</h4><p><strong>分析：</strong>框架项目，面试官肯定会好奇，你是基于什么场景来做的，条件有限可以说一个场景。</p><p><strong>回答：</strong></p><p>​在学校实验室招新的时候，新生加入飞书，期间有审核、创建资源、建群、发欢迎消息等一系列动作，整个是异步的场景，实现这个能力的时候写了一些任务管理的代码。</p><p>​同时呢，之前有关注音视频场景，知道腾讯云提供这些音视频能力，比如审核、获取元信息、转码等，一系列流程需要这么一个任务管理框架来调度。</p><p>​我就把这些重复代码抽象了出来。</p><h1 id="存储、接入、部署"><a href="#存储、接入、部署" class="headerlink" title="存储、接入、部署"></a>存储、接入、部署</h1><h4 id="1、你的框架怎么接入呢？"><a href="#1、你的框架怎么接入呢？" class="headerlink" title="1、你的框架怎么接入呢？"></a>1、你的框架怎么接入呢？</h4><p><strong>分析：</strong>一个业务团队找到你，问你怎么才能使用这个框架，你该怎么给他介绍</p><p><strong>回答：</strong></p><p>​首先，用户需要自己部署框架依赖的中间件，我们框架依赖 MySQL 和 Redis，用户自己要先部署好，同时我们框架任务依赖 MySQL 中的位置信息表、 任务配置表、任务信息表，这个也得先创建好</p><p>​接着，就可以部署 flower（启动 flowsvr 程序），我们可以选择使用脚本去访问 flowsvr 对应的创建任务接口，然后 flowsvr 会和我们部署的 MySQL 交互，将任务存储到对应的任务消息表（任务信息表名字和这个任务类型强相关）。</p><p>​接下来，我们需要想办法消费任务。</p><ol><li>第一步，将任务执行的逻辑，写到 worker 里面，逻辑写进 worker 之后，等拉到对应类型的任务，也就可以执行了，具体一点来说，worker 通过 sdk 的方式提供了三个接口方法，任务需要实现这三个接口方法，将业务逻辑写进三个接口方法，才可以将这类任务注册进框架。</li></ol><blockquote><p>这三个接口方法分别是：</p><p>ContextLoad：框架的使用者也就是用户，得定义如何解析上下文（比如如何将上下文字符串解析到程序中使用）</p><p>HandleProcess：用户得自己定义一种任务类型的真正处理逻辑</p><p>HandleFinish：用于处理任务完成后的逻辑，也就是在任务成功或失败后，需要执行的一些后续操作。例如可以在这个方法中发送任务完成的通知，记录任务的执行日志等等。具体的逻辑根据业务需要而定</p></blockquote><ol start="2"><li>第二部，就是部署 worker，消费任务</li></ol><p>​说是部署，其实就是启动这个 worker 程序，然后 worker 安装用户定义的逻辑去执行</p><h4 id="2、你的框架怎么部署呢？"><a href="#2、你的框架怎么部署呢？" class="headerlink" title="2、你的框架怎么部署呢？"></a>2、你的框架怎么部署呢？</h4><p><strong>分析：</strong> 检验你的框架实际有没有使用过</p><p><strong>回答：</strong> 我们是提供框架，业务方可以根据自己的需要部署，一般我们推荐 flower 和 worker 都是多机部署，MySQL 或 Reids 使用主从模式即可</p><h4 id="3、worker-是托管在框架这边的服务器吗？还是对于异步任务的模块-如果-worker-托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么协会到业务方的数据库？"><a href="#3、worker-是托管在框架这边的服务器吗？还是对于异步任务的模块-如果-worker-托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么协会到业务方的数据库？" class="headerlink" title="3、worker 是托管在框架这边的服务器吗？还是对于异步任务的模块?如果 worker 托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么协会到业务方的数据库？"></a>3、worker 是托管在框架这边的服务器吗？还是对于异步任务的模块?如果 worker 托管在异步任务处理框架这边的服务器，那处理完之后的数据怎么协会到业务方的数据库？</h4><p><strong>分析：</strong> 问这个问题，说明面试官对框架的定位还不是特别理解，需要讲述一下</p><p><strong>回答：</strong></p><p>​我们这边是提供框架。如果一个业务团队想接入，需要自己部署 flowsvr、worker。如果业务下有几个子业务，我们是推荐业务提供公用的 flowsvr，子业务都调用这个 flowsvr，worker 的话 可以子业务自己部署。</p><h4 id="4、为什么存储用-MySQL-不用-Redis？"><a href="#4、为什么存储用-MySQL-不用-Redis？" class="headerlink" title="4、为什么存储用 MySQL 不用 Redis？"></a>4、为什么存储用 MySQL 不用 Redis？</h4><p><strong>分析：</strong> 用 MySQL 我们是有考虑的，首先 MySQL可以持久化分析，数据更可靠，其次 MySQL 支持管理化场景，比如获取任务表的时候，要根据任务类型和任务状态去获取。</p><p>​虽然 Redis 也能持久化，但是毕竟没有 MySQL 那么可靠，其次呢，Redis 也不支持关系型查询</p><blockquote><p>Redis和MySQL是两种不同类型的数据库，它们各自有着不同的特点和适用场景。因此，将它们的可靠性进行直接对比是不太合适的，而应该从不同角度来理解它们的可靠性。</p><ol><li><p>数据持久化：Redis是一个基于内存的缓存数据库，它将数据存储在内存中，可以提供快速的读写访问速度。但由于数据存储在内存中，一旦服务器重启或崩溃，数据将会丢失，这导致了Redis在持久化方面相对不如MySQL。为了解决这个问题，Redis提供了持久化机制，可以将数据定期写入磁盘或者在每次写入数据时进行日志记录，以便在重启后恢复数据。</p></li><li><p>ACID特性：MySQL是一种关系型数据库，支持ACID（原子性、一致性、隔离性和持久性）特性，这意味着MySQL可以确保数据的完整性和一致性。而Redis虽然提供了持久化机制，但不支持完整的ACID特性，因为它主要用作缓存数据库，对一致性和持久性的要求相对较低。</p></li><li><p>数据复制和高可用性：MySQL支持主从复制和多主复制，可以实现数据的备份和高可用性。在MySQL主从复制中，一个主数据库将数据复制到多个从数据库，从数据库可以接受读取请求，从而分担主数据库的读负载，并且在主数据库发生故障时可以切换到从数据库继续提供服务。而Redis也支持主从复制，但在复制过程中可能会有数据延迟，因此对于对数据一致性要求非常高的场景，MySQL的可靠性会更好一些。</p></li></ol><p>总体而言，MySQL作为一种成熟的关系型数据库，适用于需要高度可靠性和一致性的应用场景。而Redis则适用于对读写性能要求较高，对数据一致性要求相对较低的缓存和临时存储场景。在实际应用中，可以根据具体的业务需求和数据特点选择合适的数据库解决方案，甚至将Redis和MySQL结合使用，发挥它们各自的优势。</p></blockquote><p><strong>回答：</strong></p><p>​不用 Redis 的原因是因为 Redis 的可靠性不如 MySQL，以及 Redis 不支持关系型查询，而我们的场景是任务管理场景，涉及的关系型查询还蛮多的，最典型的就是根据状态拉取一批任务来执行。</p><h4 id="5、为什么存储用-MySQL-不用-MongoDB？"><a href="#5、为什么存储用-MySQL-不用-MongoDB？" class="headerlink" title="5、为什么存储用 MySQL 不用 MongoDB？"></a>5、为什么存储用 MySQL 不用 MongoDB？</h4><p><strong>分析：</strong> 众多选型中，MongoDB 是最有竞争力的，MongoDB 可以说是最接近关系型的非关系型数据库，性能好、可扩展、支持文档数据库。</p><p>​MongoDB 的局限在于不支持事务和不支持 Join，但我们的场景，其实几乎不用事务和 Join，所以说实话，MongoDB还挺适合我们的场景。</p><p>​我们底层后续也是要支持 Mongo，提供更多能力。</p><p>​回答的时候要偏向实际出发，毕竟很多团队都不用 Mongo，并且也不想引入新的存储组件。</p><p><strong>回答：</strong></p><p>​其实 MySQL 和 Mongo 都比较适合我们场景，我们的存储能力查询是封装过的，后面也打算接入 Mongo 作为底层存储之一。现在默认用 MySQL 的原因是因为大多场景，上下文都是简洁的，包括之前调研过飞书机器人、音视频处理等，而且 MySQL 是很多业务团队的基础设施，这样就不用引入新的存储组件，减少运维的容灾成本。</p><h4 id="6、上下文怎么存储的，存不下怎么办？"><a href="#6、上下文怎么存储的，存不下怎么办？" class="headerlink" title="6、上下文怎么存储的，存不下怎么办？"></a>6、上下文怎么存储的，存不下怎么办？</h4><p><strong>分析：</strong>先讲常规是不会出现这个问题的，再讲如果出现怎么办？</p><p>url 传递：类似于丢到百度云盘上，用的时候再下载回来解析成结构体。</p><p><strong>回答：</strong></p><p>​我们是用一个字段 context 存储上下文的，最大 8192 个字节。首先任务大多数情况下，上下文都是简洁的，关键信息才用上下文存储，8192 是够用的。如果遇到真存不下的情况，我们也推荐这里用 url 传递，内容太多走字节的化，走字节还是传递都是不太友好的。</p><p>​（如果感觉面试官不太满意，再说下面）</p><p>另外，这里后面也会支持 MongoDB 做底层引擎，上下文过大就可以看作是文档了，这时候用 MongoDB 会比较合适。</p><h1 id="任务创建与调度"><a href="#任务创建与调度" class="headerlink" title="任务创建与调度"></a>任务创建与调度</h1><h4 id="1、讲讲任务创建的流程"><a href="#1、讲讲任务创建的流程" class="headerlink" title="1、讲讲任务创建的流程"></a>1、讲讲任务创建的流程</h4><p><strong>分析：</strong> 这个问题没有太大的难度，更多就是看你对流程是否清晰，是否能很好的讲解一个流程</p><p><strong>回答：</strong></p><p>​首先，请求通过 http 调用，到达 flowsvr。接着，flowsvr 通过路由找到对应的执行函数，解析参数并检查是否合法。</p><p>​然后开始执行创建任务的逻辑，先查询面前插入的表号，然后讲数据插入数据库，最后构造返回包给调用放。这就是完整的创建任务的流程。</p><h4 id="2、讲讲拉取任务接口的流程"><a href="#2、讲讲拉取任务接口的流程" class="headerlink" title="2、讲讲拉取任务接口的流程"></a>2、讲讲拉取任务接口的流程</h4><p><strong>分析：</strong> 考察对任务拉取流程是否掌握，重点在于服务之间的交互流程、服务内的执行逻辑。</p><p><strong>回答：</strong></p><p>​worker 发起占据任务请求，flower 接收到之后，会根据路由找到占据任务函数并进行检查参数，接着从数据库拉取一批任务，将这批任务设置为执行中，填充返回包并返回给 worker</p><h4 id="3、下面里面对-worker-是手动还是自动发请求拉任务？"><a href="#3、下面里面对-worker-是手动还是自动发请求拉任务？" class="headerlink" title="3、下面里面对 worker 是手动还是自动发请求拉任务？"></a>3、下面里面对 worker 是手动还是自动发请求拉任务？</h4><p><strong>分析：</strong> 这个是主流程的逻辑，这里肯定是自动的。</p><p><strong>回答：</strong></p><p>​自动按一定时间间隔去拉取，时间间隔作为任务配置表的参数，用户可以灵活配置。</p><h4 id="4、你们的-MySQL-中查询是一大批还是查询一个？"><a href="#4、你们的-MySQL-中查询是一大批还是查询一个？" class="headerlink" title="4、你们的 MySQL 中查询是一大批还是查询一个？"></a>4、你们的 MySQL 中查询是一大批还是查询一个？</h4><p><strong>分析：</strong> 不用顾虑太多，就是问下细节。具体的话，属于占据任务细节，我们是批量拉取，这样效率高一些</p><p><strong>回答：</strong> 拉取任务时，我们是一次获取一批任务，这样是为了减少对 MySQL 的请求，节约性能，具体拉多少我们有任务配置表可以配置</p><h4 id="5、任务拉取按什么顺序？"><a href="#5、任务拉取按什么顺序？" class="headerlink" title="5、任务拉取按什么顺序？"></a>5、任务拉取按什么顺序？</h4><p><strong>分析：</strong> 这里是问 worker 从 flowsvr 拉取时，以什么顺序拉取任务，比如 10000 个待执行的任务，这次拉取 100 个，是拉到哪 100 个？ 理解清楚之后，其实就是 order_time 的策略了。可以讲讲思考过程，可能会加分</p><p><strong>回答：</strong></p><p>我们考虑过用创建时间或者更新时间来排序，但都存在弊端：</p><ul><li>用创建时间排序：如果是多阶段任务，一个阶段任务完成之后，回到队列中，这时候创建时间还是最小的那批，下次调度还是他，这样就无法让出调度给更饥饿的任务。</li><li>用更新时间排序，看似没问题，但是我们有个失败重试间隔的配置，即失败之后，多久之后再重试，如果还是按照更新时间，在失败重试间隔到达之前就可能被拉取到了。</li></ul><p>​创建时间、更新时间都不行，究其原因，还是排序影响因素很多，不能与单个字段耦合，特别是数据库这两个基本都有的默认字段耦合，所以我们抽象出来一个专门用来排序的字段，用来排序。</p><p>​在任务创建时等于创建时间戳。在任务更新时，等于修改时间戳，但如果是失败之后，还要加上重试间隔。</p><p>​如果有设置优先级，那么优先级也会影响这个排序字段，我需要讲一下吗？（掌握节奏）</p><h4 id="6、优先级是怎么做的"><a href="#6、优先级是怎么做的" class="headerlink" title="6、优先级是怎么做的"></a>6、优先级是怎么做的</h4><p><strong>分析：</strong> 这个如果说好了，是个可以加分的点。业界常规用的方案是分为 0~9 这种优先等级，而我们提供了优先多少秒的能力</p><p><strong>回答：</strong> </p><p>​优先级通常实现都是几个数字，表示优先级的级别，排序时就先按优先级排序，再按排序字段排序。</p><p>​但这种方案在我们的框架中会引入两个问题：</p><ol><li>需要将 priority 加入联合索引，影响性能，并且大多时候 priority 都是一样的，这个开销有点亏，而且 priority 不够灵活。</li><li>优先级高的任务，即使失败之后，马上又是最先被调度到的，占据资源还容易堵死普通任务。</li></ol><p>​所以这里我们采用的方式，是将 priority 秒化，即 priority 不表示级别，而表示优先多少秒，然后将这个数字融入我们的排序字段，这种方案耦合小、成本低、足够灵活适合框架。</p><h4 id="7、你说的这个优先级和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少？A比B为什么优先？"><a href="#7、你说的这个优先级和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少？A比B为什么优先？" class="headerlink" title="7、你说的这个优先级和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少？A比B为什么优先？"></a>7、你说的这个优先级和实现方式，你有没有想过应用场景？如何定义优先级A和优先级B是多少？A比B为什么优先？</h4><p><strong>分析：</strong> 挑战你是否有实际场景支持</p><p><strong>回答</strong>：</p><p>​我们的优先级，表示优先多少秒。业务可以自行抽象，比如一个视频处理团队，他可以定义超级 VIP，优先级 10 小时，也就是说正常情况下，他都是排到队头，但是如果任务以及阻塞了几天了，他并不是最先执行的，这时候还是优先照顾已经等很久的任务。</p><p>​也可以定义一个 SSVIP，这种 VIP就是优先 1 年，也就是说基本无视时间，即使队列积压了几天的任务，他也直接最先处理。</p><h4 id="8、你觉得你的优先级设计是绝对优先还是相对优先？"><a href="#8、你觉得你的优先级设计是绝对优先还是相对优先？" class="headerlink" title="8、你觉得你的优先级设计是绝对优先还是相对优先？"></a>8、你觉得你的优先级设计是绝对优先还是相对优先？</h4><p><strong>分析：</strong> 绝对优先就容易形成阻塞</p><p><strong>回答：</strong></p><p>​我们的优先级是逻辑上相对优先级，因为绝对容易形成阻塞。当然功能上我们是可以实现绝对优先级的，比如一个业务，其他任务都是优先个几十秒、几分钟。某些特别重要的任务设置优先级 100 年，这就是绝对优先了。</p><h4 id="9、重试间隔是什么机制"><a href="#9、重试间隔是什么机制" class="headerlink" title="9、重试间隔是什么机制"></a>9、重试间隔是什么机制</h4><p><strong>分析：</strong> </p><p>​有时候失败之后不希望立即重试，以免浪费不必要资源</p><p>​这个问题主要是考察设计细节，通过细节看你能否自圆其说</p><p><strong>回答：</strong></p><p>​通常而言，普通的重试间隔需求无非是均匀重试和渐进式重试</p><p>​我们的框架默认使用一个 interval 字段支持渐进式重试，interval 表示最大的间隔秒。考虑到确实有部分场景，希望均价重试，但我们这里并不想新增一个标记字段来配合表示，这里选择用了一种很巧妙的方式，即使用负数表示均匀重试时间。</p><p>​其实应该还有更丰富的重试策略，更进一步可能需要列表甚至 lua 这种解析策略，但我们也调研了业界 celery 等竞品，都不会做这么复杂，这里我们提供两种策略已经是很完善了。</p><h4 id="10、flower-怎么知道任务超时了，定时器轮询吗？判断任务是否超时，有无更好的办法？"><a href="#10、flower-怎么知道任务超时了，定时器轮询吗？判断任务是否超时，有无更好的办法？" class="headerlink" title="10、flower 怎么知道任务超时了，定时器轮询吗？判断任务是否超时，有无更好的办法？"></a>10、flower 怎么知道任务超时了，定时器轮询吗？判断任务是否超时，有无更好的办法？</h4><p> <strong>分析：</strong> 首先这里需要和面试官对齐所谓的任务超时是什么情况，这里容易有歧义的，我们这里所谓的任务超时，是指一个任务被占据之后，长时间处于执行中。</p><p>​这个长时间的判断标准，是由业务来设置的：</p><ul><li>如果我们调用腾讯云图片审核能力，也就是发起一个接口调用，那这个阶段的占据时间通常不会超过一分钟，1 分钟就是最大执行时间</li><li>如果下载一个文件，那时间可能就是5分钟或者更久</li></ul><p><strong>回答：</strong> </p><p>​我们使用定时器轮询，这里是抽象了一个任务治理模块，去扫描这些超过最大执行时间的任务，最大执行时间也是业务根据检验设置的，这类任务一般都是由于异常原因，worker 没有上报结果导致，可能是 worker 挂掉等原因，所以需要任务治理去发现。</p><p>​目前架构下没有更好的方式了，这种完全失联只能扫描。</p><blockquote><p>如果发现了任务超时，设置为待执行，超时就是过长时间在执行中，只能重置。</p></blockquote><h4 id="11、任务如果执行中失败了怎么办？"><a href="#11、任务如果执行中失败了怎么办？" class="headerlink" title="11、任务如果执行中失败了怎么办？"></a>11、任务如果执行中失败了怎么办？</h4><p><strong>分析：</strong> 考察失败情况处理</p><p><strong>回答：</strong> </p><p>​框架支持重做，如果任务执行失败了并且没有超过重试次数，就会将状态改成待执行状态，等待下次被调度执行；如果执行失败并且超过重试次数了，那么就是彻底失败，将状态改成失败。</p><h4 id="12、-worker-怎么竞争任务？"><a href="#12、-worker-怎么竞争任务？" class="headerlink" title="12、 worker 怎么竞争任务？"></a>12、 worker 怎么竞争任务？</h4><p><strong>分析：</strong> 回答分布式锁的方式，要点是说：到底是谁竞争锁，竞争之后多久释放</p><p><strong>回答：</strong> 我们是使用分布式锁的方式，worker 在拉取任务之前，会竞争一个分布式锁，拿到了分布式锁才能占据任务，为了提高速度，我们是占据任务成功之后，然后就释放锁，这样并发受到的影响稍微小一些。</p><h4 id="13、为什么不用-MySQL-自带的锁？"><a href="#13、为什么不用-MySQL-自带的锁？" class="headerlink" title="13、为什么不用 MySQL 自带的锁？"></a>13、为什么不用 MySQL 自带的锁？</h4><p><strong>分析：</strong> 不主动提随机竞争方案，但如果面试官问到了为什么不使用 MySQL 锁的时候，就可以从冲突时 CPU压力不稳定的角度回答</p><p><strong>回答：</strong></p><p>​我也考虑过用 MySQL 自带的锁，并且有两个思路，第一个就是拉任务用 for update 语句，但这产生的间隙锁容易对其他 SQL 语句产生影响，并且《高性能MySQL》也是不推荐使用 for update 这种方式的。</p><p>​第二个思路是先拉一次任务，然后将这批任务设置为执行中，并设置自己为 owner，接着再拉一次执行中并且标记是 woner 的任务，但这个方案也有缺点：一个是多次 SQL 调用；第二个是当 worker 多一点的时候，碰撞容易很激烈，都是抢头部 200 个任务，去竞争设置他们，大量的锁排队，这样测试下来也发现 MySQL CPU 不稳定，冲突激烈时会很高，而且因为冲突的随机性，业务执行性能不稳定，而且很难预知。</p><p>​所以采用分布式锁的方式，避免这种冲突，也减少 SQL 调用次数。</p><h4 id="14、用了分布式锁，一个任务就一定不会被多个-worker-同时拿到吗？"><a href="#14、用了分布式锁，一个任务就一定不会被多个-worker-同时拿到吗？" class="headerlink" title="14、用了分布式锁，一个任务就一定不会被多个 worker 同时拿到吗？"></a>14、用了分布式锁，一个任务就一定不会被多个 worker 同时拿到吗？</h4><p><strong>分析：</strong> 在问你对分布式锁的理解，世界上没有完全可靠的分布式锁。</p><p><strong>回答：</strong> </p><p>​不一定，分布式锁只能说在绝大多数的情况下，都能让一个任务被一个 worker 拿到。但是如果发生了一些异常，比如 worker 陷入 gc，锁又过期了，这时候就会被其他 worker 拿到，这时候头一个 worker 恢复过来了，他们就同时执行一个任务。</p><p>​所以这里，业务自身是需要做幂等的。</p><h4 id="15、竞争分布式锁这种方式，会不会有什么问题？"><a href="#15、竞争分布式锁这种方式，会不会有什么问题？" class="headerlink" title="15、竞争分布式锁这种方式，会不会有什么问题？"></a>15、竞争分布式锁这种方式，会不会有什么问题？</h4><p><strong>分析：</strong></p><p>​主要从抢锁操作会成为系统瓶颈，导致 worker 无法水平扩容的角度出发，分析具体逻辑，再进一步抽象这个问题。本质上是由于同步拉取和并发执行两个操作的耦合导致的，最后再踢出使用单独服务拉取任务到消息队列的解耦方案</p><p><strong>回答：</strong> </p><p>​加入分布式锁之后，分布式锁的抢锁操作可能成为一个瓶颈，影响 worker 的水平扩容。因为每个 worker 在拉取任务之前都需要抢分布式锁，所有 worker 越多，抢分布式锁的竞争就越激烈，如果锁持有时间是一定的，则一个时间段可以抢到锁的 worker 数量是有限的，这也限制了 worker 的水平扩容。同时，worker 在抢锁失败之后需要等段时间再次抢锁，使得大量 worker 可能只是空转，浪费了资源。</p><p>​总体上来说，导致这个问题的本质原因是在设计中将同步拉取和并发执行两个操作耦合，如果要进一步解决这个问题还是要思考将两个操作解耦。</p><p>​这里我也考虑过优化方案，可以说一下么 (ps:如果让说，就是叙述单独服务拉取任务到消息队列的解耦方案）</p><h4 id="16、不使用-Redis，如何解决多机竞争问题？设计一个新方案"><a href="#16、不使用-Redis，如何解决多机竞争问题？设计一个新方案" class="headerlink" title="16、不使用 Redis，如何解决多机竞争问题？设计一个新方案"></a>16、不使用 Redis，如何解决多机竞争问题？设计一个新方案</h4><p><strong>分析：</strong> 提出这个问题，说明面试官看到 Redis 分布式锁这里的瓶颈，很敏锐。</p><p>​这里可以直接回答怎么做，但是更好的是先自然而然阐述下，自己对分布式瓶颈的思考，这样才能凸显出分布式锁的优势。</p><p><strong>回答：</strong> 其实我也考虑过这个问题，分布式锁会带来 worker 无法水平扩容的问题，本质是同步拉取和并发执行的耦合，所以这里引入一个拉取服务，专门用来拉取并占据任务，然后扔入 kafka，通过 kafka 多分区特性，worker 就可以并发消费了，这样就实现了解耦。</p><h4 id="17、你采用的是多台-worker-竞争任务的方式，那这样会不会出现有些-worker-在执行大量任务，但是一部分-worker-处于空闲的状态呢？"><a href="#17、你采用的是多台-worker-竞争任务的方式，那这样会不会出现有些-worker-在执行大量任务，但是一部分-worker-处于空闲的状态呢？" class="headerlink" title="17、你采用的是多台 worker 竞争任务的方式，那这样会不会出现有些 worker 在执行大量任务，但是一部分 worker 处于空闲的状态呢？"></a>17、你采用的是多台 worker 竞争任务的方式，那这样会不会出现有些 worker 在执行大量任务，但是一部分 worker 处于空闲的状态呢？</h4><p><strong>分析：</strong> </p><p>​我们以分布式锁的方案来讨论，我们的 worker 占据任务之后，在执行前就释放了锁，这个时间很短，这种情况下执行时间才是大头，那第一个 worker 还在执行中，其他 worker 就可以拉到任务，不会出现所谓一部分 worker 处于空闲，如果出现了，那其实就是 worker 太多了。</p><p><strong>回答：</strong></p><p>​不会的，我们占据任务之后，就会释放锁，这个是在执行之前，假设资源配置合理，那多台机器都会有任务去做。如果出现有机器闲置，说明可以缩容。</p><p>​另外，为了避免任务比较少时，一个 worker 老是竞争成功这种不均衡的情况，我们也加入一个随机的间隔时间，以增加更多随机性</p><h4 id="18、任务如果执行中-worker-挂掉怎么办"><a href="#18、任务如果执行中-worker-挂掉怎么办" class="headerlink" title="18、任务如果执行中 worker 挂掉怎么办?"></a>18、任务如果执行中 worker 挂掉怎么办?</h4><p><strong>分析:</strong></p><ul><li><p>如果 worker 挂了，那么之前拉取的任务就处于执行中的状态</p></li><li><p>不会再被调度那么这就有任务卡死的现象 </p></li><li><p>任务治理服务会定义检查是否有长期处于执行中卡死的任务</p></li><li><p>如果有，任务治理服务会获取这些卡死的服务，并将他们的状态重置为待执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">seelect * from A where status = 2 and now() &gt; modify_time + max_processing_time<br></code></pre></td></tr></table></figure></li></ul><p><strong>回答</strong>：</p><p>​任务会停留在执行中的状态，框架提供最大执行时间配置，超过执行时间就会由任务治理重置任务，由于我们保存了上下文，所以下次再做的时候会从最新阶段开始做，这样一部分已经做过的事情就不会重复做了。</p><h4 id="19、那你是怎么得出分布式锁性能很差，然后要引入MQ的结论的？是理论上绝对比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧？而不是拍脑袋的一个决定。"><a href="#19、那你是怎么得出分布式锁性能很差，然后要引入MQ的结论的？是理论上绝对比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧？而不是拍脑袋的一个决定。" class="headerlink" title="19、那你是怎么得出分布式锁性能很差，然后要引入MQ的结论的？是理论上绝对比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧？而不是拍脑袋的一个决定。"></a>19、那你是怎么得出分布式锁性能很差，然后要引入MQ的结论的？是理论上绝对比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧？而不是拍脑袋的一个决定。</h4><p><strong>分析：</strong></p><p>​架构的设计需要有前瞻性，可以不做，但是不能没考虑到</p><p>​最终不做的理由，也是面试官所说的，没有遇到瓶颈，为何要去优化</p><p><strong>回答：</strong></p><p>​主要是通过理论设计到这个优化，属于是做完项目的一个 review。同时也考虑到分布式锁在大多数场景都是够用了，同时也没有实际场景因为分布式锁遇到性能瓶颈，所以还没有去这么做，原则就是不过度去实现</p><h4 id="20、你在这个项目里用-mysql-是比较多的，那有用到事务吗？"><a href="#20、你在这个项目里用-mysql-是比较多的，那有用到事务吗？" class="headerlink" title="20、你在这个项目里用 mysql 是比较多的，那有用到事务吗？"></a>20、你在这个项目里用 mysql 是比较多的，那有用到事务吗？</h4><p><strong>分析：</strong></p><p>​这是询问业务细节，也是想通过询问细节知识点进一步了解项目</p><p><strong>回答：</strong></p><p>​我们的业务没有主动开启事务，目前没有地方设计 2 张表的更新操作，也没有主动加 for update 锁的场景，都是单独的 sql 语句去处理的。</p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><h4 id="1、分表为什么自己写，为什么不用组件？"><a href="#1、分表为什么自己写，为什么不用组件？" class="headerlink" title="1、分表为什么自己写，为什么不用组件？"></a>1、分表为什么自己写，为什么不用组件？</h4><p><strong>分析：</strong></p><ol><li>我们需要按大小迭代</li><li>老表热度越来越低</li><li>业界组件不支持按大小分片</li><li>自己实现成本低</li></ol><p><strong>回答：</strong></p><p>​常见的组件比如 MyCat 分表，是按照业务字段 hash，比如 useid hash 不同用户到不同的分片里。</p><p>​而在我们的框架里面，是需要按照大小来迭代新表的（达到500万条数据就分表）</p><p>​并且思路是老表逐渐作废，不是多个分片长期提供服务，相当于一个窗口不断的滑动</p><p>​同时这个分表逻辑并不复杂，评估了成本和需求之后决定自己做</p><h4 id="2、分表难在哪里"><a href="#2、分表难在哪里" class="headerlink" title="2、分表难在哪里"></a>2、分表难在哪里</h4><p><strong>分析：</strong> 其实分表不难，但这里需要把一个不难的事情，讲得听起来有点难度，以及是校招，可以定位成对学生而言很难</p><p><strong>回答：</strong></p><p>​难点我觉得有两个方面：</p><ol><li><p>选型上，我们其实是二维分表，一个是 taskType 来做了隔离</p><p>，另一个是根据大小进行了滚动分表，这里我们没有按调研的常用分表组件来做，而是选了适合我们的方式，我觉得这个是有一定难度的</p></li><li><p>实现上的细节设计考虑点还是很多，比如什么时候分表、谁来分表、怎么降低检查分表对性能的影响。比如我们一开始是想在创建认为时来 count(*) 来检查，但是考虑到这会造成性能问题，</p><p>[^性能问题]: count(*) 是全表扫描，创建一次插入请求可能是20 ms，但是加入一个 count(*) 操作可能就变成了800 ms，接口性能就急剧下降了</p><p>所以选择了定时检查，容忍了一定程度的延迟。比如还有一个问题，我们分表之后，怎么快速查询到某个任务在哪张表？这里我们选择了通过在任务 ID 上做手脚，加了个数字尾巴，这种方式减少了查询成本。这些细节其实都花了不少心思去设计。</p></li></ol><p>​总的来说，我认为这里的难点在于整体选型及细节设计上。</p><blockquote><p>​可能这个对于工作经验很丰富的人来说确实不算很难，但我真的是一步一步从 0 到 1 摸索出来的，对我而言还是很有挑战和难度的。</p></blockquote><h4 id="3、介绍你的分表方式？"><a href="#3、介绍你的分表方式？" class="headerlink" title="3、介绍你的分表方式？"></a>3、介绍你的分表方式？</h4><p><strong>分析：</strong></p><p>​要点：</p><ol><li>按大小分表</li><li>分表之后消费产生的变化</li></ol><p><strong>回答：</strong></p><p>​我们的任务达到一定阈值就会发生分表，分表之后新增任务写入新表，消费还是走老表，老表消费完成之后再消费到新表。消费几号表、写入几号表，这个信息我们也是通过一张单独的任务位置表记录的。</p><h4 id="4、为什么按大小分表？"><a href="#4、为什么按大小分表？" class="headerlink" title="4、为什么按大小分表？"></a>4、为什么按大小分表？</h4><p><strong>分析：</strong> </p><ol><li>我们的任务执行完了基本就冷了，和账单那种随时间变冷很像，其实我们会更冷一些</li><li>这里要明确，我们其实更偏向于滚表，但是我们之前的数据还能支持提供按 id 查询等能力，所以分表是 ok 的</li></ol><p><strong>回答：</strong></p><p>​我们是记录任务，任务一般做完之后，很快就变成了比较冷的数据，甚至某些业务1、2月前的历史数据都可以删除掉，所以更适合这种滚动分表</p><p>​分表之后，我们的任务消费、任务创建这种主要操作都是发生在热表上，通过任务 id 查询任务信息这类操作则可以通过后缀快速去对应的表查，无论冷热</p><p>​这种策略对性能友好、也对后面存储友好，同时也非常适合我们的场景</p><h4 id="5、我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天-10W-条，10-天-100W，那你两个月分一次就可以了，不用这么麻烦"><a href="#5、我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天-10W-条，10-天-100W，那你两个月分一次就可以了，不用这么麻烦" class="headerlink" title="5、我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天 10W 条，10 天 100W，那你两个月分一次就可以了，不用这么麻烦"></a>5、我觉得与其管理任务位置，为什么不通过时间分表呢？你这个实现方式应该挺复杂的，需要记录任务位置，我可以预估一个任务量，然后按照时间分就可以了。比如你一天 10W 条，10 天 100W，那你两个月分一次就可以了，不用这么麻烦</h4><p><strong>分析：</strong></p><p>​其实本质还是可以按时间划分的，老表时间肯定比新表早，但区别在于，触发的时机不是固定的时间分割，而是大小分割，为的是一个及时性和数据量均匀性</p><p><strong>回答：</strong></p><p>​我觉得对于任务的增速和流量大小，很有可能是不平均，比如说秒杀场景，会有一大波任务过来，这种情况，我们如果靠一个平均的速率去预估进行分表，肯定是不合理的，很容易发送数据量超过分表阈值，但是没有及时分表影响性能的情况。我认为这里不如去定时扫描任务量，这样可以保证分表是及时的。</p><h4 id="6、你为了机器人项目做了一个框架？你量这么小，弄-500w-分表？"><a href="#6、你为了机器人项目做了一个框架？你量这么小，弄-500w-分表？" class="headerlink" title="6、你为了机器人项目做了一个框架？你量这么小，弄 500w 分表？"></a>6、你为了机器人项目做了一个框架？你量这么小，弄 500w 分表？</h4><p><strong>分析:</strong>这个问题问得挺务实的，也是挑战你的出发点</p><p>​被问到不要慌，首先我们这个是框架，框架又不是服务于单个场景，其次考虑成本收益，是站得住脚的</p><p><strong>回答：</strong></p><p>​这个我们其实考虑的收益和成本。</p><p>​首先，作为一个框架，我们需要能应对不同的情况，机器人项目虽然小，但其他异步场景一天几十万也是正常的，比如区块链场景，所以提供分表对我们而言让框架不那么玩具化，这是收益。</p><p>​同时，从成本考虑，我们的分表方案其实偏向于滚表，到 500w 就产生新的表，旧表还有存活任务就继续消费旧表，新任务写入新表，实现起来代码量也比较少，思路也比较清晰，成本较低。</p><p>​综合收益和成本来看，我觉得这个算前瞻性设计而不是过度设计。</p><h4 id="7、flower-怎么知道到达分表阈值了？轮询吗？这里有细节吗？当面试官说你不能就说判断到阈值了，这里总有代码实现，我想听细节"><a href="#7、flower-怎么知道到达分表阈值了？轮询吗？这里有细节吗？当面试官说你不能就说判断到阈值了，这里总有代码实现，我想听细节" class="headerlink" title="7、flower 怎么知道到达分表阈值了？轮询吗？这里有细节吗？当面试官说你不能就说判断到阈值了，这里总有代码实现，我想听细节"></a>7、flower 怎么知道到达分表阈值了？轮询吗？这里有细节吗？当面试官说你不能就说判断到阈值了，这里总有代码实现，我想听细节</h4><p><strong>分析：</strong> 几个要点</p><ol><li>要说我们有一个任务治理模块去做的，这个模块目前为了简单，是放在 flowsvr 的，其实应该独立出来</li><li>要听细节，就要将下实际是一个线程，具体使用了什么操作来进行的检查</li></ol><p>​更进一步分析一下其他方案，以及为什么选择了 当前方案</p><p><strong>回答：</strong></p><p>​我们有个任务治理模块去轮询，可以理解为有 个线程去 <code>count(*)</code> 查看总数是否达到阈值。</p><p>​这里我们其实还考虑过在创建时判断，但是如果增加一个 <code>count(*)</code> 去判断，这样创建的吞吐会大幅降低，这种方式也可以进一步优化。</p><p>​比如创建时同时在 Redis 中增加 1 ，这样可以用 Redis 来进行判断，至于 Redis 可能遗漏一些数据，本身对我们而言这个数据也不需要完全准确。</p><p>​但为什么后面没这样做，是因为目前线程轮询的方式并不会带来瓶颈，虽然不是最好，但也够用，所以没去做太过前瞻的设计。</p><h4 id="8、如果读写请求大到单表处理不过来呢？"><a href="#8、如果读写请求大到单表处理不过来呢？" class="headerlink" title="8、如果读写请求大到单表处理不过来呢？"></a>8、如果读写请求大到单表处理不过来呢？</h4><p><strong>分析：</strong> 能问出这个问题，说明面试官很敏锐，抓住了我们这里无法水平扩展的问题。</p><p>​我们的思路就两点：</p><ol><li>这块需要量很大才会成为瓶颈，而异步任务一般不会这么大，所以没过度设计</li><li>我们也思考过怎么扩展，虽然没做，但是考虑周全</li></ol><p><strong>回答：</strong></p><p>​ 我们的热点请求，都是任务调度相关的拉取和任务设置状态，这两个操作都有走索引。</p><p>​通常来说普通的 MySQL 配置如 8 核 16 G，每秒 6000 是没什么问题的，这样 一小时可以支持2160 w任务，在异步场景下瓶颈通常也不在这里。</p><p>​如果单表确实性能不够了，我们也可以支持按用户 Hash 分片，一个比较容易的方式是接入 tdsql 这种完全兼容 mysql 的数据库，可以自动分片。另外我们也打算提供 mongodb 这样天然支持分片的文档数据库用作任务管理，这个可以根据场景选择的。</p><h4 id="9、会不会出现-schedule-begin-pos-和-schedule-end-pos-跨不止-1-张表的情况？"><a href="#9、会不会出现-schedule-begin-pos-和-schedule-end-pos-跨不止-1-张表的情况？" class="headerlink" title="9、会不会出现 schedule_begin_pos 和 schedule_end_pos 跨不止 1 张表的情况？"></a>9、会不会出现 schedule_begin_pos 和 schedule_end_pos 跨不止 1 张表的情况？</h4><p><strong>分析：</strong>考虑极端一点的情况</p><p><strong>回答：</strong></p><p>​会，但可能性不高。比如突然一波海量流量，比如 worker 挂掉，长时间积累。</p><p>​这种情况要么等待逐渐消耗，要么需要增加 worker 来提升吞吐。</p><h4 id="10、推荐分表的阈值是多少？为什么这么推荐？"><a href="#10、推荐分表的阈值是多少？为什么这么推荐？" class="headerlink" title="10、推荐分表的阈值是多少？为什么这么推荐？"></a>10、推荐分表的阈值是多少？为什么这么推荐？</h4><p><strong>分析：</strong></p><p>​我们默认是 500w，这也是一个经验值，网上说的 2000w 3 层，我感觉可能也不是特别靠谱，可能重点还是是否请求基本全走索引，不是的话，2000 w 还是有压力的。</p><p><strong>回答：</strong></p><p>​500w。网上推荐比较多的是把 B+ 树层数维持在三层，也就是最多 2000w。实践中这个数字其实应该更小一些，阿里巴巴就推荐 500w 数据分表，因为实际查询很多时候不全走索引场景，比如我们的场景需要支持比较丰富的任务管理，以及数量统计等请求。举个例子，查询某个用户当前进行中任务总数，以及分页查询，这些请求在 500w 左右就已经有压力了。</p><p>​同时 500w 和 2000w 对于相对正常的任务消费而言，都是够用的，所以选择了 500w。</p><h4 id="11、分表时，如果任务全到-1-号表，0-号表是清掉吗？用什么语句清，为什么？这里有做设计吗？"><a href="#11、分表时，如果任务全到-1-号表，0-号表是清掉吗？用什么语句清，为什么？这里有做设计吗？" class="headerlink" title="11、分表时，如果任务全到 1 号表，0 号表是清掉吗？用什么语句清，为什么？这里有做设计吗？"></a>11、分表时，如果任务全到 1 号表，0 号表是清掉吗？用什么语句清，为什么？这里有做设计吗？</h4><p><strong>分析：</strong></p><p>​这个问题还是确认分表细节，面试官这么问，我们其实并不知道他到底单纯想问已完成的表的清理，还是其实没理解我们的分表方案是滚动，所以我们再简述下我们的分表，再回答问题</p><p><strong>回答：</strong></p><p>​分表之后，0 号表如果还有任务，是先消费 0 号表，完成之后再消费 1 号表，也就类似于一个老队列，需要先做完，再做新队列</p><p>​这样滚动下去，历史的已完成的老表，就可以根据业务情况清理了，比如一个半年前的表，通常可以直接 drop 掉。</p><h4 id="12、能否继续往0-1-2-3-4-号表滚动，这样不久支持更多任务了？"><a href="#12、能否继续往0-1-2-3-4-号表滚动，这样不久支持更多任务了？" class="headerlink" title="12、能否继续往0 1 2 3 4 号表滚动，这样不久支持更多任务了？"></a>12、能否继续往0 1 2 3 4 号表滚动，这样不久支持更多任务了？</h4><p><strong>分析：</strong></p><p>​提问不太清晰，直观理解应该是说 500w 太小了，一次滚多个表，存储就更大了。我们不要陷入他的提问来纠缠这种方式为啥不好，而是说我们有更好的方式</p><p><strong>回答：</strong></p><p>​异步任务瓶颈在执行，而不是在任务拉取，通常来说单个表 500w 是够用了。但如果更进一步需要支持更多任务，我会选择用 TDSQL 这种分布式 MySQL，或者 MongoDB 这样可以分片的数据库，这样单表的数据就可以进一步往上走，也就是说维持现在的编号分表，但是某个分表，比如 1 号表，他本身又是支持了分片的。</p><h4 id="13、你是对任务信息表分表，为什么不直接按照任务-id-分表，比如大于-5002-一张表，大于-1000w-一张表？"><a href="#13、你是对任务信息表分表，为什么不直接按照任务-id-分表，比如大于-5002-一张表，大于-1000w-一张表？" class="headerlink" title="13、你是对任务信息表分表，为什么不直接按照任务 id 分表，比如大于 5002 一张表，大于 1000w 一张表？"></a>13、你是对任务信息表分表，为什么不直接按照任务 id 分表，比如大于 5002 一张表，大于 1000w 一张表？</h4><p><strong>分析：</strong> 是可以按照 id 分，但是就耦合这个数据，同时创建之后就不知道 id 是多少了，还是得线程去轮询查，没有明星受益</p><p><strong>回答：</strong></p><p>​用 id 分其实是可以的。但是考虑到 count 是最准确的，依赖于 id 这种递增规则，其实是不同用的做法。同时，如果使用 id，在创建之后也拿不到 id 是多少，也可能单独去查一次，还得单独开线程定时去查，这样做的话没有明显的收益，反而因为前面原因增加了心智成本，所以最终还是用 count 总数的方式。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h4 id="1、你这个框架的性能怎么样"><a href="#1、你这个框架的性能怎么样" class="headerlink" title="1、你这个框架的性能怎么样"></a>1、你这个框架的性能怎么样</h4><p><strong>分析：</strong></p><p>​性能其实在不同机器上测出来都不一样，我们给一个不离谱的数值就可以了，比如说是测出来 2000，如果想他问优化，就可以说是 500 优化到了 2000</p><p><strong>回答：</strong></p><p>​我们这里测了主要的接口，包括创建任务、查询任务、占据任务等。其中创建任务能达到 2000，机器是 2 核 4 G 云虚拟机，原来是 500 qps，优化之后达到 2000 qps。</p><h4 id="2、选的是什么数据来测试？"><a href="#2、选的是什么数据来测试？" class="headerlink" title="2、选的是什么数据来测试？"></a>2、选的是什么数据来测试？</h4><p><strong>分析：</strong></p><p>​这个应该是对着建立问业务细节，选择什么数据，应该是说什么数据量下，什么接口或者什么场景进行的测试，那么回答也需要细节一点</p><p><strong>回答：</strong></p><p>​我们在数据库装满 500w 数据情况下，测试了创建任务、占据任务、查询任务结果这几个核心接口，创建任务和占据任务调优之后可以从 500 到 2000 qps，查询任务结构因为有缓存所以很轻松能达到 4000 以上 qps，没有进一步测他极限，理论上 Redis 查询是可以10 多万的。</p><h4 id="3、一开始的性能瓶颈是什么？"><a href="#3、一开始的性能瓶颈是什么？" class="headerlink" title="3、一开始的性能瓶颈是什么？"></a>3、一开始的性能瓶颈是什么？</h4><p><strong>分析：</strong></p><p>​一开始是连接池压不上去，如果检验不是很深，切忌不要答得太过完美，留下一些 “不成熟” 反而是好事。注意是 MySQL 连接池</p><p><strong>回答：</strong></p><p>​一开始是因为原来连接池设置过小，大概是 10，压力上去之后，QPS 大量降低，通过 netstat 观测到 TIME_WAIT 很多，同时出现端口耗尽报错，定位到是连接池问题，调大（2000）之后不再有端口耗尽问题，同时性能高了近一倍，提升这么多主要原因也是因为端口耗尽导致压力也上不去。后面就是 GC 成为了新瓶颈，再后面还接入缓存，大大提升了查询性能。</p><h4 id="4、你是怎么测试的"><a href="#4、你是怎么测试的" class="headerlink" title="4、你是怎么测试的"></a>4、你是怎么测试的</h4><p><strong>分析：</strong></p><p>​问怎么测试有两个目的，一个看你是不是真的测试了，另一个也确实好奇你的测试方式，增加真实性，建议说多种方式。</p><p><strong>回答：</strong></p><p>​一开始是自己写 Golang 程序来进行压测，但是后面感觉不够专业，就采用了 Wrk 这个轻量级开源工具进行测试，配合 Lua 脚本可以很方便地发起压测，支持设置并发数（100、200）、持续时间、间隔时间等参数。</p><h4 id="5、如果突然有特别多数据怎么处理呢？不考虑对-worker-进行扩容，不考虑增加机器，比如多了-50-这样的需求，框架的瓶颈在什么地方？这个模块会出什么问题"><a href="#5、如果突然有特别多数据怎么处理呢？不考虑对-worker-进行扩容，不考虑增加机器，比如多了-50-这样的需求，框架的瓶颈在什么地方？这个模块会出什么问题" class="headerlink" title="5、如果突然有特别多数据怎么处理呢？不考虑对 worker 进行扩容，不考虑增加机器，比如多了 50% 这样的需求，框架的瓶颈在什么地方？这个模块会出什么问题"></a>5、如果突然有特别多数据怎么处理呢？不考虑对 worker 进行扩容，不考虑增加机器，比如多了 50% 这样的需求，框架的瓶颈在什么地方？这个模块会出什么问题</h4><p><strong>分析：</strong></p><p>​这个问题其实挺难的，属于一道优化的开放题，没有标准答案，建议以开放的思路来进行回答，展现思考。</p><p>​分多个方向提吧，数据库是最容易成为瓶颈的，先提数据库，然后从方案设计，然后从 worker 程序优化。</p><p><strong>回答：</strong></p><p>​我觉得瓶颈可能考虑三个地方：</p><ol><li>从数据库来看，我们拉取之前会判断是否这个任务类型达到了当前能执行的最大个数，这种 count 的操作数，也容易成为瓶颈，这里可以做一个 Redis 缓存，定时刷新（1~10s)，这样也能提升执行时的吞吐</li><li>从设计来看，我们刚刚提到的消息队列解耦方式，也能提高吞吐</li><li>从 worker 程序本身来看， HTTP 连接池、GC 回收阈值参数，这些也可以进一步调优，这个时间的话需要结合测试。</li></ol><h4 id="6、任务积压怎么解决、怎么发现，不能说积压了就甩给-worker-不管了。"><a href="#6、任务积压怎么解决、怎么发现，不能说积压了就甩给-worker-不管了。" class="headerlink" title="6、任务积压怎么解决、怎么发现，不能说积压了就甩给 worker 不管了。"></a>6、任务积压怎么解决、怎么发现，不能说积压了就甩给 worker 不管了。</h4><p><strong>分析：</strong></p><ol><li>积压是队列化场景常见问题</li><li>解决思路可以从多个方向去说</li><li>这个功能属于细节加强，目前没有实现，通过这个问题正好可以思考出一些方案</li></ol><p><strong>回答：</strong></p><p>​首先我们可以通过日志（记录当前还没有消费的任务个数）和监控发现积压，同时我们在拉取任务是会检查当前任务总数的，这时候也能发现。</p><p>​如果积压不严重的话，我们可以扩容 worker 来解决</p><p>​如果积压太过严重，老任务已经受影响了，可以考保新任务，我们这里基于分表逻辑来处理：简单来说，是发现积压国中时，通过触发一个特殊的分表接口，主动分表，老数据设置为失败，用户重试即可。</p><h4 id="7、你是如何调优的？"><a href="#7、你是如何调优的？" class="headerlink" title="7、你是如何调优的？"></a>7、你是如何调优的？</h4><p><strong>分析：</strong></p><p>​有几个点可以说，连接池、工具包、GC、缓存，性能调优是个难题，如果经验不是很深，切忌不要答得太过完美</p><p><strong>回答：</strong></p><p>​我是一步一步，从三个方面调优的：</p><ol><li>连接池调优：原来连接池设置过小，大概是 10，压力上去之后，QPS 大量降低，通过 netstat 观测到 TIME_WAIT 很多，同时出现端口耗尽报错，定位到是连接池的问题，调大之后不再有端口耗尽问题，同时性能提高了近一倍，提升这么多主要原因也是端口耗尽导致压力也上不去。</li><li>GC 调优：默认的配置下，新申请的内存只要达到上次预留的 1:1 大小，就会触发 GC，在高压下是很容易触发的，于是我们将配置比调大了 10 倍，达到 10:1 才会触发，这种策略大大减少了 GC 的次数，性能提升了 20% 左右</li><li>日志库优化：Golang 原来用的是 seelog，这里主要是考虑 seelog 是最古老最成熟的日志库，但实际使用下来性能是真的低，这里优化成 zaplog 之后，性能提高了 50%</li></ol><h4 id="8、那如果有更多-TIME-WAIT-状态连接-你会怎么处理？继续调大参数？"><a href="#8、那如果有更多-TIME-WAIT-状态连接-你会怎么处理？继续调大参数？" class="headerlink" title="8、那如果有更多 TIME_WAIT 状态连接 你会怎么处理？继续调大参数？"></a>8、那如果有更多 TIME_WAIT 状态连接 你会怎么处理？继续调大参数？</h4><p><strong>分析：</strong></p><p>​这个预设条件有问题，调大之后如果压力进一步放大，先达到瓶颈的是 MySQL</p><p><strong>回答：</strong></p><p>​单个 worker 对于 MySQL 的连接数 2000 已经够多了，不会再继续堆积 TIME_WAIT，此时我们的瓶颈是 MySQL。</p><h4 id="9、你不是说你的-worker-只有六台吗？六台-worker-拉取任务需要-2000-qps？"><a href="#9、你不是说你的-worker-只有六台吗？六台-worker-拉取任务需要-2000-qps？" class="headerlink" title="9、你不是说你的 worker 只有六台吗？六台 worker 拉取任务需要 2000 qps？"></a>9、你不是说你的 worker 只有六台吗？六台 worker 拉取任务需要 2000 qps？</h4><p><strong>分析：</strong></p><p>​这个问题是说 6 台 worker，就算都是 1s 一次拉取，也只需要 6qps，为啥要测到 2000.</p><p>​回答的思路从我们的定位是框架来说，也可以说一下测到 2000 并没有带来太多的额外成本。</p><p><strong>回答：</strong></p><p>​我们是框架，我们的场景虽然不需要这么高的 qps，但是我们会测到一个相对高的数值。不只是这个接口，创建任务、拉取任务、查询任务等我们都做了。虽然拉取任务不需要 2000，但我们压测适度调优就达到了 2000，属于一个非常够用的值。</p><h4 id="10、那你是怎么得出这里的性能很差，然后要引入MQ的结论的呢-是理论上觉得比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的一个决定的吧？"><a href="#10、那你是怎么得出这里的性能很差，然后要引入MQ的结论的呢-是理论上觉得比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的一个决定的吧？" class="headerlink" title="10、那你是怎么得出这里的性能很差，然后要引入MQ的结论的呢? 是理论上觉得比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的一个决定的吧？"></a>10、那你是怎么得出这里的性能很差，然后要引入MQ的结论的呢? 是理论上觉得比较差，还是实际上观察到的比较差。你应该是先遇到问题，然后才想着去优化吧，而不是拍脑袋的一个决定的吧？</h4><p><strong>分析：</strong></p><p>​这个问题的核心是挑战你为啥没有瓶颈去优化，回答主要也要解答这人问题，思路就是你说的对，没瓶颈就不要优化，我们只是设想了，没真的去做。<br><strong>回答：</strong><br>​我们主要是通过理论设想到这个优化，在做完项目之后，我们组织了一个复盘会议，进行一些功能和设计的<br>Review，就设想到了这人优化。<br>​但是因为确实没有实际问题，同时也考虑到这需要很大量级才会出现，起码得几十个worker才会真正带来问题<br>所以还没有这么去做。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短变量声明的小细节</title>
    <link href="/2023/08/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <url>/2023/08/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (*<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br><span class="hljs-keyword">return</span> &amp;i, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//use p</span><br>fmt.Println(*p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p, err := foo()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>bar()<br>fmt.Println(*p)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 5 5</li><li>B. runtime error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。知识点：变量作用域。问题出在操作符<code>:=</code>，对于使用<code>:=</code>定义的变量，如果新变量与同名已定义的变量不在同一个作用域中，那么 Go 会新定义这个变量。</p><p>​对于本例来说，main() 函数里的 p 是新定义的变量，会遮住全局变量 p，导致执行到<code>bar()</code>时程序，全局变量 p 依然还是 nil，程序随即 Crash。</p><p>正确的做法是将 main() 函数修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>p, err = foo()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>bar()<br>fmt.Println(*p)<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题目引自 Tony Bai 老师的一篇文章，原文讲的很详细，推荐。</p><p><a href="https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/">https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组和切片的比较</title>
    <link href="/2023/08/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2023/08/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面的代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println([...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125; == [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;)<br>fmt.Println([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125; == []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：有两处错误</p><ul><li>go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 <code>[...]int&#123;1&#125;</code> 和 <code>[2]int&#123;1&#125;</code> 是两种不同的类型，不能比较；</li><li>切片是不能比较的；</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>select死锁问题</title>
    <link href="/2023/08/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/select%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/select%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码的输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>foo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>bar := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> foo &lt;- &lt;-bar:<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;default&quot;</span>)<br>&#125;<br>&#125;()<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A：default</li><li>B：panic</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​B。因为 select 在执行之前，会将所有 case 语句中通道的右边部分先进行计算确定值，才会开始选择某个 case 语句。</p><p>这是我根据火丁笔记发的一篇文章：<a href="https://blog.huoding.com/2021/08/29/947">《一个 select 死锁问题》</a> 进行的修改，以便更好理解。</p><p>按常规理解，go func 中的 select 应该执行 default 分支，程序正常运行。但结果却不是，而是死锁。可以通过该链接测试：<a href="https://play.studygolang.com/p/kF4pOjYXbXf%E3%80%82">https://play.studygolang.com/p/kF4pOjYXbXf。</a></p><p>原因文章也解释了，Go 语言规范中有这么一句：</p><blockquote><p>For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the “select” statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.</p></blockquote><p>不知道大家看懂没有？于是，最后来了一个例子验证你是否理解了：为什么每次都是输出一半数据，然后死锁？（同样，这里可以运行查看结果：<a href="https://play.studygolang.com/p/zoJtTzI7K5T%EF%BC%89">https://play.studygolang.com/p/zoJtTzI7K5T）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">talk</span><span class="hljs-params">(msg <span class="hljs-type">string</span>, sleep <span class="hljs-type">int</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s %d&quot;</span>, msg, i)<br>time.Sleep(time.Duration(sleep) * time.Millisecond)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanIn</span><span class="hljs-params">(input1, input2 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input1:<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input2:<br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := fanIn(talk(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">10</span>), talk(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1000</span>))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, &lt;-ch)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有没有这种感觉：</p><p><img src="https://polarisxu.studygolang.com/posts/go/action/imgs/select-channel-deadlock.png" alt="算法入门"></p><p>这是 StackOverflow 上的一个问题：<a href="https://stackoverflow.com/questions/51167940/chained-channel-operations-in-a-single-select-case%E3%80%82">https://stackoverflow.com/questions/51167940/chained-channel-operations-in-a-single-select-case。</a></p><p>关键点和文章开头例子一样，在于 select case 中两个 channel 串起来，即 fanIn 函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input1:<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input2:<br>&#125;<br></code></pre></td></tr></table></figure><p>如果改为这样就一切正常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> t := &lt;-input1:<br>  ch &lt;- t<br><span class="hljs-keyword">case</span> t := &lt;-input2:<br>  ch &lt;- t<br>&#125;<br></code></pre></td></tr></table></figure><p>结合这个更复杂的例子分析 Go 语言规范中的那句话。</p><p>对于 select 语句，在进入该语句时，会按源码的顺序对每一个 case 子句进行求值：这个求值只针对发送或接收操作的额外表达式。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ch 是一个 chan int；</span><br><span class="hljs-comment">// getVal() 返回 int</span><br><span class="hljs-comment">// input 是 chan int</span><br><span class="hljs-comment">// getch() 返回 chan int</span><br><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> ch &lt;- getVal():<br>  <span class="hljs-keyword">case</span> ch &lt;- &lt;-input:<br>  <span class="hljs-keyword">case</span> getch() &lt;- <span class="hljs-number">1</span>:<br>  <span class="hljs-keyword">case</span> &lt;- getch():<br>&#125;<br></code></pre></td></tr></table></figure><p>在没有选择某个具体 case 执行前，例子中的 <code>getVal()</code>、<code>&lt;-input</code> 和 <code>getch()</code> 会执行。这里有一个验证的例子：<a href="https://play.studygolang.com/p/DkpCq3aQ1TE%E3%80%82">https://play.studygolang.com/p/DkpCq3aQ1TE。</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- getVal(<span class="hljs-number">1</span>):<br>fmt.Println(<span class="hljs-string">&quot;in first case&quot;</span>)<br><span class="hljs-keyword">case</span> ch &lt;- getVal(<span class="hljs-number">2</span>):<br>fmt.Println(<span class="hljs-string">&quot;in second case&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;default&quot;</span>)<br>&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;The val:&quot;</span>, &lt;-ch)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getVal</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;getVal, i=&quot;</span>, i)<br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><p>无论 select 最终选择了哪个 case，<code>getVal()</code> 都会按照源码顺序执行：<code>getVal(1)</code> 和 <code>getVal(2)</code>，也就是它们必然先输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">getVal, i= 1<br>getVal, i= 2<br></code></pre></td></tr></table></figure><p>你可以仔细琢磨一下。</p><p>现在回到 StackOverflow 上的那个问题。</p><p>每次进入以下 select 语句时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input1:<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input2:<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;-input1</code> 和 <code>&lt;-input2</code> 都会执行，相应的值是：A x 和 B x（其中 x 是 0-5）。但每次 select 只会选择其中一个 case 执行，所以 <code>&lt;-input1</code> 和 <code>&lt;-input2</code> 的结果，必然有一个被丢弃了，也就是不会被写入 ch 中。因此，一共只会输出 5 次，另外 5 次结果丢掉了。（你会发现，输出的 5 次结果中，x 比如是 0 1 2 3 4）</p><p>而 main 中循环 10 次，只获得 5 次结果，所以输出 5 次后，报死锁。</p><hr><p>虽然这是一个小细节，但实际开发中还是有可能出现的。比如文章提到的例子写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ch 是一个 chan int；</span><br><span class="hljs-comment">// getVal() 返回 int</span><br><span class="hljs-comment">// input 是 chan int</span><br><span class="hljs-comment">// getch() 返回 chan int</span><br><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> ch &lt;- getVal():<br>  <span class="hljs-keyword">case</span> ch &lt;- &lt;-input:<br>  <span class="hljs-keyword">case</span> getch() &lt;- <span class="hljs-number">1</span>:<br>  <span class="hljs-keyword">case</span> &lt;- getch():<br>&#125;<br></code></pre></td></tr></table></figure><p>因此在使用 select 时，一定要注意这种可能的问题。</p><p>不要以为这个问题不会遇到，其实很常见。最多的就是 time.After 导致内存泄露问题，网上有很多文章解释原因，如何避免，其实最根本原因就是因为 select 这个机制导致的。</p><p>比如如下代码，有内存泄露（传递给 time.After 的时间参数越大，泄露会越厉害），你能解释原因吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            i++<br>            ch &lt;- i<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> x := &lt;- ch:<br>            <span class="hljs-built_in">println</span>(x)<br>        <span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">30</span> * time.Second):<br>            <span class="hljs-built_in">println</span>(time.Now().Unix())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/chained-channel-operations-in-a-single-select-case/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/chained-channel-operations-in-a-single-select-case/。</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题t</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map的value本身的地址是不可寻的</title>
    <link href="/2023/08/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84value%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%AF%BB%E7%9A%84/"/>
    <url>/2023/08/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84value%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%AF%BB%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Math <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Math&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: Math&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m[<span class="hljs-string">&quot;foo&quot;</span>].x = <span class="hljs-number">4</span><br>fmt.Println(m[<span class="hljs-string">&quot;foo&quot;</span>].x)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 4</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B，编译报错 <code>cannot assign to struct field m[&quot;foo&quot;].x in map</code>。错误原因：对于类似 <code>X = Y</code>的赋值操作，必须知道 <code>X</code> 的地址，才能够将 <code>Y</code> 的值赋给 <code>X</code>，但 <strong>go 中的 map 的 value 本身是不可寻址的。</strong></p><p>有两个解决办法：</p><p>a.使用临时变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Math <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Math&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: Math&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tmp := m[<span class="hljs-string">&quot;foo&quot;</span>]<br>tmp.x = <span class="hljs-number">4</span><br>m[<span class="hljs-string">&quot;foo&quot;</span>] = tmp<br>fmt.Println(m[<span class="hljs-string">&quot;foo&quot;</span>].x)<br>&#125;<br></code></pre></td></tr></table></figure><p>b.修改数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Math <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Math&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: &amp;Math&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m[<span class="hljs-string">&quot;foo&quot;</span>].x = <span class="hljs-number">4</span><br>fmt.Println(m[<span class="hljs-string">&quot;foo&quot;</span>].x)<br>fmt.Printf(<span class="hljs-string">&quot;%#v&quot;</span>, m[<span class="hljs-string">&quot;foo&quot;</span>])   <span class="hljs-comment">// %#v 格式化输出详细信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>references:</p><ol><li><a href="https://blog.csdn.net/qq_36431213/article/details/82805043">https://blog.csdn.net/qq_36431213/article/details/82805043</a></li><li><a href="https://www.cnblogs.com/DillGao/p/7930674.html">https://www.cnblogs.com/DillGao/p/7930674.html</a></li><li><a href="https://haobook.readthedocs.io/zh_CN/latest/periodical/201611/zhangan.html">https://haobook.readthedocs.io/zh_CN/latest/periodical/201611/zhangan.html</a></li><li><a href="https://suraj.pro/post/golang_workaround/">https://suraj.pro/post/golang_workaround/</a></li><li><a href="https://blog.ijun.org/2017/07/cannot-assign-to-struct-field-in-map.html">https://blog.ijun.org/2017/07/cannot-assign-to-struct-field-in-map.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang</title>
    <link href="/2023/07/31/%E9%9D%A2%E8%AF%95/Golang/"/>
    <url>/2023/07/31/%E9%9D%A2%E8%AF%95/Golang/</url>
    
    <content type="html"><![CDATA[<p>Golang<span id="more"></span></p><h1 id="基础相关："><a href="#基础相关：" class="headerlink" title="基础相关："></a>基础相关：</h1><h4 id="1、相比于其他语言，Go-有什么优势或者特点？"><a href="#1、相比于其他语言，Go-有什么优势或者特点？" class="headerlink" title="1、相比于其他语言，Go 有什么优势或者特点？"></a>1、相比于其他语言，Go 有什么优势或者特点？</h4><ul><li>Go 允许跨平台编译，编译出来的二进制文件，直接部署在对应系统上即可运行</li><li>Go 在语言层次上天生支持高并发，通过 goroutine 和 channel 实现。channel 的理论依据是 CSP 并发模型，即所谓的 <code>通过通信来共享内存</code>；Go 在 routime 运行时里实现了属于自己的调度机制：GMP，降低了内核态的用户态的切换成本</li><li>GO 的语法简单，代码风格比较统一</li></ul><h4 id="2、golang-中-make-和-new-的区别？"><a href="#2、golang-中-make-和-new-的区别？" class="headerlink" title="2、golang 中 make 和 new 的区别？"></a>2、golang 中 make 和 new 的区别？</h4><ul><li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据。</li><li>new 分配返回的是指针，即类型 *Type。make 返回的数据类型本身，即 Type。</li><li>new 分配的空间被清零。make 分配空间后，会进行初始化。</li></ul><blockquote><p>new 对于普通类型，会将其值赋值为零值；对于 slice、map、chan 会将其赋值为 nil。</p><p>make 会将 slice、map、chan 赋值为零值。</p></blockquote><h4 id="3、数组和切片的区别，切片怎么扩容？"><a href="#3、数组和切片的区别，切片怎么扩容？" class="headerlink" title="3、数组和切片的区别，切片怎么扩容？"></a>3、数组和切片的区别，切片怎么扩容？</h4><p>区别：</p><ul><li>数组是值类型，长度固定</li><li>切片是引用类型，长度不固定，可以动态扩容。</li></ul><p>切片扩容：</p><ul><li>1.17 及以前<ul><li>期望容量大于当前容量的两倍，就会直接使用期望容量</li><li>如果当前切片的容量小于 1024 就会将容量翻倍</li><li>如果当前切片的容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量</li></ul></li><li>1.18 之后<ul><li>期望容量大于当前容量的两倍，就会直接使用期望容量</li><li>如果当前容量小于 256 就会将容量翻倍</li><li>如果当前容量大于等于 256，则根据公式扩容，直至预估容量 &gt;&#x3D; 期望容量</li></ul></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">扩容公式：<br><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = oldcap + (oldcap + <span class="hljs-number">3</span>*<span class="hljs-number">256</span>) / <span class="hljs-number">4</span> = <span class="hljs-number">1.25</span> * oldcap + <span class="hljs-number">192</span><br></code></pre></td></tr></table></figure><blockquote><p>为什么代码中测试扩容大小和策略对不上？</p><p>​在源码中，有一个 <code>growslice</code> 函数，它就是用来实现上述的扩容机制的，但是这只是一部分，实际上还有更进一步的优化，比如内存对齐等，靠的是 <code>roundupsize</code> 这个函数，在计算完 newcap 这个值之后，还会有一个步骤计算最终的容量。</p><p>​在计算新的容量的时候，<code>roundupsize</code> 这个函数会根据需要扩容的大小和当前切片的容量选择不同的计算方式。（下属描述的大小是指字节，最后的容量大小需要除以 8）【追问再说下面】</p><ul><li>如果当前容量比较小（小于32760字节），会根据需要扩容的大小计算新的容量，并将其映射到一个固定的大小类别中，再根据类别查找对应的容量</li><li>如果当前容量比较大，会采用位运算的方式将需要扩容的大小向上取整到 2 的幂次方，然后乘 2 作为新的容量</li></ul></blockquote><h4 id="4、for-range-的时候，它的地址会发生变化吗？"><a href="#4、for-range-的时候，它的地址会发生变化吗？" class="headerlink" title="4、for range 的时候，它的地址会发生变化吗？"></a>4、for range 的时候，它的地址会发生变化吗？</h4><ul><li>地址不会发生改变，但是地址指向的值是变化的，每遍历到一个元素，就把该元素的值写到该地址。</li></ul><p>追加：for range 循环遍历 slice 有什么问题？</p><blockquote><p>​for range 在遍历的时候，它的底层实现是这样：会对原数组进行一次拷贝，<strong>确定其值和长度</strong>，然后遍历数组中每个元素的时候，都会这个值<strong>赋值给同一个临时变量</strong>，所以每次遍历拿到的是同一个地址，但是值不同。</p></blockquote><ul><li>对于 slice 用 for range 遍历不能直接取到每个元素的地址</li><li>对于 slice 用 for range 遍历，遍历过程中追加的元素不会遍历到</li></ul><h4 id="5、defer-底层实现，go-defer，defer-的执行顺序，defer-在什么时机修改返回值？（defer和return），defer-recover-的问题？"><a href="#5、defer-底层实现，go-defer，defer-的执行顺序，defer-在什么时机修改返回值？（defer和return），defer-recover-的问题？" class="headerlink" title="5、defer 底层实现，go defer，defer 的执行顺序，defer 在什么时机修改返回值？（defer和return），defer recover 的问题？"></a>5、defer 底层实现，go defer，defer 的执行顺序，defer 在什么时机修改返回值？（defer和return），defer recover 的问题？</h4><h5 id="5-1-defer底层实现"><a href="#5-1-defer底层实现" class="headerlink" title="5.1 defer底层实现"></a>5.1 defer底层实现</h5><ul><li>defer 的底层实现是由很多 _defer 结构组成的链表，defer 函数在注册的时候，创建的 _defer 结构会依次插入到 __defer 链表的表头</li><li>在当前函数 return 的时候，依次从 _defer 链表的表头取出 _defer 结构执行里面的 fn 函数，所以执行顺序是 LIFO（先进后出）</li></ul><h5 id="5-2-defer-的执行顺序"><a href="#5-2-defer-的执行顺序" class="headerlink" title="5.2 defer 的执行顺序"></a>5.2 defer 的执行顺序</h5><ul><li>defer 的执行顺序类似于栈，是 LIFO，先调用的 defer 语句后执行。</li></ul><h5 id="5-3-defer-在什么时机修改返回值"><a href="#5-3-defer-在什么时机修改返回值" class="headerlink" title="5.3 defer 在什么时机修改返回值"></a>5.3 defer 在什么时机修改返回值</h5><ul><li>return 的过程可以被分解为以下三步：<ul><li>设置返回值</li><li>执行 defer 语句</li><li>将结果返回</li></ul></li></ul><h5 id="5-4-defer-recover"><a href="#5-4-defer-recover" class="headerlink" title="5.4 defer recover"></a>5.4 defer recover</h5><ul><li>用 recover 捕获异常时，只能捕获当前 goroutine 的 panic ，不能捕获其他 goroutine 发生的 panic</li><li>一个 recover 只能捕获一次 panic，且一一对应</li></ul><h4 id="6、unit-类型溢出"><a href="#6、unit-类型溢出" class="headerlink" title="6、unit 类型溢出"></a>6、unit 类型溢出</h4><table><thead><tr><th>类型</th><th>有无符号</th><th>占用存储内存</th><th>表述范围</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>有</td><td>32位系统 4个字节<br/>64位系统 8个字节</td><td>-2^31 ~ 2^31-1<br />-2^63 ~ 2^63-1</td><td></td></tr><tr><td>uint</td><td>无</td><td>32位系统 4个字节<br />64位系统 8个字节</td><td>0 ~ 2^32-1<br />0 ~ 2^64-1</td><td></td></tr><tr><td>rune</td><td>有</td><td>与int32一样</td><td>-2^31 ~ 2^31-1</td><td>等价于 int32，表示 Unicode 码</td></tr><tr><td>byte</td><td>无</td><td>与uint8等价</td><td>0~255</td><td>当要存储字符时选用byte</td></tr></tbody></table><p>uint8 大小为 1 个字节，占 8 位，byte 其实就是 uint8 的别名，uint8 的溢出情况举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">uint8</span> = <span class="hljs-number">255</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span><br>a + b = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="7、介绍-rune-类型"><a href="#7、介绍-rune-类型" class="headerlink" title="7、介绍 rune 类型"></a>7、介绍 rune 类型</h4><ul><li>rune 类型是 Go 语言的一种特殊数字类型。在源码中，它的定义是 <code>type rune = int32</code></li><li>官方对它的解释是：rune 是类型 int32 的别名，在所有方面都等价于它，用来区分字符值跟整数值。</li><li>使用单引号定义，返回采用 UTF-8 编码的 Unicode 码点。Go语言通过 rune 处理中文，支持国际多语言。</li></ul><h4 id="8、Go-中两个-Nil-可能不相等吗？"><a href="#8、Go-中两个-Nil-可能不相等吗？" class="headerlink" title="8、Go 中两个 Nil 可能不相等吗？"></a>8、Go 中两个 Nil 可能不相等吗？</h4><blockquote><p>​两个数据要进行比较，首先得明白数据类型，对于两个 nil的比较同样如此，这里主要得注意 interface 类型，因为interface 类型是类型 T 和值 V 二者的综合，只有在类型 T 和 值 V 都相等的的情况下，两个 interface 才相等</p></blockquote><ul><li>Go 中两个 Nil 可能不相等，当一个接口类型的变量为 Nil 和一个非接口类型的变量也为 Nil 的时候，虽然两者都为 Nil，但是却不相等。</li></ul><h4 id="9、golang-中反射原理是什么？"><a href="#9、golang-中反射原理是什么？" class="headerlink" title="9、golang 中反射原理是什么？"></a>9、golang 中反射原理是什么？</h4><h5 id="9-1解析-tag-是怎么实现的？"><a href="#9-1解析-tag-是怎么实现的？" class="headerlink" title="9.1解析 tag 是怎么实现的？"></a>9.1解析 tag 是怎么实现的？</h5><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span> <span class="hljs-comment">//名字</span><br>    Age <span class="hljs-type">uint</span> <span class="hljs-string">`key3:&quot;value3&quot;`</span> <span class="hljs-comment">//年龄</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​go 语言中的 tag 就是结构体中的各个字段的一个标签， <code>Tag</code> 本身是一个字符串，它是 <strong>以空格分隔的 key:value 对</strong></p><p>​key：必须是非空字符串，不能包含空格、控制字符、引号、冒号</p><p>​value：以双引号标记的字符串</p><p>​冒号前后不能有空格</p><p><strong>&#96;&#96;</strong> 之间的就是一个 tag，一般通过反射来实现。</p></blockquote><ul><li>Go 语言中解析 tag 是通过反射来实现的。</li></ul><h5 id="9-2-反射的原理"><a href="#9-2-反射的原理" class="headerlink" title="9.2 反射的原理"></a>9.2 反射的原理</h5><ul><li>反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力</li><li>Go 语言反射是通过接口实现的，通过隐式转换，普通的类型被转换为 inerface 类型，这个过程涉及到类型转换的过程，首先从 Golang 类型转换为 interface 类型，再从 interface 类型转换为反射类型，再从反射类型得到想要的类型和值的信息。</li></ul><h4 id="10、-go-语言中-struct-能不能比较"><a href="#10、-go-语言中-struct-能不能比较" class="headerlink" title="10、 go 语言中 struct 能不能比较"></a>10、 go 语言中 struct 能不能比较</h4><ul><li>对于不同类型的 struct 无法进行比较；而同一个 struct 的两个实例可比较也不比较（struct 包含不可比较类型、指针类型的成员变量执行的内容不可比较、接口类型的动态值不可比较）</li><li>在 Go 中，Slice、map、func 无法比较，当一个 struct 的成员是这三个类型中的任意一个，就无法比较，反之可以进行比较。</li></ul><h4 id="11、结构体打印时，-v-和-v、-v的区别"><a href="#11、结构体打印时，-v-和-v、-v的区别" class="headerlink" title="11、结构体打印时， %v 和 %+v、%#v的区别"></a>11、结构体打印时， <code>%v</code> 和 <code>%+v</code>、<code>%#v</code>的区别</h4><ul><li><code>%v</code> 输出结构体各成员的值</li><li><code>%+v</code> 输出结构体各成员的名称和值</li><li><code>%#v</code> 输出结构体名称和结构体各成员的名称和值</li></ul><h4 id="12、空-struct-占用空间吗？"><a href="#12、空-struct-占用空间吗？" class="headerlink" title="12、空 struct{} 占用空间吗？"></a>12、空 struct{} 占用空间吗？</h4><blockquote><p>可以用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数</p><p>fmt.Println(unsafe.Sizeof(struct{}{})) &#x2F;&#x2F; 0</p></blockquote><ul><li>空结构体 struct{} 实例不占据任何内存空间</li></ul><h4 id="13、go-语言中空-struct-的用途"><a href="#13、go-语言中空-struct-的用途" class="headerlink" title="13、go 语言中空 struct{} 的用途"></a>13、go 语言中空 struct{} 的用途</h4><blockquote><p>由于 struct{} 不占空间，于是可以利用空 struct 作为下述各种场景的占位符</p><ol><li><p>将 map 作为集合（Set）使用，可以将值类型定义为空结构体，仅作为占用符使用即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span></span> Has(key <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>_, ok := s[key]<br><span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span></span> Add(key <span class="hljs-type">string</span>) &#123;<br>s[key] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Set)</span></span> Delete(key <span class="hljs-type">string</span>) &#123;<br><span class="hljs-built_in">delete</span>(s, key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-built_in">make</span>(Set)<br>s.Add(<span class="hljs-string">&quot;Tom&quot;</span>)<br>s.Add(<span class="hljs-string">&quot;Sam&quot;</span>)<br>fmt.Println(s.Has(<span class="hljs-string">&quot;Tom&quot;</span>))<br>fmt.Println(s.Has(<span class="hljs-string">&quot;Jack&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不发送数据的信道：使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>&lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;do something&quot;</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(ch)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> worker(ch)<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结构体只包含方法，不包含任何的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>         <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br>         <br><span class="hljs-keyword">type</span> Door <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br>         <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Door)</span></span> Open() &#123;<br>fmt.Println(<span class="hljs-string">&quot;Open the door&quot;</span>)<br>&#125;<br>         <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Door)</span></span> Close() &#123;<br>fmt.Println(<span class="hljs-string">&quot;Close the door&quot;</span>)<br>&#125;<br>         <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := Door&#123;&#125;<br>d.Open()<br>d.Close()<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></blockquote><ul><li>将 map 作为集合（Set）使用，可以将值类型定义为空结构体，仅作为占用符使用</li><li>使用在不发送的信道上，使用 channel 不需要发送任何数据，只用来通知子协程执行任何或只用来控制协程并发度</li><li>用作接口的实现，结构体只包含方法，不包含任何字段</li></ul><h4 id="14、go-中-“-”-的作用"><a href="#14、go-中-“-”-的作用" class="headerlink" title="14、go 中 “_” 的作用"></a>14、go 中 “_” 的作用</h4><blockquote><p>在不同的场景下的作用不一样，在回答的时候需要凸显出在不同场景下，回答全面</p><ol><li><p>import 中的下划线</p><p>作用：当导入一个包的时候，不需要把所有的包都导入进来，只需要执行使用改包下的文件里所有的init()函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;hello/imp&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>imp.Print() <span class="hljs-comment">//编译报错：undefined:imp</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>下划线在代码中</p><p>作用：下划线在代码中是忽略这个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>         <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br>         <br>v1, v2, _ := function(...)<br></code></pre></td></tr></table></figure></li></ol></blockquote><ul><li>import 中的下划线用于导入这个包中的所有init函数</li><li>代码体中的下划线用于忽略这个变量</li></ul><h4 id="15、Go-闭包"><a href="#15、Go-闭包" class="headerlink" title="15、Go 闭包"></a>15、Go 闭包</h4><ul><li>匿名函数也可以被称为闭包</li><li>闭包实际上就是函数 + 引用环境（捕获的变量）</li></ul><h4 id="16、Go-多返回值怎么实现的？"><a href="#16、Go-多返回值怎么实现的？" class="headerlink" title="16、Go 多返回值怎么实现的？"></a>16、Go 多返回值怎么实现的？</h4><ul><li>Go 函数传参是通过 fp + offset 来实现的，而多个返回值也是通过 fp + offset 存储在调用函数的栈帧中</li></ul><h4 id="17、Go-语言中不能比较的类型如何比较是否相等"><a href="#17、Go-语言中不能比较的类型如何比较是否相等" class="headerlink" title="17、Go 语言中不能比较的类型如何比较是否相等"></a>17、Go 语言中不能比较的类型如何比较是否相等</h4><blockquote><p>考察对reflect.DeepEqual的了解：</p><p>​基本类型都可以用 &#x3D;&#x3D; 来比较，但不能涉及不能比较的类型，比如 slice、map等</p></blockquote><ul><li>像 string、int、float、interface 等可以通过reflect.DeepEqual和等号进行比较</li><li>像slice、struct、map 则一般使用 reflect.DeepEqual 来检测是否相等</li></ul><h4 id="18、Go-中-init-函数的特征"><a href="#18、Go-中-init-函数的特征" class="headerlink" title="18、Go 中 init 函数的特征"></a>18、Go 中 init 函数的特征</h4><ul><li>每个包下可以有很多个 init 函数，每个文件也可以有很多个 init 函数。多个 init 函数按照它们的文件名顺序（导入顺序）逐个初始化</li><li>应用初始时初始化的工作顺序是：从北道荣包的最深层开始进行初始化，层层递出最后到 main 包<ul><li>不管包被导入多少次，包内的 init 函数只会执行一次</li><li>而且包级别的变量的初始化优于 init 函数的执行</li></ul></li></ul><h4 id="19、Go-中-uintptr-和-unsafe-Pointer-的区别"><a href="#19、Go-中-uintptr-和-unsafe-Pointer-的区别" class="headerlink" title="19、Go 中 uintptr 和 unsafe.Pointer 的区别"></a>19、Go 中 uintptr 和 unsafe.Pointer 的区别</h4><blockquote><p>考察对 go 语言中指针的了解，go 语言中指针分为普通指针类型，unsafe.Pointer, uintptr（本质不是指针），三者的功能各不相同。</p><ol><li>*类型：普通指针类型，用于传递对象地址，不能进行指针运算</li><li>unsafe.Pointer：通用指针类型，用于转换为不同类型的指针，不能进行指针运算，不能读取内存存储的指（必须转换为某一类型的普通指针）</li><li>uintptr：用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象，uintptr 类型的目标会被回收</li></ol><p>回答 uintptr 和 unsafe.Pointer 的时候，重点突出指针运算上，unsafe.Pointer 用于指针类型转换，不能参与于指针运算，而 uintptr 可以。</p></blockquote><ul><li><p>unsafe.Pointer 是通用指针类型，它不能参与指针运算，任何类型的指针都可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为任意类型的指针</p><ul><li><p>当我们想让通用指针类型进行转换的时候，就需要 unsafe.Pointer 作为中间指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> b *<span class="hljs-type">float64</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> c *<span class="hljs-type">int</span> = &amp;a<br>b = (*<span class="hljs-type">float64</span>)(unsafe.Pointer(c))<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 也可以转换为 uintptr。uintptr 是指针运算的工具，但它不能持有指针对象（它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算的桥梁。</p></li></ul><blockquote><p>​很多人都认为uintptr是个指针，其实不然。不要对这个名字感到疑惑，它只不过是个 uint ，大小与当前平台的指针宽度一致。因为 unsafe.Pointer 可以跟 uintptr 互相转换，所以Go语言中可以把指针转换为 uintptr进行数值运算，然后转换回原类型，以此来模拟C语言中的指针运算。</p><p>​unsafe.Pointer 类似于C语言中的 void*，虽然未指定元素类型，但是本身类型就是个指针。</p><p>​如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MemoryPool <span class="hljs-keyword">struct</span> &#123;<br>    memStart <span class="hljs-type">uintptr</span><br>    memEnd   <span class="hljs-type">uintptr</span><br>    next     <span class="hljs-type">uintptr</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMemoryPool</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> *MemoryPool &#123;<br>    mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br>    <span class="hljs-keyword">return</span> &amp;MemoryPool&#123;<br>        memStart: <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;mem[<span class="hljs-number">0</span>])),<br>        memEnd:   <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;mem[size])),<br>        next:     <span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;mem[<span class="hljs-number">0</span>])),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *MemoryPool)</span></span> Alloc(size <span class="hljs-type">int</span>) unsafe.Pointer &#123;<br>    <span class="hljs-keyword">if</span> p.next+<span class="hljs-type">uintptr</span>(size) &gt; p.memEnd &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    ptr := unsafe.Pointer(p.next)<br>    p.next += <span class="hljs-type">uintptr</span>(size)<br>    <span class="hljs-keyword">return</span> ptr<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pool := NewMemoryPool(<span class="hljs-number">1024</span>)<br>    ptr1 := pool.Alloc(<span class="hljs-number">100</span>)<br>    ptr2 := pool.Alloc(<span class="hljs-number">200</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;ptr1: %p\n&quot;</span>, ptr1)<br>    fmt.Printf(<span class="hljs-string">&quot;ptr2: %p\n&quot;</span>, ptr2)<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h1 id="Context-相关"><a href="#Context-相关" class="headerlink" title="Context 相关"></a>Context 相关</h1><h4 id="1、context-结构体是什么样的？"><a href="#1、context-结构体是什么样的？" class="headerlink" title="1、context 结构体是什么样的？"></a>1、context 结构体是什么样的？</h4><ol><li><p>go 语言里的 context 实际上是一个接口，提供了四种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)  <span class="hljs-comment">// 返回 还有多久到期、是否到期</span><br>Done() &lt;- <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// 返回一个 只读channel，当这个 channel 被关闭时，说明这个 context 被取消</span><br>Err() <span class="hljs-type">error</span> <span class="hljs-comment">// 返回 一个错误，表示 channel 被关闭的原因，例如被取消还是超时关闭</span><br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// value 方法返回指定 key 对应的 value，这是 context 携带的值</span><br></code></pre></td></tr></table></figure></li><li><p>有 emptyCtx、cancelCtx、timerCtx、valueCtx 四种实现</p><ul><li>emptyCtx：虽然实现了 context 接口，但是不具备任何功能，因为实现很简单，基本是直接返回空值<ul><li>我们一般用 context.Background() 和 context.TODO() 都是返回一个 *emptyCtx 的动态类型（通过静态类型 context.Context 传递）</li></ul></li><li>cancelCtx：同时实现 Contex 和 canceler 接口，通过取消函数 cancelFunc 实现退出通知。注意，其退出通知机制不但通知自己，同时也通知其 children 节点<ul><li>我们一半调用 context.WithCancel() 就会返回一个 *cancelCtx 和 cancelFunc</li></ul></li><li>timerCtx：timerCtx 是一个实现了 Context 接口的具体类型，其内部封装了 cancelCtx 类型实例，同时也有个 deadline 变量，用来实现定时退出通知<ul><li>我们一般调用 context.WithTimeout() 就会返回一个 *timerCtx 和 cancelFunc，不仅可以定时通知，也可以调用 cancelFunc 进行通知</li></ul></li><li>valueCtx：valueCtx 是一个实现了 Context 接口的具体类型，其内部封装了 Context 接口类型，同时也封装了一个 k&#x2F;v 的存储变量，其是一个实现了数据传递的<ul><li>我们一般 context.WithValue() 来得到要给 *valueCtx，valueCtx 可以继承它的 parent valueCtx 中的 {key, value}</li></ul></li></ul></li></ol><h4 id="2、context-使用场景和用途？"><a href="#2、context-使用场景和用途？" class="headerlink" title="2、context 使用场景和用途？"></a>2、context 使用场景和用途？</h4><ol><li><p>context 主要用来 goroutine 之间传递上下文信息，比如传递请求的trace_id，以便追逐全局唯一请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>traceID := <span class="hljs-string">&quot;12345&quot;</span><br>ctx := context.WithValue(context.Background(), <span class="hljs-string">&quot;trace_id&quot;</span>, traceID)<br>fmt.Println(<span class="hljs-string">&quot;Trace ID:&quot;</span>, ctx.Value(<span class="hljs-string">&quot;trace_id&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>另一个用处是可以用来做取消控制，通过取消新信号和超时时间来控制子 goroutine 的退出，防止 goroutine 泄露</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            fmt.Println(<span class="hljs-string">&quot;Worker stopped&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">default</span>:<br>            fmt.Println(<span class="hljs-string">&quot;Working...&quot;</span>)<br>            time.Sleep(time.Second)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    timeout := <span class="hljs-number">5</span> * time.Second<br>    ctx, cancel := context.WithTimeout(context.Background(), timeout)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    <span class="hljs-keyword">go</span> worker(ctx)<br>    time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>包括：取消信号、超时时间、截至时间、k-v 等。</p><h1 id="Channel-相关"><a href="#Channel-相关" class="headerlink" title="Channel 相关"></a>Channel 相关</h1><h4 id="1、channel-是否线程安全？锁用在什么地方？"><a href="#1、channel-是否线程安全？锁用在什么地方？" class="headerlink" title="1、channel 是否线程安全？锁用在什么地方？"></a>1、channel 是否线程安全？锁用在什么地方？</h4><p><strong>回答</strong>：</p><ol><li>是线程安全的，hchan 的底层实现中，hchan 结构体中采用 Mutex 锁来保证数据读写安全。在对循环数组 buf 中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作 channel 数据</li></ol><h4 id="2、go-channel-的底层数据结构？"><a href="#2、go-channel-的底层数据结构？" class="headerlink" title="2、go channel 的底层数据结构？"></a>2、go channel 的底层数据结构？</h4><p><strong>回答：</strong></p><ol><li>对于包含缓冲的 channel，go 语言的 channel 底层是一个 hchan 的结构，里面包含一个执行循环数组的指针，这个循环数组就是用来存储数据的。当然还包含下次读取和下次发送数据的索引位置 recvx 和 sendx</li><li>还包含两个 goroutine 等待队列，在一个 goroutine 对这个 channel 读写阻塞的时候，会分情况放到这个两个队列里，发送数据阻塞就昂到 sendq 这个队列中，接收数据阻塞就放到 recvq 这个等待队列</li><li>为了保证 channel 的线程安全，hchan 结构体还有一个互斥锁，用作数据读写时候加锁，当前 close channel 也会用到这个互斥锁</li></ol><h4 id="3、nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？"><a href="#3、nil、关闭的-channel、有数据的-channel，再进行读、写、关闭会怎么样？" class="headerlink" title="3、nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？"></a>3、nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？</h4><p><strong>回答：</strong></p><table><thead><tr><th>操作 \ 状态</th><th>未初始化（nil）</th><th>关闭（close）</th><th>正常（normal）</th></tr></thead><tbody><tr><td>关闭</td><td>panic</td><td>panic</td><td>正常关闭</td></tr><tr><td>发送</td><td>永远阻塞可能导致死锁</td><td>panic</td><td>阻塞或成功发送</td></tr><tr><td>接收</td><td>永远阻塞可能导致死锁</td><td>缓冲区为空则为零值，否则可以继续读</td><td>阻塞或成功接收</td></tr></tbody></table><h4 id="4、向-channel-发送数据和从-channel-读取数据的流程是什么样的？"><a href="#4、向-channel-发送数据和从-channel-读取数据的流程是什么样的？" class="headerlink" title="4、向 channel 发送数据和从 channel 读取数据的流程是什么样的？"></a>4、向 channel 发送数据和从 channel 读取数据的流程是什么样的？</h4><p><strong>回答：</strong></p><ul><li>发送时<ul><li>如果 channel 的读等待队列存在接收者 goroutine，将数据直接发送给第一个等待的 goroutine，唤醒接收的 goroutine</li><li>如果 channel 的读等待队列不存在接收者 goroutine<ul><li>如果循环数组 buf 未满，那么将会把数据发送到循环数组 buf 的队尾</li><li>如果循环数组 buf 已满，那么这个时候就会走阻塞发送的流程，将当前 goroutine 加入写等待队列，并挂起等待唤醒</li></ul></li></ul></li><li>接收时<ul><li>如果 channel 的写等待队列存在发送者 goroutine<ul><li>如果是无缓冲 channel，直接从第一个发送者 goroutine 那里把数据拷贝给接收变量，唤醒发送的 goroutine</li><li>如果是有缓冲 channel（未满），将循环数组 buf 的队首元素拷贝给接收变量</li><li>如果是有缓冲 channel（已满），相比于未满会多一步，将第一个发送者 goroutine 的数据拷贝到 buf 循环数组，唤醒发送的 goroutine</li></ul></li><li>如果 channel 的写等待队列不存在发送者 goroutine<ul><li>如果循环数组 buf 非空，将循环数组 buf 的队首元素拷贝给接收变量</li><li>如果循环数组 buf 为空，这个时候就会走阻塞接受的流程，将当前 goroutine 加入到读等待队列，并挂起等待唤醒</li></ul></li></ul></li></ul><h1 id="Map-相关"><a href="#Map-相关" class="headerlink" title="Map 相关"></a>Map 相关</h1><h4 id="1、map-使用的注意点，是否是并发安全的？"><a href="#1、map-使用的注意点，是否是并发安全的？" class="headerlink" title="1、map 使用的注意点，是否是并发安全的？"></a>1、map 使用的注意点，是否是并发安全的？</h4><p><strong>回答：</strong></p><ul><li>map 不是并发安全的。</li><li>如果某个任务正在对 map 进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除），否则会导致进程崩溃</li><li>在查找、赋值、遍历、删除的过程中都会检测写标志置位（等于1），则直接 fatal 退出程序。赋值和删除函数在检测完写标志是复位之后，先将写标志位置位，才会进行之后的操作。</li></ul><h4 id="2、map循环是有序的还是无序的？"><a href="#2、map循环是有序的还是无序的？" class="headerlink" title="2、map循环是有序的还是无序的？"></a>2、map循环是有序的还是无序的？</h4><p><strong>分析：</strong>突出随机桶号和槽位</p><p><strong>回答：</strong></p><p>​map 的遍历是无序的，map 每次遍历，都会从一个随机值序号的桶开始，在每个桶中，再按照之前选定的随机槽位开始遍历，所以是无序的。</p><p><strong>补充问题：</strong>为什么 go 语言的 map 要这样设计，要随机选定桶号和槽位进行随机遍历？</p><p><strong>分析：</strong>突出扩容会带来 key 的位置发生变化</p><p><strong>回答：</strong></p><p>​因为 map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 的位置就会发生改变。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大变化。这样，遍历 map 的结构就不可能按原来的顺序了。所以，go 语言强制每次遍历都随机开始。</p><h4 id="3、map-如何顺序读取？"><a href="#3、map-如何顺序读取？" class="headerlink" title="3、map 如何顺序读取？"></a>3、map 如何顺序读取？</h4><p><strong>分析：</strong>对 map 的 key 进行排序，然后按照这个排完序之后的 key 从 map 里出对应的数据即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>KeyList := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-number">3</span>: <span class="hljs-number">200</span>,<br><span class="hljs-number">4</span>: <span class="hljs-number">200</span>,<br><span class="hljs-number">1</span>: <span class="hljs-number">100</span>,<br><span class="hljs-number">8</span>: <span class="hljs-number">800</span>,<br><span class="hljs-number">5</span>: <span class="hljs-number">500</span>,<br><span class="hljs-number">2</span>: <span class="hljs-number">200</span>,<br>&#125;<br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> m &#123;<br>KeyList = <span class="hljs-built_in">append</span>(KeyList, key)<br>&#125;<br>sort.Ints(KeyList)<br><span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> KeyList &#123;<br>fmt.Println(m[key])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回答：</strong></p><p>​如果想顺序遍历 map，先把 key 放到切片排序，再按照 key 的顺序遍历 map</p><h4 id="4、map-中删除一个-key，它的内存会释放吗？"><a href="#4、map-中删除一个-key，它的内存会释放吗？" class="headerlink" title="4、map 中删除一个 key，它的内存会释放吗？"></a>4、map 中删除一个 key，它的内存会释放吗？</h4><p><strong>分析：</strong></p><p>考察 map 中 key 的删除原理，map 删除 key 的时候是根据 hash 值找对对应的槽位，找到对应的 key 删除，将key置为空，并且将对应的 tophash 置为 emptyOne，如果后面没有任何数据了，则再将 emptyOne 状态置为emptyReset 。所以删除一个 key ，只是修改对应内存位置的值，并不会释放内存。</p><p><strong>回答：</strong></p><p>​不会释放，删除一个 key，可以认为是标记删除，只是修改 key 对应位置的值为空，并不会释放内存，只有在置空这个 map 的时候，整个 map 的空间才会被垃圾回收后释放。</p><h4 id="5、怎么处理对-map-进行并发访问？有没有其他方案？区别是什么"><a href="#5、怎么处理对-map-进行并发访问？有没有其他方案？区别是什么" class="headerlink" title="5、怎么处理对 map 进行并发访问？有没有其他方案？区别是什么"></a>5、怎么处理对 map 进行并发访问？有没有其他方案？区别是什么</h4><p><strong>分析：</strong></p><p>使用线程安全的 map，一般有这两种方式：</p><ul><li>加锁</li><li>sync.map</li></ul><p>​ 性能来说，sync.map 在性能上要优于 map 加锁，因为 sync.map 在底层使用了两个 map，read 和 dirty 来提升性能，对 read 的操作时，原子操作不用加锁 ，只有在对 read 操作不能满足要求时才会加锁操作 dirty，这样就减少了加锁场景，锁竞争频率会减小很多，所以性能会高于单纯的 map 加锁，在回答的时候突出 sync.map 的read 和 dirty，以及锁竞争频率</p><p><strong>回答：</strong></p><p>​对 map 进行加读写锁或者是使用 sync.map 这两种方式都可以对 map 进行并发访问</p><p>​和 原始 map + RWLock 的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：它在底层使用了两个 map：read 和 dirty。可以无锁访问 read map，而且会优先操作 read map，倘若之操作 read map 就可以满足要求，那就不用去加锁操作 write map(dirty)，所以在某些特定场景中，它发生锁竞争的频率会远远小于 map + RWLock 的实现方式。</p><ul><li>优点：适合读多写少的场景</li><li>缺点：写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降。</li></ul><h4 id="6、nil-map-和-空-map-有何不同？"><a href="#6、nil-map-和-空-map-有何不同？" class="headerlink" title="6、nil map 和 空 map 有何不同？"></a>6、nil map 和 空 map 有何不同？</h4><p><strong>分析：</strong>考察各种情况下的 map 的读写情况</p><p><strong>回答：</strong></p><ol><li><p>未初始化的 map 为 nil map</p><p>a. 往值为 nil 的 map 添加值，会触发 panic</p><p>b. 读取值为 nil 的 map，不会报错</p><p>c. 删除值为 nil 的 map，不会报错</p></li><li><p>已经初始化，没有任务元素的 map 为 空map，对 空map 增删改查不会报错</p></li></ol><h4 id="7、map-的数据结构是什么？是怎么实现扩容？"><a href="#7、map-的数据结构是什么？是怎么实现扩容？" class="headerlink" title="7、map 的数据结构是什么？是怎么实现扩容？"></a>7、map 的数据结构是什么？是怎么实现扩容？</h4><h5 id="7-1-数据结构是什么？"><a href="#7-1-数据结构是什么？" class="headerlink" title="7.1 数据结构是什么？"></a>7.1 数据结构是什么？</h5><p><strong>分析：</strong>回答突出 hmap、bmap、tophash，以及溢出指针 overflow</p><p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230803192609519.png" alt="image-20230803192609519"></p><p><strong>回答：</strong></p><p>​map 的底层数组实际上是一个哈希表。在运行时表现为一个指向 hmap 结构体的指针，hmap 中又记录了桶数组指针 buckets，溢出桶指针以及元素个数等字段。每个桶是一个 bmap 的数据结构，可以存储 8 个键值对和 8 个 tophash值以及指向下一个溢出桶的指针 overflow。为了内存紧凑，采用的是先存 8 个 key 过后再存 value。</p><h5 id="7-2-map-怎么实现扩容？"><a href="#7-2-map-怎么实现扩容？" class="headerlink" title="7.2 map 怎么实现扩容？"></a>7.2 map 怎么实现扩容？</h5><p><strong>分析：</strong>参考 map 的底层结构体，回答一定要涵盖 <strong>扩容策略</strong>、<strong>扩容时机</strong>、<strong>扩容方式</strong>（渐进式扩容）</p><p><strong>回答：</strong></p><ul><li><strong>扩容时机：</strong> <strong>写时扩容</strong>。向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容<ul><li>扩容条件：<ul><li>超过负载： map 元素个数 &gt; 6.5（负载因子） * 桶个数，触发双倍扩容</li><li>溢出桶太多，触发等量扩容<ul><li>当桶数 &lt; 2^15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，则认为溢出桶过多</li><li>当桶数 &gt; 2^15 时，如果溢出桶总数 &gt;&#x3D; 2^15，则认为溢出桶过多</li></ul></li></ul></li></ul></li><li><strong>扩容机制：</strong><ul><li>双倍扩容：新建一个 buckets 数组，新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。</li><li>等量扩容：并不扩大容量，buckets 数量维持不变，重新做一遍类似双倍扩容 搬迁动作，把松散的键值对重新排列一次，使得同一个 buckets 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</li></ul></li><li><strong>扩容方式：</strong><ul><li>扩容过程并不是一次性进行的，而是采用的渐进式扩容，在插入、修改、删除 key 的时候，都会尝试进行搬迁桶的工作，每次都会检查 oldbucket 是否 nil，如果不是 nil，则每次搬迁 2 个桶，蚂蚁搬家一样渐进式扩容</li></ul></li></ul><h4 id="8、map-的-key-为什么得是可比较类型的？"><a href="#8、map-的-key-为什么得是可比较类型的？" class="headerlink" title="8、map 的 key 为什么得是可比较类型的？"></a>8、map 的 key 为什么得是可比较类型的？</h4><p><strong>分析：</strong>考察 go 语言中如何通过一个 key 计算得到它在桶中的位置</p><ul><li><p>第一步：根据 key 来计算出一个 hash 值（64位的，当然与机器位数挂钩）</p></li><li><p>第二步：根据 hash 值的 低 B 位锁定桶号（找到对应的 bucket）</p></li><li><p>第三步：接着在桶中找到对应的槽位（根据 hash 值的高 8 位，找到对应的一个 cell）</p></li><li><p>但是这里会存在一个 hash 冲突的问题，并不是找到了这个槽位，就是当前 key 的位置，因为可能有其他的 key 和这个 key 计算出的 hash 值相同，那么显然槽位也就一样</p></li><li><p>所以还有第四步：进而比较 key 本身，来获取当前 key 的位置，所以 key 一定要是可比较的</p></li></ul><p><strong>回答：</strong></p><ul><li>首先 map 的 key、value 是存在 buckets 数组里的，而每个 bucket 又可以容纳 8 个 key 和 8 个 value</li><li>当要插入一个新的 key-value 时，会对 key 进行 hash 运算，得到一个 hash 值，然后根据 hash 值的低 B 位来决定命中哪个 bucket<ul><li>bucket 数量 &#x3D; 2^B</li></ul></li><li>在命中某个 bucket 后，又会根据 hash 值的高 8 位来决定是 8 个key里的哪个位置。如果不巧，发生了 hash冲突，即该位置上已经有其他 key 存在了，则会去其他空位置寻找插入。如果全满了，则使用 overflow 指针指向一个新的 bucket，重复刚刚的寻找操作。</li></ul><p>从上面的流程可以看出，在发生 hash 冲突，即该位置是否已经有其他 key 时，肯定是要进行比较的，所以 key 必须得是可比较类型。像 slice、map、function 就不能作为 key。</p><h1 id="Sync-map-相关"><a href="#Sync-map-相关" class="headerlink" title="Sync.map 相关"></a>Sync.map 相关</h1><h4 id="1、read-map-什么时候会更新？"><a href="#1、read-map-什么时候会更新？" class="headerlink" title="1、read map 什么时候会更新？"></a>1、read map 什么时候会更新？</h4><p><strong>分析：</strong> 考察 sync.map 的读写原理和设计思想，sync.map 底层采用两个 map：read 和 dirty，来保证 map 的执行效率和线程安全。</p><p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230803204551968.png" alt="image-20230803204551968"></p><p>sync.map 的设计思想：</p><ul><li>当 dirty 非空时，dirty 要包含整个 map 中的所有有效 key</li><li>当 dirty 为空时，则 read 中包含整个 map 中的所有 key，所有的操作都优先只操作 read，操作 read 时不用加锁，用原子操作来保证效率，在操作 read 不能满足的情况下，再进行加锁操作 dirty</li><li>对某个 key 在 read 操作时，当整个 key 不存在于 read，去操作 dirty 的时候，会使 misses+1，当 misses 次数大于等于 dirty 长度时，会将 dirty 提升为新的 read，然后把 dirty 置空，misses 清零</li></ul><p>因为 read 和 dirty 中都保存有对应 key 的指针，所以当这个 key 存在于 read 的时候，要更新这个 key，就会在 read 中进行更新，然后根据这个 key 是否被标记删除，决定是否要同步到 dirty，如果是标记删除的 key，dirty 中不存在，要保证上文 sync.map 设计思想中提到的：当 dirty 非空时，dirty 要包含整个 map 中所有有效 key，在重新写入后，这个 key 会变成有效的，所以要同步到 dirty，如果不是标记删除的，那么这个 key 在dirty 中存在，就不用同步。</p><p>Store 更新操作：</p><ol><li>key 存在于 read中：<ol><li>p &#x3D;&#x3D; expunged，更新 read，并加锁同步 dirty</li><li>p &#x3D;&#x3D; nil，key 存在于 read，被标记删除，但还没有完成 dirty 的重塑，需要将该 key 更新到 dirty中</li><li>p &#x3D;&#x3D; &amp;value，正常更新 read</li></ol></li><li>key 不存在于 read：即为新增操作（只操作dirty）<ol><li>dirty 为 nil，根据 read 重建 dirty，将 read 中除 nil 外的所有 key-value 加入到 dirty 中，并把该 key 也加入</li><li>dirty 不为 nil，直接插入新的  dirty</li></ol></li></ol><p>Load 读操作：</p><ol><li>先到 read 中读，再到 dirty 中加锁读</li><li>读取过程中，如果不存在 read中，但存在 dirty 中，misses+1，若此时 misses 刚好达到 dirty 的长度时，就会重塑 read，拷贝 dirty 的数据到 read 中，将 dirty 提升为 read，并将 dirty 置为 nil</li></ol><p>Range 遍历：</p><ol><li>在遍历时，会先判断 read 中的 amended 字段，若该字段为 true ，表示 dirty 中有 read 中 没有的 key，则将 dirty 提升为 read，然后直接遍历 read，这样就避免了 访问 dirty 加锁导致性能下降</li><li>若 read 中 amended 为 false，则直接遍历 read 即可</li></ol><p><strong>回答：</strong></p><ul><li>delete 和 update 的时候， key 存在于 read，read 会更新</li><li>当 misses 次数大于等于 dirty 长度时，会将 dirty 提升为 read，read 会更新</li></ul><h4 id="2、dirty-map-什么时候会更新？"><a href="#2、dirty-map-什么时候会更新？" class="headerlink" title="2、dirty map 什么时候会更新？"></a>2、dirty map 什么时候会更新？</h4><p><strong>分析：</strong>根据上一个问题的分析，</p><ul><li>dirty 会在操作 read 不满足时进行操作，</li><li>在 dirty 提升为 read 之后，dirty 会被更新为 nil，此时若有一个新的 key 要插入，dirty 也会进行更新，会根据 read 重塑（将 read 中除 nil 外的 key 加入 dirty 中）</li></ul><p><strong>回答：</strong></p><ul><li>插入一个新的 key 的时候，会直接插入到 dirty</li><li>执行 store 操作的时候，当 read 中存在这个值，dirty 中不存在这个 key 的时候会更新，将这个 key-value 插入到 dirty</li><li>delete 的时候，当 read 中没有这个 key，而 dirty 中存在这个 key 的时候，会更新，将这个 key-value 直接从 dirty map 删除</li><li>当 misses 数量 大于等于 dirty 长度时，会将 dirty 提升为 read，将 dirty 中的所有 key-value 拷贝到 read 中，然后将 dirty 置为 nil</li><li>当 dirty 为 nil 的时候，此时插入一个新的 key，会重塑新的 key，会重塑 dirty，新建一个 dirty map，将 read 中的非 expunged 状态的 key-value copy 到 dirty</li></ul><h4 id="3、read-map-和-dirty-map-的删除逻辑有什么区别？"><a href="#3、read-map-和-dirty-map-的删除逻辑有什么区别？" class="headerlink" title="3、read map 和 dirty map 的删除逻辑有什么区别？"></a>3、read map 和 dirty map 的删除逻辑有什么区别？</h4><p><strong>分析：</strong>Delete 删除操作：</p><ol><li>key 只存在于 read 中，直接将 key 对应的 p 设置为 nil</li><li>key 只存在 dirty 中，直接在 dirty 中删除该 key</li><li>都存在，将 p 设置 nil，这种情况 read 与 dirty 指向一个 p，故都指向 nil</li></ol><p>回答中突出<strong>标记删除</strong>和直接删除</p><p><strong>回答：</strong></p><ul><li>read 删除是标记删除，并没有在 map 中实际删除这个 key，而只是将这个 key 对应的 value 设置为 nil，等到 misses 大于等于 dirty 长度的时候，将用 dirty 覆盖 read 的时候，才会真正删除这个 key，是延迟删除</li><li>dirty 中删除是直接将这个 key 从 dirty 这个 map 中删除掉，是直接删除</li></ul><h4 id="4、既然在删除-read-的时候没有删除这个-key，而在-dirty-覆盖的时候又只覆盖了-read，那么假如-dirty-中也存在这个-key，这个-key是不是会被遗漏，没有删掉，而导致内存泄漏？"><a href="#4、既然在删除-read-的时候没有删除这个-key，而在-dirty-覆盖的时候又只覆盖了-read，那么假如-dirty-中也存在这个-key，这个-key是不是会被遗漏，没有删掉，而导致内存泄漏？" class="headerlink" title="4、既然在删除 read 的时候没有删除这个 key，而在 dirty 覆盖的时候又只覆盖了 read，那么假如 dirty 中也存在这个 key，这个 key是不是会被遗漏，没有删掉，而导致内存泄漏？"></a>4、既然在删除 read 的时候没有删除这个 key，而在 dirty 覆盖的时候又只覆盖了 read，那么假如 dirty 中也存在这个 key，这个 key是不是会被遗漏，没有删掉，而导致内存泄漏？</h4><p><strong>分析：</strong>对上个问题的补充：</p><p>​因为 read 中 key 只是标记删除了，此时 read 和 dirty 中的 p 指向的是同一个值，此时 dirty 也是标记删除状态，并未删除这个值，真正的删除在后面。当 misses 次数达到 dirty 长度的时候，会将 dirty 提升为 read，在重塑 dirty 的时候，这个 key 对应的 p 会被置为 expunged，后面再次发生 dirty 提升为 read 的时候，会过滤p 的值为 expunged 的 key，就不会存在这个 key 了，就删除成功了。</p><p><strong>回答：</strong></p><p>​不会，因为在把 dirty 提升为 read，覆盖完 read 之后，会将 dirty 置为 nil，下一次重塑 dirty 的时候，dirty 中就没有这个 key 了，之后再进行一次 dirty 提升为 read 的时候，read 中的 key 就会被删除了。</p><h4 id="5、sync-Map-中的-read-和-dirty-有什么关系？"><a href="#5、sync-Map-中的-read-和-dirty-有什么关系？" class="headerlink" title="5、sync.Map 中的 read 和 dirty 有什么关系？"></a>5、sync.Map 中的 read 和 dirty 有什么关系？</h4><p><strong>分析：</strong>由前面的分析，可知</p><ol><li>当 dirty 非空时，dirty 要包含整个 map 中的所有有效 key</li><li>当 dirty 为空时，则 read 中包含整个 map 中的所有 key，并且在 missess 达到 dirty 长度时，会将 dirty 提升为 read，再置空 dirty。此时有新的 key 插入的时候，又要根据 read 重塑 dirty，所以可以认为 read 和 dirty 互为快照。</li></ol><p><strong>回答：</strong></p><p>read 可以看作是 dirty 的一个快照。</p><ul><li><p>在 dirty 不为空的时候，dirty 包含 map 中所有有效 key</p></li><li><p>在 dirty 为空的时候， read 包含 map 中所有有效 key</p></li><li><p>在read的misses达到dirty的长度的时候，会将dirty提升为read，用dirty中的所有key&#x2F;value覆盖read，之后dirty置<br>为nil</p></li><li><p>当dirty为nil的时候，插入一个新key，此时会根据read来重塑dirty，将read中非标记删除的key&#x2F;value都<br>copy到dirty</p></li></ul><h4 id="6、sync-Map-中的值是否一定是有效的？"><a href="#6、sync-Map-中的值是否一定是有效的？" class="headerlink" title="6、sync.Map 中的值是否一定是有效的？"></a>6、sync.Map 中的值是否一定是有效的？</h4><p><strong>分析：</strong>在 key 存在于 read 中的时执行删除操作，并不会真正删除这个 key，而是将其 value 置为 nil，标记删除。</p><p>​故 sync.Map 中的 key 还可能是已经删除的状态，回答时突出还可能存在 <strong>标记删除</strong>状态</p><p><strong>回答：</strong></p><p> 不一定 sync.Map 中的值其实是由 emtry 中的一个 p 指针指向的，p 可能有三种状态，nil、正常值、expunged。</p><p>当 p 的状态为 expunged 和 nil 为标记删除状态，表示这个值是被删除了的，并不一定都是有效的。</p><h4 id="7、sync-Map-应用场景"><a href="#7、sync-Map-应用场景" class="headerlink" title="7、sync.Map 应用场景"></a>7、sync.Map 应用场景</h4><p><strong>分析：</strong></p><p>​sync.Map 底层采用两个 map：read 和 dirty 来保证 map 的执行效率 和线程安全的。只有在操作 read 的时候是原子操作，不用加锁，执行效率高，在操作 dirty 的时候还是要加锁，所以影响 sync.Map 效率取决于操作 dirty 的频率。在写比较多的场景，要操作 dirty，故应该避免这种写操作。</p><p>​故突出 <strong>读多写少</strong>这种场景</p><p><strong>回答：</strong></p><p>​sync.Map 是适用于读多、更新多、删多、写少的情况。</p><blockquote><p>我们期望更多的流量在 read map 这一层拦截，从而避免加锁访问 dirty map</p><p>对于更新、删除、读取，read map 可以尽量通过一些原子操作，让整个操作变得无锁化，这样就可以避免进一步加锁访问 dirty map</p><p>倘若写操作过多，sync.Map 基本等价于一把互斥锁 + map</p></blockquote><h1 id="GMP-相关"><a href="#GMP-相关" class="headerlink" title="GMP 相关"></a>GMP 相关</h1><h4 id="1、什么是-GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）"><a href="#1、什么是-GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）" class="headerlink" title="1、什么是 GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）"></a>1、什么是 GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的比较少）</h4><h5 id="1-1-什么是GMP？"><a href="#1-1-什么是GMP？" class="headerlink" title="1.1 什么是GMP？"></a>1.1 什么是GMP？</h5><p><strong>分析：</strong> gmp 模型是 go 语言中的协程调度模型</p><p><strong>GMP 简单介绍</strong></p><p>G：Goroutine</p><p>M：内核线程，每个 m 都有 1 个特殊的协程 g0，这个 g0 主要负责协程调度和切换，goroutine 只有绑定到 m 上才能正常运行</p><p>P：逻辑处理器 Processor ，包含 goroutine 本地队列，队列长度为 256，当有 goroutine 要创建时，会被添加到 P 的本地队列上，如果 P 的本地队列已满，则会维护到全局队列里</p><p><strong>P 和 M 的创建时机</strong></p><p>P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p><p>M 何时创建：没有足够的 M 来关联 P 并允许其中可允许的 G时。比如所有的 M 此时都阻塞了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p><p><strong>回答：</strong></p><p>​GMP 是 Go 语言协程调度模型，G 代表 Goroutine，M 代表内核线程，P 代表逻辑处理器，P 中包含本地队列 G，G 通过 P 绑定到 M，才能真正运行</p><h5 id="1-2-调度过程是怎样的？"><a href="#1-2-调度过程是怎样的？" class="headerlink" title="1.2 调度过程是怎样的？"></a>1.2 调度过程是怎样的？</h5><p><strong>分析：</strong></p><p>​上面回答了 GMP 是 Go 语言的协程调度模型，这个问题是对上一个问题的补充提问，进一步回答协程怎样调度的。协程的调度是一个很复杂的过程，既然是调度，肯定设计到协程的上下文切换、调度策略、调度时机以及调度过程。</p><p><strong>协程的上下文切换：</strong></p><p>​协程的调度主要是发生在 Goroutine 和 g0 之间</p><p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230804211222878.png" alt="image-20230804211222878"></p><p>​协程经过 g —-&gt; g0 —-&gt; g 的过程就完成了一次调度循环，一次协程调度过程跟线程调度一样，也会发生协程的上下文切换，同样需要保存协程的执行现场，这样才能够切回 g，接着上一次继续执行。</p><p>​协程的执行现场主要是几个寄存器的值，分别是 rsp、rip、rbp。</p><p>rsp：指向函数调用的栈顶</p><p>rip：指向程序要指向的下一条指令</p><p>rbp：存储函数栈帧的起始地址</p><p>​这些寄存器主要保存在 goroutine 的 sched 这个字段结构中，goroutine 的结构如下：</p><p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230804211709507.png" alt="image-20230804211709507"></p><p><strong>调度策略：</strong></p><p>​协程的调度过程可以认为是 m 寻找一个可以运行的 g 来运行的过程：</p><ul><li>优先从 P 的本地队列获取 goroutine 来执行；</li><li>如果本地队列没有，从全局队列获取</li><li>如果全局队列也没有，从网络轮询器重查找是否有 Goroutine 等待运行</li><li>如果还是没有，则会从其他的 P 上偷取 goroutine</li></ul><p>​上述调度策略有一个问题：如果本地队列一直有 g 的话，那么全局队列的 g 可能完全没有机会执行？</p><ul><li>所以，Go 的调度器在每执行 61 次调度，就会优先从全局队列中获取一个 g 放到当前 p 队列。</li><li>如果本地队列已经满了，无法从全局运行队列调用并放入怎么办？<ul><li>此时调度器会将本地运行队列的一半放入全局队列。这保证了当程序中有很多协程时，每个协程都有执行的机会</li></ul></li></ul><p><strong>调度模式：</strong></p><p>​调度模式一般有两种，抢占式 和 协作式。</p><ul><li>协作式调度：依靠被调度方主动弃权</li><li>抢占式调度：依靠调度器强制将被调度方被动中断</li></ul><p><strong>发生调度的时机：</strong></p><ul><li>等待读取或写入未缓冲的通道</li><li>由于 time.Sleep() 而等待</li><li>等待互斥量是否</li><li>发生系统调用</li></ul><p><strong>回答：</strong></p><p>​协程在刚创建的时候，会优先加到当前 p  的本地队列中，等待被调度。</p><ul><li>当这个 p 队列满了的时候，本地队列满了时，会将本地队列的一半 G 和新创建的 G 打乱顺序，一起放入全局队列。</li></ul><p>​每个 m 都有一个特殊的协程 g0 负责调度工作，每一轮调度的过程是这样的：M 优先执行其所绑定的 P 的本地运行队列中的 G，</p><ul><li><p>如果本地队列没有 G，则会从全局队列获取，为了提高效率和负载均衡，会从全局队列获取多个 G，而不是只取一个</p></li><li><p>当全局队列没有时，会从其他 M 的 P 上偷取 G 来运行，偷取的个数通常是其他 P 运行队列的一半</p></li><li><p>如果还没有获取到 g，则 m 就处于自旋状态（自旋状态就是当前 M 会一直尝试去全局、其他队列获取 G）</p></li></ul><h4 id="2、GMP-能不能去掉-P-层，为什么？"><a href="#2、GMP-能不能去掉-P-层，为什么？" class="headerlink" title="2、GMP 能不能去掉 P 层，为什么？"></a>2、GMP 能不能去掉 P 层，为什么？</h4><p><strong>分析：</strong> 考察对 P 的作用的理解。在起初的时候，是单纯的 GM 模型，是没有 P 的，为什么会被弃用呢？假设没有 P 的话，也就没有本地p 的 g队列，则所有的 M 都会去全局队列获取 g，这样势必<strong>有锁竞争问题</strong>，所以回答的时候抓住这个点分析即可</p><p><strong>回答：</strong></p><ul><li>每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争</li><li>每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法。如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源的利用率。</li></ul><h4 id="3、M-和-P-的数量问题？"><a href="#3、M-和-P-的数量问题？" class="headerlink" title="3、M 和 P 的数量问题？"></a>3、M 和 P 的数量问题？</h4><p><strong>分析：</strong></p><p>​其实是上一个问题的补充问题，考察对 gmp 模型的了解深部深入</p><p><strong>回答：</strong> </p><p><strong>P 的数量：</strong></p><p>​由启动时环境变量 <code>$GOMAXPROCS</code> 或者由<code>runtime</code> 的方法<code>GOMAXPROCS()</code> 决定</p><p><strong>M 的数量：</strong></p><p>​go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000。</p><p>​但是内核很难支持这么多的线程数 runtime&#x2F;debug 中的 SetMaxThreads 函数，设置 M 的最大数量</p><p>​一个 M 阻塞了，会创建新的 M。</p><p><strong>G 的数量：</strong></p><p>​理论上没有限制，受限于内存，但是 goroutine 过多会影响程序性能</p><h4 id="4、进程、线程、协程-有什么区别？"><a href="#4、进程、线程、协程-有什么区别？" class="headerlink" title="4、进程、线程、协程 有什么区别？"></a>4、进程、线程、协程 有什么区别？</h4><p><strong>分析：</strong> </p><p>​进程、线程、协程都是并发单元，但是具体又有不同，在分析三者区别的时候，可以从大小、调度、资源分配以及用户态或者是内核态等几个方面进行分析</p><p><strong>回答：</strong></p><p>​进程可以理解为一个动态的程序，进程是操作系统分配的基本单位。</p><p>​线程是操作系统调度的基本单位，进程独占一个虚拟内存空间，而进程里的线程共享一个进程虚拟内存空间。线程的粒度更小，一个进程可以有多个线程。</p><p>​协程可以理解为用户态线程，跟线程的区别主要有三个方面：</p><ol><li>大小：协程大小为 2 k，可以动态扩容，而线程大小为 2 m，协程更轻量</li><li>切换成本：线程切换需要用户态到内核态的切换，而协程的切换不用，只在用户态完成，线程切换需要保存各种寄存器，而协程切换只需要保存 rsp、rip、rbp 三个寄存器，协程切换消耗更小</li><li>调度：线程的调度由操作系统完成，而协程的调度由运行时的调度器完成</li></ol><h4 id="5、抢占式调度如何抢占的？"><a href="#5、抢占式调度如何抢占的？" class="headerlink" title="5、抢占式调度如何抢占的？"></a>5、抢占式调度如何抢占的？</h4><p><strong>分析：</strong> 考察对 go 语言的协程调度方式的了解，调度模式一般有两种：抢占式 和 协作式。</p><ul><li>协作式调度：在一定情况下，使用权会被抢占</li><li>抢占式调度：会主动让渡使用权</li></ul><p>​Go 语言的调度方式都是抢占式的，但是在 Go1.14之前 和 Go1.14 之后的具体抢占策略实现又有所不同，本题在回答的时候，要注意区分 go 的版本，对 Go1.14 之前 和 Go1.14之后的抢占策略熟悉，并且分析出 Go1.14 之后的抢占策略的优势</p><p><strong>Go 语言调度方式：</strong></p><p>​Go 语言的调度模式在 Go1.14 之前是基于协作的抢占式调度，在 Go1.14及以后实现了基于信号的抢占式调度（异步抢占）</p><p><strong>Go1.14 之前：</strong></p><p>​协作式调度就是 m 会主动让渡出 p，让 p 可以与其他的 m 绑定，以下情况会发生这种主动让渡（协作调度）：</p><ul><li>同一个 goroutine 运行超过 10 ms</li></ul><p>​而下面情况下会发生抢占：</p><p>​抢占的原理：</p><p>​Go 会启动一个线程，一直运行着 “sysmon” 函数，该函数实现了抢占式调度（以及其他诸如使网络处理的等待状态变为非阻塞状态）的功能。sysmon 运行在 M （Machine，实际上是一个系统线程），且不需要 P（Processor）</p><p>​当 sysmon 发现 M 已运行同一个（Goroutine） 10ms 以上，它会将该 G 的内部参数 <code>preemep</code> 设置为 true</p><p>​当 G 进行函数调用时，G 会检查自己的 <code>preempt</code> 标志，如果它为 true，则它将自己与 M 分离并推入 goroutine 的全局队列，抢占完成。</p><p>​但是通过上述过程可以看到，要发生抢占，有 1 个前提：那就是发生函数调用，如果没有函数调用，即使设置了抢占标志，也不会进行该标志的检查，自然也就不会执行抢占过程。所以下述代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> fmt.Println(<span class="hljs-string">&quot;hi&quot;</span>)<br><span class="hljs-keyword">for</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​设置单核情况下，在 go1.14之前，这个代码将正常运行，被阻塞住，因为不会发生调度，for 循环这个死循环不是函数调用，所以 <code>preempt</code> 标志检查这个阶段，不会发生抢占式调度，这个 goroutine 不会被抢占，一直阻塞。</p><p><strong>Go 1.14 之后</strong></p><p>​sysmon 会检查到运行了 10ms 以上的  G。然后 sysmon 向运行 G 的 P 发送信号（SIGURG）。Go 的信号处理程序会调用 P 上的一个叫做 gsignal 的 goroutine 来处理该信号，将其映射到 M 而不是 G，并使其检查该信号。gsignal 看到抢占信号，停止正在运行的 G。</p><p>​由于次机制会显示发出信号，因此无需调用函数，就能将正在运行死循环的 goroutine 切换到另一个 goroutine</p><p>​通过使用信号的异步抢占机制，上面的代码现在就可以按预期工作。<code>GODEBUG=asyncpreemtpoff=1</code> 可用于禁用异步抢占。</p><p><strong>回答：</strong></p><p>​<strong>Go1.14 之前是协作式抢占</strong>，Go 会启动一个线程，一直运行着 “sysmon” 函数，该函数实现了抢占式调度（以及其他注入使网络处理的等待状态转变为非阻塞状态）的功能。sysmon 运行在 M（Machine，实际上是一个系统线程），且不需要 P（Processor）</p><p>​当 sysmon 发现 M 已经运行同一个 G 10ms 以上时，它会将该 G 的内部参数 <code>preempt</code> 设置为 true</p><p>​当 G 进行函数调用时， G 会检查自己的 <code>preempt</code> 标志，如果它会 true，则它将自己与 M 分离并推入 goroutine 的全局队列，抢占完成</p><p>​<strong>Go1.14之后是异步式抢占，基于信号</strong>：sysmon 会检测到运行了 10ms 以上的 G(goroutine)。然后 sysmon 向运行 G 的 P 发送信号（SIGURG）。Go 的信号处理程序会调用 P 上的一个叫做 gsignal 的 goroutine 来处理该信号，将其映射到 M 而不是 G，并使其检查该信号。gsignal 看到抢占信号，停止运行正在运行的 G。</p><p>​基于信号量的抢占可以防止类似死循环这种没有发生函数调用的 goroutine 一直占用 CPU 导致程序阻塞，提高了程序的合理性。</p><h1 id="Sync-相关："><a href="#Sync-相关：" class="headerlink" title="Sync 相关："></a>Sync 相关：</h1><h4 id="1、除了-mutex-以外，还有哪些方式可以安全读写共享内存？"><a href="#1、除了-mutex-以外，还有哪些方式可以安全读写共享内存？" class="headerlink" title="1、除了 mutex 以外，还有哪些方式可以安全读写共享内存？"></a>1、除了 mutex 以外，还有哪些方式可以安全读写共享内存？</h4><p><strong>分析：</strong></p><p>​考察 Go 语言中数据竞争的解决方案，在  Go 语言中有锁，信号量还有channel 三种实现方式，回答的时候出现信号量以及 channel 关键字</p><ol><li><p><strong>用信号量实现互斥功能</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/sync/semaphore&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">()</span></span> &#123;<br>num++<br>fmt.Println(<span class="hljs-string">&quot;num is &quot;</span>, num)<br>time.Sleep(time.Millisecond * <span class="hljs-number">50</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> (<br>Limit  = <span class="hljs-number">1</span><br>Weight = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := semaphore.NewWeighted(Limit)<br><span class="hljs-keyword">var</span> w sync.WaitGroup<br>w.Add(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>s.Acquire(context.Background(), Weight)<br>Add()<br>s.Release(Weight)<br>w.Done()<br>&#125;()<br>&#125;<br>w.Wait()<br>fmt.Println(<span class="hljs-string">&quot;end...&quot;</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 channel 实现互斥功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>num++<br>fmt.Println(<span class="hljs-string">&quot;num is &quot;</span>, num)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> w sync.WaitGroup<br>w.Add(<span class="hljs-number">10</span>)<br>chanLock := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>chanLock &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>add()<br>&lt;-chanLock<br>w.Done()<br>&#125;()<br>&#125;<br>w.Wait()<br>fmt.Println(<span class="hljs-string">&quot;end... &quot;</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>mutex 实现互斥</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>num++<br>fmt.Println(<span class="hljs-string">&quot;num is &quot;</span>, num)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> w sync.WaitGroup<br>w.Add(<span class="hljs-number">10</span>)<br>m := sync.Mutex&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>m.Lock()<br>add()<br>m.Unlock()<br>w.Done()<br>&#125;()<br>&#125;<br>w.Wait()<br>fmt.Println(<span class="hljs-string">&quot;end... &quot;</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>回答：</strong></p><ul><li>将共享变量的读写放到一个 goroutine，其它 goroutine 通过 channel 进行读写操作</li><li>可以用个数为 1 的信号量（semaphore）实现互斥</li><li>通过 Mutex 锁实现</li></ul><h4 id="2、Go-如何实现原子操作"><a href="#2、Go-如何实现原子操作" class="headerlink" title="2、Go 如何实现原子操作"></a>2、Go 如何实现原子操作</h4><p><strong>分析：</strong></p><p>​回答时突出 Go 语言实现的原子操作在 sync&#x2F;atomic 包下，提供了 store、add 等方法</p><p><strong>回答：</strong></p><p>​原子操作是一组不可中断的指令序列，由底层硬件支持，Go 语言的原子操作由 sync&#x2F;atomic 包提供，主要提供了下面的一些方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddT</span><span class="hljs-params">(addr *T, delta T)</span></span>(<span class="hljs-built_in">new</span> T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Store</span><span class="hljs-params">(addr *T, val T)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadT</span><span class="hljs-params">(adr *T)</span></span>(val T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapT</span><span class="hljs-params">(addr *T, <span class="hljs-built_in">new</span> T)</span></span>(old T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareAndSwap</span><span class="hljs-params">(addr *T, old, <span class="hljs-built_in">new</span> T)</span></span>(swapped <span class="hljs-type">bool</span>)<br></code></pre></td></tr></table></figure><h4 id="3、原子操作和锁的区别"><a href="#3、原子操作和锁的区别" class="headerlink" title="3、原子操作和锁的区别"></a>3、原子操作和锁的区别</h4><p><strong>分析：</strong></p><p>​二者都可以用来保证线程安全，但是二者在实现原理和使用方式上都存在很大的区别。</p><p>​可以从二者的实现方式、作用范围、使用场景以及锁类型等几个方面来分析</p><p><strong>回答：</strong></p><p>​原子操作由底层硬件支持，而锁是基于原子操作 + 信号量完成的。若实现相同的功能，前者通常会更有效率</p><p>​原子操作是单个指令的互斥操作；</p><p>​互斥锁&#x2F;读写锁是一种数据结构，可以完成临界区（多个指令）的互斥操作，扩大原子操作的范围</p><p>​原子操作是无锁操作，属于乐观锁；说起锁的时候，一般属于悲观锁</p><h4 id="4、Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"><a href="#4、Mutex-是悲观锁还是乐观锁？悲观锁、乐观锁是什么？" class="headerlink" title="4、Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？"></a>4、Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</h4><p><strong>分析：</strong></p><p>​先明确什么是悲观锁、乐观锁：</p><ul><li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作</li><li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</li></ul><p>​然后显然 Mutex 是悲观锁。</p><p><strong>回答：</strong></p><p>​悲观锁和乐观锁是两种锁的思想，乐观锁假定别人不会修改数据。在操作数据的时候，查看一下数据，然后修改完真正生效的时候查看一下数据有没有发生变化，如果发生变化，则认为数据被修改，有并发问题，放弃操作，否则执行操作。而悲观锁就是时时刻刻认为有其他操作者修改数据，每次操作数据的时候，都尝试把数据锁住，在操作期间其他人不能修改数据，直至锁被释放。</p><p>​Mutex 是悲观锁，Go sync 包提供了两种锁类型：互斥锁 sync.Mutex 和 读写锁 sync.RWMutex，都是属于悲观锁</p><h4 id="5、互斥锁-Mutex-底层是怎么实现的？"><a href="#5、互斥锁-Mutex-底层是怎么实现的？" class="headerlink" title="5、互斥锁 Mutex 底层是怎么实现的？"></a>5、互斥锁 Mutex 底层是怎么实现的？</h4><p><strong>分析：</strong></p><p>​Mutex 的底层定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>state <span class="hljs-type">int32</span> <span class="hljs-comment">// int32 类型，表示锁状态，例如是否被锁定</span><br>sema <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>明确各个字段的含义以及作用：</p><p>​state 是 32 位的整型变量，内部实现是把它分成了四份，用来记录 Mutex 的四种状态。Mutex 的内部布局</p><p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230805215842607.png" alt="image-20230805215842607"></p><ul><li>Waiter：表示阻塞等待锁的线程个数，协程解锁时根据此值判断释放需要释放信号量</li><li>Starving：表示该 Mutex 是否处于饥饿状态，0：正常状态，1：饥饿状态，说明有协程阻塞超过 1 ms</li><li>Woken：表示是否有协程已被唤醒，0：没有协程唤醒，1：已有协程唤醒，正在加锁过程中</li><li>Locked：表示该 Mutex 是否被锁定，0：没有锁定，1：已被锁定</li></ul><p>​sema 是一个 uint32 类型的整型，用于协程排队和唤醒，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待这个信号量的协程</p><p><strong>回答：</strong></p><p>​mutex 底层是通过原子操作加信号量来实现的，通过 atomic 包中的一些原子操作来实现锁的锁定，通过信号量来实现协程的阻塞与唤醒</p><h4 id="6、Mutex-有几种模式？"><a href="#6、Mutex-有几种模式？" class="headerlink" title="6、Mutex 有几种模式？"></a>6、Mutex 有几种模式？</h4><p><strong>分析：</strong></p><p>​对上一个问题的补充，通过 state 字段的倒数第三位 Starving 可以判断除锁释放处于饥饿模式。所以锁有两种模式：饥饿模式和正常模式。在不同模式下，获取锁的方式有所不同。</p><p><strong>回答：</strong></p><p>​在正常模式下，锁的等待着会按照先进先出的顺序来获取锁，但是刚被唤醒的 Goroutine 与刚被创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的锁会被放入到等待队列的队首。如果一个等待的 Goroutine 超过 1ms 没有获取到锁，那么会将锁转变为饥饿模式。————不公平</p><p>​在饥饿模式下，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁，也不会进入自旋状态尝试获取锁，它们会加入到等待队列的末尾。如果一个 GOroutine 获得了互斥锁并且它是处在队列的末尾或它获得锁之前等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。——–公平</p><h4 id="7、在-Mutex-上的自旋的-Goroutine-会占用太多资源吗？"><a href="#7、在-Mutex-上的自旋的-Goroutine-会占用太多资源吗？" class="headerlink" title="7、在 Mutex 上的自旋的 Goroutine 会占用太多资源吗？"></a>7、在 Mutex 上的自旋的 Goroutine 会占用太多资源吗？</h4><p><strong>分析：</strong></p><p>​自旋状态：当一个线程在获取锁的时候，如果锁已经被其他线程获取了，那么该线程将循环等待，然后不断地判断释放能否成功获取，知道获取到锁才会退出循环。</p><p>​从这里看出 goroutine 的自旋状态会消耗 CPU 资源，导致 CPU 一定时间的空转。所以长时间处于自旋状态肯定是不合理的。故自旋状态一定要满足一定的条件：</p><ul><li>次数不能过多</li><li>锁不能处于饥饿模式，不然其他 goroutine 很难获取到锁</li><li>处理器的个数，比如单核下自旋是没有意义的，因为同时只有一个线程可以运行，要获取锁只能等待当前线程释放，自旋自然没有意义</li></ul><p><strong>回答：</strong></p><p>​goroutine 自旋要满足一定条件：</p><ul><li>自旋次数没有超过 4 次</li><li>锁已被占用，并锁不处于饥饿模式</li><li>多核处理器</li><li>GOMAXPROCS &gt; 1</li><li>p 上本地的 goroutine 队列为空</li></ul><p>​mutex 会让当前的 goroutine 去空转 CPU，在空转完后再调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终进入 等待队列里，结束自旋</p><h4 id="8、读写锁是怎么实现的？"><a href="#8、读写锁是怎么实现的？" class="headerlink" title="8、读写锁是怎么实现的？"></a>8、读写锁是怎么实现的？</h4><p><strong>分析：</strong><br>    读写锁的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;<br>w           Mutex  <span class="hljs-comment">// 复用互斥锁</span><br>writerSem   <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，用于写等待读</span><br>readerSem   <span class="hljs-type">uint32</span> <span class="hljs-comment">// 信号量，用于读等待写</span><br>readerCount <span class="hljs-type">int32</span>  <span class="hljs-comment">// 当前正在啊hi下的读操作 goroutine 数量</span><br>readerWait  <span class="hljs-type">int32</span>  <span class="hljs-comment">// 写协程等待完成的读协程的数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​从定义可以看出，读写锁里面有一个互斥锁 Mutex 存在，所以在实现上一定会基于 mutex，但是多余了其余的一些字段，用于记录读锁加锁次数，当前正在读的 goroutine 数量，以及写阻塞时等待完成的读 goroutine 数量。</p><p>​加锁过程：</p><ul><li>加读锁：<ul><li>若锁处于空闲状态，那么直接获取读锁</li><li>若有协程持有锁，那么无法获取锁，当前 goroutine 空闲</li></ul></li><li>加写锁：<ul><li>获取写锁需要用到 mutex 和 readerWait，首先获取成功之后，若 readerWait 大于 0，此时 goroutine 占用了读锁，那么加写锁阻塞，</li><li>若没有 goroutine 占用读锁，加写锁成功</li></ul></li></ul><p>​解锁过程：</p><ul><li>释放读锁：<ul><li>直接释放读锁；若有 goroutine 等待加读锁，则在释放读锁之后会将 readerWait 减 1；当 readerWait 减到 0 时，就唤醒被阻塞的写操作的 goroutine 了</li><li>修改 readerCount 值为正，解除互斥，然后唤醒所有的读 goroutine，最后释放互斥锁 mutex</li></ul></li></ul><p><strong>回答：</strong></p><p>​读写锁是基于互斥锁实现的，这个互斥锁被读写共享，但是通过 readerWait、readerCount 进行控制。</p><p>​readerWait 大于 0 时会阻塞加写锁，当 readerCount 为负时，锁处于互斥状态。</p><ul><li>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞</li><li>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞</li><li>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞</li><li>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以有用读锁</li></ul><h4 id="9、Mutex-以及被一个-Goroutine-获取了，等待它中的-Goroutine-们只能一直等待。那么等这个锁释放后，等待中的-Goroutine-中哪一个会优先获取-Mutex？"><a href="#9、Mutex-以及被一个-Goroutine-获取了，等待它中的-Goroutine-们只能一直等待。那么等这个锁释放后，等待中的-Goroutine-中哪一个会优先获取-Mutex？" class="headerlink" title="9、Mutex 以及被一个 Goroutine 获取了，等待它中的 Goroutine 们只能一直等待。那么等这个锁释放后，等待中的 Goroutine 中哪一个会优先获取 Mutex？"></a>9、Mutex 以及被一个 Goroutine 获取了，等待它中的 Goroutine 们只能一直等待。那么等这个锁释放后，等待中的 Goroutine 中哪一个会优先获取 Mutex？</h4><p><strong>回答：</strong><br>    对第 7 题的补充，通过第 7 题分析我们知道：在正常模式和饥饿模式下获取锁的策略是不同的，所以在回答的时候也要分为两种情况来回答：</p><ul><li>在饥饿模式下，新加入的 goroutine 不会获取锁，而是加入获取锁的 goroutine 队列排队，所以排在最前面的 goroutine 会优先获取锁</li><li>在正常模式下，则是新请求的 goroutine 更容易获取锁，为什么呢？可以联想到资源占用，新请求的 goroutine 正在 CPU 上运行，占用着 CPU 资源，更容易抢锁成功</li></ul><p><strong>回答：</strong></p><ul><li>正常模式下，当一个 Goroutine 获取到锁之后，其他的 Goroutine 开始进入自旋转（为了持有CPU）或者进入沉默阻塞状态（加入队列，等待信号量唤醒）。但是这里存在一个问题，新请求的 Goroutine 进入自旋时是仍然拥有 CPU 的，所以比等待信号量唤醒的 Goroutine 更容易获取锁。用官方话来说激素，新请求锁的 Goroutine 具有优势，它正在 CPU 上运行，而且能有好几个，所以刚刚唤醒  Goroutine 有很大可能在锁竞争中失败</li><li>而在饥饿状态下，新加入的 goroutine 不参与锁的竞争，会加入获取锁的 goroutine 等待队列末尾排队，所以是排在最前面的 goroutine 会优先获取锁</li></ul><h4 id="10、waitgroup-是怎样实现协程等待的？"><a href="#10、waitgroup-是怎样实现协程等待的？" class="headerlink" title="10、waitgroup 是怎样实现协程等待的？"></a>10、waitgroup 是怎样实现协程等待的？</h4><p><strong>分析：</strong></p><p>​watigroup 的结构定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WaitGroup <span class="hljs-keyword">struct</span> &#123;<br>noCopy noCopy<br><br><span class="hljs-comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span><br><span class="hljs-comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span><br><span class="hljs-comment">// compilers only guarantee that 64-bit fields are 32-bit aligned.</span><br><span class="hljs-comment">// For this reason on 32 bit architectures we need to check in state()</span><br><span class="hljs-comment">// if state1 is aligned or not, and dynamically &quot;swap&quot; the field order if</span><br><span class="hljs-comment">// needed.</span><br>state1 <span class="hljs-type">uint64</span><br>state2 <span class="hljs-type">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>state1：64 位值，高 32 位为计数器，就是协程组中运行着的协程个数，低32位为等待者计数，即等待者的个数。比如我们一般在主协程中执行 wait() 函数，那么等待者计数为 1</p><p>state2：信号量，用于协程排队和唤醒</p><p>waitgroup 对外提供了三个方法：Add(int)、Done()、Wait()</p><ul><li>Add：用来设置 WaitGroup 的计数值</li><li>Done：用来将 WaitGroup 的计数值减一，其实就是调用了 Add(-1)</li><li>Wait：其实就是检查 WaitGroup 的计数值，如果大于 0 ，就阻塞等待，知道 WaitGroup 的计数值变成 0，进入下一步</li></ul><p>​主要就是通过这三个方法的配合来实现线程等待</p><p><strong>回答：</strong></p><p>​waitgroup 内部维护了一个计数器，当调用了 <code>wg.Add(1)</code> ，就会增加对应的数量；当调用 <code>wg.Done()</code> 时，计数器就会减一。直到计数器的数量减到 0 时，就会调用 runtime_Semrelease 唤起之前因为 <code>wg.Wait()</code> 而阻塞住的 goroutine。</p><h4 id="11、sync-Once-的原理，是怎样保证代码段只执行-1-次？"><a href="#11、sync-Once-的原理，是怎样保证代码段只执行-1-次？" class="headerlink" title="11、sync.Once 的原理，是怎样保证代码段只执行 1 次？"></a>11、sync.Once 的原理，是怎样保证代码段只执行 1 次？</h4><p><strong>分析：</strong></p><p>​直接看 sync.Once 源码，很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>done <span class="hljs-type">uint32</span> <span class="hljs-comment">// 标识位</span><br>m    Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<br><span class="hljs-comment">// 原子加载标识值，判断是否已被执行过    </span><br><span class="hljs-keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="hljs-number">0</span> &#123;<br>o.doSlow(f)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> doSlow(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) &#123;<span class="hljs-comment">// 还没执行过函数</span><br>o.m.Lock()<br><span class="hljs-keyword">defer</span> o.m.Unlock()<br><span class="hljs-keyword">if</span> o.done == <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// 再次判断下是否已被执行过函数</span><br><span class="hljs-keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="hljs-number">1</span>) <span class="hljs-comment">// 原子操作：修改表示符</span><br>f()<span class="hljs-comment">// 执行函数</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​主要是通过一个标识位来判断逻辑是否已经执行过。</p><p><strong>回答：</strong></p><p>​内部维护了 一个标识位，当它 &#x3D;&#x3D; 0 表示还没执行过函数，此时会加锁修改标志位，然后执行对应的函数。后续再执行时发现标识位 !&#x3D; 0，则不会再执行后续动作了。</p><blockquote><p><code>sync.Once</code> 主要用于以下场景：</p><ul><li>单例模式：确保全局只有一个实例对象，避免重复创建资源。</li><li>延迟初始化：在程序运行过程中需要用到某个资源时，通过 <code>sync.Once</code> 动态地初始化该资源。</li><li>只执行一次的操作：例如只需要执行一次的配置加载、数据清理等操作。</li></ul></blockquote><h1 id="并发相关："><a href="#并发相关：" class="headerlink" title="并发相关："></a>并发相关：</h1><h4 id="1、怎么控制并发数？"><a href="#1、怎么控制并发数？" class="headerlink" title="1、怎么控制并发数？"></a>1、怎么控制并发数？</h4><p>​<strong>分析：</strong></p><p>​这个问题其实是一个略带开放设计的问题，极有可能和高并发的接口设计配合使用，比如有个这样的场景:现在有一个请求接口，gps 达到 3w，接口用 go 语言来实现，不考虑消息队列等中间件的情况下，你会怎么设计?<br>其实核心就是考虑怎么控制并发的 goroutine 的数量，一个请求用 go func() 开一个协程显然不合理，会造成<br>goroutine 太多，反而会影响程序的性能。但是串行又不合理，那要怎么用一定数量的 goroutine 来实现并发呢?<br>可以结合 java 或者 c++ 语言中的池化技术，用协程池来外理。再结合之前的消息队列作用，用管道来缓冲请求</p><p><strong>回答：</strong></p><ul><li>有缓冲的 channel：利用缓冲满时发送阻塞的特性，处理端开一定数量的处理协程来消费</li><li>实现一个协程池，控制处理请求的 worker 的数量</li></ul><h4 id="2、多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？"><a href="#2、多个-goroutine-对同一个-map-写会-panic，异常是否可以用-defer-捕获？" class="headerlink" title="2、多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？"></a>2、多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？</h4><p><strong>分析：</strong></p><p>​考察对 go 语言中集中 error 的了解程度</p><p>​Go 语言的错误分为三种 error、panic 和 fatal error：</p><ul><li>Error 就是我们常说的错误，一般通过函数返回值传递，需要使用 <code>if err != nil</code> 处理</li><li>Panic 大家有时也会叫异常，通常对标其他语言的 exception。数组越界、空指针引用等都会触发 panic，业务代码也可以主动触发 panic。这一类错误可以使用 recover 捕获</li><li>Fatal error 是由系统触发的严重错误，这类错误一般都是跟系统资源相关的。典型的 Fatal error 就是无法从系统申请内存。之所以说严重，是因为程序没法从这类错误中恢复正常。Fatal error 无法被 recover 捕获</li></ul><p><strong>回答：</strong></p><p>​map 会检测是否存在并发写，如果检测到并发写会触发 Fatal error，Fatal error 是属于系统触发的严重错误，无法被 <code>recover()</code> 捕获</p><h4 id="3、如何优雅的实现一个-goroutine-池（百度-手写代码）"><a href="#3、如何优雅的实现一个-goroutine-池（百度-手写代码）" class="headerlink" title="3、如何优雅的实现一个 goroutine 池（百度 手写代码）"></a>3、如何优雅的实现一个 goroutine 池（百度 手写代码）</h4><p><strong>分析：</strong></p><p>​明确协程池的作用，应该有哪些角色、怎么添加任务、以及获取 worker 的大小怎么限制。</p><p><strong>回答：</strong></p><p><strong>协程池模型</strong></p><p>​协程池简单理解就是有一个池子一样的东西，里面装这个固定数量的 goroutine ，当有一个任务到来的时候，会将这人任务交给池子里的一人空闲的 goroutine 去外理，如果池子里没有空闲的 goroutine 了，任务就会阻塞等待。所以协程池有三个角色 Worker，Task，Pool。</p><p><strong>属性定义</strong></p><p>​Worker：用于执行任务的 goroutine</p><p>​Task：具体的任务</p><p>​Pool：池子</p><p>​下面看一下各个角色的定义</p><p><strong>Task</strong>：有一个成员函数，表示这个 task 具体的实现逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>f  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span><span class="hljs-comment">// 具体的执行逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Pool</strong>：有4个成员</p><ul><li><p>RunningWorkers</p></li><li><p>Capacity：表示池子里的 worker 的数量，即工作的 goroutine 的数量，</p></li><li><p>JobCh： 表示任务队列用于存放任务，goroutine 从这个 JobCh 获取任务，执行的逻辑</p></li><li><p>sync.Mutex</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>RunningWorkers <span class="hljs-type">int64</span><br>    Capacity       <span class="hljs-type">int64</span><br>    JobCh   <span class="hljs-keyword">chan</span> *Task<br>    sync.Mutex<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>worker</strong>：执行任务单元，简单理解就是干活的 goroutine，这个 worker 只做一件事，就是不断从任务列表里取出来任务执行，而 worker 的数量就是协程池里协程的数量，由 Pool 的参数 WorkerNum 指定</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> task := <span class="hljs-keyword">range</span> p.JobCh &#123;<br>do ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法定义</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTask</span><span class="hljs-params">(funcArg <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>) *Task<br></code></pre></td></tr></table></figure><p>NewTask 用于创建一个任务，参数是一个函数，返回值是一个 Task 类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPool</span><span class="hljs-params">(Capacity <span class="hljs-type">int</span>, taskNum <span class="hljs-type">int</span>)</span></span> *Pool<br></code></pre></td></tr></table></figure><p>NewPool 返回一个写成数量固定为 taskNum 协程池对象指针，其任务列表的长度为 taskNum</p><p>接下来主要介绍协程池的各个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> AddTask(task *Task)<br></code></pre></td></tr></table></figure><p>AddTask 方法是往协程池添加任务，如果当前运行着的 worker 数量小于协程池 worker 容量，则立即启动一个协程 worker 来处理任务，否则将任务添加到任务队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Run()<br></code></pre></td></tr></table></figure><p>Run 方法将协程池跑起来，启动一个 worker 来处理任务</p><p><strong>完整代码</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// Task 具体的任务</span><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// NewTask Task 的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTask</span><span class="hljs-params">(funcArg <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>) *Task &#123;<br><span class="hljs-keyword">return</span> &amp;Task&#123;<br>f: funcArg,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Pool 协程池</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br>RunningWorkers <span class="hljs-type">int64</span>      <span class="hljs-comment">// 正在运行的 worker 数量</span><br>Capacity       <span class="hljs-type">int64</span>      <span class="hljs-comment">// goroutine 数量</span><br>JobCh          <span class="hljs-keyword">chan</span> *Task <span class="hljs-comment">// 用于 worker 取任务</span><br>sync.Mutex                <span class="hljs-comment">// 互斥锁</span><br>&#125;<br><br><span class="hljs-comment">// NewPool 创建一个池子，指定容量 和 任务缓存列表大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPool</span><span class="hljs-params">(capacity <span class="hljs-type">int64</span>, taskNum <span class="hljs-type">int</span>)</span></span> *Pool &#123;<br><span class="hljs-keyword">return</span> &amp;Pool&#123;<br>Capacity: capacity,<br>JobCh:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, taskNum),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// GetCap 获取缓存池容量大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> GetCap() <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">return</span> p.Capacity<br>&#125;<br><br><span class="hljs-comment">// 增加运行的 worker 数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> incRunning() &#123;<br>atomic.AddInt64(&amp;p.RunningWorkers, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 减少运行的 worker 数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> decRunning() &#123;<br>atomic.AddInt64(&amp;p.RunningWorkers, <span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-comment">// GetRunningWorkers 获取正在工作的 worker 数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> GetRunningWorkers() <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">return</span> atomic.LoadInt64(&amp;p.RunningWorkers)<br>&#125;<br><br><span class="hljs-comment">// 协程池开始工作：分配 worker 给 缓冲列表中的 goroutine</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> run() &#123;<br>p.incRunning()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>p.decRunning()<br>&#125;()<br><span class="hljs-keyword">for</span> task := <span class="hljs-keyword">range</span> p.JobCh &#123; <span class="hljs-comment">// 从任务列表获取任务</span><br>task.f()<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-comment">// AddTask 往协程池添加任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> AddTask(task *Task) &#123;<br><span class="hljs-comment">// 加锁防止启动多个 worker</span><br>p.Lock()<br><span class="hljs-keyword">defer</span> p.Unlock()<br><br><span class="hljs-comment">// 如果任务池满，则不再创建 worker</span><br><span class="hljs-keyword">if</span> p.GetRunningWorkers() &lt; p.GetCap() &#123;<br>p.run()<br>&#125;<br><span class="hljs-comment">// 将任务推入队列，等待消费，队列满时，会阻塞等待 worker 消费任务</span><br>p.JobCh &lt;- task<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建任务池</span><br>pool := NewPool(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br><span class="hljs-comment">// 任务放入池中</span><br>pool.AddTask(NewTask(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;I am Task&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;))<br>&#125;<br>time.Sleep(time.Second * <span class="hljs-number">5</span>) <span class="hljs-comment">// 等待执行</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、select-可以用于什么？"><a href="#4、select-可以用于什么？" class="headerlink" title="4、select 可以用于什么？"></a>4、select 可以用于什么？</h4><p><strong>分析：</strong> </p><p>​首先明确具体用法，然后根据这个用法去思考解决了什么问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- ch1:<br><span class="hljs-comment">// 如果从 ch1 信道成功接收数据，则执行该分支代码</span><br><span class="hljs-keyword">case</span> ch2 &lt;- <span class="hljs-number">1</span>:<br><span class="hljs-comment">// 如果成功向 ch2 信道发送数据，则执行该分支代码</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 如果上面都没有成功，则进入 default 分支处理流程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​select 主要用于配合 channel 来使用，当前可以从多个 channel 中获取数据或者向多个 channel 发送数据，类似于 io 多路复用</p><p>​当 channel 数据没有准备好的时候，若有 default 的话，就会走 default 语句，不会阻塞在这里，这种方法就实现了非阻塞的 channel 数据读写</p><p><strong>回答：</strong></p><ol><li>select 可以让同一个 goroutine 监听多个 channel 的读写操作，实现单个 goroutine 的多路复用</li><li>配合 default 实现 goroutine 的非阻塞读写，当 channel 的数据没有准备好或者不能写入的时候，执行 default，并不会阻塞</li></ol><h4 id="5、主协程如何等待其余协程完再操作"><a href="#5、主协程如何等待其余协程完再操作" class="headerlink" title="5、主协程如何等待其余协程完再操作"></a>5、主协程如何等待其余协程完再操作</h4><p><strong>分析：</strong></p><p>​sync.WaitGroup 和 channel 来实现协程等待</p><p><strong>回答：</strong></p><p>​可以使用 sync.WaitGroup 和 channel 实现</p><ul><li><p>sync.WaitGroup 实现写等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> w sync.WaitGroup<br>w.Add(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(num)<br>w.Done()<br>&#125;(i)<br>&#125;<br>w.Wait()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>channel 实现写等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(num)<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;(i)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>&lt;-ch<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="GC-相关"><a href="#GC-相关" class="headerlink" title="GC 相关"></a>GC 相关</h1><h4 id="1、go-gc-是怎么实现的？"><a href="#1、go-gc-是怎么实现的？" class="headerlink" title="1、go gc 是怎么实现的？"></a>1、go gc 是怎么实现的？</h4><p><strong>分析：</strong></p><p>​Go 语言的 gc 经历了多个版本的迭代和逐步优化，在回答的时候突出三色标记法配合混合写屏障技术就可以了，但是对于问题的追问，其中设计到的细节要做到心中有数</p><p><strong>回答：</strong></p><p>​go 语言的 gc 策略是采用三色标记法。但是单纯的三色标记法会带来 **STW(stop the world)**，导致执行效率不高，所以在 1.8 版本之后，采用了三色标记法配合混合写屏障技术来实现 gc。</p><p><strong>问题追问</strong></p><p><strong>Go gc 经历了哪几个版本？</strong></p><p>1.3 版本之前：普通标记清除法，整个 gc 过程需要启动 STW，效率极低</p><p>1.5 版本：三色标记法，堆空间启动写屏障（白色强制变成灰色），全部扫描之后，需要重写扫描一次栈（需要 STW，因为栈要求响应速度快，所以不引入写屏障），效率普通</p><p>1.8 版本：三色标记法，混合写屏障机制：栈空间不启动（根节点可到达对象和新加入的对象全部标记为黑色）</p><p>堆空间启动写屏障，整个过程不要 SWT，效率高。</p><p><strong>三色标记法过程是怎样的？有什么问题？</strong></p><p>第一步：应用程序开始运行时，所有对象默认标记为白色</p><p>第二步：从根节点遍历，把根节点遍历到的对象标记为灰色，放到灰色标记列表中</p><p>第三步：遍历灰度集合，将灰色对象标记为黑色，并由灰色标记移动到黑色标记中</p><p>将黑色引用对象引用的白色标记为灰色，放到灰色标记中</p><p>第四步：重复第三步，直到灰色标记为空</p><p>​三色标记的整个过程都是跟业务逻辑并行的，这样就会带来一定的问题，可能会修改已标记为黑色对象的引用关系，比如会让黑色对象指向一个白色对象，所以标记过程中还是需要 STW，会影响程序的性能。</p><p><strong>针对三色标记的 STW，是怎么解决的？</strong></p><p>​引入了屏障技术来解决 STW 的问题，屏障技术分为插入写屏障和删除写屏障，在 go1.8 之后是采用二者的一个综合，用混合写屏障来处理</p><p><strong>什么是插入写屏障？用插入写屏障解决 STW 会有什么问题</strong></p><p>​插入屏障主要是针对插入新对象或者说是添加对象之间的引用关系，被插入的对象或者是被引用指向的对象标记为灰色，但是插入写屏障只能在堆上操作，不能在栈上操作，这是因为 go 在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万的 goroutine 的栈都进行屏障保护会有严重的性能问题</p><p><strong>删除写屏障是怎么工作的？</strong></p><p>​删除写屏障主要是断开引用关系，被断开连接的下一个对象直接标记为灰色。（这种方式回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮的 GC 中被清理。）</p><p><strong>混合写屏障是怎么工作的？</strong></p><p>​在 GC 刚开始的时候，会将栈上的可达对象全部标记为黑色，gc 过程中任务在栈上新创建的对象，均标记为黑色。这样就可以保证三色标记流程结束后，不需要再堆栈上重新进行一次 rescan。在堆上操作时：堆上被删除的对象标记为黑色，堆上新添加的对象标记为灰色。</p><h4 id="2、-GC-中-STW-时机，各个阶段是如何解决的？"><a href="#2、-GC-中-STW-时机，各个阶段是如何解决的？" class="headerlink" title="2、 GC 中 STW 时机，各个阶段是如何解决的？"></a>2、 GC 中 STW 时机，各个阶段是如何解决的？</h4><p><strong>分析：</strong></p><p>​go 语言的整个 gc 流程大致可以分为下面 5 个步骤</p><table><thead><tr><th>阶段</th><th>描述</th><th>赋值器状态</th></tr></thead><tbody><tr><td>SweepTermination</td><td>清楚终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障</td><td>STW</td></tr><tr><td>Mark</td><td>扫描标记阶段，与赋值器并发执行，写屏障开启状态</td><td>并发</td></tr><tr><td>MarkTermination</td><td>标记终止阶段，保证一个周期内标记任务完成，停止写屏障</td><td>STW</td></tr><tr><td>GCoff</td><td>内存清除阶段，将需要回收的内存归还到堆中，写屏障关闭状态</td><td>并发</td></tr><tr><td>GCoff</td><td>内存归还阶段，将过多的内存归还给操作系统，写屏障关闭状态</td><td>并发</td></tr></tbody></table><p><strong>回答：</strong></p><p>​虽然有了混合写屏障技术，go 语言的整个 gc 过程中还是有两次 STW，因为写屏障需要开启和关闭，在整个标记程序开始之前需要 STW，用于开启写屏障，为标记做准备，在标记终止阶段同样需要短暂的 STW 来暂停写屏障。</p><h4 id="3、GC-的触发时机？"><a href="#3、GC-的触发时机？" class="headerlink" title="3、GC 的触发时机？"></a>3、GC 的触发时机？</h4><p><strong>分析：</strong></p><p>​go 的触发分为手动和被动两种</p><ol><li>主动触发，通过调用 runtime.GC() 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕</li><li>被动触发，分为两种方式<ul><li>go 后台有一系统监控线程，当超过两分钟没有产生任何 GC 时，强制触发 GC</li><li>内存使用增长一定比例时有可能会触发，每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认为 100%，即当内存扩大一倍时启用 GC<ul><li>我们可以通过 debug.SetGCPerceng(500) 来修改步调，这里表示当前堆大小超过了上次标记的堆大小的 500%，就会触发</li><li>而第一次 GC 的触发临界值是 4 MB</li></ul></li></ul></li></ol><p><strong>回答：</strong></p><ul><li>gc 可以在代码中通过调用 runtime.GC 手动触发</li><li>也可以由系统被动触发，当超过两分钟没有 gc 或者是内存分配达到了一定的阈值的时候就会强制触发 gc</li></ul><h4 id="4、GC-扫描的根节点由哪些？"><a href="#4、GC-扫描的根节点由哪些？" class="headerlink" title="4、GC 扫描的根节点由哪些？"></a>4、GC 扫描的根节点由哪些？</h4><p><strong>分析：</strong></p><p>​gc 的标记是从根节点开始的，扫描的对象是在堆上的，所以要明确堆上的对象是怎么建立关联的。</p><p>​举个例子，我们在程序中一般创建对象，假设创建在堆上，然后我们在函数内去操作这个对象，这里我们是通过在函数中的局部变量去操作这个堆上的对象的。所以这种情况下，堆上对象一定是和局部变量相关联的，局部变量是保存在栈上的，所以要找到堆中可达对象，栈上的对象可以作为根节点全部扫描一遍。</p><p>​还有一种情况，对象不是在函数内部创建的，是以全局变量创建的，这种情况下，全局对象是不是也可以作为根节点呢？</p><p>​所以在回答的时候要思考和联想堆中的对象是怎么关联的，来明确根节点有哪些</p><p><strong>回答：</strong></p><p>​根节点包括：</p><ul><li>全局变量：程序在编译期间就能确定那些存在于程序整个生命周期的变量</li><li>执行在栈上的对象或指针：每个 goroutine 都包含自己的执行栈，这些执行栈上的对象包含栈上的变量及指向分配的堆内存区块的指针</li><li>寄存器中的变量：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块</li></ul><h1 id="内存相关："><a href="#内存相关：" class="headerlink" title="内存相关："></a>内存相关：</h1><h4 id="1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？"><a href="#1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？" class="headerlink" title="1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？"></a>1、谈谈内存泄漏，什么情况下内存会发生泄漏？怎么定位排查内存泄漏问题？</h4><p><strong>分析：</strong></p><p>​内存泄漏：就是程序中存在内存不能及时被有效释放，导致这部分内存不可用，随着越来越多的积累，可能出现内存泄漏，会出现内存用满，程序崩溃的情况。</p><p>​思考 go 语言中编码哪些情况会出现这种情况？</p><p>​最常见的就是 goroutine 的阻塞不能快速释放，导致这部分内存一直占用着，随着 goroutine 越来越多，就内存泄漏了</p><p><strong>回答：</strong></p><h5 id="1-1、什么是内存泄漏？"><a href="#1-1、什么是内存泄漏？" class="headerlink" title="1.1、什么是内存泄漏？"></a><strong>1.1</strong>、什么是内存泄漏？</h5><p>​内存泄漏就是程序生命周期中一些对象不能被及时回收，一直占用内存，导致这部分内存不可用的情况</p><h5 id="1-2-go-语言内存泄漏原因"><a href="#1-2-go-语言内存泄漏原因" class="headerlink" title="1.2  go 语言内存泄漏原因"></a>1.2  <strong>go 语言内存泄漏原因</strong></h5><p><strong>分析</strong></p><p>​go 语言中内存泄漏的场景有很多，像 time.NewTicker 资源未及时释放， select 阻塞等等，其实大部分情况都是由于阻塞或者程序空转，导致程序不能结束，一直占用内存。</p><p><strong>回答：</strong></p><p>​go 语言的内存泄漏一般是由于程序阻塞或者空转导致程序不能及时结束导致的，常见的情况就是 goroutine 阻塞或者空转，比如 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一直处于阻塞状态，不能被 GC，还有一种就是一些资源句柄未释放，比如文件打开未关闭等等。然后就是 goroutine 内部的业务逻辑不合理，比如：</p><ul><li>Goroutine 内进行 channel&#x2F;mutex 等读操作一直被阻塞</li><li>Goroutine内的业务逻辑进入死循环，资源一直无法释放</li><li>Goroutine内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待</li></ul><h5 id="1-3-常见的-goroutine-泄漏场景"><a href="#1-3-常见的-goroutine-泄漏场景" class="headerlink" title="1.3 常见的 goroutine 泄漏场景"></a>1.3 常见的 goroutine 泄漏场景</h5><p><strong>回答：</strong></p><ul><li><p>channel 如果忘记初始化，无论是读还是写操作，都会阻塞</p></li><li><p>channel 发送数量超过 channel 接收数量，就会造成阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    ch3 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> Getdata(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>,ch1)<br>    <span class="hljs-keyword">go</span> Getdata(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>,ch2)<br>    <span class="hljs-keyword">go</span> Getdata(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>,ch3)<br>    <span class="hljs-keyword">select</span>&#123;<br>        <span class="hljs-keyword">case</span> v:=&lt;- ch1:<br>            fmt.Println(v)<br>        <span class="hljs-keyword">case</span> v:=&lt;- ch2:<br>            fmt.Println(v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>channel 接收数量超过 channel 发送数量，也会造成阻塞</p></li><li><p>http request body 未关闭，goroutine 不会退出</p></li><li><p>互斥锁忘记解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//协程拿到锁未释放，其他协程获取锁会阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutexTest</span><span class="hljs-params">()</span></span> &#123;<br>    mutex := sync.Mutex&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            mutex.Lock()<br>            fmt.Printf(<span class="hljs-string">&quot;%d goroutine get mutex&quot;</span>, i)<br>      <span class="hljs-comment">//模拟实际开发中的操作耗时</span><br>            time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>        &#125;()<br>    &#125;<br>    time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>sync.WaitGroup 使用不当</p></li><li><p>time.NewTicker 是每个指定时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">timer := time.NewTicker(time.Duration(<span class="hljs-number">2</span>) * time.Second)<br><span class="hljs-comment">// defer timer.Stop()</span><br><span class="hljs-keyword">for</span> <span class="hljs-literal">true</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-timer.C:<br><span class="hljs-comment">// do something</span><br><span class="hljs-keyword">default</span>:<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>) * time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="1-4-如何排查"><a href="#1-4-如何排查" class="headerlink" title="1.4 如何排查"></a>1.4 如何排查</h5><p><strong>分析：</strong></p><p>​go 语言的性能分析，比如 CPU，内存一般使用 pprof 工具进行分析</p><p><strong>回答：</strong></p><p>​单个函数：调用 runtime.NumGoroutine 方法打印 执行代码前后的 Goroutine 的运行数量，进行前后对比，就能知道有没有泄漏了。</p><p>​生产&#x2F;测试环境：使用 PProf 实时监测 Goroutine 的数量</p><h4 id="2、知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？"><a href="#2、知道-golang-的内存逃逸吗？什么情况下会发生内存逃逸？" class="headerlink" title="2、知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？"></a>2、知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？</h4><h5 id="2-1-什么是内存逃逸？"><a href="#2-1-什么是内存逃逸？" class="headerlink" title="2.1 什么是内存逃逸？"></a>2.1 什么是内存逃逸？</h5><p><strong>分析：</strong></p><p>​go 语言的内存逃逸分析是在编译期决定对象分配方式的一种策略，决定对象时分配在堆上还是分配在栈上。就是优先本来可以分配到栈上的对象被分配到堆上了，这个时候就发生了逃逸。</p><p>​具体的逃逸分析有：</p><ol><li>如果函数外部没有引用，则优先放到栈中</li><li>如果函数外部存在引用，则必定放到堆中</li><li>如果栈上放不下，则必定放到堆上</li></ol><p>​前两种主要考虑对象的生命周期，当这个对象的生命周期不能被确定，不能跟随当前函数结束而结束，就会发送逃逸，被分配到堆上。</p><p><strong>回答：</strong></p><p>​内存逃逸是编译器在程序编译时期根据逃逸分析策略，将原本应该分配到栈上的对象分配到堆上的一个过程。</p><h5 id="2-2-什么情况下会发生内存逃逸"><a href="#2-2-什么情况下会发生内存逃逸" class="headerlink" title="2.2 什么情况下会发生内存逃逸"></a>2.2 什么情况下会发生内存逃逸</h5><p>​以下场景会发生内存逃逸：</p><ul><li>方法内返回局部变量指针</li><li>向 channel 发送指针数据</li><li>在闭包中引用包外的值</li><li>在 slice 或 map 中存储指针</li><li>切片（扩容后）长度太大</li><li>在 interface 类型上调用方法</li></ul><h5 id="2-3-内存逃逸有什么影响"><a href="#2-3-内存逃逸有什么影响" class="headerlink" title="2.3 内存逃逸有什么影响"></a>2.3 内存逃逸有什么影响</h5><p><strong>分析：</strong></p><p>​从栈对象和堆对象的区别来说，堆对象需要垃圾回收机制来释放内存，栈对象会跟随函数结束被编译器回收</p><p><strong>回答：</strong></p><p>​大量的内存逃逸会给 gc 带来压力。</p><h4 id="3、简述-Go-是如何分配内存的？"><a href="#3、简述-Go-是如何分配内存的？" class="headerlink" title="3、简述 Go 是如何分配内存的？"></a>3、简述 Go 是如何分配内存的？</h4><p><strong>分析：</strong></p><p>​Go 的内存分配借鉴了 Google 的 TCMalloc 分配算法，其核心思想是内存池 + 多级对象管理。内存池主要预先分配内存，减少向系统申请的频率；多级对象有：mheap、mspan（跨度）、mcentral、mcache、arenas（内存分配器）。它们以 mspan 作为基本分配单位</p><p><img src="C:\Users\ft\AppData\Roaming\Typora\typora-user-images\image-20230808193919445.png" alt="image-20230808193919445"></p><p><strong>回答：</strong></p><p>​go 语言对象的分配根据对象大小的不同申请策略也不同：</p><ul><li>当要分配大于 32K 的对象时，从 mheap（堆） 分配。</li><li>当要分配的对象小于等于 32k 大于 16B 时，从 P 上的 mcache（线程缓存） 分配，如果 mcache 没有内存，则从 mcentral（中心缓冲） 获取，如果 mcentral 也没有，则向 mheap 申请，如果 mheap 也没有，则向操作系统申请</li><li>当要分配的对象小于等于 16B（微小对象），从 mcache 的微型分配器上分配。</li></ul><h4 id="4、Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"><a href="#4、Channel-分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？" class="headerlink" title="4、Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？"></a>4、Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</h4><h5 id="4-1-channel-分配在栈上还是堆上？"><a href="#4-1-channel-分配在栈上还是堆上？" class="headerlink" title="4.1 channel 分配在栈上还是堆上？"></a>4.1 channel 分配在栈上还是堆上？</h5><p><strong>分析：</strong></p><p>​这个题可以看作是对上一个颗理解程度的考察，可以用内存逃逸的思想来分析这个题，因为 channel 的作用就是用做两个 goroutine 之间的通信，所以在很大程度上它的生命周期并不会局限在一个函数内部，所以大概率会发生内存逃逸，就很容易得出结论，channel 大概率会分配到堆上</p><p><strong>回答：</strong></p><p>​channel 分配在堆上，channel 被设计用来实现协程间通信的组件，其作用和生命周期不可能仅局限于某个函数内部，所以 golang 直接将其分配在堆上。</p><h5 id="4-2-哪些对象分配在堆上，哪些对象分配在栈上？"><a href="#4-2-哪些对象分配在堆上，哪些对象分配在栈上？" class="headerlink" title="4.2 哪些对象分配在堆上，哪些对象分配在栈上？"></a>4.2 哪些对象分配在堆上，哪些对象分配在栈上？</h5><p><strong>分析：</strong></p><p>​对象是分配在栈上还是对上跟 go 语言的语法没有关系，需要在编译期由编译器进行逃逸分析而决定。根据逃逸分析策略来思考</p><p><strong>回答：</strong></p><p>​一般来说，大的对象直接分配在堆上，如果一个局部变量会被外部引用，生命周期不稳定，也会分配到堆上，其他小的对象优先分配在栈上。</p><h4 id="5、介绍一下大对象、小对象，什么情况下会导致-GC-压力大？"><a href="#5、介绍一下大对象、小对象，什么情况下会导致-GC-压力大？" class="headerlink" title="5、介绍一下大对象、小对象，什么情况下会导致 GC 压力大？"></a>5、介绍一下大对象、小对象，什么情况下会导致 GC 压力大？</h4><p><strong>分析：</strong></p><p>​首先压力大指的是我们 GC 的时候，需要占用比较高的 CPU  时间和内存带宽资源，这就会影响我们用户 goroutine的执行。<br>​而当大量小对象 逃逸到堆上，就意味着这些小对象是需要被 GC 回收的(可能是在某一次 GC)，因为栈上的对象<br>可以 随着栈帧的释放而回收，而堆上的对象只能由 GC 来进行内存管理</p><p>​同样巨大的 map 和 slice 也就意味着 GC 需要处理更多的数据</p><p><strong>回答：</strong></p><ul><li>go 语言中小于等于 32K 的对象就是小对象，其中小于 16K 的是微小对象（而且是不含指针的对象），其它都是大对象</li><li>当有大量小对象逃逸到堆上，或者有巨大的 map 和 slice 的情况下（原本在栈上的话，会随着栈帧的释放而回收，逃逸到堆上，只能由 GC 处理）， GC 压力会较大</li></ul><h1 id="Go-代码性能优化"><a href="#Go-代码性能优化" class="headerlink" title="Go 代码性能优化"></a>Go 代码性能优化</h1><h4 id="1、你知道-Go-的哪些性能优化手段？"><a href="#1、你知道-Go-的哪些性能优化手段？" class="headerlink" title="1、你知道 Go 的哪些性能优化手段？"></a>1、你知道 Go 的哪些性能优化手段？</h4><p><strong>分析：</strong></p><p>​Go 代码性能优化就两个：内存分配优化 和 并发优化，其余不值一提</p><p>​一般建议是，用过对象池，知道内存逃逸大概怎么定位，就可以在里面写 Go 程序性能优化了，并发优化都是看场景的，不强求。</p><p><strong>回答：</strong></p><ul><li><p>Go 内存分配优化：核心就是内存逃逸和对象池</p><ul><li><p>内存逃逸优化：属于那种听上去逼格很高，但是实际上效果非常有限的，将 SQL 优化一下，几十几百毫秒省出来了，但是 Go 内存分配优化来优化，可能也就优化了 1 毫秒</p><p>一般是使用 <code>go build -gcflags &#39;-m&#39;</code> 命令来看哪里发生了逃逸，然后尝试优化掉</p></li><li><p>对象池：可以使用 Go 官方提供的 sync.Pool，一般来说，如果你有什么接口是要处理比较大批数据的，就是可以考虑这种方案</p></li></ul></li><li><p>并发优化：主要思路就是 有锁改无锁；写锁改读写锁；原子操作（CAS 也可以看作是乐观锁）；全局锁</p><ul><li>并发优化这个在业务开发里面比较少用</li></ul></li></ul><h1 id="代码题相关"><a href="#代码题相关" class="headerlink" title="代码题相关"></a>代码题相关</h1><h4 id="1、使用三个协程，每秒钟打印-cat-dog-fish-（要求顺序不能变换，协程-1-打印-cat，协程-2-打印-dog，-协程-3-打印-fish）"><a href="#1、使用三个协程，每秒钟打印-cat-dog-fish-（要求顺序不能变换，协程-1-打印-cat，协程-2-打印-dog，-协程-3-打印-fish）" class="headerlink" title="1、使用三个协程，每秒钟打印 cat dog fish （要求顺序不能变换，协程 1 打印 cat，协程 2 打印 dog， 协程 3 打印 fish）"></a>1、使用三个协程，每秒钟打印 cat dog fish （要求顺序不能变换，协程 1 打印 cat，协程 2 打印 dog， 协程 3 打印 fish）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(<span class="hljs-number">3</span>)<br>chcat := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>chdog := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>chfish := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> printCat(&amp;wg, chcat, chfish)<br><span class="hljs-keyword">go</span> printDog(&amp;wg, chdog, chcat)<br><span class="hljs-keyword">go</span> printFish(&amp;wg, chfish, chdog)<br>wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printCat</span><span class="hljs-params">(wg *sync.WaitGroup, cat <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, fish <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> &#123;<br>cat &lt;- <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;cat&quot;</span>)<br>time.Sleep(time.Second)<br>&lt;-fish<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printDog</span><span class="hljs-params">(wg *sync.WaitGroup, dog <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, cat <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> &#123;<br>&lt;-cat<br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;dog&quot;</span>)<br>dog &lt;- <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printFish</span><span class="hljs-params">(wg *sync.WaitGroup, fish <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, dog <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> &#123;<br>&lt;-dog<br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;fish&quot;</span>)<br>time.Sleep(time.Second)<br>fish &lt;- <span class="hljs-number">1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、实现两个协程轮流输出-A-1-B-2-C-3-…-Z-26"><a href="#2、实现两个协程轮流输出-A-1-B-2-C-3-…-Z-26" class="headerlink" title="2、实现两个协程轮流输出 A 1 B 2 C 3 … Z 26"></a>2、实现两个协程轮流输出 A 1 B 2 C 3 … Z 26</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> w sync.WaitGroup<br>w.Add(<span class="hljs-number">52</span>)<br>strChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>numChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><br>strChan &lt;- <span class="hljs-number">0</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; i++ &#123;<br>&lt;-strChan<br>fmt.Printf(<span class="hljs-string">&quot;%v \n&quot;</span>, <span class="hljs-type">string</span>(i))<br>w.Done()<br>numChan &lt;- <span class="hljs-number">1</span><br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; i++ &#123;<br>&lt;-numChan<br>fmt.Printf(<span class="hljs-string">&quot;%v \n&quot;</span>, i)<br>w.Done()<br>strChan &lt;- <span class="hljs-number">0</span><br>&#125;<br>&#125;()<br>w.Wait()<br>fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、N-个-goroutine-循环打印数字-min-max"><a href="#3、N-个-goroutine-循环打印数字-min-max" class="headerlink" title="3、N 个 goroutine 循环打印数字 min - max"></a>3、N 个 goroutine 循环打印数字 min - max</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg = sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> min = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> max = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(n)<br><span class="hljs-keyword">var</span> chanArray = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>chanArray[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(chanArray[(i+<span class="hljs-number">1</span>)%n])<br><span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> chanArray[i] &#123;<br><span class="hljs-keyword">if</span> num &gt; max &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;g %d 进行打印 %d \n&quot;</span>, i, num)<br>chanArray[(i+<span class="hljs-number">1</span>)%n] &lt;- num + <span class="hljs-number">1</span><br>&#125;<br>&#125;(i)<br>&#125;<br><br>chanArray[<span class="hljs-number">0</span>] &lt;- min<br>wg.Wait()<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型自动使用其string方法</title>
    <link href="/2023/07/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%85%B6string%E6%96%B9%E6%B3%95/"/>
    <url>/2023/07/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%85%B6string%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Direction <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>North Direction = <span class="hljs-literal">iota</span><br>East<br>South<br>West<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Direction)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;North&quot;</span>, <span class="hljs-string">&quot;East&quot;</span>, <span class="hljs-string">&quot;South&quot;</span>, <span class="hljs-string">&quot;West&quot;</span>&#125;[d]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(South)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：South。知识点：iota 的用法、类型的 <code>String()</code> 方法。</p><p>根据 iota 的用法推断出 South 的值是 2；另外，<strong>如果类型定义了 <code>String()</code> 方法，当使用 <code>fmt.Printf()</code>、<code>fmt.Print()</code> 和 <code>fmt.Println()</code> 会自动使用 String() 方法，实现字符串的打印。</strong></p><p>Reference:</p><ol><li><a href="https://wiki.jikexueyuan.com/project/the-way-to-go/10.7.html">https://wiki.jikexueyuan.com/project/the-way-to-go/10.7.html</a></li><li><a href="https://www.sunansheng.com/archives/24.html">https://www.sunansheng.com/archives/24.html</a></li><li><a href="https://yourbasic.org/golang/iota/">https://yourbasic.org/golang/iota/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iota的用法</title>
    <link href="/2023/07/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2023/07/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b = <span class="hljs-literal">iota</span><br>)<br><span class="hljs-keyword">const</span> (<br>name = <span class="hljs-string">&quot;name&quot;</span><br>c    = <span class="hljs-literal">iota</span><br>d    = <span class="hljs-literal">iota</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(a)<br>fmt.Println(b)<br>fmt.Println(c)<br>fmt.Println(d)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：0 1 1 2。</p><p>知识点：iota 的用法。</p><p>iota 是 golang 语言的常量计数器，只能在常量的表达式中使用。</p><p>iota 在 <strong>const 关键字出现时将被重置为0</strong>，const中每新增一行常量声明将使 iota 计数一次。</p><p>Reference: <a href="https://studygolang.com/articles/2192">https://studygolang.com/articles/2192</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针类型和值类型的方法</title>
    <link href="/2023/07/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/07/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Speak(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Speak(think <span class="hljs-type">string</span>) (talk <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> think == <span class="hljs-string">&quot;speak&quot;</span> &#123;<br>talk = <span class="hljs-string">&quot;speak&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>talk = <span class="hljs-string">&quot;hi&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> peo People = Student&#123;&#125;<br>think := <span class="hljs-string">&quot;speak&quot;</span><br>fmt.Println(peo.Speak(think))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. speak</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>编译错误 <code>Student does not implement People (Speak method has pointer receiver)</code>，值类型 <code>Student</code> 没有实现接口的 <code>Speak()</code> 方法，而是指针类型 <code>*Student</code> 实现改方法。</p><p>详细请参考这篇文章 <a href="https://seekload.net/2019/06/06/go-study-method.html">https://seekload.net/2019/06/06/go-study-method.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础类型创建的方法</title>
    <link href="/2023/07/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/07/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> PrintInt ()  &#123;<br>fmt.Println(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>i.PrintInt()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p><strong>基于类型创建的方法必须定义在同一个包内</strong>，上面的代码基于 int 类型创建了 PrintInt() 方法，由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。解决的办法可以定义一种新的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Myint <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Myint)</span></span> PrintInt ()  &#123;<br>fmt.Println(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i Myint = <span class="hljs-number">1</span><br>i.PrintInt()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>len中的门道</title>
    <link href="/2023/07/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/len%E4%B8%AD%E7%9A%84%E9%97%A8%E9%81%93/"/>
    <url>/2023/07/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/len%E4%B8%AD%E7%9A%84%E9%97%A8%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>在 Go语言爱好者周刊第 104 期有一道题目，以下代码输出什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> x *<span class="hljs-keyword">struct</span> &#123;<br>    s [][<span class="hljs-number">32</span>]<span class="hljs-type">byte</span><br>  &#125;<br>  <br>  <span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(x.s[<span class="hljs-number">99</span>]))<br>&#125;<br></code></pre></td></tr></table></figure><p>A：运行时 panic；B：32；C：编译错误；D：0</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>正确率只有 16%。</p><p>正确答案：B。</p><h2 id="01-解析题目"><a href="#01-解析题目" class="headerlink" title="01 解析题目"></a>01 解析题目</h2><p>先剖析下这段代码，x 变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x *<span class="hljs-keyword">struct</span> &#123;<br>  s [][<span class="hljs-number">32</span>]<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里不是定义一个结构体类型，而是定义一个结构体类型指针变量，即 x 是一个指针，指针类型是一个匿名结构体。很显然，x 的值是 nil，因为没有初始化，可以打印证实这一点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x *<span class="hljs-keyword">struct</span> &#123;<br>s [][<span class="hljs-number">32</span>]<span class="hljs-type">byte</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;x.Type = %T; x.Value= %v\n&quot;</span>, x, x)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">x.Type = *struct &#123; s [][32]uint8 &#125;; x.Value= &lt;nil&gt;<br></code></pre></td></tr></table></figure><p>这也是为什么 48% 的人选择 A （panic） 的原因，毕竟 x 是 nil，panic 很自然的。比如这样就会 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">println</span>(x.s)<br><span class="hljs-comment">// panic: runtime error: invalid memory address or nil pointer dereference</span><br></code></pre></td></tr></table></figure><p>相应的，fmt.Println(x.s[99]) 也会 panic。但为什么 <code>len(x.s[99])</code> 就不 panic 了呢？所以得从 len 入手一探究竟。</p><h2 id="02-len-详解"><a href="#02-len-详解" class="headerlink" title="02 len 详解"></a>02 len 详解</h2><p>len 函数是一个内置类型，什么意思？就是由编译器实现的。它的参数可以接收多种类型，有泛型的味道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">len</span><span class="hljs-params">(v Type)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>关于它的说明，标准库文档有说明：</p><blockquote><p>内建函数 len 返回 v 的长度，这取决于具体类型：</p><ul><li>数组：v 中元素的数量</li><li>数组指针：*v 中元素的数量（v 为 nil 时 panic）</li><li>切片、map：v 中元素的数量；若 v 为nil，len(v) 即为零</li><li>字符串：v 中字节的数量</li><li>通道：通道缓存中队列（未读取）元素的数量；若 v 为 nil，len(v) 即为零</li></ul></blockquote><p>光这个解释，还不够全面，len 函数还有其他一些特殊的点。这要看 Go 语言规范。</p><p>在规范中，有一节是<a href="https://hao.studygolang.com/golang_spec.html#id221">关于 len 和 cap 的</a>。有如下几个要点：</p><ul><li>返回结果总是 int；</li><li>返回结果有可能是常量；</li><li>有时对函数参数不求值，即编译期确定返回值；</li></ul><p>2、3 点解释下。（规范中有说明）</p><p>如果 len 或 cap 的函数参数 v 是字符串常量，则返回值是一个常量。</p><p><strong>如果 v 的类型是数组或指向数组的指针，且表达式 v 没有包含 channel 接收或（非常量）函数调用，则返回值也是一个常量。这种情况下，不会对 v 进行求值（即编译期就能确定）。否则返回值不是常量，且会对 v 进行求值（即得运行时确定）。</strong></p><p><strong>这一点是这道题的关键。</strong></p><p>首先，x.s[99] 的类型是 <code>[32]byte</code>，它是一个数组，且表达式 <code>x.s[99]</code> 没有包含 channel 接收也不是函数调用，因此不会对 x.s[99] 进行求值，不求值自然不会 panic（想不明白？可以想成没有解引用操作）。也就是说，编译器能够在编译阶段分析出 x.s[99] 的类型是 [32]byte，且不需要对 x.s[99] 求值，因此直接返回数组的长度，即 32。</p><h2 id="03-其他类似情况"><a href="#03-其他类似情况" class="headerlink" title="03 其他类似情况"></a>03 其他类似情况</h2><p>类似这样不求值的情况还有没有？还真有。比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> testdata *<span class="hljs-keyword">struct</span> &#123;<br>  a *[<span class="hljs-number">7</span>]<span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> testdata.a &#123;<br>  fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样不会 panic，原理和上面的类似，<a href="https://hao.studygolang.com/golang_spec.html#id355">在 Go 语言规范有说明</a>。</p><p>“range” 子句中右侧的表达式被称为 range 表达式 ，它可以是数组、数组的指针、切片、字符串、map或是允许接收操作 的 channel。range 表达式会在开始此循环前被求值一次，但有一个例外：当存在最多一个迭代变量且 <code>len(x)</code> 是常量时，range 表达式是不被求值的。</p><p>所以上面代码中 testdata.a 不会被求值，因为 len(testdata.a) 是常量。</p><p>但如果改为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> testdata *<span class="hljs-keyword">struct</span> &#123;<br>  a *[<span class="hljs-number">7</span>]<span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-keyword">range</span> testdata.a &#123;<br>  fmt.Println(i, j)<br>&#125;<br></code></pre></td></tr></table></figure><p>就会 panic。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>通过这么一道「诡异」的面试题，希望你能够对 len 有更深的理解，也希望你能够重视 Go 语言规范，多留意一些细节，同时学会如何寻找问题的答案。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-104/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-104/。</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer注册函数</title>
    <link href="/2023/07/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>​</p><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>​下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">defer</span> calc(<span class="hljs-string">&quot;1&quot;</span>, a, calc(<span class="hljs-string">&quot;10&quot;</span>, a, b))<br>a = <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> calc(<span class="hljs-string">&quot;2&quot;</span>, a, calc(<span class="hljs-string">&quot;20&quot;</span>, a, b))<br>b = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(index <span class="hljs-type">string</span>, a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ret := a + b<br>fmt.Println(index, a, b, ret)<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>程序执行到 main() 函数三行代码的时候，会先执行 calc() 函数的 b 参数，即：<code>calc(&quot;10&quot;,a,b)</code>，输出：10 1 2 3，得到值 3，因为<br>defer 定义的函数是延迟函数，故 calc(“1”,1,3) 会被延迟执行；</p><p>程序执行到第五行的时候，同样先执行 calc(“20”,a,b) 输出：20 0 2 2 得到值 2，同样将 calc(“2”,0,2) 延迟执行；</p><p>程序执行到末尾的时候，按照栈先进后出的方式依次执行：calc(“2”,0,2)，calc(“1”,1,3)，则就依次输出：2 0 2 2，1 1 3 4。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map的输出</title>
    <link href="/2023/07/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84%E8%BE%93%E5%87%BA/"/>
    <url>/2023/07/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">0</span>:<span class="hljs-string">&quot;zero&quot;</span>,<span class="hljs-number">1</span>:<span class="hljs-string">&quot;one&quot;</span>&#125;<br><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k,v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0</span> zero<br><span class="hljs-number">1</span> one<br><span class="hljs-comment">// 或者</span><br><span class="hljs-number">1</span> one<br><span class="hljs-number">0</span> zero<br></code></pre></td></tr></table></figure><p>map 的输出是无序的。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量和作用域</title>
    <link href="/2023/07/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/07/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面选项正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> a := <span class="hljs-number">1</span>; <span class="hljs-literal">false</span> &#123;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b := <span class="hljs-number">2</span>; <span class="hljs-literal">false</span> &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1 2</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：A。</p><p>推荐一篇文章，讲的很详细 <a href="https://studygolang.com/articles/35587">https://studygolang.com/articles/35587</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>切片对底层数组的影响</title>
    <link href="/2023/07/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E5%AF%B9%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2023/07/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E5%AF%B9%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := s1[<span class="hljs-number">1</span>:]<br>s2[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span><br>fmt.Println(s1)<br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1 2 4]</span><br><span class="hljs-string">[1 2 4]</span><br></code></pre></td></tr></table></figure><p>我们已经知道，golang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组，这会导致 s2[1] &#x3D; 4 语句影响 s1。</p><p>而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1。</p><p>但是为什么对 s2 赋值后影响的却是 s1 的第三个元素呢？这是因为切片 s2 是从数组的第二个元素开始，s2 索引为 1 的元素对应的是 s1 索引为 2 的元素。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer函数需要先注册</title>
    <link href="/2023/07/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E5%85%88%E6%B3%A8%E5%86%8C/"/>
    <url>/2023/07/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E5%85%88%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br>&#125;()<br><span class="hljs-keyword">if</span> a == <span class="hljs-literal">true</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><p>defer 关键字后面的函数或者方法想要执行必须先注册，return 之后的 defer 是不能注册的， 也就不能执行后面的函数或方法。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string的使用</title>
    <link href="/2023/07/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面的代码有几处语法问题，各是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">string</span> = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br>        x = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：2 处有语法问题。</p><p>golang 的字符串类型是不能赋值 nil 的，也不能跟 nil 比较。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer(4)</title>
    <link href="/2023/07/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-5/"/>
    <url>/2023/07/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-5/</url>
    
    <content type="html"><![CDATA[<p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>person := &amp;Person&#123;<span class="hljs-number">28</span>&#125;<br><br><span class="hljs-comment">// 1.</span><br><span class="hljs-keyword">defer</span> fmt.Println(person.age)<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>fmt.Println(p.age)<br>&#125;(person)<br><br><span class="hljs-comment">// 3.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(person.age)<br>&#125;()<br><br>person = &amp;Person&#123;<span class="hljs-number">29</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>29 28 28。</p><p>这道题之前题目的基础上做了一点点小改动，前一题最后一行代码 <code>person.age = 29</code> 是修改引用对象的成员 age，这题最后一行代码 <code>person = &amp;Person&#123;29&#125;</code> 是修改引用对象本身，来看看有什么区别。</p><p>1.person.age 这一行代码跟之前含义是一样的，此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；</p><p>2.defer 缓存的是结构体 Person{28} 的地址，这个地址指向的结构体没有被改变，最后 defer 语句后面的函数执行的时候取出仍是 28；</p><p>3.闭包引用，person 的值已经被改变，指向结构体 <code>Person&#123;29&#125;</code>，所以输出 29.</p><p>由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 28 28。</p><p>以上解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的defer</title>
    <link href="/2023/07/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%AE%80%E5%8D%95%E7%9A%84defer/"/>
    <url>/2023/07/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%AE%80%E5%8D%95%E7%9A%84defer/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码正确的输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;F&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f()<br>fmt.Println(<span class="hljs-string">&quot;M&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. F M D</li><li>B. D F M</li><li>C. F D M</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>C。</p><p> 被调用函数里的 defer 语句在返回之前就会被执行，所以输出顺序是 F D M。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer(4)</title>
    <link href="/2023/07/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-4/"/>
    <url>/2023/07/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-4/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码段输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>person := &amp;Person&#123;<span class="hljs-number">28</span>&#125;<br><br><span class="hljs-comment">// 1. </span><br><span class="hljs-keyword">defer</span> fmt.Println(person.age)<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>fmt.Println(p.age)<br>&#125;(person)  <br><br><span class="hljs-comment">// 3.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(person.age)<br>&#125;()<br><br>person.age = <span class="hljs-number">29</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：29 29 28。变量 person 是一个指针变量 。</p><p>1.person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；</p><p>2.defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；</p><p>3.很简单，闭包引用，输出 29；</p><p>又由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 29 28。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解闭包</title>
    <link href="/2023/07/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
    <url>/2023/07/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">app</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>t := <span class="hljs-string">&quot;Hi&quot;</span><br>c := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>t = t + <span class="hljs-string">&quot; &quot;</span> + b<br><span class="hljs-keyword">return</span> t<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := app()<br>b := app()<br>a(<span class="hljs-string">&quot;go&quot;</span>)<br>fmt.Println(b(<span class="hljs-string">&quot;All&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>A：Hi All；B：Hi go All；C：Hi；D：go All</p><p>这道题目答对的人蛮多的：60%。不管你是答对还是答错，如果最后再加一行代码：fmt.Println(a(“All”))，它输出什么？想看看你是不是蒙对了。（提示：你可以输出 t 的地址，看看是什么情况。）</p><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Hi All<br>Hi <span class="hljs-keyword">go</span> All<br></code></pre></td></tr></table></figure><pre><code class="hljs"> 闭包通过一个结构体来实现，它存储一个函数和一个关联的上下文环境。</code></pre><p>​因此每一个闭包都有自己的上下文环境，所以a与b两个闭包的内容是互不干涉的。</p><p>​第一次调用<code>a(&quot;go&quot;)</code>时，将 “go”添加到 a 闭包的 t 变量中，此时 a 闭包的 t 变量为 “Hi go”。</p><p>​接着调用 <code>b(&quot;All&quot;)</code>，将 “All” 添加到 b 闭包的 t 变量中，此时 b 闭包的 t 变量为 “Hi All”。</p><p>​最后我们再次调用 <code>a(&quot;All&quot;)</code>，将 “All” 添加到 a 闭包的 t 变量中，此时 a 闭包的 t 变量为 “Hi go All” 。</p><p>​所以最后的答案为 <code>fmt.Println(b(&quot;All&quot;))</code>输出 <code>&quot;Hi All&quot;</code>，<code>fmt.Println(a(&quot;All&quot;))</code>输出<code>Hi go All</code>。</p><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><h2 id="01-什么是闭包"><a href="#01-什么是闭包" class="headerlink" title="01 什么是闭包"></a>01 什么是闭包</h2><p>维基百科对<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">闭包的定义</a>：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如 C++）。</p></blockquote><p>关于（函数）闭包，有几个关键点：</p><ul><li>函数是一等公民；</li><li>闭包所处环境，可以引用环境里的值；</li></ul><p>问到什么是闭包时，网上一般这么回答的：</p><blockquote><p>在支持函数是一等公民的语言中，一个函数的返回值是另一个函数，被返回的函数可以访问父函数内的变量，当这个被返回的函数在外部执行时，就产生了闭包。</p></blockquote><p>所以，上面题目中，函数 app 的返回值是另一个函数，因此产生了闭包。</p><h2 id="02-Go-中的闭包"><a href="#02-Go-中的闭包" class="headerlink" title="02 Go 中的闭包"></a>02 Go 中的闭包</h2><p>Go 中的函数是一等公民，之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/H3iuhkvQWonZbi7AzmokSA">函数是一等公民，这到底在说什么？</a></p><p>日常开发中，闭包是很常见的。举几个例子。</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>在 net&#x2F;http 包中的函数 ProxyURL，实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ProxyURL returns a proxy function (for use in a Transport)</span><br><span class="hljs-comment">// that always returns the same URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ProxyURL</span><span class="hljs-params">(fixedURL *url.URL)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Request)</span></span> (*url.URL, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Request)</span></span> (*url.URL, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> fixedURL, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的返回值是另一个函数，签名是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Request)</span></span> (*url.URL, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>在返回的函数中，引用了父函数（ProxyURL）的参数 fixedURL，因此这是闭包。</p><h3 id="Web-中间件"><a href="#Web-中间件" class="headerlink" title="Web 中间件"></a>Web 中间件</h3><p>在 Web 开发中，中间件一般都会使用闭包。比如 Echo 框架中的一个中间件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// BasicAuthWithConfig returns an BasicAuth middleware with config.</span><br><span class="hljs-comment">// See `BasicAuth()`.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BasicAuthWithConfig</span><span class="hljs-params">(config BasicAuthConfig)</span></span> echo.MiddlewareFunc &#123;<br><span class="hljs-comment">// Defaults</span><br><span class="hljs-keyword">if</span> config.Validator == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;echo: basic-auth middleware requires a validator function&quot;</span>)<br>&#125;<br>  ...<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(next echo.HandlerFunc)</span></span> echo.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c echo.Context)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">/// 省略很多代码</span><br>      ...<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，echo.MiddlewareFunc 是一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MiddlewareFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(HandlerFunc)</span></span> HandlerFunc<br></code></pre></td></tr></table></figure><p>而 echo.HandlerFunc 也是一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(Context)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>所以，上面的函数嵌套了几层，是典型的闭包。</p><h3 id="这是闭包吗？"><a href="#这是闭包吗？" class="headerlink" title="这是闭包吗？"></a>这是闭包吗？</h3><p>在 Go 中不支持函数嵌套定义，函数内嵌套函数，必须通过匿名函数的形式。匿名函数在 Go 中是很常见的，比如开启一个 goroutine，通常通过匿名函数。</p><p>现在有一个问题，以下代码是闭包吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := <span class="hljs-number">5</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;a =&quot;</span>, a)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果按照上面网上一般的回答，这不是闭包，因为并没有返回函数。但按照维基百科的定义，这个属于闭包。有没有其他证据呢？</p><p>在 Go 语言规范中，关于函数字面值（匿名函数）有这么一句话：</p><blockquote><p>Function literals are <em>closures</em>: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.</p></blockquote><p>也就是说，函数字面值（匿名函数）是闭包，它们可以引用外层函数定义的变量。</p><p>此外，在官方 FAQ 中有这样的说明：</p><p><a href="https://docs.studygolang.com/doc/faq#closures_and_goroutines">What happens with closures running as goroutines?</a></p><p>例子是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br>    values := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(v)<br>            done &lt;- <span class="hljs-literal">true</span><br>        &#125;()<br>    &#125;<br><br>    <span class="hljs-comment">// wait for all goroutines to complete before exiting</span><br>    <span class="hljs-keyword">for</span> _ = <span class="hljs-keyword">range</span> values &#123;<br>        &lt;-done<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 Go 中很常见的代码（很容易写错的），FAQ 称开启 goroutine 的那个匿名函数是一个闭包。</p><h2 id="03-汇编看看实现"><a href="#03-汇编看看实现" class="headerlink" title="03 汇编看看实现"></a>03 汇编看看实现</h2><p>回到开始的题目，我们通过汇编看看，Go 闭包的实现，是不是按照维基百科说的，「闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）」。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go tool compile -S main.go<br></code></pre></td></tr></table></figure><p>看关键代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)TEXT<span class="hljs-string">&quot;&quot;</span>.app(SB), ABIInternal, $<span class="hljs-number">24</span><span class="hljs-number">-8</span><br><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)MOVQ(TLS), CX<br><span class="hljs-number">0x0009</span> <span class="hljs-number">00009</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)CMPQSP, <span class="hljs-number">16</span>(CX)<br><span class="hljs-number">0x000d</span> <span class="hljs-number">00013</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)PCDATA$<span class="hljs-number">0</span>, $<span class="hljs-number">-2</span><br><span class="hljs-number">0x000d</span> <span class="hljs-number">00013</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)JLS<span class="hljs-number">96</span><br><span class="hljs-number">0x000f</span> <span class="hljs-number">00015</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)PCDATA$<span class="hljs-number">0</span>, $<span class="hljs-number">-1</span><br><span class="hljs-number">0x000f</span> <span class="hljs-number">00015</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)SUBQ$<span class="hljs-number">24</span>, SP<br><span class="hljs-number">0x0013</span> <span class="hljs-number">00019</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)MOVQBP, <span class="hljs-number">16</span>(SP)<br><span class="hljs-number">0x0018</span> <span class="hljs-number">00024</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)LEAQ<span class="hljs-number">16</span>(SP), BP<br><span class="hljs-number">0x001d</span> <span class="hljs-number">00029</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)FUNCDATA$<span class="hljs-number">0</span>, gclocals·<span class="hljs-number">2</span>a5305abe05176240e61b8620e19a815(SB)<br><span class="hljs-number">0x001d</span> <span class="hljs-number">00029</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)FUNCDATA$<span class="hljs-number">1</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)<br><span class="hljs-number">0x001d</span> <span class="hljs-number">00029</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)LEAQ<span class="hljs-keyword">type</span>.noalg.<span class="hljs-keyword">struct</span> &#123; F <span class="hljs-type">uintptr</span>; <span class="hljs-string">&quot;&quot;</span>.t <span class="hljs-type">string</span> &#125;(SB), AX<br><span class="hljs-number">0x0024</span> <span class="hljs-number">00036</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQAX, (SP)<br><span class="hljs-number">0x0028</span> <span class="hljs-number">00040</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)PCDATA$<span class="hljs-number">1</span>, $<span class="hljs-number">0</span><br><span class="hljs-number">0x0028</span> <span class="hljs-number">00040</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)CALLruntime.newobject(SB)<br><span class="hljs-number">0x002d</span> <span class="hljs-number">00045</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQ<span class="hljs-number">8</span>(SP), AX<br><span class="hljs-number">0x0032</span> <span class="hljs-number">00050</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)LEAQ<span class="hljs-string">&quot;&quot;</span>.app.func1(SB), CX<br><span class="hljs-number">0x0039</span> <span class="hljs-number">00057</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQCX, (AX)<br><span class="hljs-number">0x003c</span> <span class="hljs-number">00060</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQ$<span class="hljs-number">2</span>, <span class="hljs-number">16</span>(AX)<br><span class="hljs-number">0x0044</span> <span class="hljs-number">00068</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)LEAQ<span class="hljs-keyword">go</span>.<span class="hljs-type">string</span>.<span class="hljs-string">&quot;Hi&quot;</span>(SB), CX<br><span class="hljs-number">0x004b</span> <span class="hljs-number">00075</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQCX, <span class="hljs-number">8</span>(AX)<br><span class="hljs-number">0x004f</span> <span class="hljs-number">00079</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)MOVQAX, <span class="hljs-string">&quot;&quot;</span>.~r0+<span class="hljs-number">32</span>(SP)<br><span class="hljs-number">0x0054</span> <span class="hljs-number">00084</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)MOVQ<span class="hljs-number">16</span>(SP), BP<br><span class="hljs-number">0x0059</span> <span class="hljs-number">00089</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)ADDQ$<span class="hljs-number">24</span>, SP<br><span class="hljs-number">0x005d</span> <span class="hljs-number">00093</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)RET<br><span class="hljs-number">0x005e</span> <span class="hljs-number">00094</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)NOP<br></code></pre></td></tr></table></figure><p>其中 <code>LEAQ type.noalg.struct &#123; F uintptr; &quot;&quot;.t string &#125;(SB), AX</code> 这行表明 Go 对闭包的实现和维基百科说的类似。</p><p>现在看看下面这种是不是这么实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := <span class="hljs-number">5</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;a =&quot;</span>, a)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>看看汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go tool compile -S test.go<br><span class="hljs-string">&quot;&quot;</span>.main.func1 STEXT size=215 args=0x8 locals=0x50 funcid=0x0<br>  0x0000 00000 (test.go:9)TEXT<span class="hljs-string">&quot;&quot;</span>.main.func1(SB), ABIInternal, <span class="hljs-variable">$80</span>-8<br>  0x0000 00000 (test.go:9)MOVQ(TLS), CX<br>  0x0009 00009 (test.go:9)CMPQSP, 16(CX)<br>  0x000d 00013 (test.go:9)PCDATA<span class="hljs-variable">$0</span>, $-2<br>  0x000d 00013 (test.go:9)JLS205<br>  0x0013 00019 (test.go:9)PCDATA<span class="hljs-variable">$0</span>, $-1<br>  0x0013 00019 (test.go:9)SUBQ<span class="hljs-variable">$80</span>, SP<br>  0x0017 00023 (test.go:9)MOVQBP, 72(SP)<br>  0x001c 00028 (test.go:9)LEAQ72(SP), BP<br>  0x0021 00033 (test.go:9)FUNCDATA<span class="hljs-variable">$0</span>, gclocals·69c1753bd5f81501d95132d08af04464(SB)<br>  0x0021 00033 (test.go:9)FUNCDATA<span class="hljs-variable">$1</span>, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)<br>  0x0021 00033 (test.go:10)MOVQ<span class="hljs-string">&quot;&quot;</span>.a+88(SP), AX<br>  0x0026 00038 (test.go:10)MOVQAX, (SP)<br>  0x002a 00042 (test.go:10)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$0</span><br>  0x002a 00042 (test.go:10)CALLruntime.convT64(SB)<br>  0x002f 00047 (test.go:10)MOVQ8(SP), AX<br>  0x0034 00052 (test.go:10)MOVQAX, <span class="hljs-string">&quot;&quot;</span>..autotmp_21+64(SP)<br>  0x0039 00057 (test.go:10)LEAQ<span class="hljs-built_in">type</span>.[2]interface &#123;&#125;(SB), CX<br>  0x0040 00064 (test.go:10)MOVQCX, (SP)<br>  0x0044 00068 (test.go:10)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$1</span><br>  0x0044 00068 (test.go:10)CALLruntime.newobject(SB)<br>  0x0049 00073 (test.go:10)MOVQ8(SP), AX<br>  0x004e 00078 (test.go:10)LEAQtype.string(SB), CX<br>  0x0055 00085 (test.go:10)MOVQCX, (AX)<br>  0x0058 00088 (test.go:10)LEAQ<span class="hljs-string">&quot;&quot;</span>..stmp_1(SB), CX<br>  0x005f 00095 (test.go:10)MOVQCX, 8(AX)<br>  0x0063 00099 (test.go:10)LEAQtype.int(SB), CX<br>  0x006a 00106 (test.go:10)MOVQCX, 16(AX)<br>  0x006e 00110 (test.go:10)PCDATA<span class="hljs-variable">$0</span>, $-2<br>  0x006e 00110 (test.go:10)CMPLruntime.writeBarrier(SB), <span class="hljs-variable">$0</span><br>  0x0075 00117 (test.go:10)JNE189<br>  0x0077 00119 (test.go:10)MOVQ<span class="hljs-string">&quot;&quot;</span>..autotmp_21+64(SP), CX<br>  0x007c 00124 (test.go:10)MOVQCX, 24(AX)<br>  0x0080 00128 (test.go:10)PCDATA<span class="hljs-variable">$0</span>, $-1<br>  0x0080 00128 (test.go:10)PCDATA<span class="hljs-variable">$1</span>, $-1<br></code></pre></td></tr></table></figure><p>发现并没有这样的结构体，可见 Go 对这种情况做了特殊处理，因为它不是重复使用的匿名函数。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>通过以上的讲解，对闭包应该有了更清晰的认识。如果面试中再被问到闭包，你可以这么回答：</p><blockquote><p>对闭包来说，函数在该语言中得是一等公民。一般来说，一个函数返回另外一个函数，这个被返回的函数可以引用外层函数的局部变量，这形成了一个闭包。通常，闭包通过一个结构体来实现，它存储一个函数和一个关联的上下文环境。但 Go 语言中，匿名函数就是一个闭包，它可以直接引用外部函数的局部变量，因为 Go 规范和 FAQ 都这么说了。</p></blockquote><p>面试官会不会被你惊到：原来如此，后一种说法我之前没有注意过。</p><blockquote><p>4 月 14 日更新：</p><p>来自<a href="https://mp.weixin.qq.com/s/gfyW0pBIHsf2oYluQNbP8A">微信公众号</a>的读者 **gopher **留言：</p><p>noalg 代表不会生成 equal 和 hash 函数，因为闭包的 struct 是匿名的，不存在比较或者作为 key 的场景。<br>F uintptr 更准确的说应该是 .F uintptr，编译器生成的符号大部分都是.开头的。<br>“”.t string 表示捕获了一个 string 类型的变量 t，而且是 by value 而不是 by reference，因为”We use value capturing for values &lt;&#x3D; 128 bytes that are never reassigned after capturing (effectively constant).”。<br>通过 (func)(*struct) 的类型转换，即可通过 .F 找到对应的函数。<br>题外话：closure 通过 struct 实现只是为了 GC 更友好，另外匿名 struct 是为了不同的 package 共用 struct 的可能性。</p></blockquote><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/go-closure/">https://polarisxu.studygolang.com/posts/go/action/go-closure/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer（3）</title>
    <link href="/2023/07/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%EF%BC%883%EF%BC%89/"/>
    <url>/2023/07/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>f1()、f2()、f3() 函数分别返回什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r++<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br>t := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>t = t + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> t<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">int</span>)</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;(r)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>1 5 1。</p><p>​对于<code>f1()</code>和<code>f2()</code>昨天就解析过了，这里不作过多赘述。</p><p>​<code>f3()</code>中<code>defer</code>语句中注册的是一个匿名函数，在这个匿名函数中，参数 r 是按值传递的，也就是传递的是 r 的副本。因此，这个匿名函数中的 r 和外层函数 f3() 中的 r 实际上是两个不同的变量。在匿名函数中，r 被加上了 5，但这个修改只是对匿名函数中的 r 副本进行的，不会影响外层函数 f3() 中的 r。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型断言2</title>
    <link href="/2023/07/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%802/"/>
    <url>/2023/07/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%802/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>ShowA() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">interface</span> &#123;<br>ShowB() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Work <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowA() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowB() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a A = Work&#123;<span class="hljs-number">3</span>&#125;<br>s := a.(Work)<br>fmt.Println(s.ShowA())<br>fmt.Println(s.ShowB())<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 13 23</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：A。</p><p>知识点：类型断言。很简单，不多解释。 </p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer对返回值的影响</title>
    <link href="/2023/07/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%AF%B9%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2023/07/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%AF%B9%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increaseA</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>&#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increaseB</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r++<br>&#125;()<br><span class="hljs-keyword">return</span> r<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(increaseA())<br>fmt.Println(increaseB())<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1 1</li><li>B. 0 1</li><li>C. 1 0</li><li>D. 0 0</li></ul><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>B。</p><p>​在Go语言的函数中的<code>return</code>语句在底层并不是原子操作，它分为 <strong>返回值赋值</strong> 和 <strong>RET指令</strong>两部分，而 <strong>defer</strong>的执行时机就在返回值赋值操作后，RET指令执行前。</p><p>​对于 <code>increaseA()</code>来说，先进行返回值赋值，即 返回i的值赋值给一个临时变量，值为0（待执行RET指令后，再将该变量返回到调用该函数的地方）；再调用defer语句，将 i++，此时并不会影响到返回值，故输出为0</p><p>​对于<code>increaseB()</code>来说，不同的是，它的返回值参数是具名返回值，这样系统就不会为它创建一个新变量，而是直接将返回值赋值该具名返回值上，然后调用defer语句后的函数，将返回值 r++，故此时的返回值变为1.</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短变量声明</title>
    <link href="/2023/07/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%88%A4%E6%96%AD/"/>
    <url>/2023/07/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码中，x 已声明，y 没有声明，判断每条语句的对错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span> x, _ := f()<br><span class="hljs-number">2.</span> x, _ = f()<br><span class="hljs-number">3.</span> x, y := f()<br><span class="hljs-number">4.</span> x, y = f()<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>错、对、对、错。</p><ol><li>x 已经声明了，且后面是 <code>_</code> 空标识符，故不能再使用 <code>:=</code></li><li>x 已经声明，故可以使用 <code>=</code>重新赋值</li><li>虽然 x 已经声明，但 y 没有声明，只要有一个未声明的变量，就可以使用 <code>:=</code></li><li>y 未声明，不能使用赋值符号 <code>=</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中不支持隐式转换</title>
    <link href="/2023/07/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/07/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：<span id="more"></span></h1><p>有下面 3 行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 32 位机器</span><br><span class="hljs-number">1</span>）<span class="hljs-keyword">var</span> x <span class="hljs-type">int32</span> = <span class="hljs-number">32.0</span><br><span class="hljs-number">2</span>）<span class="hljs-keyword">var</span> y <span class="hljs-type">int</span> = x<br><span class="hljs-number">3</span>）<span class="hljs-keyword">var</span> z <span class="hljs-type">rune</span> = x<br></code></pre></td></tr></table></figure><p>它们是否能编译通过？为什么？</p><p>如果面试时问这道题，你需要想想面试官想考察你什么。</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><h2 id="01-数字字面量"><a href="#01-数字字面量" class="headerlink" title="01 数字字面量"></a>01 数字字面量</h2><p>在 Go 语言中，字面量是无类型（untyped）的。无类型是什么意思？无类型意味着可以赋值给类似类型的变量或常量。用上面例子，32.0 是无类型的浮点数字面量，因此它可以赋值给任意数字相关类型变量（或常量）。以下都是合法的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int64</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">float32</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> d <span class="hljs-type">complex64</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> e <span class="hljs-type">byte</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">rune</span> = <span class="hljs-number">32.0</span><br></code></pre></td></tr></table></figure><p>所以上题中 1）是正确的。</p><h2 id="02-不同类型"><a href="#02-不同类型" class="headerlink" title="02 不同类型"></a>02 不同类型</h2><p>在目前 Go 1.16 版本中（实际上只有很早期的版本不是），int 类型在 32 位机器占 4 字节，64 位机器占 8 字节。所以，在 32 位机器上，int32 和 int 的内存占用和内存布局是完全一样的。但 Go 语言不会做隐式类型转换，int 和 int32 是不同的类型，因此上题中 2）编译不通过。</p><h2 id="03-类型别名"><a href="#03-类型别名" class="headerlink" title="03 类型别名"></a>03 类型别名</h2><p>熟悉 C 语言的小伙伴，看到 Go 中以下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myint <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>会以为 myint 和 int 是一样的，认为 myint 是 int 的别名。而实际上，myint 是和 int 完全不一样的类型，只不过 myint 的底层类型是 int，它们直接可以强制类型转换，却不会隐式转换。关于这点无需多讲，重点要讲的是类型别名。</p><p>从 Go1.9 开始引入了类型别名，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">AliasDecl = identifier, <span class="hljs-string">&quot;=&quot;</span>, Type .<br></code></pre></td></tr></table></figure><p>具体例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> intalias = <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>myint 是新类型，和 int 不一样；而 intalias 却和 int 一样，它只是 int 的别名：所有使用 intalias 的地方都可以使用 int。</p><p>那为什么 Go 中会引入类型别名呢？Russ Cox 的论文 <a href="https://talks.golang.org/2016/refactor.article">Codebase Refactoring (with help from Go)</a> 介绍了它的背景。总结一下类型别名的用途，主要有两点：</p><ul><li>在大规模重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码会使用新包中的类型，有些代码使用旧包中的类型， 最典型的是 <code>context</code> 包。最开始，context 包名是 <code>golang.org/x/net/context</code>，1.7 开始，引入标准库，这样一来，存在两份。Go 1.9 开始采用别名重构了它；</li><li>允许一个庞大的包分解成内部的几个小包，但是小包中的类型需要集中暴漏在上层的大包中；</li></ul><p>在 Go 中，你可以为任意类型定义别名，比如数组、结构体、指针、函数、接口、Slice、Map、Channel 等，包括为自定义类型定义别名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> F = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">type</span> I = <span class="hljs-keyword">interface</span>&#123;&#125;<br>...<br></code></pre></td></tr></table></figure><p>此外，还可以为其他包中的类型定义别名，比如为标准库类型定义别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyReader = bufio.Reader<br></code></pre></td></tr></table></figure><p>关于类型别名的一些注意事项：</p><ul><li>别名和原类型是一样的，因此 switch-type 结构中，不能存在两个 case，一个是原类型，一个是别名；</li><li>类型别名不能循环定义，比如以下是不允许的：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T = <span class="hljs-keyword">struct</span> &#123;<br>next *T1<br>&#125;<br><br><span class="hljs-keyword">type</span> T1 = T<br></code></pre></td></tr></table></figure><ul><li>因为别名和原类型是一样的，因此共享同样的方法集，不论这个方法是定义在原类型还是别名上；</li><li>别名的导出性可以和原类型不一样；</li><li>不能为别的包的类型通过定义别名来增加方法。以下行为是不允许的：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyReader = bufio.Reader<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(MyReader)</span></span> AliasMethod() &#123;<br>fmt.Println(<span class="hljs-string">&quot;This is alias method&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译报错：<code>cannot define new methods on non-local type bufio.Reader</code>。</p><p>回到开头题目的 3），rune 是什么类型？定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">rune</span> = <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><p>很显然，rune 是 int32 的别名，因此题目中 3）也能编译通过。</p><p>除了 rune，Go 内置类型中，还有 byte 是 uint8 的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">byte</span> = <span class="hljs-type">uint8</span><br></code></pre></td></tr></table></figure><p>需要说明的是，在 Go1.9 之前，rune 和 byte 的别名性质就存在，是编译器负责处理的。只是 Go1.9 之后，别名可以用于其他类型了。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>一道看似简单的题目，如果你能够分析透彻，把语言的变化都说出来，我相信面试官会给你加分。</p><p>今天的题目，你做对了吗？</p><p>题解来自：<a href="https://polarisxu.studygolang.com/posts/go/action/type-and-alias/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/type-and-alias/。</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一元运算符</title>
    <link href="/2023/07/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/07/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>Go101 发布的一条 twitter。以下代码是否能正常运行，结果是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    v := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>    *v = <span class="hljs-number">2</span><br>    <span class="hljs-built_in">println</span>(<span class="hljs-number">5</span>/+-*v)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>大家肯定很懵。我看到时也蒙圈了。</p><p>试着运行了一下，竟然输出了 -2 。。。我忍不住“卧槽”。。。</p><p>我不得不说，Go101 扣的真细节。</p><p>于是我尝试着找一些线索，看看为什么可以这样写。</p><h2 id="01-直接看汇编"><a href="#01-直接看汇编" class="headerlink" title="01 直接看汇编"></a>01 直接看汇编</h2><p>遇到一些不解的地方，有时候借助汇编也许能得到答案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -S main.go<br></code></pre></td></tr></table></figure><p>看关键的几行汇编：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">0x001d 00029 (main.go:6)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$0</span><br>0x001d 00029 (main.go:6)NOP<br>0x0020 00032 (main.go:6)CALLruntime.printlock(SB)<br>0x0025 00037 (main.go:6)MOVQ$-2, (SP)<br>0x002d 00045 (main.go:6)CALLruntime.printint(SB)<br>0x0032 00050 (main.go:6)CALLruntime.printnl(SB)<br>0x0037 00055 (main.go:6)CALLruntime.printunlock(SB)<br></code></pre></td></tr></table></figure><p>从 <code>MOVQ $-2, (SP)</code> 看出，直接编译器直接计算出 -2 了。。。（可以进一步加上 -N 来禁止优化，但没有没有看出额外特别的）</p><h2 id="02-看规范"><a href="#02-看规范" class="headerlink" title="02 看规范"></a>02 看规范</h2><p>之前的一些题解，我总是在 Go 语言规范中找到解释，因此这次也不例外。</p><p>在运算符章节，Go 中有如下几个一元运算符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">unary_op = <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;!&quot;</span> | <span class="hljs-string">&quot;^&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;&amp;&quot;</span> | <span class="hljs-string">&quot;&lt;-&quot;</span> .<br></code></pre></td></tr></table></figure><p>其中，+、- 和 * 同时也是算术运算符中的加、减和乘。</p><p>接着，在运算符优先级处提到：一元运算符有最高的优先级。</p><p>我们分析题目中的表达式：<code>5/+-*v</code>。5 后面 &#x2F;，很显然，这是除法。而 + 前面没有操作数，因此是一个一元运算符；同理 - 和 <code>*</code> 也是一元运算符。而一元运算符有最高的优先级，因此这个表达式优先计算 <code>+-*v</code> 的值。那这个东西为什么又合法呢？</p><p>在规范中有这么一句话：</p><blockquote><p>对于整数操作数，一元运算符 <code>+</code> , <code>-</code> 和 <code>^</code> 有如下定义：（省略了 ^ 的解释）</p><p>+x 　　　　 是 0 + x<br>-x 取其负值 是 0 - x</p></blockquote><p>也就是说，<code>+-*v</code> 相当于：<code>0+(0-(*v))</code>。（为什么一元运算符左结合，因为一元，必须得有运算数，得跟着运算数走）</p><p>这样一来，结果变成了求 5&#x2F;-2 的值，结果自然是 -2（别跟我说应该是 2.5）。</p><p>（规范参考 Bekcpear 翻译版：<a href="https://hao.studygolang.com/golang_spec.html%EF%BC%89">https://hao.studygolang.com/golang_spec.html）</a></p><h2 id="03-其他语言的行为"><a href="#03-其他语言的行为" class="headerlink" title="03 其他语言的行为"></a>03 其他语言的行为</h2><p>看到这，我不禁想看看其他语言怎么实现的。（没有指针的语言，就只能包含 &#x2F;+- 了）</p><p><strong>C 语言</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> *p = &amp;i;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-number">5</span>/+-*p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果也是 -2。</p><p><strong>Java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>       System.out.println(<span class="hljs-number">5</span>/+-<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果也是 -2。</p><p><strong>PHP</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>/+-<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>结果是 -2.5。（弱类型语言嘛）</p><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">5</span>/+-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>结果是 -3。（Python 对 &#x2F; 的处理和别的语言还是不太一样）</p><p><strong>JS</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">5</span>/+-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>结果和 PHP 一样，-2.5。</p><p>最后看看 <strong>Rust</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-number">5</span>/+-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器告诉我：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: expected expression, found `+`<br></code></pre></td></tr></table></figure><p>Rust 果然不一样！我们不一样、不一样。。。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>奇淫技巧，如果能顺便学一点知识，那是极好的。当然，最关键的是希望有探索精神，找到其中的原因，举一反三，也许这点比较重要。</p><p>题解来自：<a href="https://polarisxu.studygolang.com/posts/go/action/operator/">https://polarisxu.studygolang.com/posts/go/action/operator/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口的动态类型、动态值、静态类型</title>
    <link href="/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E5%80%BC%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E5%80%BC%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>ShowA() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">interface</span> &#123;<br>ShowB() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Work <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowA() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowB() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := Work&#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> a A = c<br><span class="hljs-keyword">var</span> b B = c<br>fmt.Println(a.ShowB())<br>fmt.Println(b.ShowA())<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 23 13</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>知识点：接口的静态类型。a、b 具有相同的动态类型和动态值，分别是结构体 work 和 {3}；a 的静态类型是 A，b 的静态类型是 B，接口 A 不包括方法 ShowB()，接口 B 也不包括方法 ShowA()，编译报错。</p><p>看下编译的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.ShowB undefined (<span class="hljs-built_in">type</span> A has no field or method ShowB)<br>b.ShowA undefined (<span class="hljs-built_in">type</span> B has no field or method ShowA)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>silce/array</title>
    <link href="/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/silce-array/"/>
    <url>/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/silce-array/</url>
    
    <content type="html"><![CDATA[<h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：<span id="more"></span></h1><p><strong>1、以下代码输出什么？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">1</span>&#125;<br>    fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：编译错误；B：[2 1]；C：[0 0 1]；D：[0 1]</p><p><strong>2、以下代码输出什么？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">1</span>: <span class="hljs-number">77</span>, <span class="hljs-number">88</span>&#125;<br><span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(x), x[<span class="hljs-number">2</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>A：5 66；B：5 88；C：7 88；D：以上都不对</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>第 1 题是 Go 语言爱好者周刊<a href="https://mp.weixin.qq.com/s/4HI78Yd1ENVFCWHCESlPBg">第 87</a>的题目。</p><p>正确答案是：C，正确率 52%。这道题相对简单，但依然有近一半的人答错了。</p><p>而第 2 题是<a href="https://mp.weixin.qq.com/s/pgIoGnOd0CMPHFc4HD0xFA">周刊第 88 期</a>的题目，正确答案也是 C，只有 25%。</p><p>这涉及到 array&#x2F;slice 的一些相关知识。</p><h2 id="01-数组和切片"><a href="#01-数组和切片" class="headerlink" title="01 数组和切片"></a>01 数组和切片</h2><p>关于两者，Go 语言规范中都有明确定义。</p><p><a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-array-types-rt-rp-rp-ruby">数组</a>是这么说明的：</p><blockquote><p>数组是单一类型元素的有序序列，该单一类型称为元素类型。元素的个数被称为数组长度，并且不能为负值。长度是数组类型的一部分；它必须为一个可以被 int 类型的值所代表的非负常量。</p></blockquote><p>这里一个关键点就是，长度是数组的一部分，因此 [3]int 和 [4]int 是不同类型。</p><p>再看看<a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-slice-types-rt-rp-rp-ruby">切片</a>：</p><blockquote><p>切片是针对一个底层数组的连续段的描述符，它提供了对该数组内有序序列元素的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量被称为切片长度，且不能为负。未初始化的切片的值为 <code>nil</code> 。</p></blockquote><p>从 EBNF 的表示可以看出区别：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ArrayType</span>   = <span class="hljs-string">&quot;[&quot;</span>, ArrayLength, <span class="hljs-string">&quot;]&quot;</span>, ElementType .<br><span class="hljs-attribute">SliceType</span> = <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>, ElementType .<br></code></pre></td></tr></table></figure><p>也就是说，长度不是切片类型的一部分，切片长度可变。</p><h2 id="02-常见字面量初始化"><a href="#02-常见字面量初始化" class="headerlink" title="02 常见字面量初始化"></a>02 常见字面量初始化</h2><p>我不打算讲解数组&#x2F;切片初始化的各种情况，主要介绍常见的字面量初始化，以及和上面题目相关的部分。</p><p>通常我们会这么初始化一个数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intSet = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>[]</code> 中的 6，它表示数组的长度。因为初始化时，我们只给定了 3 个数，因此后 3 个元素是 0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[2 4 6 0 0 0]<br></code></pre></td></tr></table></figure><p>注意和这种写法的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intSet = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><p>对于切片来说，一般这样初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intSlice = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment">// 或基于 intSet 进行初始化</span><br><span class="hljs-keyword">var</span> intSlice = intSet[:]<br></code></pre></td></tr></table></figure><p>当然，针对 Slice，更多时候是通过 make 创建，然后其他方式初始化，这里不展开了。</p><h2 id="03-特殊的初始化"><a href="#03-特殊的初始化" class="headerlink" title="03 特殊的初始化"></a>03 特殊的初始化</h2><p>在 Go语言规范「<a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-composite-literals-rt-rp-rp-ruby">Composite literals</a>」部分对数组和切片的字面值初始化进行了规定，因为数组和切片类似，我们这里只说切片的情况。</p><p>先看组合字面值的 EBNF 表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">CompositeLit  = LiteralType, LiteralValue .<br>LiteralType   = StructType | ArrayType | <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>, ElementType |<br>                SliceType | MapType | TypeName .<br>LiteralValue  = <span class="hljs-string">&quot;&#123;&quot;</span>, [ ElementList, [ <span class="hljs-string">&quot;,&quot;</span> ] ], <span class="hljs-string">&quot;&#125;&quot;</span> .<br>ElementList   = KeyedElement, &#123; <span class="hljs-string">&quot;,&quot;</span>, KeyedElement &#125; .<br>KeyedElement  = [ Key, <span class="hljs-string">&quot;:&quot;</span> ], Element .<br>Key           = FieldName | Expression | LiteralValue .<br>FieldName     = identifier .<br>Element       = Expression | LiteralValue .<br></code></pre></td></tr></table></figure><p>从上到下看，简单解释一下：</p><ul><li>第 1 行，表示组合字面值由 LiteralType 和 LiteralValue 构成，其中 LiteralType 表示组合字面值的类型，LiteralValue 表示值；</li><li>第 2 行，解释 LiteralType，它可以是 <code>=</code> 后面的类型。允许的类型有：结构体、数组、切片、map 等，其中还可以是类似 <code>[…]int</code> 的形式；</li><li>第 4 行，解释 LiteralValue，它由一对 <code>&#123;&#125;</code> 包裹，其中包含可选的 ElementList；</li><li>第 5 行，解释 ElementList，它由若干 KeyedElement 组成；</li><li>第 6 行，解释 KeyedElement，这是<strong>该篇题目的重点之处</strong>。在 EBNF 中，<code>[]</code> 表示这部分是可选的，因此表示具体元素时，一般 Key 可以省略（map 不能省略），这就是通常数组和切片的初始化语法；</li></ul><p>在这个之后，规范上给出了针对数组和切片字面值的应用规则：</p><ol><li>数组中的每个元素有一个关联的标记其位置的整数索引。</li><li><strong>带键的元素使用该键作为其索引</strong>。这个键必须是可被类型 int 所表示的一个非负常量；而且如果其被赋予了类型的话则必须是整数类型。</li><li><strong>不带键的元素使用之前元素的索引加一</strong>。如果第一个元素没有键，则其索引为零。</li></ol><p>根据以上 3 点，我们很容易知道，在 <code>a := []int&#123;2: 1&#125;</code> 中，我们指定了第 3 个元素（注意索引是从 0 开始的）的值为 1，根据数组&#x2F;切片的特性，自然存在第 1、2 个元素，没有指定值时，Go 会为其设置默认值。因此这个写法和下面的写法等价：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>对于第 88 期的题目：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">1</span>: <span class="hljs-number">77</span>, <span class="hljs-number">88</span>&#125;<br></code></pre></td></tr></table></figure><p>指定了第 5 个元素（对应索引是 4），值是 44。根据上面规则的第三点，55、66 都没有指定索引，因此它们的索引是前一个元素的索引加一，即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">5</span>: <span class="hljs-number">55</span>, <span class="hljs-number">6</span>: <span class="hljs-number">66</span><br></code></pre></td></tr></table></figure><p>下一个元素是 <code>1: 77</code>，为其指定了索引 1，因此它的下一元素 88 的索引就是 2 了，因此这个定义相当于如下的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">5</span>: <span class="hljs-number">55</span>, <span class="hljs-number">6</span>: <span class="hljs-number">66</span>, <span class="hljs-number">1</span>: <span class="hljs-number">77</span>, <span class="hljs-number">2</span>: <span class="hljs-number">88</span>&#125;<br></code></pre></td></tr></table></figure><p>同样，因为数组&#x2F;切片的特性，缺少的元素（索引 0 和 3）值是 0，而整个切片的长度是最大索引加一，即 7。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>别觉得这道题目恶心，实际中这么写代码可能也确实会被打（当然，第 87 题的写法还是很有可能的）。这里主要是希望大家多掌握一些规范、细节，我想不少人不清楚，原来数组（切片）也可以指定索引进行初始化。语言语法毕竟必须严谨，而这些都在 Go 语言规范里。</p><p>延伸思考：第 88 期的题目，如果改为这样结果又如何？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">3</span>: <span class="hljs-number">77</span>, <span class="hljs-number">88</span>&#125;<br></code></pre></td></tr></table></figure><p>欢迎大胆的留言说出你的答案！</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-88/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-88/。</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题t</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map使用</title>
    <link href="/2023/07/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面代码中 A B 两处应该怎么修改才能顺利编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>        <span class="hljs-comment">//A</span><br>m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> v := m[<span class="hljs-string">&quot;b&quot;</span>]; v != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">//B</span><br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>正确的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-comment">// A</span><br>m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> v, ok := m[<span class="hljs-string">&quot;b&quot;</span>]; !ok &#123; <span class="hljs-comment">//B</span><br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>A 处，只声明了map m ,并没有分配内存空间，不能直接赋值，需要使用 make()，都提倡使用 make() 或者字面量的方式直接初始化 map。</p><p>B 处，<code>v,k := m[&quot;b&quot;]</code> 当 key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，k 返回 false。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>切片的长度和容量</title>
    <link href="/2023/07/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F/"/>
    <url>/2023/07/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>切片 a、b、c 的长度和容量分别是多少？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>a := s[:<span class="hljs-number">0</span>]<br>b := s[:<span class="hljs-number">2</span>]<br>c := s[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-built_in">cap</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>a、b、c 的长度和容量分别是 0 3、2 3、1 2。</p><p>知识点：数组或切片的截取操作。截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，截取得到的<strong>切片长度和容量计算方法是 j-i、l-i</strong>。操作符 [i:j:k]，k 主要是用来限制切片的容量，但是不能大于数组的长度 l，截取得到的<strong>切片长度和容量计算方法是 j-i、k-i</strong>。</p><p>a切片截取<code>s[:]</code>相当于<code>s[0:0]</code>，故长度为0，容量为<code>l - i = 3 - 0 = 3；</code></p><p>b切片截取<code>s[:2]</code>相当于<code>s[0:2]</code>,故长度为<code>j - i = 2 - 0 = 2</code>，容量为<code>l - i = 3 - 0 = 3；</code></p><p>c切片截取<code>s[1:2:cap(s)]</code>相当于<code>s[1:2:3]</code>,故长度为<code>j - i = 2 - 1 = 1</code>,容量为<code>l - i = 3 - 1 = 2</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口</title>
    <link href="/2023/07/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/07/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>ShowA() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">interface</span> &#123;<br>ShowB() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Work <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowA() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowB() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := Work&#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> a A = c<br><span class="hljs-keyword">var</span> b B = c<br>fmt.Println(a.ShowA())<br>fmt.Println(b.ShowB())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：13 23。</p><p>知识点：接口。一种类型实现多个接口，结构体 Work 分别实现了接口 A、B，所以接口变量 a、b 调用各自的方法 ShowA() 和 ShowB()，输出 13、23。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>int类型强制转换为string类型</title>
    <link href="/2023/07/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAstring%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/07/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAstring%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := <span class="hljs-number">65</span><br>    fmt.Println(<span class="hljs-type">string</span>(i))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. A</li><li>B. 65</li><li>C. compilation error</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><p>UTF-8 编码中，十进制数字 65 对应的符号是 A。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nil切片和空切片</title>
    <link href="/2023/06/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87/"/>
    <url>/2023/06/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码下划线处可以填入哪个选项？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s1 []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> s2 = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">if</span> __ == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;yes nil&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;no nil&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-string">``</span><br><br>- A. s1<br>- B. s2<br>- C. s1、s2 都可以<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：C。</p><p>知识点：nil 切片和空切片。</p><ol><li>空切片：空切片是一个长度为 0 的切片，它是一个有效的切片对象。可以通过使用字面量或使用 <code>make</code> 函数创建一个空切片。例如，<code>[]int&#123;&#125;</code> 或 <code>make([]int, 0)</code> 都可以创建一个空切片。空切片可以进行追加元素、访问索引等操作，只是没有任何元素。</li><li>nil 切片：nil 切片是一个未分配底层数组的切片。它的零值就是 nil。nil 切片不能进行任何操作，包括追加元素、访问索引等，因为它没有底层数组可供操作。</li><li>nil 切片和 nil 相等，一般用来表示一个不存在的切片；空切片和 nil 不相等，表示一个空的集合。</li></ol><p>​都可以填入，但当填入的是<code>s1</code>时，表示为nil切片与<code>nil</code>相等，故输出<code>yes nil</code></p><p>​当填入<code>s2</code>时，表示为空切片，空切片与nil不相等，故输出<code>no nil</code></p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题t</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>goroutine后语句的调用</title>
    <link href="/2023/06/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E5%90%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <url>/2023/06/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E5%90%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> fmt.Println(&lt;-ch1)<br>    ch1 &lt;- <span class="hljs-number">5</span><br>    time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：5、B：不能编译；C：运行时死锁</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>答案为<code>C</code>。因为goroutine后的的函数在调用之前，参数就已经被求好值了，也就是说<code>main</code>函数执行到<code>go fmt.Println(&lt;- ch1)</code>时，会先求<code>&lt;-ch1</code>此时，由于不存在除<code>main</code>外的goroutine为<code>ch1</code>传值，故程序运行时死锁。</p><p>以下解析来自<a href="https://mp.weixin.qq.com/s/kma8hvdLVPIkZnKw_MaSKg">Go语言爱好者周刊第 78 期</a>的一道题。当时正确率有点低，才 35%，可见不少人的基础还是不扎实。</p><p>此题如果改为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(&lt;-ch1)<br>  &#125;()<br>ch1 &lt;- <span class="hljs-number">5</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果就是 A 了。对比下你能知道原因了吧！</p><p>在 Go 语言规范中，关于 <a href="https://docs.studygolang.com/ref/spec#Go_statements">go 语句</a>有这么一句描述：</p><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">GoStmt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;go&quot;</span> Expression .<br></code></pre></td></tr></table></figure><p>The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for <a href="https://docs.studygolang.com/ref/spec#Expression_statements">expression statements</a>.</p><p>The function value and parameters are <a href="https://docs.studygolang.com/ref/spec#Calls">evaluated as usual</a> in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete.</p></blockquote><p>这里说明，go 语句后面的函数调用，其参数会先求值，这和普通的函数调用求值一样。在规范中<a href="https://docs.studygolang.com/ref/spec#Calls">调用部分</a>是这样描述的：</p><blockquote><p>Given an expression <code>f</code> of function type <code>F</code>,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(a1, a2, … an)</span></span><br></code></pre></td></tr></table></figure><p>calls <code>f</code> with arguments <code>a1, a2, … an</code>. Except for one special case, arguments must be single-valued expressions <a href="https://docs.studygolang.com/ref/spec#Assignability">assignable</a> to the parameter types of <code>F</code> and are evaluated before the function is called.</p></blockquote><p>大意思是说，函数调用之前，实参就被求值好了。</p><p>因此这道题目 <code>go fmt.Println(&lt;-ch1)</code> 语句中的 <code>&lt;-ch1</code> 是在 main goroutine 中求值的。这相当于一个无缓冲的 chan，发送和接收操作都在一个 goroutine 中（main goroutine）进行，因此造成死锁。</p><p>更进一步，大家可以通过汇编看看上面两种方式的不同。</p><p>此外，defer 语句也要注意。比如下面的做法是不对的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-built_in">recover</span>()<br></code></pre></td></tr></table></figure><p>而应该使用这样的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">recover</span>()<br>&#125;()<br></code></pre></td></tr></table></figure><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/。</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可变函数</title>
    <link href="/2023/06/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0/"/>
    <url>/2023/06/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>对 add() 函数调用正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> args &#123;<br>sum += arg<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. add(1, 2)</li><li>B. add(1, 3, 7)</li><li>C. add([]int{1, 2})</li><li>D. add([]int{1, 3, 7}…)</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：ABD。</p><p>知识点：可变函数。在 Go 中，可变函数（Variadic Function）是一种特殊类型的函数，可以接受可变数量的参数。我们可以在函数定义中使用 <code>...</code> 语法来表示可变参数，使得函数可以接受任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(numbers ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>total := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> numbers &#123;<br>total += num<br>&#125;<br><span class="hljs-keyword">return</span> total<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result := sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)      <span class="hljs-comment">// 调用可变函数并传递多个参数</span><br>fmt.Println(result)         <span class="hljs-comment">// 输出结果: 6</span><br><br>result = sum(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 调用可变函数并传递多个参数</span><br>fmt.Println(result)         <span class="hljs-comment">// 输出结果: 30</span><br><br>nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;   <span class="hljs-comment">// 使用切片作为参数</span><br>result = sum(nums...)       <span class="hljs-comment">// 使用 ... 展开切片作为可变函数的参数</span><br>fmt.Println(result)         <span class="hljs-comment">// 输出结果: 60</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中的*p++</title>
    <link href="/2023/06/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E7%9A%84-p/"/>
    <url>/2023/06/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E7%9A%84-p/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incr</span><span class="hljs-params">(p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>*p++<br><span class="hljs-keyword">return</span> *p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p :=<span class="hljs-number">1</span><br>incr(&amp;p)<br>fmt.Println(p)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1</li><li>B. 2</li><li>C. 3</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>​一元运算符具有最高优先级。由于++和–运算符形成的是语句，而不是表达式，因此它们不属于运算符层次结构。因此，语句<em>p++与（</em>p）++相同。</p><p>知识点：指针，incr() 函数里的 p 是 <code>*int</code> 类型的指针，指向的是 main() 函数的变量 p 的地址。 第 2 行代码是将该地址的值执行一个自增操作，incr() 返回自增后的结果。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string只是可读的</title>
    <link href="/2023/06/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E5%8F%AA%E6%98%AF%E5%8F%AF%E8%AF%BB%E7%9A%84/"/>
    <url>/2023/06/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E5%8F%AA%E6%98%AF%E5%8F%AF%E8%AF%BB%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下列选项正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello&quot;</span><br>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span><br>fmt.Println(str)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. hello</li><li>B. xello</li><li>C. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考代码及解析：C。</p><p>知识点：Go 语言中的字符串是只读的。</p><p>如果想要修改字符串中的某个字符，可以将字符串转换为字节数组 ([]byte)，然后通过索引修改字节数组中的对应位置的值，最后再将字节数组转换回字符串。</p><p>以下是修改字符串的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello&quot;</span><br>strBytes := []<span class="hljs-type">byte</span>(str)<br>strBytes[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span><br>str = <span class="hljs-type">string</span>(strBytes)<br>fmt.Println(str)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体嵌套</title>
    <link href="/2023/06/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97/"/>
    <url>/2023/06/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)<br>p.ShowB()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;<br>People<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := Teacher&#123;&#125;<br>t.ShowA()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">showA<br>showB<br></code></pre></td></tr></table></figure><p>知识点：结构体嵌套。这道题可以结合第 12 天的第三题一起看，Teacher 没有自己 ShowA()，所以调用内部类型 People 的同名方法，需要注意的是第 5 行代码调用的是 People 自己的 ShowB 方法。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行defer会保存一份副本</title>
    <link href="/2023/06/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%89%A7%E8%A1%8Cdefer%E4%BC%9A%E4%BF%9D%E5%AD%98%E4%B8%80%E4%BB%BD%E5%89%AF%E6%9C%AC/"/>
    <url>/2023/06/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%89%A7%E8%A1%8Cdefer%E4%BC%9A%E4%BF%9D%E5%AD%98%E4%B8%80%E4%BB%BD%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;  <br>    fmt.Println(i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := <span class="hljs-number">5</span><br>    <span class="hljs-keyword">defer</span> hello(i)<br>    i = i + <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5。<br></code></pre></td></tr></table></figure><p>这个例子中，hello() 函数的参数在执行 defer 语句的时候会保存一份副本，在实际调用 hello() 函数时用，所以是 5.</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>名言金句</title>
    <link href="/2023/06/23/%E9%98%85%E8%AF%BB/%E5%90%8D%E8%A8%80%E9%87%91%E5%8F%A5/"/>
    <url>/2023/06/23/%E9%98%85%E8%AF%BB/%E5%90%8D%E8%A8%80%E9%87%91%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h4 id="1、陈凯先院士讲话："><a href="#1、陈凯先院士讲话：" class="headerlink" title="1、陈凯先院士讲话："></a><strong>1、陈凯先院士讲话：</strong><span id="more"></span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">不是因为有了希望才坚持，而是因为坚持了才有希望。<br><br>不是因为有了机会才去争取，而是因为争取了才有机会。<br><br>不是因为成长了才去承担，而是因为承担了才会成长。<br><br>不是因为会了才去做，而是因为做了才能会。<br><br>不是因为拥有了才去付出，而是因为付出了才会拥有。<br><br>不是因为突破了才去挑战，而是因为挑战了才有突破。<br><br>不是因为有了收获才去感恩，而是因为感恩了才会有收获。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>名言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全局变量声明</title>
    <link href="/2023/06/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
    <url>/2023/06/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>定义一个包内全局字符串变量，下面语法正确的是（多选）：</p><ul><li>A. var str string</li><li>B. str :&#x3D; “”</li><li>C. str &#x3D; “”</li><li>D. var str &#x3D; “”</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">AD。<br></code></pre></td></tr></table></figure><p>B 短变量声明只支持局部变量声明；C 是赋值，str 必须在这之前已经声明。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体嵌套：外部覆盖内部</title>
    <link href="/2023/06/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%EF%BC%9A%E5%A4%96%E9%83%A8%E8%A6%86%E7%9B%96%E5%86%85%E9%83%A8/"/>
    <url>/2023/06/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%EF%BC%9A%E5%A4%96%E9%83%A8%E8%A6%86%E7%9B%96%E5%86%85%E9%83%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)<br>p.ShowB()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;<br>People<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := Teacher&#123;&#125;<br>t.ShowB()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：teacher showB。</p><p>知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化输入%+d</title>
    <link href="/2023/06/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-d/"/>
    <url>/2023/06/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-d/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := <span class="hljs-number">-5</span><br>    j := +<span class="hljs-number">5</span><br>    fmt.Printf(<span class="hljs-string">&quot;%+d %+d&quot;</span>, i, j)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. -5 +5</li><li>B. +5 +5</li><li>C. 0 0</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>A.</p><p><code>%d</code>表示输出十进制数字，<code>+</code>表示输出数值的符号。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>delete删除map键值对</title>
    <link href="/2023/06/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/delete%E5%88%A0%E9%99%A4map%E9%94%AE%E5%80%BC%E5%AF%B9/"/>
    <url>/2023/06/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/delete%E5%88%A0%E9%99%A4map%E9%94%AE%E5%80%BC%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-built_in">delete</span>(s, <span class="hljs-string">&quot;h&quot;</span>)<br>    fmt.Println(s[<span class="hljs-string">&quot;h&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. runtime panic</li><li>B. 0</li><li>C. compilation error</li></ul><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​删除map不存在的键值对时，不会报错，相当于没用任何作用；获取不存在的键值对时，返回该类型对应的零值，所以返回0。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nil的动态值和动态类型</title>
    <link href="/2023/06/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E5%8A%A8%E6%80%81%E5%80%BC%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/06/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E5%8A%A8%E6%80%81%E5%80%BC%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;nil&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;not nil&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. nil</li><li>B. not nil</li><li>C. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这是很常见的问题。</p><p>参考答案及解析：A。</p><p>​在 Go 语言中，接口的动态值（dynamic value）是指接口变量实际持有的值，而动态类型（dynamic type）是指接口变量所对应的具体类型。</p><p>​当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cap函数</title>
    <link href="/2023/06/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/cap%E5%87%BD%E6%95%B0/"/>
    <url>/2023/06/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/cap%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下哪种类型可以使用 cap() 函数？</p><ul><li>A. array</li><li>B. slice</li><li>C. map</li><li>D. channel</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：ABD。</p><p>知识点：cap()，cap() 函数不适用 map。详情参考：<a href="https://docs.studygolang.com/pkg/builtin/#cap">https://docs.studygolang.com/pkg/builtin/#cap</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组之间的比较</title>
    <link href="/2023/06/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2023/06/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>b := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">if</span> a == b &#123;<br>fmt.Println(<span class="hljs-string">&quot;equal&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;not equal&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. compilation error</li><li>B. equal</li><li>C. not equal</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><p> Go语言中，数组之间的比较需要注意下面这几个点：</p><ul><li>数组长度必须相等才能进行比较</li><li>数组类型必须一致才能进行比较</li><li>数组元素的值逐个比较：进行数组比较时，会逐个比较数组中的元素值。如果所有元素的值都相等，则认为两个数组相等；如果存在不相等的元素，则认为两个数组不相等。</li></ul><p>题目中两个数组的长度不相等，故无法比较，会导致编译错误<code> compilation error</code></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>切片的第三个参数</title>
    <link href="/2023/06/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
    <url>/2023/06/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    t := a[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-number">4</span>]<br>    fmt.Println(t[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.3</li><li>B.4</li><li>C.compilation error</li></ul><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。</p><p>假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：</p><p><strong>长度：j-i，容量：k-i</strong></p><p>截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：<strong>j-i、k-i。</strong></p><p>所以例子中，切片 t 下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    t := a[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-number">4</span>]<br>    fmt.Println(t[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.3</li><li>B.4</li><li>C.compilation error</li></ul><h3 id="答案解析：-1"><a href="#答案解析：-1" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。</p><p>假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：</p><p><strong>长度：j-i，容量：k-i</strong></p><p>截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：<strong>j-i、k-i。</strong></p><p>所以例子中，切片 t 为 [4]，长度和容量都是 1。为 [4]，长度和容量都是 1。</p><p>以上解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体嵌套接口</title>
    <link href="/2023/06/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/06/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码能否通过编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> worker <span class="hljs-keyword">interface</span> &#123;<br>work()<br>&#125;<br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>worker<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br>fmt.Println(w)<br>&#125;<br></code></pre></td></tr></table></figure><p>A: 能；B: 不能；C: 不知道</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这里答错的原因在于 worker 是一个接口，如果是一个普通的类型，相信大家会答对。一个结构体竟然可以嵌入一个接口？！</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>我们都知晓 Go 没有继承，但可以通过内嵌类型模拟部分继承的功能。大家要记住，接口也是类型，自然也将它作为嵌入类型。如果题目的 person 接口体改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>worker worker<br>&#125;<br></code></pre></td></tr></table></figure><p>相信会有更多人答对，这和嵌入类型唯一的区别在于是否显示指定了字段名，其他并无区别。</p><p>将接口作为嵌入类型可能让人感觉有些奇怪：那这个类型不是默认就实现了这个接口？！确实是这样的，所以才有了题目中这一句能编译通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br></code></pre></td></tr></table></figure><p>只不过，因为实例化 person 时，没有给 worker 指定值，因此 person 中的 worker 是 nil，调用它的话会报错，但编译是没问题的。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>有人可能要问，嵌入接口有实际用途吗？我找一个标准库中的例子。</p><p>在 sort 包中，有一个接口：Interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Len is the number of elements in the collection.</span><br>Len() <span class="hljs-type">int</span><br><span class="hljs-comment">// Less reports whether the element with</span><br><span class="hljs-comment">// index i should sort before the element with index j.</span><br>Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br><span class="hljs-comment">// Swap swaps the elements with indexes i and j.</span><br>Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是用于排序的。还有另外一个结构体：<a href="https://docs.studygolang.com/src/sort/sort.go?s=7078:7105#L239">reverse</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// This embedded Interface permits Reverse to use the methods of</span><br><span class="hljs-comment">// another Interface implementation.</span><br>Interface<br>&#125;<br></code></pre></td></tr></table></figure><p>它就内嵌了一个 Interface，用于排序的反转。</p><p>而内嵌接口的关键在于如何给这个内嵌的接口赋值。sort 包有一个函数：Reverse</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span></span> Interface &#123;<br><span class="hljs-keyword">return</span> &amp;reverse&#123;data&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中实例化 reverse 时，直接通过传递的 Interface 实例赋值给 reverse 的内嵌接口，然后 reverse 类型可以有选择的重新实现内嵌的 Interface 的方法。比如 Less 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> r.Interface.Less(j, i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>回到上面的题目，如果我们通过实例化的 w 调用 work 方法会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br>w.work()<span class="hljs-comment">// panic</span><br></code></pre></td></tr></table></figure><p>和上面 reverse 类似，你需要给 person 中的 worker 实例化，也就是需要一个实现了 worker 接口的类型实例。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span></span> work() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;I am &quot;</span>, s.name, <span class="hljs-string">&quot;, I am learning&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这样实例化 person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;worker: student&#123;<span class="hljs-string">&quot;polarisxu&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>你掌握了吗？</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/">https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据竞争</title>
    <link href="/2023/06/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/"/>
    <url>/2023/06/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码有什么问题，怎么解决？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">total, sum := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        total += i<br>    &#125;()<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;total:%d sum %d&quot;</span>, total, sum)<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><h2 id="01-考点一"><a href="#01-考点一" class="headerlink" title="01 考点一"></a>01 考点一</h2><p>我相信很多人应该一眼看出了其中的一个问题，那就是 i 使用的问题。常见的题目是这样的：以下代码，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(i)<br>  &#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">1e9</span>)<br></code></pre></td></tr></table></figure><p>相信很多人知道，会输出一堆 11（可能还有其他的数字），而不是期望的输出 1 到 10。</p><p>怎么改进？你应该也知晓。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(i)<br>  &#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">1e9</span>)<br></code></pre></td></tr></table></figure><p>（当然这里的输出顺序是乱的，大家应该清楚）</p><h2 id="02-考点二"><a href="#02-考点二" class="headerlink" title="02 考点二"></a>02 考点二</h2><p>该题的第二个考点：data race。因为存在多 goroutine 同时写 total 变量的问题，所以有数据竞争。可以加上 -race 参数验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run -race main.go<br>==================<br>WARNING: DATA RACE<br>Read at 0x00c0001b4020 by goroutine 8:<br>  main.main.func1()<br>      /Users/xuxinhua/main.go:12 +0x57<br><br>Previous write at 0x00c0001b4020 by main goroutine:<br>  main.main()<br>      /Users/xuxinhua/main.go:9 +0x10b<br><br>Goroutine 8 (running) created at:<br>  main.main()<br>      /Users/xuxinhua/main.go:11 +0xe7<br>==================<br></code></pre></td></tr></table></figure><p>这可以通过加锁的方式解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mutex sync.Mutex<br>total, sum := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  sum += i<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    mutex.Lock()<br>    total += i<br>    mutex.Unlock()<br>  &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，也可以通过 atomic 包解决：（注意 total 的类型，因为 atomic.AddInt64 需要）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  sum += i<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    atomic.AddInt64(&amp;total, <span class="hljs-type">int64</span>(i))<br>  &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 -race 你验证，发现 data race 没了。</p><p>细心的你不知道发现没有，以上代码我故意把最后的 fmt 输出那一行去掉了，因为它用了 total 变量，避免它导致 data race。这引出考点三。</p><h2 id="03-考点三"><a href="#03-考点三" class="headerlink" title="03 考点三"></a>03 考点三</h2><p>我上面都没有给完整的代码，因为经过上面两步，最终的结果还是不对的。从上面说的 fmt 输出代码去掉就说明还有问题。</p><p>初学 Go 应该遇到类似这样的问题，下面代码一般没有输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>原因是 main 函数先退出了，开启的 goroutine 根本没有机会执行。所以，常见的解决办法是在最后加一个 Sleep：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;()<br>  <br>  time.Sleep(<span class="hljs-number">1e9</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Sleep 会让 main goroutine 休眠，调度器调度其他 goroutine 运行。</p><p>回到开头的题目其实也存在这个问题，通过在 fmt 语句之前加上 Sleep，基本能得到正确的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        atomic.AddInt64(&amp;total, <span class="hljs-type">int64</span>(i))<br>    &#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">1e9</span>)<br><br>fmt.Printf(<span class="hljs-string">&quot;total:%d sum %d&quot;</span>, total, sum)<br></code></pre></td></tr></table></figure><p>但如果加上 -race 发现还是有问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run -race main.go<br>==================<br>WARNING: DATA RACE<br>Read at 0x00c00001c0b0 by main goroutine:<br>  main.main()<br>      /Users/xuxinhua/main.go:20 +0xe4<br><br>Previous write at 0x00c00001c0b0 by goroutine 7:<br>  <span class="hljs-built_in">sync</span>/atomic.AddInt64()<br>      /Users/xuxinhua/.go/current/src/runtime/race_amd64.s:276 +0xb<br>  main.main.func1()<br>      /Users/xuxinhua/main.go:15 +0x44<br><br>Goroutine 7 (finished) created at:<br>  main.main()<br>      /Users/xuxinhua/main.go:14 +0xa4<br>==================<br>total:55 <span class="hljs-built_in">sum</span> 55Found 1 data race(s)<br></code></pre></td></tr></table></figure><p>所以，这种方式是不靠谱的，这时正确的方式是使用 sync.WaitGroup。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync/atomic&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        sum += i<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            atomic.AddInt64(&amp;total, <span class="hljs-type">int64</span>(i))<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br><br>    fmt.Printf(<span class="hljs-string">&quot;total:%d sum %d&quot;</span>, total, sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/">https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有点难度：json和slice</title>
    <link href="/2023/06/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%BA%A6%EF%BC%9Ajson%E5%92%8Cslice/"/>
    <url>/2023/06/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%BA%A6%EF%BC%9Ajson%E5%92%8Cslice/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> AutoGenerated <span class="hljs-keyword">struct</span> &#123;<br>Age   <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Child []<span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;child&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jsonStr1 := <span class="hljs-string">`&#123;&quot;age&quot;: 14,&quot;name&quot;: &quot;potter&quot;, &quot;child&quot;:[1,2,3]&#125;`</span><br>a := AutoGenerated&#123;&#125;<br>json.Unmarshal([]<span class="hljs-type">byte</span>(jsonStr1), &amp;a)<br>aa := a.Child<br>fmt.Println(aa)<br>jsonStr2 := <span class="hljs-string">`&#123;&quot;age&quot;: 12,&quot;name&quot;: &quot;potter&quot;, &quot;child&quot;:[3,4,5,7,8,9]&#125;`</span><br>json.Unmarshal([]<span class="hljs-type">byte</span>(jsonStr2), &amp;a)<br>fmt.Println(aa)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>结果为什么是 [1 2 3] [3 4 5] 呢？</p><p>这道题涉及到两个知识点：</p><ul><li>json 解析；</li><li>slice；</li></ul><h2 id="1、json-解析"><a href="#1、json-解析" class="headerlink" title="1、json 解析"></a>1、json 解析</h2><p>关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。<a href="https://docs.studygolang.com/pkg/encoding/json/#Unmarshal%E3%80%82">https://docs.studygolang.com/pkg/encoding/json/#Unmarshal。</a></p><blockquote><p>Unmarshal 解析 JSON 编码的数据，并将结果存入 v 指向的值。如果 v 为 nil 或不是指针，则 Unmarshal 返回 InvalidUnmarshalError。</p><p>Unmarshal 和 Marshal 做相反的操作，必要时申请 map、slice 或指针，有如下的附加规则：</p><ul><li><p>为了将 JSON 数据解码写入一个指针，Unmarshal 首先处理 JSON 数据为 JSON 字面值 null 的情况。此时，Unmarshal 会将指针设置为 nil。否则，Unmarshal 会将 JSON 数据解码为指针所指向的值。如果指针为 nil，则 Unmarshal 为其分配一个新值并使指针指向它。</p></li><li><p>为了将 JSON 数据解码为实现 Unmarshaler 接口的值，Unmarshal 调用该值的 UnmarshalJSON 方法，包括当输入为 JSON null 时。否则，如果该值实现 encoding.TextUnmarshaler 且输入是带引号的 JSON 字符串，则 Unmarshal 会使用该字符串的未加引号形式来调用该值的 UnmarshalText 方法。</p></li><li><p>要将 json 数据解码写入一个结构体，函数会匹配输入对象的键和 Marshal 使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配；</p></li><li><p>为了将 JSON 数据解码到结构中，Unmarshal 将传入的对象键与 Marshal 使用的键（结构字段名称或其 Tag）进行匹配，希望使用精确匹配，但还接受不区分大小写的匹配。默认情况下，没有相应结构字段的对象键将被忽略（有关替代方法，请参见 Decoder.DisallowUnknownFields）。</p></li><li><p>要将 JSON 数据解码写入一个接口类型值，Unmarshal 将其中之一存储在接口值中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Bool</span>                   对应<span class="hljs-title class_">JSON</span>布尔类型<br>float64                对应<span class="hljs-title class_">JSON</span>数字类型<br><span class="hljs-built_in">string</span>                 对应<span class="hljs-title class_">JSON</span>字符串类型<br>[]<span class="hljs-keyword">interface</span>&#123;&#125;          对应<span class="hljs-title class_">JSON</span>数组<br>map[<span class="hljs-built_in">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; 对应<span class="hljs-title class_">JSON</span>对象<br>nil                    对应<span class="hljs-title class_">JSON</span>的<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure></li><li><p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p></li><li><p>为了将 JSON 数组解码为 Go 数组，Unmarshal 将 JSON 数组元素解码为对应的 Go 数组元素。如果 Go 数组长度小于 JSON 数组，则其他 JSON 数组元素将被丢弃。如果 JSON 数组长度小于 Go 数组，则将其他 Go 数组元素会设置为零值。</p></li><li><p>要将 JSON 对象解码到 map 中，Unmarshal 首先要建立将使用的 map。如果 map 为零，Unmarshal 会分配一个新 map。否则，Unmarshal 会重用现有 map，保留现有条目（item）。然后，Unmarshal 将来自 JSON 对象的键&#x2F;值对存储到 map 中。map 的键类型必须是任意字符串类型、整数或实现了 json.Unmarshaler 或 encoding.TextUnmarshaler 接口的类型。</p></li><li><p>如果 JSON 值不适用于给定的目标类型，或者 JSON 数字写入目标类型时溢出，则 Unmarshal 会跳过该字段并尽最大可能完成解析。如果没有遇到更多的严重错误，则 Unmarshal 返回一个 UnmarshalTypeError 来描述最早的此类错误。但无法确保有问题的字段之后的所有其余字段都将被解析到目标对象中。</p></li><li><p>JSON 的 null 值解码为 Go 的接口、指针、切片时会将它们设为 nil，因为 null 在 JSON 里一般表示“不存在”。 因此将 JSON null 解码到任何其他 Go 类型中不会影响该值，并且不会产生任何错误。</p></li><li><p>解析带引号的字符串时，无效的 UTF-8 或无效的 UTF-16 不会被视为错误。而是将它们替换为 Unicode 字符 U+FFFD。</p></li></ul></blockquote><p>跟此题相关的是下面这点：</p><blockquote><p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p></blockquote><p>因此第一次解析时，a.Child 是 [1 2 3]，aa 自然也是 [1 2 3]。第二次解析时，a.Child 的长度会被重置为 0，也就说里面的值会被重置（比如 a.Child &#x3D; a.Child[:0]），然后将 3,4,5,7,8,9 一个个 append 到 a.Child 中。</p><p>而 append 操作可能会涉及到底层数组的扩容：当原来的容量不足时，会进行扩容。怎么扩容的呢？目前的版本（Go1.15.x）按照如下规则扩容：（扩容规则依赖具体实现，不同版本可能不一样）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get element of array, growing if necessary.</span><br><span class="hljs-keyword">if</span> v.Kind() == reflect.Slice &#123;<br>  <span class="hljs-comment">// Grow slice if necessary</span><br>  <span class="hljs-keyword">if</span> i &gt;= v.Cap() &#123;<br>    newcap := v.Cap() + v.Cap()/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> newcap &lt; <span class="hljs-number">4</span> &#123;<br>      newcap = <span class="hljs-number">4</span><br>    &#125;<br>    newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)<br>    reflect.Copy(newv, v)<br>    v.Set(newv)<br>  &#125;<br>  <span class="hljs-keyword">if</span> i &gt;= v.Len() &#123;<br>    v.SetLen(i + <span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始容量最小为 4；</li><li>之后按照容量的一半扩容，所以容量是 4、6、9、13、19…</li></ul><p>有人问上题为什么 aa 的容量是 4，这里正好解释了。</p><p>因此，第一次解析，aa.Child 是：[1 2 3]，cap &#x3D; 4。第二次解析，aa.Child 先被重置，之后将 3,4,5,7,8,9 一个个 append，最后 aa.Child 是：[3 4 5 6 7 8 9], cap &#x3D; 6。</p><h2 id="2、slice"><a href="#2、slice" class="headerlink" title="2、slice"></a>2、slice</h2><p>以上就是能从 json Unmarshal 文档能学到的相关知识。接下来关键在于 slice。关于 slice 的知识，网上很多教程，这里只讲解和该题相关的内容。</p><p>1）aa :&#x3D; a.Child 意味着什么？</p><p>先看 a.Child 的内部结构。</p><p><img src="/images/json02.png" alt="img"></p><p>赋值给 aa 后呢？aa 和 a.Child 共用底层数组。</p><p>这里有引入一个小知识点，aa :&#x3D; a.Child 后，以下代码输出的两个地址是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%p,%p\n&quot;</span>, a.Child, aa)<br></code></pre></td></tr></table></figure><p>它们输出的都是底层数组的地址，这里一定要注意。通过它们，你可以验证底层数组扩容了（地址变了，表明扩容了）。</p><p>如果要输出 slice 本身的地址，应该这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%p,%p\n&quot;</span>, &amp;a.Child, &amp;aa)<br></code></pre></td></tr></table></figure><p>2）执行第二次 json 解析后</p><p>根据上文的讲解，底层数组从索引 0 位置开始依次被 3、4、5、7 填充。因为 aa 的 len 是 3，所以即使底层数组变成了 3、4、5、7，aa 看到却是 3、4、5。</p><p>当再继续解析时，底层数组容量不够，因此进行扩容，cap 变成 6，将原底层数组的元素拷贝一份到新的数组中。所以最后 a.Child 的底层数组是这个新的底层数组：[3 4 5 7 8 9]，cap &#x3D; 6。而 aa 的底层数组还是原来的。最后的内部表示是这样的。</p><p><img src="/images/json04.png" alt="img"></p><h2 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h2><p>总结起来两点：</p><ul><li>json 解析的规则，文档上明确说明了；（有人评论说跟 json 没关系，但我觉得很多人根本不知道 json 对这块是怎么处理的，正因为有这样的处理，才引出了 slice 扩容的问题）</li><li>slice 内部表示和 append 导致扩容。</li></ul><p>希望你已经彻底掌握了以上知识点。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/">https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个不同类型的数值能否相加？</title>
    <link href="/2023/06/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E5%80%BC%E8%83%BD%E5%90%A6%E7%9B%B8%E5%8A%A0%EF%BC%9F/"/>
    <url>/2023/06/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E5%80%BC%E8%83%BD%E5%90%A6%E7%9B%B8%E5%8A%A0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := <span class="hljs-number">5</span><br>    b := <span class="hljs-number">8.1</span><br>    fmt.Println(a + b)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.13.1</li><li>B.13</li><li>C.compilation error</li></ul><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">C</span><br></code></pre></td></tr></table></figure><p>​Go语言的类型机制更加严格，没有隐式类型转换，所以不同类型的数据不能直接参与同一个运算。</p><p>​a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可变函数参数</title>
    <link href="/2023/06/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <url>/2023/06/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(num ...<span class="hljs-type">int</span>)</span></span> &#123;  <br>    num[<span class="hljs-number">0</span>] = <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>    hello(i...)<br>    fmt.Println(i[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.18</li><li>B.5</li><li>C.Compilation error</li></ul><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析:"></a>答案解析:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><p>​由于切片是引用类型，在函数调用过程中，实际上是将切片的底层数组传递给了 <code>hello</code> 函数。故在函数中是对切片的底层数组进行修改，所以主函数中输出的值也随着被修改了，即18。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对nil的map取值</title>
    <link href="/2023/06/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9nil%E7%9A%84map%E5%8F%96%E5%80%BC/"/>
    <url>/2023/06/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9nil%E7%9A%84map%E5%8F%96%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[person]<span class="hljs-type">int</span><br>    p := person&#123;<span class="hljs-string">&quot;mike&quot;</span>&#125;<br>    fmt.Println(m[p])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.0</li><li>B.1</li><li>C.Compilation error</li></ul><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>这段代码会输出一个零值，即 <code>0</code>。</p><p>原因是在代码中定义了一个 <code>map[person]int</code> 类型的变量 <code>m</code>，但是没有对其进行初始化。在没有进行初始化操作时，<code>map</code> 的零值为 <code>nil</code>，也就是一个空的 <code>map</code>。</p><p>在打印语句中，尝试通过 <code>m[p]</code> 获取 <code>map</code> 中键为 <code>p</code> 的值。由于 <code>m</code> 是一个空的 <code>map</code>，并没有键为 <code>p</code> 的项，因此返回其值类型的零值，即 <code>0</code>。</p><p>因此，代码输出为 <code>0</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于channel</title>
    <link href="/2023/06/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Echannel/"/>
    <url>/2023/06/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Echannel/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于 channel，下面语法正确的是：</p><ul><li>A. var ch chan int</li><li>B. ch :&#x3D; make(chan int)</li><li>C. &lt;- ch</li><li>D. ch &lt;-</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ABC。<br></code></pre></td></tr></table></figure><p>​A、B 都是声明 channel；C 读取 channel；写 channel 是必须带上值，所以 D 错误。</p><p>​需要注意的是，A选项中，使用 <code>var ch chan int</code> 声明了一个通道变量 <code>ch</code>，但没有对其进行初始化操作，没有创建一个可用的通道。在使用通道之前，需要使用 <code>ch = make(chan int)</code> 进行初始化。</p><p>​若尝试向未初始化的通道发送数据，但由于通道未初始化，这将导致发送操作在无缓冲通道上被阻塞</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>goroutine执行速度快</title>
    <link href="/2023/06/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BF%AB/"/>
    <url>/2023/06/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">var</span> wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">println</span>(i)<br><span class="hljs-keyword">defer</span> wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>输出结果不唯一，代码存在风险, 所有 go 语句未必都能执行到。</p><p>这是使用 WaitGroup 经常犯下的错误！请各位同学多次运行就会发现输出都会不同甚至又出现报错的问题。 这是因为 go 执行太快了，导致 wg.Add(1) 还没有执行 main 函数就执行完毕了。wg.Add 的位置放错了。</p><p>改为下面代码试试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">var</span> wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt; N; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-built_in">println</span>(i)<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>        &#125;(i)<br>    &#125;<br><br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>以上解析来自<a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>channel</title>
    <link href="/2023/06/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/channel/"/>
    <url>/2023/06/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/channel/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>执行下面的代码会发生什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>a, ok := &lt;-ch<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;close&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;a: &quot;</span>, a)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">close</span>(ch)<br>fmt.Println(<span class="hljs-string">&quot;ok&quot;</span>)<br>time.Sleep(time.Second * <span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>记住 channel 的一些关键特性：</p><ul><li>给一个 nil channel 发送数据，造成永远阻塞</li><li>从一个 nil channel 接收数据，造成永远阻塞</li><li>给一个已经关闭的 channel 发送数据，引起 panic</li><li>从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</li><li>无缓冲的channel是同步的，而有缓冲的channel是非同步的</li></ul><p>15字口诀：“空读写阻塞，写关闭异常，读关闭空零”，往已经关闭的 channel 写入数据会 panic。</p><p>本题中，因为 main 在开辟完两个 goroutine 之后，立刻关闭了 ch， 结果就是 panic：</p><blockquote><p>panic: send on closed channel</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简历</title>
    <link href="/2023/06/04/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86/"/>
    <url>/2023/06/04/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类型断言</title>
    <link href="/2023/06/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%882%EF%BC%89/"/>
    <url>/2023/06/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否编译通过？如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := GetValue()<br><span class="hljs-keyword">switch</span> i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;int&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;string&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;interface&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;unknown&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​该代码无法编译通过。</p><p>原因是在 <code>switch i.(type)</code> 语句中，<code>i</code> 是一个普通的 <code>int</code> 类型变量，而 <code>i.(type)</code> 只能用于接口类型的断言。因此，编译器会报错。</p><p>​如果想要判断一个变量的类型，可以使用 <code>reflect</code> 包来实现。以下是修改后的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := GetValue()<br><span class="hljs-keyword">switch</span> reflect.TypeOf(i).Kind() &#123;<br><span class="hljs-keyword">case</span> reflect.Int:<br>fmt.Println(<span class="hljs-string">&quot;int&quot;</span>)<br><span class="hljs-keyword">case</span> reflect.String:<br>fmt.Println(<span class="hljs-string">&quot;string&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unknown&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>​编译失败。考点：类型断言，类型断言的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型断言。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数赋值给变量</title>
    <link href="/2023/06/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F/"/>
    <url>/2023/06/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么以及原因？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> []<span class="hljs-type">string</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    h := hello<br>    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;nil&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;not nil&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. nil</li><li>B. not nil</li><li>C. compilation error</li></ul><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​B。</p><p>​在Go语言中，函数变量可以存储函数的地址。在 <code>main</code> 函数中，变量 <code>h</code> 被赋值为 <code>hello</code> 函数的地址。即使 <code>hello</code> 函数返回了一个空切片 <code>nil</code>，它仍然被认为不是 <code>nil</code>。因此，条件 <code>h == nil</code> 不满足，程序会执行 <code>else</code> 分支，输出 “not nil”。</p><p>以下解析来自<a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>​这道题目里面，是将函数 hello 赋值给变量 h，而不是函数的返回值（即不是进行函数调用），所以输出 not nil。注意 Go 中函数是一等公民。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>init函数</title>
    <link href="/2023/06/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0(2)/"/>
    <url>/2023/06/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于 init 函数，下面说法正确的是：</p><ul><li>A. 一个包中，可以包含多个 init 函数；</li><li>B. 程序运行时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数；</li><li>C. main 包中，不能有 init 函数；</li><li>D. init 函数可以被其他函数调用；</li></ul><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​AB。</p><p>关于 init() 函数有几个需要注意的地方：</p><ol><li>init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等;</li><li>一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数；</li><li>同一个包中多个 init() 函数的执行顺序没有明确定义，<strong>但是不同包的init函数是根据包导入的依赖关系决定的</strong>;</li><li>init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误;</li><li>一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次；</li><li>引入包，不可出现死循坏。即A import B,B import A，这种情况编译失败；</li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常量和非常量的溢出</title>
    <link href="/2023/06/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%9E%E5%B8%B8%E9%87%8F%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
    <url>/2023/06/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%9E%E5%B8%B8%E9%87%8F%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>今天给两道类似的题目，注意，有半数以上的人可能会做错！</p><p>题一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br><br>    <span class="hljs-built_in">println</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>题二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br><br>    <span class="hljs-built_in">println</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>它们分别输出什么？请写出你的答案，能解释原因最好。</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这是站长在去年双节期间公众号「polarisxu」上发布的题目。</p><p>答对的人真不多（半数以上答错了），特别是题一，一半以上竟然是 128，难道不知道 int8 能表示的范围吗？[-128, 127]。不过为什么答案是：题一 -128，题二编译错误？</p><p>其实这是一道计算机基础题。</p><p>先看看网友 Jayce 的解释：第一题是 -128（untyped const）&#x2F; -1 (int8 var)，untyped 隐式转换为 int8，刚好在范围内，结果是 128 ，溢出 int8 的范围。因为结果不是常量，允许溢出，最高位为符号位，变成了补码，刚好又是 -128。 第二题 -128 和 -1 都是 const，直接在编译时求值，untyped 的 -128 隐式转 int8，结果为 128，仍然是一个 const。const 转换时不允许溢出，编译错误。 其实差别就是表达式的值，题一不是常量题二是，常量类型转换不允许溢出后 truncate。</p><h2 id="关于补码"><a href="#关于补码" class="headerlink" title="关于补码"></a>关于补码</h2><p>如果你忘了补码（<code>Two&#39;s Complement</code>，2 的补码，一般直接称为补码），这里简单做个说明。</p><p>先问一个问题：在计算机内部 -1 二进制表示是什么（假如为 int8）？</p><p>我们很容易这么想：1 的二进制是 00000001，而最高位是符号位，因此 -1 是 10000001。因为 1 + (-1) &#x3D; 0，但 00000001 + 10000001 &#x3D; 10000010，很显然，这个结果不是 0。这是原码表示。</p><p><img src="https://polarisxu.studygolang.com/posts/basic/imgs/complement01.png" alt="原码形式"></p><p>所以，计算机内部采用补码（Two’s Complement）表示负数。补码怎么得到呢？一般分两步：</p><p><img src="https://polarisxu.studygolang.com/posts/basic/imgs/complement02.png" alt="-1的补码表示"></p><ul><li>第一步，每一个二进制位都取相反值，0 变成 1，1 变成 0。比如，00000001 的相反值就是 11111110。</li><li>第二步，将上一步得到的值加 1。11111110 就变成 11111111。</li></ul><p><img src="https://polarisxu.studygolang.com/posts/basic/imgs/complement03.png" alt="补码形式的加法"></p><p>关于原码、反码和补码，可以看这篇文章：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html%EF%BC%8C%E5%BE%88%E8%AF%A6%E7%BB%86%E3%80%82">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html，很详细。</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="先看题一"><a href="#先看题一" class="headerlink" title="先看题一"></a>先看题一</h3><p>因为 <code>var b int8 = -128 / a</code> 不是常量表达式，因此 untyped 常量 -128 隐式转换为 int8 类型（即和 a 的类型一致），所以 <code>-128 / a</code> 的结果是 int8 类型，值是 128，超出了 int8 的范围。因为结果不是常量，允许溢出，128 的二进制表示是 10000000，正好是 -128 的补码。所以，第一题的结果是 -128。</p><blockquote><p>关于整数溢出的 Go 语言规范说明：<a href="https://hao.studygolang.com/golang_spec.html#id158%E3%80%82">https://hao.studygolang.com/golang_spec.html#id158。</a></p></blockquote><p>在 Go 语言规范中关于整数运算有这样的说明：<a href="https://hao.studygolang.com/golang_spec.html#id327">https://hao.studygolang.com/golang_spec.html#id327</a></p><blockquote><p>对于两个整数值 x 和 y ，其整数商 q &#x3D; x &#x2F; y 和余数 r &#x3D; x % y 满足如下关系：</p><p>x &#x3D; q*y + r 且 |r| &lt; |y|</p><p>这个规则有一个例外，如果对于 x 的整数类型来说，被除数 x 是该类型中最负的那个值，那么，因为 补码 的 整数溢出 ，商 q &#x3D; x &#x2F; -1 等于 x （并且 r &#x3D; 0 ）。</p></blockquote><p>所以例外情况有：</p><table><thead><tr><th align="left">类型</th><th align="left">x, q 的值</th></tr></thead><tbody><tr><td align="left">int8</td><td align="left">-128</td></tr><tr><td align="left">int16</td><td align="left">-32768</td></tr><tr><td align="left">int32</td><td align="left">-2147483648</td></tr><tr><td align="left">int64</td><td align="left">-9223372036854775808</td></tr></tbody></table><h3 id="再看题二"><a href="#再看题二" class="headerlink" title="再看题二"></a>再看题二</h3><p>对于 <code>var b int8 = -128 / a</code>，因为 a 是 int8 类型常量，所以 <code>-128 / a</code> 是常量表达式，在编译器计算，结果必然也是常量。因为 a 的类型是 int8，因此 -128 也会隐式转为 int8 类型，128 这个结果超过了 int8 的范围，但常量不允许溢出，因此编译报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这题并非 Go 独有，而是计算机的基础。比如相应的 C 语言程序，结果和 Go 对应程序是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对应题一</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">char</span> a = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">char</span> b = <span class="hljs-number">-128</span> / a;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, b);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果 -128。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对应题二</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> a = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">char</span> b = <span class="hljs-number">-128</span> / a;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, b);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译报错。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/basic/complement/%E3%80%82">https://polarisxu.studygolang.com/posts/basic/complement/。</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体实例json系列化</title>
    <link href="/2023/05/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8Bjson%E7%B3%BB%E5%88%97%E5%8C%96/"/>
    <url>/2023/05/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8Bjson%E7%B3%BB%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := <span class="hljs-keyword">struct</span> &#123;<br>time.Time<br>N <span class="hljs-type">int</span><br>&#125;&#123;<br>time.Date(<span class="hljs-number">2020</span>, <span class="hljs-number">12</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, time.UTC),<br><span class="hljs-number">5</span>,<br>&#125;<br><br>m, _ := json.Marshal(t)<br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, m)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：<code>&#123;&quot;Time&quot;: &quot;2020-12-20T00:00:00Z&quot;, &quot;N&quot;: 5&#125;</code>；B：<code>&quot;2020-12-20T00:00:00Z&quot;</code>；C：<code>&#123;&quot;N&quot;: 5&#125;</code>；D：<code>&lt;nil&gt;</code></p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这是来自<a href="https://mp.weixin.qq.com/s/oDMSFjjzGbu7kkERM8ilGw">《Go语言爱好者周刊第74期》</a>的题目，正确率 12%。</p><p>大家不用在乎是不是刁钻的题目，通过题目能学到知识才是最重要的。</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>对一个结构体实例进行 json 系列化，直觉很容易选 A。但很显然，不可能这么简单，因此需要仔细看代码。至于选 C 和 D 的人，多半是瞎猜的吧，当然选 B 也不排除有瞎猜的。</p><p>为什么选 B 呢？我想借助一个例子讲解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br>  <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  name  <span class="hljs-type">string</span><br>  hobby <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  person := Person&#123;name: <span class="hljs-string">&quot;polarisxu&quot;</span>, hobby: <span class="hljs-string">&quot;Golang&quot;</span>&#125;<br>  m, _ := json.Marshal(person)<br>  fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, m)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你认为输出 <code>&#123;&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang&quot;&#125;</code>，那你得去补补 encoding&#x2F;json 包的知识了。要想输出 <code>&#123;&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang”&#125;</code>，一般我们会这么做：将 Person 的字段导出，同时设置上 tag。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>  Hobby <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;hobby&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但如果我们不想导出 Person 的字段呢？可以通过实现 Marshaler 来做到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> MarshalJSON() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;&quot;name&quot;:&quot;`</span>+p.name+<span class="hljs-string">`&quot;,&quot;hobby&quot;:&quot;`</span>+p.hobby+<span class="hljs-string">`&quot;&#125;`</span>), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>回到题目上，<a href="https://docs.studygolang.com/pkg/time/#Time">time.Time</a> 是什么类型？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Time <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// contains filtered or unexported fields</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个没有导出任何字段的结构体类型，因此它肯定<a href="https://docs.studygolang.com/src/time/time.go?s=38148:38191#L1230">实现了 Marshaler 接口</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MarshalJSON implements the json.Marshaler interface.</span><br><span class="hljs-comment">// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> MarshalJSON() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> y := t.Year(); y &lt; <span class="hljs-number">0</span> || y &gt;= <span class="hljs-number">10000</span> &#123;<br><span class="hljs-comment">// RFC 3339 is clear that years are 4 digits exactly.</span><br><span class="hljs-comment">// See golang.org/issue/4556#c15 for more discussion.</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;Time.MarshalJSON: year outside of range [0,9999]&quot;</span>)<br>&#125;<br><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(RFC3339Nano)+<span class="hljs-number">2</span>)<br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>b = t.AppendFormat(b, RFC3339Nano)<br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br><span class="hljs-keyword">return</span> b, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这么说，答案不应该就是 A 吗？别急。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>如果 t 是这么定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">t := <span class="hljs-keyword">struct</span> &#123;<br>  Time time.Time<br>  N <span class="hljs-type">int</span><br>&#125;&#123;<br>  time.Date(<span class="hljs-number">2020</span>, <span class="hljs-number">12</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, time.UTC),<br>  <span class="hljs-number">5</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>那结果就是 A。而题目中，time.Time 是内嵌的。你学习 Go 时，应该看过通过内嵌来模拟继承的功能吧！</p><p>正是因为内嵌，t 的方法集包括了 time.Time 的方法集，所以，t 自动实现了 Marshaler 接口。因此答案是 B。</p><p>其实这道题的情况，在日常工作中还真有可能遇到。所以，当你内嵌某个类型时，特别这个类型不是你自己定义的，需要留意这种情况。</p><p>一般解决这个问题的方法有两种：1）不内嵌；2）重新实现 MarshalJSON 方法。</p><p>然而这道题无法重新实现 MarshalJSON 方法，因为结构体类型是匿名的。只能通过不内嵌来得到正确的结果。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>最后一起看下 json.Marshal 函数的文档，主要看下面这段：</p><blockquote><p>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</p></blockquote><p>大意是说，如果值实现了 json.Marshaler 接口并且不是 nil 指针，则 Marshal 函数会调用其 MarshalJSON 方法以生成 JSON。如果不存在 MarshalJSON 方法，但该值实现 encoding.TextMarshaler 接口，则 Marshal 函数调用其 MarshalText 方法并将结果编码为 JSON 字符串。</p><p>可见，json.Marshal 函数优先调用 MarshalJSON，然后是 MarshalText，如果都没有，才会走正常的类型编码逻辑。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/。</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空接口和非空接口</title>
    <link href="/2023/05/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%9E%E7%A9%BA%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/05/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%9E%E7%A9%BA%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码打印出来什么内容，说出为什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Show()<br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Show() &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span> People &#123;<br><span class="hljs-keyword">var</span> stu *Student<br><span class="hljs-keyword">return</span> stu<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> live() == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;AAAAAAA&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;BBBBBBB&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​答案解析：</p><p><strong>结果</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BBBBBBB</span><br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>我们需要了解<code>interface</code>的内部结构，才能理解这个题目的含义。（源码基于 Go1.17）</p><p>interface 在使用的过程中，共有两种表现形式</p><p>一种为**空接口(empty interface)**，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> MyInterface <span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>另一种为<strong>非空接口(non-empty interface)</strong>, 定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInterface <span class="hljs-keyword">interface</span> &#123;<br>function()<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种 interface 类型在底层分别用两种<code>struct</code>表示，空接口为<code>eface</code>, 非空接口为<code>iface</code>。</p><hr><h4 id="空接口-eface"><a href="#空接口-eface" class="headerlink" title="空接口 eface"></a>空接口 eface</h4><p>空接口 eface 结构，由两个属性构成，一个是类型信息 _type，一个是数据信息。其数据结构声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;      <span class="hljs-comment">// 空接口</span><br>    _type *_type         <span class="hljs-comment">// 类型信息</span><br>    data  unsafe.Pointer <span class="hljs-comment">// 指向数据的指针(go 语言中特殊的指针类型 unsafe.Pointer 类似于 c 语言中的void*)</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>_type 属性</strong>：是 Go 语言中所有类型的公共描述，Go 语言几乎所有的数据结构都可以抽象成 <code>_type</code>，是所有类型的公共描述，**_type 负责决定 data 应该如何解释和操作，** <code>_type</code> 的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> _type <span class="hljs-keyword">struct</span> &#123;<br>size       <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 类型大小</span><br>ptrdata    <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 前缀持有所有指针的内存大小</span><br>hash       <span class="hljs-type">uint32</span>  <span class="hljs-comment">// 数据 hash 值</span><br>tflag      tflag<br>align      <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 对齐</span><br>fieldalign <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 嵌入结构体时的对齐</span><br>kind       <span class="hljs-type">uint8</span>   <span class="hljs-comment">// kind 有些枚举值 kind 等于 0 是无效的</span><br><span class="hljs-comment">// function for comparing objects of this type</span><br><span class="hljs-comment">// (ptr to object A, ptr to object B) -&gt; ==?</span><br>equal     <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span><br>gcdata    *<span class="hljs-type">byte</span><br>str       nameOff<br>ptrToThis typeOff<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>data 属性</strong>： 表示指向具体的实例数据的指针，它是一个<code>unsafe.Pointer</code>类型，相当于一个 C 的万能指针<code>void*</code>。</p><hr><h4 id="非空接口-iface"><a href="#非空接口-iface" class="headerlink" title="非空接口 iface"></a>非空接口 iface</h4><p>iface 表示 non-empty interface 的数据结构，非空接口初始化的过程就是初始化一个 iface 类型的结构，其中<code>data</code>的作用与 <code>eface</code> 的相同，这里不再多加描述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>  tab  *itab<br>  data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>iface 结构中最重要的是 itab 结构（结构如下），每一个 <code>itab</code> 都占 32 字节的空间。itab 可以理解为<code>pair&lt;interface type, concrete type&gt;</code> 。itab 里面包含了 interface 的一些关键信息，比如 method 的具体实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;<br>  inter  *interfacetype   <span class="hljs-comment">// 接口自身的元信息</span><br>  _type  *_type           <span class="hljs-comment">// 具体类型的元信息</span><br>  hash   <span class="hljs-type">int32</span>            <span class="hljs-comment">// _type 里也有一个同样的 hash，此处多放一个是为了方便运行接口断言</span><br>  _      [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br>  fun    [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span>       <span class="hljs-comment">// 函数指针，指向具体类型所实现的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中值得注意的字段，个人理解如下：</p><ol><li><code>interface type</code>包含了一些关于 interface 本身的信息，比如<code>package path</code>，包含的<code>method</code>。这里的interfacetype 是定义 interface 的一种抽象表示。</li><li><code>_type</code>表示具体化的类型，与 eface 的 <code>_type</code> 类型相同。</li><li><code>hash</code>字段其实是对<code>_type.hash</code>的拷贝，它会在 interface 的实例化时，用于快速判断目标类型和接口中的类型是否一致。另，Go 的 interface 的 Duck-typing 机制也是依赖这个字段来实现。</li><li><code>fun</code>字段其实是一个动态大小的数组，虽然声明时是固定大小为 1，但在使用时会直接通过 fun 指针获取其中的数据，并且不会检查数组的边界，所以该数组中保存的元素数量是不确定的。</li></ol><hr><p>所以，People 拥有一个 Show 方法，属于非空接口，People 的内部定义是一个<code>iface</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>    Show()  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span> People &#123;<br>    <span class="hljs-keyword">var</span> stu *Student<br>    <span class="hljs-keyword">return</span> stu      <br>&#125;<br></code></pre></td></tr></table></figure><p>stu 是一个指向 nil 的空指针，但是最后<code>return stu</code> 会触发匿名变量 <code>People = stu</code> 值拷贝动作，所以最后<code>live()</code>放回给上层的是一个<code>People insterface&#123;&#125;</code>类型，也就是一个<code>iface struct&#123;&#125;</code>类型。 stu 为 nil，只是<code>iface</code>中的 data 为 nil 而已。 但是<code>iface struct&#123;&#125;</code>本身并不为 nil.</p><p>所以如下判断的结果为<code>BBBBBBB</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <br>    <span class="hljs-keyword">if</span> live() == <span class="hljs-literal">nil</span> &#123;  <br>        fmt.Println(<span class="hljs-string">&quot;AAAAAAA&quot;</span>)      <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;BBBBBBB&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承与多态的特点</title>
    <link href="/2023/05/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B9/"/>
    <url>/2023/05/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码能通过编译吗？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Speak(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Speak(think <span class="hljs-type">string</span>) (talk <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> think == <span class="hljs-string">&quot;love&quot;</span> &#123;<br>talk = <span class="hljs-string">&quot;You are a good boy&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>talk = <span class="hljs-string">&quot;hi&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> peo People = Student&#123;&#125;<br>think := <span class="hljs-string">&quot;love&quot;</span><br>fmt.Println(peo.Speak(think))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​在接口类型的变量中持有的是对象的指针而不是对象本身，因此对于实现接口的类型，需要使用指针赋值给接口类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> peo People = Student&#123;&#125;<br></code></pre></td></tr></table></figure><p>​将 <code>Student&#123;&#125;</code> 的结构体字面量赋值给 <code>peo</code>，此时会发生编译错误，因为 <code>Student&#123;&#125;</code> 的类型是 <code>Student</code>，而不是 <code>*Student</code>。</p><p>要使代码通过编译，需要将 <code>Student&#123;&#125;</code> 转换为 <code>*Student</code> 类型的指针，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> peo People = &amp;Student&#123;&#125;<br></code></pre></td></tr></table></figure><p>这样，<code>peo</code> 变量持有的是 <code>*Student</code> 类型的指针，可以调用 <code>peo.Speak()</code> 方法。</p><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>​继承与多态的特点</p><p>在 golang 中对多态的特点体现从语法上并不是很明显。</p><p>我们知道发生多态的几个要素：</p><p>1、有interface接口，并且有接口定义的方法。</p><p>2、有子类去重写interface的接口。</p><p>3、有父类指针指向子类的具体对象</p><p>那么，满足上述 3 个条件，就可以产生多态效果，就是，父类指针可以调用子类的具体方法。</p><p>所以上述代码报错的地方在 <code>var peo People = Student&#123;&#125;</code> 这条语句， <code>Student&#123;&#125;</code> 已经重写了父类 <code>People&#123;&#125;</code> 中的 <code>Speak(string) string</code> 方法，那么只需要用父类指针指向子类对象即可。（Go 中不叫父类，这里是为了好理解）</p><p>所以应该改成 <code>var peo People = &amp;Student&#123;&#125;</code> 即可编译通过。（People 为 interface 类型，就是指针类型）</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Go程序设计语言》</title>
    <link href="/2023/05/28/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B/"/>
    <url>/2023/05/28/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>阅读本书，请点击：<a href="/file/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80.pdf">Go程序设计语言</a></p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nil的使用</title>
    <link href="/2023/05/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/05/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面赋值正确的是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">A. <span class="hljs-keyword">var</span> x = <span class="hljs-literal">nil</span><br>B. <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-literal">nil</span><br>C. <span class="hljs-keyword">var</span> x <span class="hljs-type">string</span> = <span class="hljs-literal">nil</span><br>D. <span class="hljs-keyword">var</span> x <span class="hljs-type">error</span> = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​BD。</p><p>​在 Go 语言中，nil 是一个预定义的标识符，用于表示空值或空指针。根据不同的类型，可以使用不同的方式来赋值为 nil。在选项 B 中，使用了空接口类型（interface{}），可以将其赋值为 nil。在选项 D 中，使用了 error 类型，也可以将其赋值为 nil。</p><p>​选项 A 和选项 C 是不正确的。在 Go 语言中，nil 不能直接赋值给变量，而且字符串类型和 nil 之间不存在直接赋值的语义。</p><p>​因此，选项 B 和选项 D 是正确的方式来将变量赋值为 nil。</p><p>以下解析来自 Go<a href="https://studygolang.com/interview/question">语言中文网</a></p><p>​参考答案及解析：BD。这道题考的知识点是 nil。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看它的源码就知道，所以 D 是对的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iota</title>
    <link href="/2023/05/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota/"/>
    <url>/2023/05/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面代码能通过编译吗？如果可以，输出什么内容？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>x = <span class="hljs-literal">iota</span><br>_<br>y<br>z = <span class="hljs-string">&quot;zz&quot;</span><br>k <br>p = <span class="hljs-literal">iota</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>fmt.Println(x,y,z,k,p)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>可以通过编译，输出如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> zz zz <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​这里考察的知识点是<strong>iota</strong></p><p>​<strong>iota是golang语言的常量计数器,只能在常量的表达式中使用。</strong></p><p>​iota最初的值为0，并且会随着const的出现，进行自增长。在上述代码中，const表达式中有6个变量，故iota从初始化为0，然后自增到5。</p><p>​所以输出如上。</p><p>详情可以参考 <a href="https://www.cnblogs.com/zsy/p/5370052.html">连接</a></p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>值引用只读</title>
    <link href="/2023/05/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%AA%E8%AF%BB/"/>
    <url>/2023/05/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%AA%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码能否编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = student<br>list[<span class="hljs-string">&quot;student&quot;</span>].Name = <span class="hljs-string">&quot;LDB&quot;</span><br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​编译失败。</p><p><code>map[string]Student</code> 的 value 是一个 Student 结构值，所以当<code>list[&quot;student&quot;] = student</code>,是一个值拷贝过程。而<code>list[&quot;student&quot;]</code>则是一个值引用。那么值引用的特点是<code>只读</code>。所以对<code>list[&quot;student&quot;].Name = &quot;LDB&quot;</code>的修改是不允许的。</p><p><strong>方法一：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = student<br><span class="hljs-comment">//list[&quot;student&quot;].Name = &quot;LDB&quot;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方法1:</span><br><span class="hljs-comment">    */</span><br>    tmpStudent := list[<span class="hljs-string">&quot;student&quot;</span>]<br>    tmpStudent.Name = <span class="hljs-string">&quot;LDB&quot;</span><br>    list[<span class="hljs-string">&quot;student&quot;</span>] = tmpStudent<br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment">方法1:</span><br><span class="hljs-comment">*/</span><br>tmpStudent := list[<span class="hljs-string">&quot;student&quot;</span>]<br>tmpStudent.Name = <span class="hljs-string">&quot;LDB&quot;</span><br>list[<span class="hljs-string">&quot;student&quot;</span>] = tmpStudent<br></code></pre></td></tr></table></figure><p>是先做一次值拷贝，做出一个<code>tmpStudent副本</code>,然后修改该副本，然后再次发生一次值拷贝复制回去，<code>list[&quot;student&quot;] = tmpStudent</code>,但是这种会在整体过程中发生 2 次结构体值拷贝，性能很差。</p><p><strong>方法二</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = &amp;student<br>list[<span class="hljs-string">&quot;student&quot;</span>].Name = <span class="hljs-string">&quot;LDB&quot;</span><br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将 map 的类型的 value 由 Student 值，改成 Student 指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student<br></code></pre></td></tr></table></figure><p>这样，我们实际上每次修改的都是指针所指向的 Student 空间，指针本身是常指针，不能修改，<code>只读</code>属性，但是指向的 Student 是可以随便修改的，而且这里并不需要值拷贝。只是一个指针的赋值。</p><p>以上分析来自<a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串连接</title>
    <link href="/2023/05/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/05/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于字符串连接，下面语法正确的是？</p><ul><li>A. str :&#x3D; ‘abc’ + ‘123’</li><li>B. str :&#x3D; “abc” + “123”</li><li>C. str :&#x3D; ‘123’ + “abc”</li><li>D. fmt.Sprintf(“abc%d”, 123)</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BD</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在 Go 中，字符串连接使用双引号 <code>&quot;</code> 表示字符串字面值，而不是单引号 <code>&#39;</code>。因此，选项 B 中的 <code>&quot;abc&quot; + &quot;123&quot;</code> 表示将两个字符串连接起来，得到结果字符串 <code>&quot;abc123&quot;</code>。</p><p>​选项 A 中的单引号 <code>&#39;</code> 表示字符字面值，不能直接用于字符串连接。</p><p>​选项 C 中的 <code>&#39;123&#39;</code> 是无效的表达式，因为字符字面值只能包含一个字符。</p><p>​选项 D 使用 <code>fmt.Sprintf</code> 函数可以实现字符串格式化，将字符串和其他类型的值进行组合。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型定义和类型别名</title>
    <link href="/2023/05/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D/"/>
    <url>/2023/05/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否通过编译？如果通过，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> MyInt1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> MyInt2 = <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> =<span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> i1 MyInt1 = i <br><span class="hljs-keyword">var</span> i2 MyInt2 = i<br>fmt.Println(i1,i2)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。</p><p>​<code>type MyInt1 int</code>是创建了新类型MyInt1</p><p>​<code>type MyInt2 = int</code>是创建了int的类型别名MyInt2</p><p>​<code>var i1 MyInt1 = i </code>代码中相当于将int类型的变量赋值给MyInt类型的变量，Go是强类型语言，编译肯定不通过，</p><p>​而<code>var i2 MyInt2 = i</code>中的MyInt2只是int的别名，其本质还是int，所以可以赋值。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针变量访问成员变量</title>
    <link href="/2023/05/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <url>/2023/05/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>通过指针变量 p 访问其成员变量 name，有哪几种方式？（多选）</p><ul><li>A.p.name</li><li>B.(&amp;p).name</li><li>C.(*p).name</li><li>D.p-&gt;name</li></ul><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AC</span><br></code></pre></td></tr></table></figure><p>A. <code>p.name</code>：直接使用指针变量 <code>p</code> 访问其成员变量 <code>name</code>。</p><p>C. <code>(*p).name</code>：通过解引用指针变量 <code>p</code>，然后访问其成员变量 <code>name</code>。</p><p>B. <code>(&amp;p).name</code> 是不正确的，因为 <code>&amp;p</code> 表示取 <code>p</code> 的地址，得到的是一个指向指针变量 <code>p</code> 的指针，而非指针变量 <code>p</code> 自身。</p><p>D. <code>p-&gt;name</code> 是 C&#x2F;C++ 中的语法，而在 Go 中是不支持的。</p><p>参考程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> F <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := F&#123;<br>name: <span class="hljs-string">&quot;ft&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> p *F <span class="hljs-comment">// 将指针类型声明为 *F</span><br>p = &amp;f<br>fmt.Println(p)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短变量声明</title>
    <link href="/2023/05/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
    <url>/2023/05/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否通过编译，如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span>(<br>size := <span class="hljs-number">1024</span><br>max_size = size*<span class="hljs-number">2</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(size,max_size)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。</p><p><code>:=</code>是短变量声明，可以用来声明和初始化局部变量。题目中的<code>var</code>也是用来声明变量的，故这里会报错。</p><p>对于短变量声明的使用，有以下限制</p><ol><li>必须使用显示初始化</li><li>不能提供数据类型</li><li>只能在函数内使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>make+append</title>
    <link href="/2023/05/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make-append/"/>
    <url>/2023/05/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make-append/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>写出程序的运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br>    fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3]<br></code></pre></td></tr></table></figure><p>解析：使用make关键字，不仅会分配内存，还会对变量进行初始化，这里将长度为10的切片全部初始化为0。</p><p>​然后用append往里面添加元素，就在10个0后面追加3个元素，即答案。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>append</title>
    <link href="/2023/05/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append/"/>
    <url>/2023/05/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：跟前两天的重复，当作复习了"><a href="#题目：跟前两天的重复，当作复习了" class="headerlink" title="题目：跟前两天的重复，当作复习了"></a>题目：<span id="more"></span>跟前两天的重复，当作复习了</h1><p>下面这段代码能否通过编译，如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。append()的第二个参数不能直接使用slice，需要使用…操作符，将一个切片追加到另一个切片上:<code>append(s1, s2...)</code>。或者直接跟上元素，形如:append(s1, 1, 2, 3)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2...)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对指针执行append操作</title>
    <link href="/2023/05/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9%E6%8C%87%E9%92%88%E6%89%A7%E8%A1%8Cappend%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/05/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9%E6%8C%87%E9%92%88%E6%89%A7%E8%A1%8Cappend%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>list = <span class="hljs-built_in">append</span>(list, <span class="hljs-number">1</span>)<br>fmt.Println(list)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​不能通过编译，new([]int) 之后的 list 是一个 <code>*[]int</code> 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。</p><p>正确的使用方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>*list = <span class="hljs-built_in">append</span>(*list, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Println(*list)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常量取地址</title>
    <link href="/2023/05/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%8F%96%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/05/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%8F%96%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> cl = <span class="hljs-number">100</span><br><br><span class="hljs-keyword">var</span> bl = <span class="hljs-number">123</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    <span class="hljs-built_in">println</span>(&amp;bl,bl)<br>    <span class="hljs-built_in">println</span>(&amp;cl,cl)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析:"></a>答案解析:</h2><p>在 Go 语言中，常量在编译时被解析和计算，并直接嵌入到生成的可执行文件中。这意味着在程序运行时，常量的值已经被硬编码到了指令中，而不需要为其分配内存空间。</p><p>常量的值在编译阶段就已经确定，并且是不可变的。由于常量的值是固定的，编译器可以直接将其替换为字面值。因此，在运行时并不需要为常量分配内存空间，也不需要为其保存内存地址。</p><p>与常量不同，变量的值是在运行时动态确定的，因此需要为变量分配内存空间，并且变量在内存中有对应的地址。</p><p>总结起来，常量在编译时被解析和计算，并且其值直接嵌入到生成的可执行文件中，因此不占用内存地址。而变量的值在运行时确定，需要为其分配内存空间，并且具有对应的内存地址。</p><p>以下解析来自 Go<a href="https://studygolang.com/interview/question">语言中文网</a></p><p>考点：<strong>常量</strong></p><p>常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cannot take the address of cl<br></code></pre></td></tr></table></figure><p>内存四区概念：</p><h4 id="A-数据类型本质："><a href="#A-数据类型本质：" class="headerlink" title="A.数据类型本质："></a>A.数据类型本质：</h4><p>固定内存大小的别名</p><h4 id="B-数据类型的作用："><a href="#B-数据类型的作用：" class="headerlink" title="B. 数据类型的作用："></a>B. 数据类型的作用：</h4><p>编译器预算对象(变量)分配的内存空间大小。</p><h4 id="C-内存四区"><a href="#C-内存四区" class="headerlink" title="C. 内存四区"></a>C. 内存四区</h4><p>流程说明</p><p>1、操作系统把物理硬盘代码load到内存</p><p>2、操作系统把c代码分成四个区</p><p>3、操作系统找到main函数入口执行</p><h5 id="栈区-Stack-："><a href="#栈区-Stack-：" class="headerlink" title="栈区(Stack)："></a>栈区(Stack)：</h5><p>空间较小，要求数据读写性能高，数据存放时间较短暂。由编译器自动分配和释放，存放函数的参数值、函数的调用流程方法地址、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区)</p><h5 id="堆区-heap"><a href="#堆区-heap" class="headerlink" title="堆区(heap):"></a>堆区(heap):</h5><p>空间充裕，数据存放时间较久。一般由开发者分配及释放(但是Golang中会根据变量的逃逸现象来选择是否分配到栈上或堆上)，启动Golang的GC由GC清除机制自动回收。</p><h5 id="全局区-静态全局变量区"><a href="#全局区-静态全局变量区" class="headerlink" title="全局区-静态全局变量区:"></a>全局区-静态全局变量区:</h5><p>全局变量的开辟是在程序在<code>main</code>之前就已经放在内存中。而且对外完全可见。即作用域在全部代码中，任何同包代码均可随时使用，在变量会搞混淆，而且在局部函数中如果同名称变量使用<code>:=</code>赋值会出现编译错误。</p><p>全局变量最终在进程退出时，由操作系统回收。</p><blockquote><p>我么在开发的时候，尽量减少使用全局变量的设计</p></blockquote><h6 id="全局区-常量区："><a href="#全局区-常量区：" class="headerlink" title="全局区-常量区："></a>全局区-常量区：</h6><p>常量区也归属于全局区，常量为存放数值字面值单位，即不可修改。或者说的有的常量是直接挂钩字面值的。</p><p>比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> cl = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>cl是字面量10的对等符号。</p><p>所以在golang中，常量是无法取出地址的，因为字面量符号并没有地址而言。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体比较</title>
    <link href="/2023/05/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83/"/>
    <url>/2023/05/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面代码是否可以编译通过？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>sn1 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br>sn2 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br><span class="hljs-keyword">if</span> sn1 == sn2 &#123;<br>fmt.Println(<span class="hljs-string">&quot;sn1 == sn2&quot;</span>)<br>&#125;<br><br>sm1 := <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>m   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, m: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;<br><br>sm2 := <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>m   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, m: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;<br><br><span class="hljs-keyword">if</span> sm1 == sm2 &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 == sm2&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>编译不通过，因为map属于不可比较类型。</p><blockquote><p>.&#x2F;prog.go:31:9: invalid operation: sm1 &#x3D;&#x3D; sm2 (struct containing map[string]string cannot be compared)</p></blockquote><p>考点：结构体比较</p><blockquote><p>结构体比较规则注意1：只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。</p></blockquote><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">sn1 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br>sn3:= <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;&#123;age:<span class="hljs-number">11</span>, name:<span class="hljs-string">&quot;qq&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><code>sn3</code>与<code>sn1</code>就不是相同的结构体了，不能比较。</p><blockquote><p><strong>结构体比较规则注意2</strong>：结构体是相同的，但是结构体属性中有不可以比较的类型，如<code>map</code>,<code>slice</code>，则结构体不能用<code>==</code>比较。</p></blockquote><p>可以使用reflect.DeepEqual进行比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reflect.DeepEqual(sm1, sm2) &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 == sm2&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 != sm2&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://studygolang.com/interview/question">文章出处</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于len的细节</title>
    <link href="/2023/05/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Elen%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <url>/2023/05/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Elen%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> s = <span class="hljs-string">&quot;Go101.org&quot;</span><br><br><span class="hljs-comment">// len(s) == 9</span><br><span class="hljs-comment">// 1 &lt;&lt; 9 == 512</span><br><span class="hljs-comment">// 512 / 128 == 4</span><br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>A、0 0；B、0 4；C：4 0；D：4 4</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>答案是 4 0（即选 C）。</p><p>不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所以会重新思考。</p><p>好几个群都问，为什么结果会是 4 0，希望我解释下。因此有了此文。</p><p>这个小题涉及到几个知识点。</p><h2 id="len-函数的结果"><a href="#len-函数的结果" class="headerlink" title="len 函数的结果"></a>len 函数的结果</h2><p>要注意，len 是一个内置函数。在官方标准库文档<a href="https://docs.studygolang.com/pkg/builtin/#len">关于 len 函数</a> 有这么一句：</p><blockquote><p>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification’s “Length and capacity” section for details.</p></blockquote><p>明确支持，当参数是字符串字面量和简单 array 表达式，len 函数返回值是常量，这很重要。</p><p>上题中，如果 <code>const s = &quot;Go101.org”</code> 改为 <code>var s = &quot;Go101.org&quot;</code> 结果又会是什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;Go101.org&quot;</span><br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是 0 0。</p><p>但改为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> s = [<span class="hljs-number">9</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>&#125;<br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果又是 4 0。</p><p>接着看文档那句话的后半句，查看 Go 语言规范中<a href="https://hao.studygolang.com/golang_spec.html#id221">关于长度和容量的说明</a> 。</p><blockquote><p>内置函数 len 和 cap 获取各种类型的实参并返回一个 int 类型结果。实现会保证结果总是一个 int 值。</p><p>如果 s 是一个字符串常量，那么 len(s) 是一个常量 。如果 s 类型是一个数组或到数组的指针且表达式 s 不包含 信道接收 或（非常量的） 函数调用的话， 那么表达式 len(s) 和 cap(s) 是常量；这种情况下， s 是不求值的。否则的话， len 和 cap 的调用结果不是常量且 s 会被求值。</p></blockquote><p>可见题目中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure><p>第一句的 len(s) 是常量（因为 s 是字符串常量）；而第二句的 len(s[:]) 不是常量。这是这两条语句的唯一区别：两个 len 的返回结果数值并无差异，都是 9，但一个是常量一个不是。</p><h2 id="关于位移操作"><a href="#关于位移操作" class="headerlink" title="关于位移操作"></a>关于位移操作</h2><p>根据上面的分析，现在问题的关键在于位移运算这里。Go 语言规范中有<a href="https://docs.studygolang.com/ref/spec#Operators">这么一句</a> ：</p><blockquote><p>The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.</p></blockquote><p>大意是：在位移表达式的右侧的操作数必须为整数类型，或者可以被 uint 类型的值所表示的无类型的常量。如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。</p><p>这里的关键在于常量位移表达式。根据上文的分析，<code>1 &lt;&lt; len(s)</code> 是常量位移表达式，而 <code>1 &lt;&lt; len(s[:])</code> 不是。</p><p>规范上关于常量表达式中，还有<a href="https://docs.studygolang.com/ref/spec#Constant_expressions">这么一句</a> ：</p><blockquote><p>If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.</p></blockquote><p>大意是：如果常量 位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ）</p><p>因此对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code> 是一个常量位移表达式，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</p><p>而对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，因为 <code>1 &lt;&lt; len(s[:])</code> 不是一个常量位移表达式，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型）。</p><p>为什么是 byte 类型，大家可能还是有点晕。这要回到关于常量的说明上。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是在编译的时候进行计算的。在 Go 语言中，常量分两种：无类型和有类型。Go 规范上说，字面值常量， true , false , iota 以及一些仅包含无类型的恒定操作数的 常量表达式 是无类型的。</p><p>那有类型常量是怎么来的呢？一般有两种：显示声明或隐式得到。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">23</span><br><span class="hljs-keyword">const</span> b <span class="hljs-type">float32</span> = <span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>无类型常量都有一个默认类型（无类型常量的默认类型分别是 bool , rune , int , float64 , complex128 或 string）。当在上下文中需要请求该常量为一个带类型的值时，这个 默认类型 便指向该常量隐式转换后的类型。</p><p>所以 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code> 中，根据规范定义，1 会隐式转换为 byte 类型，因此 <code>1 &lt;&lt; len(s[:])</code> 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一道很具迷惑性的题目引出这么多小知识点。可能有人要喷：讨论这些有什么用？这也太细节了。我想说的是，Go 语言规范，细节点很多，能多掌握一些没坏处，说不定将来实际工作就遇到了类似的问题呢？！以上的知识点，很细节，但我认为也是挺有价值的。</p><p>当然了，你怎么说都行，你都是对的，你开心就好！</p><p>答案来自：<a href="https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/">https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interface</title>
    <link href="/2023/05/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/interface/"/>
    <url>/2023/05/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/interface/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>Go 1.15 中 var i interface{} &#x3D; a 会有额外堆内存分配吗？</p><p>具体代码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a  <span class="hljs-type">int</span> = <span class="hljs-number">3</span><br><span class="hljs-comment">// 以下有额外内存分配吗？</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = a<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>在 Go 中，接口被实现为一对指针（请参阅 Russ Cox 的 Go 数据结构：<a href="https://research.swtch.com/interfaces">接口</a>）：指向有关类型信息的指针和指向值的指针。可以简单的表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>    tab  *itab<br>    data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 tab 是指向类型信息的指针；data 是指向值的指针。因此，一般来说接口意味着必须在堆中动态分配该值。</p><p>然而，**<a href="https://docs.studygolang.com/doc/go1.15">Go 1.15 发行说明</a>**在 runtime 部分中提到了一个有趣的改进：</p><blockquote><p>Converting a small integer value into an interface value no longer causes allocation.</p></blockquote><p>意思是说，将小整数转换为接口值不再需要进行内存分配。小整数是指 0 到 255 之间的数。</p><p>我们实际简单测试一下。</p><p>创建一个包 smallint，在包中创建文件 smallint.go，加上如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> smallint<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Convert</span><span class="hljs-params">(val <span class="hljs-type">int</span>)</span></span> []<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        slice[i] = val<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更好的看到效果，函数中进行了 100 次 int 到 interface 的转换。写个基准测试 smallint_test.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> smallint_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;testing&quot;</span><br>    <span class="hljs-string">&quot;test/smallint&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkConvert</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>        result := smallint.Convert(<span class="hljs-number">12</span>)<br>        _ = result<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分别使用 Go1.14 和 Go1.15 版本进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go version<br>go version go1.14.7 darwin/amd64<br>$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8      569830       1966 ns/op     2592 B/op      101 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 1.647s<br>$ go version<br>go version go1.15 darwin/amd64<br>$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8     1859451        655 ns/op     1792 B/op        1 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 2.178s<br></code></pre></td></tr></table></figure><p>接着讲 smallint_test.go 中调用 Convert 的参数由 12 改为 256，再次使用 Go1.15 运行，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8      551546       2049 ns/op     2592 B/op      101 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 1.502s<br></code></pre></td></tr></table></figure><p>证明了上面提到的优化点。</p><p>那么，你想过它大概怎么实现的吗？因为上文提到，Go 中接口的实现，使用一个指针字段指向接口值。现在竟然不再额外进行内存分配，说明做了什么特殊的事情。</p><p>其实答案非常简单。如果你对 Python、Java 等语言熟悉，应该知道大概如何实现的。Go 中如何做的，可以在 <strong><a href="https://go-review.googlesource.com/c/go/+/216401">Go CL 216401</a></strong> 中（合并到**<a href="https://github.com/golang/go/commit/9828c43288a53d3df75b1f73edad0d037a91dff8">此提交</a>**中了，GitHub 上更易于阅读）找到。具体来说就是 Go 中定义了一个特殊的静态数组，该数组由 256 个整数组成（0 到 255）。当必须分配内存以将整数存储在堆上，并将其转换为接口的一部分时，它首先检查是否它可以只返回指向数组中适当元素的指针。这种经常使用的值的静态分配，是一种很常见的优化手段。例如，Python 对小整数执行类似的操作，Java 也有常量池，进行类似的优化处理。</p><p>实际上，Go 以前有一个优化，如果你将 0 转换为接口值，它将返回一个指向特殊静态零值的指针。这次新的 0-255 优化替代了该值。</p><p>对具体实现细节感兴趣的，可以阅读下上文提到的提交。</p><p>答案解析来自：<a href="https://mp.weixin.qq.com/s/1r0nt8nA3foDRRrbRp4omg">https://mp.weixin.qq.com/s/1r0nt8nA3foDRRrbRp4omg</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>按位或操作符</title>
    <link href="/2023/05/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%89%E4%BD%8D%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <url>/2023/05/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%89%E4%BD%8D%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a, b <span class="hljs-type">float64</span> = <span class="hljs-number">1.0</span>, <span class="hljs-number">4.0</span><br>fmt.Println(a | b)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：5；B：+Inf；C：panic；D：不能编译</p><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>正确答案：D</p><p><code>|</code> 操作是按位或操作符，它的操作数只能是整数，而上面这道题的操作数是 float64，因此编译不通过。</p><p>这是 Go 规范的内容 <a href="https://docs.studygolang.com/ref/spec#Arithmetic_operators%EF%BC%9A">https://docs.studygolang.com/ref/spec#Arithmetic_operators：</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">+    <span class="hljs-built_in">sum</span>                    integers, floats, complex values, strings<br>-    difference             integers, floats, complex values<br>*    product                integers, floats, complex values<br>/    quotient               integers, floats, complex values<br>%    remainder              integers<br><br>&amp;    bitwise AND            integers<br>|    bitwise OR             integers<br>^    bitwise XOR            integers<br>&amp;^   bit clear (AND NOT)    integers<br><br>&lt;&lt;   <span class="hljs-string">left shift             integer &lt;&lt; integer &gt;= 0</span><br><span class="hljs-string">&gt;&gt;   right shift            integer &gt;&gt; integer &gt;= 0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>append的使用</title>
    <link href="/2023/05/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/05/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否通过编译，如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。append()的第二个参数不能直接使用slice，需要使用…操作符，将一个切片追加到另一个切片上:<code>append(s1, s2...)</code>。或者直接跟上元素，形如:append(s1, 1, 2, 3)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2...)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new的易错点</title>
    <link href="/2023/05/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/"/>
    <url>/2023/05/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>list = <span class="hljs-built_in">append</span>(list, <span class="hljs-number">1</span>)<br>fmt.Println(list)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​不能通过编译，new([]int) 之后的 list 是一个 <code>*[]int</code> 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。</p><p>​如果想要用，应该解引用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">list := *<span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>​输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Go语言高性能编程》</title>
    <link href="/2023/05/10/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    <url>/2023/05/10/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://geektutu.com/post/high-performance-go.html">Go 语言高性能编程 | 极客兔兔 (geektutu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go高性能编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new和make的区别</title>
    <link href="/2023/05/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/05/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>new()和make()的区别？</p><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p><code>new</code>和<code>make</code>都是Go语言中用来分配内存的内置函数，但是他们的用途不同。</p><p>​<code>new</code>函数用于为任何类型分配内存，它返回指向新分配了类型零值的指针。例如<code>new(int)</code>返回一个指向新分配的<code>int</code>类型零值的指针。</p><p>​<code>make</code>函数只能用于创建引用类型的变量，如<strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>类型。它会为引用类型的变量分配内存，并初始化该类型的值，并返回该变量的引用，即可以通过该变量访问和修改切片中的元素。</p><p>​简而言之，<code>new</code>只分配内存，而<code>make</code>除了分配内存外，还会初始化值。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>init函数</title>
    <link href="/2023/05/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0/"/>
    <url>/2023/05/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>init() 函数是什么时候执行的？</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p><code>init()</code> 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证。</p><p>一句话总结： import –&gt; const –&gt; var –&gt; <code>init()</code> –&gt; <code>main()</code></p><p>答案解析来自：<a href="https://geektutu.com/post/qa-golang-2.html#Q1-init-%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F">init() 函数是什么时候执行的？</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go好文分享</title>
    <link href="/2023/05/08/Go/Go%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB/"/>
    <url>/2023/05/08/Go/Go%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="好文链接如下"><a href="#好文链接如下" class="headerlink" title="好文链接如下"></a>好文链接如下<span id="more"></span></h1><blockquote><p>本文所有内容来自Go语言中文网的转载，用于自己方便学习。</p></blockquote><h4 id="185期"><a href="#185期" class="headerlink" title="185期"></a>185期</h4><h5 id="1-如何解决-Go-with-Grafana-Pyroscope-中的内存泄漏问题"><a href="#1-如何解决-Go-with-Grafana-Pyroscope-中的内存泄漏问题" class="headerlink" title="1.如何解决 Go with Grafana Pyroscope 中的内存泄漏问题"></a>1.<a href="https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/">如何解决 Go with Grafana Pyroscope 中的内存泄漏问题</a></h5><h5 id="2-为什么-defer-的执行顺序和注册顺序不同？✔"><a href="#2-为什么-defer-的执行顺序和注册顺序不同？✔" class="headerlink" title="2.为什么 defer 的执行顺序和注册顺序不同？✔"></a>2.<a href="https://mp.weixin.qq.com/s/xpjNOwn1kNICQE4TmjpQZg">为什么 defer 的执行顺序和注册顺序不同？</a>✔</h5><h5 id="3-Go-语言中没有枚举类型，但是我们可以这样做✔"><a href="#3-Go-语言中没有枚举类型，但是我们可以这样做✔" class="headerlink" title="3.Go 语言中没有枚举类型，但是我们可以这样做✔"></a>3.<a href="https://mp.weixin.qq.com/s/QFr_Pgt9GzOG3zlgcXEVwQ">Go 语言中没有枚举类型，但是我们可以这样做</a>✔</h5><h5 id="4-Go-单元测测时尽量用-fake-object"><a href="#4-Go-单元测测时尽量用-fake-object" class="headerlink" title="4.Go 单元测测时尽量用 fake object"></a>4.<a href="https://mp.weixin.qq.com/s/yycu10nLvpC0XiRemSy3lA">Go 单元测测时尽量用 fake object</a></h5><h4 id="184期"><a href="#184期" class="headerlink" title="184期"></a>184期</h4><h5 id="1-最小的Go二进制"><a href="#1-最小的Go二进制" class="headerlink" title="1.最小的Go二进制"></a>1.<a href="https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb">最小的Go二进制</a></h5><h5 id="2-Go-开发命令行程序指南"><a href="#2-Go-开发命令行程序指南" class="headerlink" title="2.Go 开发命令行程序指南"></a>2.<a href="https://mp.weixin.qq.com/s/Qyp35Q6UjtZHfwkDUWbEog">Go 开发命令行程序指南</a></h5><h5 id="3-如何用一个端口同时暴露-HTTP1-x2F-2、gRPC-协议？"><a href="#3-如何用一个端口同时暴露-HTTP1-x2F-2、gRPC-协议？" class="headerlink" title="3.如何用一个端口同时暴露 HTTP1&#x2F;2、gRPC 协议？"></a>3.<a href="https://mp.weixin.qq.com/s/e-QNv5-Ip2EcDp-S6CuXEg">如何用一个端口同时暴露 HTTP1&#x2F;2、gRPC 协议？</a></h5><h5 id="4-Go-测试综合指南"><a href="#4-Go-测试综合指南" class="headerlink" title="4.Go 测试综合指南"></a>4.<a href="https://blog.jetbrains.com/zh-hans/go/2023/01/03/comprehensive-guide-to-testing-in-go/">Go 测试综合指南</a></h5><h4 id="183期"><a href="#183期" class="headerlink" title="183期"></a>183期</h4><h5 id="1、-为什么-Go-不支持-T-转换为-interface"><a href="#1、-为什么-Go-不支持-T-转换为-interface" class="headerlink" title="1、[为什么 Go 不支持 ]T 转换为 []interface"></a>1、[为什么 Go 不支持 <a href="https://mp.weixin.qq.com/s/lG-sswO8i6w_6sMztvyOjw">]T 转换为 []interface</a></h5><h5 id="2、Golang反射学习：手写一个RPC"><a href="#2、Golang反射学习：手写一个RPC" class="headerlink" title="2、Golang反射学习：手写一个RPC"></a>2、<a href="https://mp.weixin.qq.com/s/PzfiMXiYjfGQFHW_0hTS4A">Golang反射学习：手写一个RPC</a></h5><h5 id="3、如何用-Go-进行正确的性能剖析？"><a href="#3、如何用-Go-进行正确的性能剖析？" class="headerlink" title="3、如何用 Go 进行正确的性能剖析？"></a>3、<a href="https://blog.pickme.lk/how-to-get-profiling-right-with-go-813ff89d4757">如何用 Go 进行正确的性能剖析？</a></h5><h5 id="4、gRPC-监控对高性能系统的重要性"><a href="#4、gRPC-监控对高性能系统的重要性" class="headerlink" title="4、gRPC 监控对高性能系统的重要性"></a>4、<a href="https://www.groundcover.com/blog/grpc-monitoring">gRPC 监控对高性能系统的重要性</a></h5><h5 id="5、gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？"><a href="#5、gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？" class="headerlink" title="5、gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？"></a>5、<a href="https://mp.weixin.qq.com/s/BHrxHQrMKZrhb34hR3La5w">gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？</a></h5><h5 id="6、Go-Mutex：保护并发访问共享资源的利器"><a href="#6、Go-Mutex：保护并发访问共享资源的利器" class="headerlink" title="6、Go Mutex：保护并发访问共享资源的利器"></a>6、<a href="https://mp.weixin.qq.com/s/y6lppalSRwLhCjS9yQYuUQ">Go Mutex：保护并发访问共享资源的利器</a></h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>空结构体</title>
    <link href="/2023/05/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2023/05/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>空 struct{} 占多少空间？有什么用途？</p><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(unsafe.Sizeof(<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>set := <span class="hljs-built_in">make</span>(Set)<br><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125; &#123;<br>set[item] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>fmt.Println(<span class="hljs-built_in">len</span>(set)) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">if</span> _, ok := set[<span class="hljs-string">&quot;A&quot;</span>]; ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;A exists&quot;</span>) <span class="hljs-comment">// A exists</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-ch<br><span class="hljs-comment">// do something</span><br>&#125;()<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，声明只包含方法的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Lamp <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> On() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;On&quot;</span>)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> Off() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Off&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>答案解析来源：<a href="https://geektutu.com/post/qa-golang-1.html#Q16-%E7%A9%BA-struct-%E7%9A%84%E7%94%A8%E9%80%94">空 struct{} 的用途</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何确认两个map是否相等</title>
    <link href="/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E4%B8%A4%E4%B8%AAmap%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <url>/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E4%B8%A4%E4%B8%AAmap%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：<span id="more"></span></h1><p>​如何确认两个map是否相等？</p><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>map 深度相等的条件：</p><ol><li>都为 nil</li><li>非空、长度相等，指向同一个 map 实体对象</li><li>相应的 key 指向的 value “深度”相等</li></ol><p>直接将使用 map1 &#x3D;&#x3D; map2 是错误的。这种写法只能比较 map 是否为 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> n <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br>fmt.Println(m == <span class="hljs-literal">nil</span>)<br>fmt.Println(n == <span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">// 不能通过编译</span><br><span class="hljs-comment">//fmt.Println(m == n)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>因此只能是遍历 map 的每个元素，比较元素是否都是深度相等。</p><p>答案解析来自：<a href="https://golang.design/go-questions/map/compare/">https://golang.design/go-questions/map/compare/</a></p><p>其实还可以采用反射进行判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>( <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;relflect&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> n <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br>    fmt.Println(reflect.DeepEqual(m,n))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对map的元素取地址</title>
    <link href="/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9map%E7%9A%84%E5%85%83%E7%B4%A0%E5%8F%96%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9map%E7%9A%84%E5%85%83%E7%B4%A0%E5%8F%96%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h4><p>​以下代码能否成功编译通过？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>fmt.Println(&amp;m[<span class="hljs-string">&quot;qcrao&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>​这段代码是错误的，会引起编译错误。</p><p>​原因是 <code>&amp;m[&quot;qcrao&quot;]</code> 语句是无效的，因为 <code>m[&quot;qcrao&quot;]</code> 返回的是一个值，而非一个变量，所以不能对其取地址。</p><p>​如果需要对 map 中的某个值取地址，应该先将其赋值给一个变量，再对变量取地址。例如，可以修改代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>    value := m[<span class="hljs-string">&quot;qcrao&quot;</span>]<br>    fmt.Println(&amp;value)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的返回值</title>
    <link href="/2023/05/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <url>/2023/05/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码有什么缺陷：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span>(total <span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> x+y, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>​第二个返回值没有命名。</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号（）；如果只有要给返回值且命名也必须加上括号。这里第一个返回值有命名total，第二个没有命名，所以错误。</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//两个都加上命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (total <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> x + y, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">//两个都不命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> x + y, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map可以边遍历边删除吗</title>
    <link href="/2023/05/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E5%8F%AF%E4%BB%A5%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4%E5%90%97/"/>
    <url>/2023/05/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E5%8F%AF%E4%BB%A5%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>Go 的 map 可以边遍历边删除吗？</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>​map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p><p>上面说的是发生在多个协程同时读写同一个 map 的情况下。 如果在同一个协程内边遍历边删除，并不会检测到同时读写，理论上是可以这样做的。但是，遍历的结果就可能不会是相同的了，有可能结果遍历结果集中包含了删除的 key，也有可能不包含，这取决于删除 key 的时间：是在遍历到 key 所在的 bucket 时刻前或者后。</p><p>一般而言，这可以通过读写锁来解决：sync.RWMutex。</p><p>读之前调用 RLock() 函数，读完之后调用 RUnlock() 函数解锁；写之前调用 Lock() 函数，写完之后，调用 Unlock() 解锁。</p><p>另外，sync.Map 是线程安全的 map，也可以使用。</p><p>参考答案来自：<a href="https://golang.design/go-questions/map/delete-on-range/">https://golang.design/go-questions/map/delete-on-range/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用append向slice添加元素</title>
    <link href="/2023/05/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%94%A8append%E5%90%91slice%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0/"/>
    <url>/2023/05/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%94%A8append%E5%90%91slice%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面两段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    fmt.Println(s)<br>&#125;<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br><span class="hljs-number">2.</span>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ol><li>创建了一个长度为5的整数切片因为是使用make创建了，故是创建并初始化为0，然后将1、2、3三个整数追加到切片的末尾，最终输出切片的所有元素。由于append函数会自动扩容切片，因此最终输出的是一个长度为8的整数切片，包含5个0和1、2、3三个整数。</li><li>这段代码创建了一个空的整数切片，然后将1、2、3、4四个整数追加到切片的末尾，最终输出切片的所有元素。由于append函数会自动扩容切片，因此最终输出的是一个长度为4的整数切片，包含1、2、3、4四个整数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map为什么是无序的？</title>
    <link href="/2023/05/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%9F/"/>
    <url>/2023/05/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>map 的 key 为什么是无序的？</p><p>在遍历 map 的时候，我们会发现，输出的 key 是无序的。为什么？</p><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p><p>​当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key&#x2F;value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。</p><p>​当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key&#x2F;value 对了。</p><p>​多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。</p><p>答案解析来自：<a href="https://golang.design/go-questions/map/unordered/">https://golang.design/go-questions/map/unordered/</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer_执行顺序</title>
    <link href="/2023/05/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/05/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">package main<br><br>import (<br>    &quot;fmt&quot;<br>)<br><br>func main() &#123;<br>    defer_call()<br>&#125;<br><br>func defer_call() &#123;<br>    defer func() &#123; fmt.Println(&quot;打印前&quot;) &#125;()<br>    defer func() &#123; fmt.Println(&quot;打印中&quot;) &#125;()<br>    defer func() &#123; fmt.Println(&quot;打印后&quot;) &#125;()<br><br>    panic(&quot;触发异常&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">打印后<br>打印中<br>打印前<br>panic: 触发异常<br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在函数返回或者发生panic时，defer语句会按照先进后出的顺序执行，若是因为发生panic退出函数，则最后再执行panic语句。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再练for-range</title>
    <link href="/2023/04/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%86%8D%E7%BB%83for-range/"/>
    <url>/2023/04/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%86%8D%E7%BB%83for-range/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出的是什么？请说明原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> key,val := <span class="hljs-keyword">range</span> slice &#123;<br>m[key] = &amp;val<br>&#125;<br><br><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k,<span class="hljs-string">&quot;-&gt;&quot;</span>,*v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">3</span> -&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​for range 循环的时候会创建每个元素的副本，而不是元素的引用。</p><p>​在使用<strong>for-range</strong>循环里，每次遍历使用的val都是对同一个元素的遍历赋值，故在第一个for循环里，每次使用的都是<strong>val</strong>的元素进行赋值，即map中所有的元素的值都是变量val的地址。</p><p>​在最后一次遍历时，<strong>val</strong>指向slice的最后一个元素的地址，即3的地址。故最后的输出都是3。</p><h4 id="正确的写法："><a href="#正确的写法：" class="headerlink" title="正确的写法："></a>正确的写法：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> slice &#123;<br>v := val<br>m[key] = &amp;v<br>&#125;<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k, <span class="hljs-string">&quot;-&gt;&quot;</span>, *v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型断言</title>
    <link href="/2023/04/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
    <url>/2023/04/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>如果 Add() 函数的调用代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a Integer = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b Integer = <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = &amp;a<br>sum := i.(*Integer).Add(b)<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>则Add函数定义正确的是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">A.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span></span> Add(b Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br>B.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span></span> Add(b *Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> a + *b<br>&#125;<br><br>C.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span></span> Add(b Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> *a + b<br>&#125;<br><br>D.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> *a + *b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AC</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在 <code>main</code> 函数中，<code>i</code> 被定义为一个接口类型的变量，它的值是指向变量 <code>a</code> 的指针。当调用 <code>Add</code> 函数时，使用了类型断言 <code>i.(*Integer)</code> 来将接口类型的变量 <code>i</code> 转换为 <code>*Integer</code> 类型。类型断言的语法为 <code>x.(T)</code>，其中 <code>x</code> 是一个接口类型的表达式，<code>T</code> 是一个类型。类型断言检查 <code>x</code> 的动态类型是否等于 <code>T</code>，如果检查成功，则返回 <code>x</code> 的动态值，否则会引发运行时恐慌。</p><p>​在这个例子中，由于 <code>i</code> 的动态类型为 <code>*Integer</code>，因此类型断言成功，并返回了指向变量 <code>a</code> 的指针。因此，当调用 <code>Add</code> 函数时，可以使用指针接收器 <code>*Integer</code>（选项 C），也可以使用值接收器 <code>Integer</code>（选项 A）。在 Go 语言中，当使用指针调用一个值接收器方法时，编译器会自动解引用该指针。</p><p>​同时，由于 <code>b</code> 是一个值类型的变量，所以在 <code>Add</code> 函数中应该使用值类型的参数 <code>Integer</code>。因此，选项 B 和 D 都是错误的。</p><p>​综上所述，正确答案是 A 和 C。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>switch语句</title>
    <link href="/2023/04/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/switch%E8%AF%AD%E5%8F%A5/"/>
    <url>/2023/04/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/switch%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于switch语句，下面说法正确的有?</p><ul><li>A. 条件表达式必须为常量或者整数；</li><li>B. 单个case中，可以出现多个结果选项；</li><li>C. 需要用break来明确退出一个case；</li><li>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span>、D<br></code></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>A：错误。条件表达式可以是任何类型的表达式，而不仅仅是常量或整数，比如字符串、浮点数、布尔值等都是可以的。<br>B：正确。在单个case语句块中，可以有多个结果选项。比如，可以在一个case中执行多个语句，也可以用表达式或者函数，用分号分隔即可，</p><p>C：错误。在switch语句中，每个case语句块执行完毕后会自动退出，不需要使用break语句来明确退出。但是，在某些情况下，可能需要在case中使用break语句，以避免执行下一个case。</p><p>D：正确。当在一个case中使用了fallthrough关键字时，程序会跳过当前case中的break语句，并执行紧跟的下一个case。如果没有使用fallthrough关键字，则当前case执行完毕后会自动退出switch语句。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang小知识</title>
    <link href="/2023/04/27/Go/Golang%E9%A2%98%E5%BA%93/"/>
    <url>/2023/04/27/Go/Golang%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转化</title>
    <link href="/2023/04/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/"/>
    <url>/2023/04/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于类型转化，下面选项正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">A.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = i<br><br>B.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = (MyInt)i<br><br>C.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = MyInt(i)<br><br>D.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = i.(MyInt)<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">C</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ul><li>​A选项是错误的，因为将int类型的变量赋值给MyInt类型的变量是不允许的。</li><li>选项 B 是错误的，应该是使用类型转换语法将 int 类型的变量转换为 MyInt 类型，即 <code>var j MyInt = MyInt(i)</code>。</li><li>对于选项 C，使用类型转换表达式 <code>MyInt(i)</code> 可以将 <code>i</code> 的值从 <code>int</code> 类型转换为 <code>MyInt</code> 类型，并将结果赋给 <code>j</code>。</li><li>对于选项 D，使用类型断言 <code>i.(MyInt)</code> 是错误的，因为 <code>i</code> 的底层类型是 <code>int</code>，而不是 <code>MyInt</code>，所以无法将其转换为 <code>MyInt</code> 类型。</li></ul><p><strong>类型断言</strong>：用于将接口类型的值转换为具体的类型。在转换的过程中需要注意以下几点：</p><ol><li>语法：value.(type)<ul><li>value：接口类型的值</li><li>type：需要转换的具体类型</li></ul></li><li>转换前需要判断接口类型的值是否为 nil 或者对应类型的零值，避免在转换时出现 panic。</li></ol><p>下面是一个类型断言的正确使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">1</span><br><br>v, _ := i.(<span class="hljs-type">int</span>)<br>str, _ := i.(<span class="hljs-type">string</span>)<br>fmt.Println(<span class="hljs-string">&quot;v type is&quot;</span>, reflect.TypeOf(v))<br>fmt.Println(<span class="hljs-string">&quot;str type is&quot;</span>, reflect.TypeOf(str))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">v <span class="hljs-keyword">type</span> is <span class="hljs-type">int</span><br>str <span class="hljs-keyword">type</span> is <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多重赋值</title>
    <link href="/2023/04/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC/"/>
    <url>/2023/04/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><h4 id="下面代码输出正确的是？"><a href="#下面代码输出正确的是？" class="headerlink" title="下面代码输出正确的是？"></a>下面代码输出正确的是？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">1</span><br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br>i, s[i<span class="hljs-number">-1</span>] = <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Z&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;s: %v \n&quot;</span>, s)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">A. s: [Z,B,C]<br>B. s: [A,Z,C]<br></code></pre></td></tr></table></figure><h4 id="正确答案："><a href="#正确答案：" class="headerlink" title="正确答案："></a>正确答案：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​多重赋值分为两个步骤，有先后顺序：</p><ul><li>计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；</li><li>赋值；</li></ul><p>​所以本题，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 <code>i, s[0] = 2, &quot;Z&quot;</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环语句</title>
    <link href="/2023/04/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <url>/2023/04/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下<span id="more"></span></h2><p>关于循环语句，下面说法正确的有（）</p><ul><li>A. 循环语句既支持 for 关键字，也支持 while 和 do-while；</li><li>B. 关键字 for 的基本使用方法与 C&#x2F;C++ 中没有任何差异；</li><li>C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；</li><li>D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；</li></ul><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">C、D<br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ul><li><p>A. 该选项不正确。Go语言中只支持for循环语句，而不支持while和do-while循环语句。但是for循环的使用方法较为灵活，使用 <code>for</code> 循环来模拟这些语句的效果。可以满足大部分循环需求。</p></li><li><p>选项 B 中的说法不正确，因为 Go 语言中的 <code>for</code> 语句与 C&#x2F;C++ 中略有不同。例如：</p><ul><li>条件语句中不需要括号；</li><li>可以省略条件语句，相当于 <code>while(true)</code>；</li><li>提供了一个更高级的 <code>break</code>，可以选择中断哪一个循环；</li><li>不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</li></ul></li><li><p>C. 该选项正确。Go语言的for循环语句支持continue和break关键字来控制循环流程，同时还提供了一个更高级的break，可以选择中断指定的循环语句。</p><ul><li><p>这里使用<strong>Loop</strong>标签，用于选择需要中断哪一个循环，下面的例子选择中断外面的循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>Loop:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// 使用标签选择中断外层循环</span><br><span class="hljs-keyword">break</span> Loop<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i:%d, j:%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 标签名为 Loop，用于中断外层循环</span><br>fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">i:<span class="hljs-number">0</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">1</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">2</span><br>i:<span class="hljs-number">1</span>, j:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>下面的例子选择中断内部循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>Loop:<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// 使用标签选择中断外层循环</span><br><span class="hljs-keyword">break</span> Loop<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i:%d, j:%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 标签名为 Loop，用于中断内层循环</span><br>fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">i:<span class="hljs-number">0</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">1</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">2</span><br>i:<span class="hljs-number">1</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">2</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">2</span>, j:<span class="hljs-number">1</span><br>i:<span class="hljs-number">2</span>, j:<span class="hljs-number">2</span><br>Done!<br></code></pre></td></tr></table></figure></li><li><p>对比上述两种情况，应该就能大概理解这个<strong>Loop</strong>的用法了。</p></li></ul></li><li><p>D. 该选项正确。Go语言中的for循环语句不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</p><ul><li><pre><code class="go">//会报错for i := 0, j := 1; i &lt; 10; i ++&#123;        ...    &#125;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- ```go<br>  <span class="hljs-regexp">//</span>可以正常使用<br>  <span class="hljs-regexp">//</span>平行赋值： i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>  <br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《MySQL必知必会》</title>
    <link href="/2023/04/24/%E9%98%85%E8%AF%BB/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"/>
    <url>/2023/04/24/%E9%98%85%E8%AF%BB/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>持续更新中……<span id="more"></span></p><h1 id="《MySQL必知必会》"><a href="#《MySQL必知必会》" class="headerlink" title="《MySQL必知必会》"></a>《MySQL必知必会》</h1><h2 id="一、了解SQL"><a href="#一、了解SQL" class="headerlink" title="一、了解SQL"></a>一、了解SQL</h2><h3 id="1、数据库基础"><a href="#1、数据库基础" class="headerlink" title="1、数据库基础"></a>1、数据库基础</h3><p><strong>数据库</strong>：一个以某种有组织的方式存储的数据集合。</p><p><strong>表</strong>：一种结构化的文件，可用来存储某种特定类型的数据。数据库中的每个表都有一个自己的名字，用来标识自己，此名字是唯一的。</p><blockquote><p><strong>表名</strong>：相同数据库不能两次使用相同的表名，不同数据库可以使用相同的表名。</p></blockquote><p><strong>列</strong>：表中的一个字段。所有表都说由一个或者多个列组成的。可以把数据库想象成一个网格，每一列存储着一条特定的信息，如一个列存储所有顾客的编号，另一个列存储所有顾客的地址。</p><p><strong>数据类型</strong>：每个表列都有相应的数据类型，它限制该列中存储的数据。</p><p><strong>行</strong>：表中的数据是按行存储的，所保存的每个记录存储在自己的行内，如果将表想象成网格，网格中垂直的列为表列，水平行为表行。例如顾客表可以每行存储一个顾客，表中的行数为记录的总数。</p><p><strong>主键</strong>：一列或者一组列。其值能够唯一区分表中的每个行。表中每一行都应该有可以唯一标识自己的一列。</p><p>​唯一标识表中每行的这个列或者这组列称为主键。主键用来表示要给特定的行。</p><blockquote><p><strong>应该总是定义主键</strong>：虽然并不是总需要主键，但为每个表创建一个主键，以便于以后的数据操作和管理。</p></blockquote><p>​表中的任何列都可以作为主键，只有满足以下条件：</p><ul><li>任意两行不具有相同的 主键值</li><li>每个行都必须有一个主键值（主键列不允许NULL值）</li></ul><p>​在使用多列作为主键时，上述条件必须应用到构造主键的所有列，所有列值的组合必须是唯一的。</p><h3 id="2、什么是SQL"><a href="#2、什么是SQL" class="headerlink" title="2、什么是SQL"></a>2、什么是SQL</h3><p><strong>SQL</strong>是结构化查询语言的缩写。SQL是一种专门用来与数据库通信的语言。</p><p><strong>SQL的优点</strong>：</p><ul><li>几乎所有重要的DBMS都支持SQL，所以学习此语言使你几乎能与所有数据库打交道。</li><li>简单易学。</li><li>虽然看上去很简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li></ul><h2 id="二、MySQL简介"><a href="#二、MySQL简介" class="headerlink" title="二、MySQL简介"></a>二、MySQL简介</h2><h3 id="1、什么是MySQL"><a href="#1、什么是MySQL" class="headerlink" title="1、什么是MySQL"></a>1、什么是MySQL</h3><p>​<strong>MySQL</strong>：数据的所有存储、检索、管理和吹了实际上是由数据库软件——DBMS（数据库管理系统）完成的。MySQL是一种DBMS，即它是一种数据库软件。</p><p>​MySQL数据库是基于客户机-服务器的数据库。</p><h3 id="2、MySQL工具"><a href="#2、MySQL工具" class="headerlink" title="2、MySQL工具"></a>2、MySQL工具</h3><p>​<strong>mysql命令行实用程序</strong>：每个MySQL安装都会有一个mysql的简单命令行使用程序。在使用这个实用程序的时候，需要注意：</p><ul><li>命令行输入在mysql&gt;之后</li><li>命令用;或者\g结束，仅按Enter不执行命令</li><li>输入help或者\h获取帮助。</li><li>输入quit或者exit退出命令行实用程序。</li></ul><p><strong>MySQL Administrator</strong>：是一个图形交互客户机，用于简化MySQL服务器的管理。</p><p><strong>MySQL Query Browser</strong>：一个图形交互客户机，用来编写和执行MySQL命令。</p><h2 id="三、使用MySQL"><a href="#三、使用MySQL" class="headerlink" title="三、使用MySQL"></a>三、使用MySQL</h2><h3 id="1、连接"><a href="#1、连接" class="headerlink" title="1、连接"></a>1、连接</h3><p><strong>信息</strong>：连接MySQl，需要以下信息：</p><ul><li>主机名——连接本地MySQL服务器，为localhost；</li><li>端口（如果使用默认端口3306之外的端口）；</li><li>一个合法的用户名；</li><li>用户口令。</li></ul><h3 id="2、选择数据库"><a href="#2、选择数据库" class="headerlink" title="2、选择数据库"></a>2、选择数据库</h3><p><code>use</code>：一个关键字，用于执行任意数据库操作前选择一个数据库。</p><h3 id="3、了解数据库和表"><a href="#3、了解数据库和表" class="headerlink" title="3、了解数据库和表"></a>3、了解数据库和表</h3><p><strong>查看数据库</strong>：在你不知道可以使用哪些数据库名时，可以使用<code>SHOW DATABASES</code>显示这些信息</p><p>​<code>SHOW DATABASES</code>；返回可用数据库的一个列表。</p><p><strong>查看要给数据库内的表的列表</strong>：可以使用<code>SHOW TABLES</code></p><p>​<code>SHOW TABLES</code>；返回当前选择的数据库内的可用表的列表。</p><p><strong>查看表的信息</strong>：<code>SHOW COLUMNS FROM TABLE</code>要求给出一个表名，它对于每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值、以及其他信息。</p><p><strong>所支持的其他SHOW语句</strong>：</p><ul><li><code>SHOW STATUS</code>，用于显示广泛的服务器状态信息；</li><li><code>SHOW CREATE DATABASE</code>和<code>SHOW CREATE TABLE</code>，分别用来显示创建特定数据库或表的MySQL语句；</li><li><code>SHOW GRANTS</code>用来显示授权用户的安全权限</li><li><code>SHO ERRORS</code>和<code>SHOW WARNINGS</code>用来显示服务器错误或者警告信息。</li></ul><h2 id="四、检索数据"><a href="#四、检索数据" class="headerlink" title="四、检索数据"></a>四、检索数据</h2><h3 id="1、SELECT语句"><a href="#1、SELECT语句" class="headerlink" title="1、SELECT语句"></a>1、SELECT语句</h3><p>​SQL语句是用简单的英语单词构成的，这些单词称为关键词，每个SQL语句都是由一个或者多个关键字构成的。</p><p>​最经常使用的SQL语句就是<code>SELECT</code>语句，它的用途是从一个或者多个表中检索信息。使用<code>SELECT</code>检索信息，至少给出两条信息——想选择什么，以及从什么地方开始选择。</p><h3 id="2、检索单个列"><a href="#2、检索单个列" class="headerlink" title="2、检索单个列"></a>2、检索单个列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name <br>FROM products;<br></code></pre></td></tr></table></figure><p>​上述语句利用<code>SELECT</code>语句从<code>products</code>表中检索一个名为<code>prod_name</code>的列。</p><h3 id="3、检索多个列"><a href="#3、检索多个列" class="headerlink" title="3、检索多个列"></a>3、检索多个列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price <br>FROM products;<br></code></pre></td></tr></table></figure><h3 id="4、检索所有列"><a href="#4、检索所有列" class="headerlink" title="4、检索所有列"></a>4、检索所有列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM products;<br></code></pre></td></tr></table></figure><h3 id="5、检索不同的行"><a href="#5、检索不同的行" class="headerlink" title="5、检索不同的行"></a>5、检索不同的行</h3><p>执行下面语句，会返回所有匹配的行，但其中有很多重复的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id <br>From products;<br></code></pre></td></tr></table></figure><p>如果你不想要每个值每次都出现，怎么办？例如，你想得出products表中产品的所有供应商的ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT vend_id<br>FROM products;<br></code></pre></td></tr></table></figure><p> 解决的办法是使用<code>DISTINCT</code>，顾名思义，此关键字指示MySQL只返回不同的值。</p><h3 id="6、限制结果"><a href="#6、限制结果" class="headerlink" title="6、限制结果"></a>6、限制结果</h3><p>​<strong>SELECT</strong>语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或者前几行，可以使用<strong>LIMIT</strong>子句。</p><p>​此语句使用<strong>SELECT</strong>语句检索单个列。<code>LIMIT 5</code>指示<strong>MySQL</strong>返回不多于5行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name <br>FROM products<br>LIMIT 5;<br></code></pre></td></tr></table></figure><p>​为得出下一个5行，可以指定要检索的开始和行数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name <br>FROM products<br>LIMIT 5, 5;<br></code></pre></td></tr></table></figure><p><code>LIMIT 5, 5</code>指示<strong>MySQL</strong>返回从<strong>行5</strong>开始的<strong>5行</strong>。第一个数为开始为止，第二个数为要检索的行数。</p><blockquote><p>⭐<strong>行0</strong>：检索出来的第一行为行0，而不是行1，因此<code>LIMIT 1, 1</code>将检索出来第二行而不是第一行。</p></blockquote><blockquote><p>⭐<strong>在行数不够时</strong>：<strong>LIMIT</strong>中指定要检索的行数为检索的最大行数，如果没用足够的行，<strong>MySQL</strong>将只返回它能返回的那么多行。</p></blockquote><h3 id="7、使用完全限定的表名"><a href="#7、使用完全限定的表名" class="headerlink" title="7、使用完全限定的表名"></a>7、使用完全限定的表名</h3><p>​迄今为止使用的<strong>SQL</strong>例子只能通过列名引用列。也可能会使用完全限定的名字来引用列（同时使用表名和列名）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select products.prod_name<br>FROM products;<br></code></pre></td></tr></table></figure><p>​这条<strong>SQL</strong>语句在功能上等于本章最开始使用的那一条语句，但这里指定了一个完全限定的列名。</p><p>​表名也可以是完全限定的，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select products.prod_name<br>FROM book.products;<br></code></pre></td></tr></table></figure><p>​这条SQL语句在功能上等于刚刚使用的那条语句（假设products表确实存在book数据库中）</p><p>​虽然这种表示很麻烦，但是有些情形需要这么用，后面会介绍。</p><h2 id="五、排序检索数据"><a href="#五、排序检索数据" class="headerlink" title="五、排序检索数据"></a>五、排序检索数据</h2><h3 id="1、排序数据"><a href="#1、排序数据" class="headerlink" title="1、排序数据"></a>1、排序数据</h3><p>​正如前面所述，下面的<strong>SQL</strong>语句返回某个数据库表的单个列，但却没用特定的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products;<br></code></pre></td></tr></table></figure><p>​其次，检索出来的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序会收到MySQL重用收回存储空间的影响。因此，如果补明确控制的话，不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</p><p>​为了明确地排序用<strong>SELECT</strong>语句检索出来的数据，可以用<strong>ORDER BY</strong>自居。<strong>ORDER BY</strong>子句取一个或多个列的名字，据此对输出进行排序。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><p>​这条语句除了指示<strong>MySQL</strong>对<code>prod_name</code>列以字母顺序排序数据的<strong>ORDER BY</strong>子句外，与前面的语句相同。</p><h3 id="2、按多个列排序"><a href="#2、按多个列排序" class="headerlink" title="2、按多个列排序"></a>2、按多个列排序</h3><p>​下面的语句指示<strong>MySQL</strong>按照——先按价格，然后再按名称排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price<br>FROM products<br>ORDER BY prod_price, prod_name;<br></code></pre></td></tr></table></figure><h3 id="3、指定排序方向"><a href="#3、指定排序方向" class="headerlink" title="3、指定排序方向"></a>3、指定排序方向</h3><p>​数据排序分为——升序排序（默认）、降序排序。</p><p>​当我们想使用降序排序的时候，必须指定<strong>DESC</strong>关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price<br>FROM products<br>ORDER BY prod_price DESC;<br></code></pre></td></tr></table></figure><p>​但是，如果打算用多个列排序怎么办？下面的例子以降序排序产品（最贵的在前面），然后再对产品名排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price<br>FROM products<br>ORDER BY prod_price DESC, prod_name;<br></code></pre></td></tr></table></figure><blockquote><p><strong>DESC</strong>关键字只应用到直接位于其前面的列名。如果想在多个列上进行降序排序，必须对每个列指定<strong>DECS</strong>关键字。</p><p>与<strong>DESC</strong>对应的是<strong>ASC</strong>关键字，在升序排序时可以指定它，但实际上没用多大用处，因为升序是默认的。</p></blockquote><p>​使用<strong>ORDER BY</strong>和<strong>LIMIT</strong>的组合，能够找出一个列中最高或者最低的只。下面的例子演示如何找出最昂贵物品的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_price<br>FROM products<br>ORDER BY prod_price DESC<br>LIMIT 1<br></code></pre></td></tr></table></figure><p>​<code>prod_price DESC</code>保证行是按照最昂贵到最便宜检索的，而<code>LIMIT 1</code>告诉<strong>MySQL</strong>仅返回一行。</p><h2 id="六、过滤数据"><a href="#六、过滤数据" class="headerlink" title="六、过滤数据"></a>六、过滤数据</h2><h3 id="1、使用WHERE子句"><a href="#1、使用WHERE子句" class="headerlink" title="1、使用WHERE子句"></a>1、使用WHERE子句</h3><p>​数据库表一般包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件，搜索条件也称为过滤条件。</p><p>​在SELECT语句中，数据根据WHERE子中指定的搜索条件进行过滤WHERE子句在表名之后给出，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE prod_price = 2.50;<br></code></pre></td></tr></table></figure><p>​这条语句从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行。</p><h3 id="2、WHERE子句操作符"><a href="#2、WHERE子句操作符" class="headerlink" title="2、WHERE子句操作符"></a>2、WHERE子句操作符</h3><p>​<img src="/images/where.png" alt="子句操作符"></p><h4 id="（1）检查单个值"><a href="#（1）检查单个值" class="headerlink" title="（1）检查单个值"></a>（1）检查单个值</h4><p>​上面举的例子就是，我们再举一个例子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select prod_name, prod_price<br>FROM products<br>where prod_name = &#x27;fuses&#x27;;<br></code></pre></td></tr></table></figure><p>​检查<code>WHERE prod_name=fuses</code>语句，它返回prod_name的值为Fuses的一行。MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配。</p><h4 id="（2）不匹配检查"><a href="#（2）不匹配检查" class="headerlink" title="（2）不匹配检查"></a>（2）不匹配检查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select vend_id, prod_name<br>FROM products<br>where vend_id &lt;&gt; 1003<br></code></pre></td></tr></table></figure><p>​上述例子是列出不是由供应商1003制造的所有产品。</p><p>下面是相同的例子，只是用的是**!&#x3D;<strong>而不是</strong>&lt;&gt;**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select vend_id, prod_name<br>FROM products<br>where vend_id != 1003<br></code></pre></td></tr></table></figure><h4 id="（3）范围值检查"><a href="#（3）范围值检查" class="headerlink" title="（3）范围值检查"></a>（3）范围值检查</h4><p>​为了检查某个范围的值，可使用BETWEEN操作符。其语法与其他WHERE子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。</p><p>​例如，BETWEEN操作符可用来检索价格在5美元和10美元之间或日期在指定的开始日期和结束日期之间的所有产品，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECTprod_name,prod_price <br>FROMproducts <br>WHEREprod_price BETWEEN 5 AND 10;<br></code></pre></td></tr></table></figure><p>​从这个例子中可以看到，在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。</p><h4 id="（4）空值检查"><a href="#（4）空值检查" class="headerlink" title="（4）空值检查"></a>（4）空值检查</h4><p>​在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值<strong>NULL</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id<br>FROM customers<br>WHERE cust_email IS NULL<br></code></pre></td></tr></table></figure><p>​ustomers包含有具有空值的列，如果在文件中没有某位顾客的电子邮件地址，则cust_email列将包含NULL值:</p><h2 id="七、数据过滤"><a href="#七、数据过滤" class="headerlink" title="七、数据过滤"></a>七、数据过滤</h2><h3 id="1、组合WHERE子句"><a href="#1、组合WHERE子句" class="headerlink" title="1、组合WHERE子句"></a>1、组合WHERE子句</h3><p>​第6章中介绍的所有WHERE子句在过滤数据时使用的都是单一的条件。为了进行更强的过滤控制，MySQL允许给出多个WHERE子句。这些子句可以两种方式使用:以AND子句的方式或OR子句的方式使用。</p><h4 id="（1）AND操作符"><a href="#（1）AND操作符" class="headerlink" title="（1）AND操作符"></a>（1）AND操作符</h4><p>​为了通过不止一个列进行过滤，可使用AND操作符给WHERE子句附加条件。下面的代码给出了一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_price, prod_name<br>FROM products<br>WHERE vend_id = 1003 AND prod_price &lt;= 10<br></code></pre></td></tr></table></figure><p>​此SQL语句检索由供应商1003制造且价格小于等于10美元的所有产品的名称和价格。这条SELECT语句中的WHERE子句包含两个条件，并且用AND关键字联结它们。AND指示DBMS只返回满足所有给定条件的行。如果某个产品由供应商1003制造，但它的价格高于10美元，则不检索它。类似，如果产品价格小于10美元，但不是由指定供应商制造的也不被检索。</p><h4 id="（2）OR操作符"><a href="#（2）OR操作符" class="headerlink" title="（2）OR操作符"></a>（2）OR操作符</h4><p>​<strong>OR</strong>操作符与<strong>AND</strong>操作符不同，它指示<strong>MySQL</strong>检索匹配任一条件的行，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id = 1002 OR vend_id = 1003;<br></code></pre></td></tr></table></figure><p>​此SQL语句检索由任一个指定供应商制造的所有产品的产品名和价格。OR操作符告诉DBMS匹配任一条件而不是同时匹配两个条件。</p><h4 id="（3）计算次序"><a href="#（3）计算次序" class="headerlink" title="（3）计算次序"></a>（3）计算次序</h4><p>​WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂和高级的过滤。<br>​但是，组合AND和OR带来了一个有趣的问题。为了说明这个问题，来看一个例子。假如需要列出价格为10美元(含）以上且由1002或1003制造的所有产品。下面的SELECT语句使用AND和OR操作符的组合建立了一个WHERE子句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price, vend_id<br>FROM products<br>WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &gt;= 10;<br></code></pre></td></tr></table></figure><p>​上面的结果返回的行中有两行价格小于10美元，显然，返回的行未按预期的进行过滤。为什么会这样呢?原因在于计算的次序。SQL(像多数语言一样）在处理OR操作符前，优先处理AND操作符。当SQL看到上述WHERE子句时，它理解为由供应商1003制造的任何价格为10美元(含）以上的产品，或者由供应商1002制造的任何产品，而不管其价格如何。换句话说，由于AND在计算次序中优先级更高，操作符被错误地组合了。</p><p>​此问题的解决方法是使用圆括号明确地分组相应的操作符。请看下面的SELECT语句及输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price, vend_id<br>FROM products<br>WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;<br></code></pre></td></tr></table></figure><p>​这条SELECT语句与前一条的唯一差别是，这条语句中，前两个条件用圆括号括了起来。因为圆括号具有较AND或OR操作符高的计算次序，DBMS首先过滤圆括号内的OR条件。这时，SQL语句变成了选择由供应商1002或1003制造的且价格都在10美元(含）以上的任何产品，这正是我们所希望的。</p><blockquote><p>​<strong>在WHERE子句中使用圆括号</strong> 任何时候使用具有AND和OR操作符的WHERE子句,都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。</p></blockquote><h3 id="2、IN操作符"><a href="#2、IN操作符" class="headerlink" title="2、IN操作符"></a>2、IN操作符</h3><p>​圆括号在<strong>WHERE</strong>子句中还有另外一种用法。<strong>IN</strong>操作符用来指定条件范围，范围中的每个条件都可以进行匹配。<strong>IN</strong>取合法值的由逗号分隔的清单，全都括在圆括号中。下面的例子说明了这个操作符:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id in(1002, 1003)<br>ORDER BY prod_name<br></code></pre></td></tr></table></figure><p>​此<strong>SELECT</strong>语句检索供应商1002和<strong>1003</strong>制造的所有产品。IN操作符后跟由逗号分隔的合法值清单，整个清单必须括在圆括号中。</p><p>​如果你认为<strong>IN</strong>操作符完成与OR相同的功能，那么你的这种猜测是对的。下面的<strong>SQL</strong>语句完成与上面的例子相同的工作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id = 1002 OR vend_id = 1003<br>ORDER BY prod_name<br></code></pre></td></tr></table></figure><p>​为什么要使用IN操作符?其优点具体如下?</p><ul><li>在使用长的合法选项清单时，<strong>IN</strong>操作符的语法更清楚且更直观。</li><li>在使用<strong>IN</strong>时，计算的次序更容易管理（因为使用的操作符更少)。<strong>IN</strong>操作符一般比<strong>OR</strong>操作符清单执行更快。</li><li><strong>IN</strong>的最大优点是可以包含其他<strong>SELECT</strong>语句,使得能够更动态地建立<strong>WHERE</strong>子句。第14章将对此进行详细介绍。</li></ul><h3 id="3、NOT操作符"><a href="#3、NOT操作符" class="headerlink" title="3、NOT操作符"></a>3、<strong>NOT</strong>操作符</h3><p>​<strong>WHERE</strong>子句中的<strong>NOT</strong>操作符有且只有一个功能，那就是否定它之后所跟的任何条件。</p><p>​下面的例子说明<strong>NOT</strong>的使用。为了列出除<strong>1002</strong>和<strong>1003</strong>之外的所有供应商制造的产品，可编写如下的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id NOT IN (1002, 1003)<br>ORDER BY prod_name<br></code></pre></td></tr></table></figure><p>​这里的<strong>NOT</strong>否定跟在它之后的条件，因此，<strong>MySQ</strong>L不是匹配<strong>1002</strong>和<strong>1003</strong>的<strong>vend_id</strong>，而是匹配<strong>1002</strong>和<strong>1003</strong>之外供应商的<strong>vend_id</strong>。<br>​为什么使用<strong>NOT</strong>?对于简单的<strong>WHERE</strong>子句，使用<strong>NOT</strong>确实没有什么优势。但在更复杂的子句中，<strong>NOT</strong>是非常有用的。例如，在与<strong>IN</strong>操作符联合使用时，<strong>NOT</strong>使找出与条件列表不匹配的行非常简单。</p><blockquote><p><strong>MySQL中的NOT</strong> <strong>MySQL</strong>支持使用<strong>NOT</strong>对<strong>IN</strong>、<strong>BETWEEN</strong>和<strong>EXISTS</strong>子句取反,这与多数其他<strong>DBMS</strong>允许使用<strong>NOT</strong>对各种条件取反有很大的差别。</p></blockquote><h2 id="八、用通配符进行过滤"><a href="#八、用通配符进行过滤" class="headerlink" title="八、用通配符进行过滤"></a>八、用通配符进行过滤</h2><h3 id="1、LIKE操作符"><a href="#1、LIKE操作符" class="headerlink" title="1、LIKE操作符"></a>1、<strong>LIKE</strong>操作符</h3><h4 id="（1）百分号（-）通配符"><a href="#（1）百分号（-）通配符" class="headerlink" title="（1）百分号（%）通配符"></a>（1）百分号（%）通配符</h4><p>​最常使用的通配符是百分号(<strong>%</strong>)。在搜索串中，**%<strong>表示任何字符出现任意次数。例如，为了找出所有以词</strong>jet<strong>起头的产品，可使用以下</strong>SELECT**语句;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &quot;jet%&quot;;<br></code></pre></td></tr></table></figure><p>​此例子使用了搜索模式’<strong>jet%</strong>‘。在执行这条子句时，将检索任意以<strong>jet</strong>起头的词。**%**告诉MySQL接受jet之后的任意字符，不管它有多少字符。</p><p>​通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。下面的例子使用两个通配符，它们位于模式的两端:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &quot;%anvil%&quot;;<br></code></pre></td></tr></table></figure><p>​搜索模式’<strong>%anvil%</strong>‘表示匹配任何位置包含文本<strong>anvil</strong>的值，而不论它之前或之后出现什么字符。</p><p>​通配符也可以出现在搜索模式的中间，虽然这样做不太有用。下面的例子找出以<strong>s</strong>起头以<strong>e</strong>结尾的所有产品:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &quot;s%e&quot;;<br></code></pre></td></tr></table></figure><p>​重要的是要注意到，除了一个或多个字符外，**%<strong>还能匹配0个字符。</strong>%**代表搜索模式中给定位置的0个、1个或多个字符。</p><h4 id="（2）下划线（-通配符"><a href="#（2）下划线（-通配符" class="headerlink" title="（2）下划线（_)通配符"></a>（2）下划线（_)通配符</h4><p>​另一个有用的通配符是下划线**(_)**。下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。</p><p>​举一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &#x27;_ ton anvil&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>ANV021 ton anvil</p><p>ANV032 ton anvil</p></blockquote><p>​此WHERE子句中的搜索模式给出了后面跟有文本的两个通配符。结果只显示匹配搜索模式的行:第一行中下划线匹配1，第二行中匹配2。.5 ton anvil产品没有匹配，因为搜索模式要求匹配两个通配符而不是一个。对照一下，下面的SELECT语句使用%通配符，返回三行产品:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE <span class="hljs-string">&#x27;% ton anvil&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>ANV01.5 ton anvil<br>ANV021 ton anvil<br>ANV032 ton anvil</p></blockquote><h3 id="2、通配符使用技巧"><a href="#2、通配符使用技巧" class="headerlink" title="2、通配符使用技巧"></a>2、通配符使用技巧</h3><p>​正如所见，MySQL的通配符很有用。但这种功能是有代价的:通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li><p>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</p></li><li><p>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</p></li><li><p>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</p><p>总之，通配符是一种极重要和有用的搜索工具，以后我们经常会用到它。</p></li></ul><h2 id="九、用正则表达式进行搜索"><a href="#九、用正则表达式进行搜索" class="headerlink" title="九、用正则表达式进行搜索"></a>九、用正则表达式进行搜索</h2><h3 id="1、正则表达式介绍"><a href="#1、正则表达式介绍" class="headerlink" title="1、正则表达式介绍"></a>1、正则表达式介绍</h3><p>​前两章中的过滤例子允许用匹配、.比较和通配操作符寻找数据。对于基本的过滤（或者甚至是某些不那么基本的过滤)，这样就足够了。但随着过滤条件的复杂性的增加，WHERE子句本身的复杂性也有必要增加。<br>​这也就是正则表达式变得有用的地方。正则表达式是用来匹配文本的特殊的串(字符集合)。如果你想从一个文本文件中提取电话号码，可以使用正则表达式。如果你需要查找名字中间有数字的所有文件，可以使用一个正则表达式。如果你想在一个文本块中找到所有重复的单词，可以使用一个正则表达式。如果你想替换一个页面中的所有URL为这些URL的实际HTML链接,也可以使用一个正则表达式(对于最后这个例子，或者是两个正则表达式)。<br>​所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。有见识的程序员和网络管理员已经关注作为他们技术工具重要内容的正则表达式很长时间了。<br>​正则表达式用正则表达式语言来建立，正则表达式语言是用来完成刚讨论的所有工作以及更多工作的一种特殊语言。与任意语言一样，正则表达式具有你必须学习的特殊的语法和指令。</p><h3 id="2、使用MySQL正则表达式"><a href="#2、使用MySQL正则表达式" class="headerlink" title="2、使用MySQL正则表达式"></a>2、使用MySQL正则表达式</h3><p>​那么，正则表达式与MySQL有何关系?已经说过，正则表达式的作用是匹配文本,将一个模式(正则表达式)与一个文本串进行比较。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。</p><h3 id="（1）基本字符匹配"><a href="#（1）基本字符匹配" class="headerlink" title="（1）基本字符匹配"></a>（1）基本字符匹配</h3><p>​我们从一个非常简单的例子开始。下面的语句检索列<strong>prod_name</strong>包含文本<strong>1000</strong>的所有行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;1000&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><p>​除关键字<strong>LIKE</strong>被<strong>REGEXP</strong>替代外，这条语句看上去非常像使用LIKE的语句(第8章)。它告诉<strong>MySQL</strong>: <strong>REGEXP</strong>后所跟的东西作为正则表达式(与文字正文1000匹配的一个正则表达式）处理。</p><p>​为什么要费力地使用正则表达式?在刚才的例子中，正则表达式确实没有带来太多好处（可能还会降低性能)，不过，请考虑下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;.000&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>JetPack 1000<br>JetPack 2000</p></blockquote><p>​这里使用了正则表达式**.000<strong>。.是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，</strong>1000<strong>和</strong>2000**都匹配且返回。</p><blockquote><p>​<strong>匹配不区分大小写</strong> MySQL中的正则表达式匹配(自版本3.23.4后)不区分大小写(即,大写和小写都匹配)。为区分大小写,可使用<strong>BINARY</strong>关键字,如<code>WHERE prod_name REGEXPBINARY &#39;JetPack .000&#39;</code>.</p></blockquote><h3 id="（2）进行OR匹配"><a href="#（2）进行OR匹配" class="headerlink" title="（2）进行OR匹配"></a>（2）进行OR匹配</h3><p>​为搜索两个串之一(或者为这个串，或者为另一个串)，使用|，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;1000|2000&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>JetPack 1000<br>JetPack 2000</p></blockquote><p>​语句中使用了正则表达式<code>1000 | 2000</code>。**|<strong>为正则表达式的</strong>OR<strong>操作符。它表示匹配其中之一，因此</strong>1000<strong>和</strong>2000<strong>都匹配并返回。使用|从功能上类似于在</strong>SELECT<strong>语句中使用</strong>OR<strong>语句，多个</strong>OR**条件可并入单个正则表达式。</p><h3 id="（3）匹配几个字符之一"><a href="#（3）匹配几个字符之一" class="headerlink" title="（3）匹配几个字符之一"></a>（3）匹配几个字符之一</h3><p>​匹配任何单一字符。但是，如果你只想匹配特定的字符，怎么办?可通过指定一组用**[和]**括起来的字符来完成，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;[123] Ton&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>1 ton anvil<br>2 ton anvil</p></blockquote><p>​这里，使用了正则表达式<code>[ 123] Ton</code>。<code>[ 123]</code>定义一组字符，它的意思是匹配1或2或3，因此，1 ton和2 ton都匹配且返回(没有3 ton)。<br>​正如所见,<strong>[ ]<strong>是另一种形式的OR语句。事实上,正则表达式<code>[ 123]Ton</code>为<code>[ 1|2|3]Ton</code>的缩写，也可以使用后者。但是，需要用</strong>[]<strong>来定义</strong>OR</strong>语句查找什么。为更好地理解这一点，请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;1|2|3 Ton&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>prod_name<br>1 ton anvil<br>2 ton anvil<br>JetPack 1000<br>JetPack 2000<br>TNT (1 stick)</p></blockquote><p>​这并不是期望的输出。两个要求的行被检索出来，但还检索出了另外3行。之所以这样是由于MySQL假定你的意思是’1’或’2’或’3 ton’。除非把字符|括在一个集合中，否则它将应用于整个串。</p><p>​字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1、2或3，但[^123]却匹配除这些字符外的任何东西。</p><h3 id="（4）匹配范围"><a href="#（4）匹配范围" class="headerlink" title="（4）匹配范围"></a>（4）匹配范围</h3><p>​集合可用来定义要匹配的一个或多个字符。例如，下面的集合将匹配数字0到9:</p><blockquote><p>[0123456789]</p></blockquote><p>​为简化这种类型的集合，可使用-来定义一个范围。下面的式子功能上等同于上述数字列表:</p><blockquote><p>[0-9]</p></blockquote><p>​范围不限于完整的集合，**[ 1-3]<strong>和</strong>[6-9]<strong>也是合法的范围。此外，范围不一定只是数值的，</strong>[a-z]**匹配任意字母字符。<br>举一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;[1-5] Ton&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>prod_name<br>.5 ton anvil<br>1 ton anvil<br>2 ton anvil</p></blockquote><p>​这里使用正则表达式<code>[ 1-5] Ton</code>。**[ 1-5]<strong>定义了一个范围，这个表达式意思是匹配1到5，因此返回3个匹配行。由于</strong>5 ton**匹配，所以返回.<strong>5 ton</strong>。</p><h3 id="（5）匹配特殊字符"><a href="#（5）匹配特殊字符" class="headerlink" title="（5）匹配特殊字符"></a>（5）匹配特殊字符</h3><p>​正则表达式语言由具有特定含义的特殊字符构成。我们已经看到**.<strong>、</strong>[]<strong>、</strong>|**和-等，还有其他一些字符。请问，如果你需要匹配这些字符，应该怎么办呢?</p><p>​例如,如果要找出包含**.**字符的值,怎样搜索?请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name<br>FROM vendors<br>WHERE vend_name REGEXP &#x27;.&#x27;<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><blockquote><p>vend_name<br>ACME<br>Anvils R Us<br>Furball Inc.<br>Jet Set<br>Jouets Et Ours<br>LT Supplies</p></blockquote><p>​这并不是期望的输出，**.<strong>匹配任意字符，因此每个行都被检索出来。<br>​为了匹配特殊字符，必须用<code>\\</code>为前导。<code>ll-</code>表示查找</strong>-<strong>，<code>ll.</code>表示查找</strong>.**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name<br>FROM vendors<br>WHERE vend_name REGEXP &#x27;\\.&#x27;<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><blockquote><p>vend_name<br>Furball Inc.</p></blockquote><p>​有字符都必须以这种方式转义。这包括**.<strong>、</strong>|<strong>、</strong>[]**以及迄今为止使用过的其他特殊字符。</p><h3 id="（6）匹配字符类"><a href="#（6）匹配字符类" class="headerlink" title="（6）匹配字符类"></a>（6）匹配字符类</h3><p>​存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类。如下：</p><p><img src="/images/%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB.png" alt="字符类"></p><h2 id="十、创建计算字段"><a href="#十、创建计算字段" class="headerlink" title="十、创建计算字段"></a>十、创建计算字段</h2><h2 id="十一、使用数据处理函数"><a href="#十一、使用数据处理函数" class="headerlink" title="十一、使用数据处理函数"></a>十一、使用数据处理函数</h2><h3 id="1、使用函数"><a href="#1、使用函数" class="headerlink" title="1、使用函数"></a>1、使用函数</h3><p>​大多数SQL实现支持以下类型的函数。</p><ul><li>用于处理文本串（如删除或填充值，转换值为大写或小写)的文本函数。</li><li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算)的数值函数。</li><li>用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的日期和时间函数。</li><li>返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。</li></ul><h4 id="（1）文本处理函数"><a href="#（1）文本处理函数" class="headerlink" title="（1）文本处理函数"></a>（1）文本处理函数</h4><p>​下面是一个使用upper()函数的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, UPPER(vend_name) AS vend_name_upcase<br>FROM vendors<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><blockquote><p>vend_namevend_name_upcase<br>ACMEACME<br>Anvils R UsANVILS R US<br>Furball Inc.FURBALL INC.<br>Jet SetJET SET<br>Jouets Et OursJOUETS ET OURS<br>LT SuppliesLT SUPPLIES</p></blockquote><p>​正如所见，<strong>upper()<strong>将文本转换为大写，因此本例子中每个供应商都列出两次，第一次为</strong>vendors</strong>表中存储的值，第二次作为列<strong>vend_name_upcase</strong>转换为大写。</p><p>​下面列出了常用的文本处理函数：</p><p><img src="/images/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png"></p><p><img src="/images/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B01.png" alt="常用的文本处理函数"></p><p>​上面SOUNDEX需要做进一步的解释。SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对sOUNDEX的支持。<br>​下面给出一个使用Soundex()函数的例子。customers表中有一个顾客coyote Inc.，其联系名为Y.Lee。但如果这是输入错误，此联系名实际应该是Y.Lie,怎么办?显然,按正确的联系名搜索不会返回数据，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE cust_contact = &#x27;Y. Lie&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact</p></blockquote><p>​现在试一下使用<strong>Soundex()<strong>函数进行搜索，它匹配所有发音类似于</strong>Y.Lie</strong>的联系名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE Soundex(cust_contact) = Soundex(&#x27;Y. Lie&#x27;);<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact<br>Coyote Inc.Y Lee</p></blockquote><h4 id="（2）日期和时间处理函数"><a href="#（2）日期和时间处理函数" class="headerlink" title="（2）日期和时间处理函数"></a>（2）日期和时间处理函数</h4><p>​日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。<br>​一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。<br>​下面列出了某些常用的日期和时间处理函数。</p><p><img src="/images/%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" alt="常用日期和时间处理函数"></p><p>​需要注意的是MySQL使用的日期格式。无论你什么时候指定一<br>个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式<code>yyyy-mm-dd</code>。因此，2<strong>005年9月1日</strong>，给出为<strong>2005-09-01</strong>。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性（如，04&#x2F;05&#x2F;06是<strong>2006年5月4日</strong>或2006年4月5日或<strong>2004年5月6日</strong>或……)。</p><p>​因此基本的日期比较应该很简单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE order_date = &#x27;2005-09-01&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_numorder_date<br>10001200052005-09-01 00:00:00</p></blockquote><p>​但是，使用<code>WHERE order_date = &#39;2005-09-01&#39;</code>可靠吗?<strong>order_ date</strong>的数据类型为<strong>datetime</strong>。这种类型存储日期及时间值。样例表中的值全都具有时间值<strong>00:00:00</strong>,但实际中很可能并不总是这样。如果用当前日期和时间存储订单日期(因此你不仅知道订单日期，还知道下订单当天的时间)，怎么办?比如，存储的<strong>order_date</strong>值为<strong>2005-09-01 11:30:05</strong>，则<code>WHERE order_date = &#39;2005-09-01&#39;</code>失败。即使给出具有该日期的一行，也不会把它检索出来，因为<strong>WHERE</strong>匹配失败。<br>​解决办法是指示MySQL仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较。为此，必须使用Date()函数。Date(order_date)指示MySQL仅提取列的日期部分，更可靠的SELECT语句为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE Date(order_date) = &#x27;2005-09-01&#x27;;<br></code></pre></td></tr></table></figure><p>​不过，还有一种日期比较需要说明。如果你想检索出<strong>2005年9月</strong>下的所有订单，怎么办?简单的相等测试不行，因为它也要匹配月份中的天数。有几种解决办法，其中之一如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE Date(order_date) BETWEEN &#x27;2005-09-01&#x27; AND &#x27;2005-09-30&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_numorder_date<br>10001200052005-09-01 00:00:00<br>10003200062005-09-12 00:00:00<br>10004200072005-09-30 00:00:00</p></blockquote><p>​还有另外一种办法（一种不需要记住每个月中有多少天或不需要操心闰年2月的办法):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE YEAR(order_date) = 2005 AND Month(order_date) = 9;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_numorder_date<br>10001200052005-09-01 00:00:00<br>10003200062005-09-12 00:00:00<br>10004200072005-09-30 00:00:00</p></blockquote><p>​Year()是一个从日期(或日期时间)中返回年份的函数。类似，Month( )从日期中返回月份。因此, <code>WHERE Year(order_date)= 2005 AND Month (order_date) =9</code>检索出<strong>order_date</strong>为2005年9月的所有行。</p><h4 id="（3）数值处理函数"><a href="#（3）数值处理函数" class="headerlink" title="（3）数值处理函数"></a>（3）数值处理函数</h4><p>​数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期-时间处理函数的使用那么频繁。</p><p>​具有讽刺意味的是，在主要DBMS的函数中，数值函数是最一致最统一的函数。下面列出一些常用的数值处理函数。</p><p><img src="/images/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" alt="常用数值处理函数"></p><h2 id="十二、汇总数据"><a href="#十二、汇总数据" class="headerlink" title="十二、汇总数据"></a>十二、汇总数据</h2><h3 id="1、聚集函数"><a href="#1、聚集函数" class="headerlink" title="1、聚集函数"></a>1、聚集函数</h3><p>​我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有以下几种。</p><ul><li>确定表中行数（或者满足某个条件或包含某个特定值的行数)。</li><li>获得表中行组的和。</li><li>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。</li></ul><p>​上述例子都需要对表中数据（而不是实际数据本身）汇总。因此，返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了)。重复一遍，实际想要的是汇总信息。<br>​为方便这种类型的检索，MySQL给出了5个聚集函数，见下图1。这些函数能进行上述罗列的检索。</p><p><img src="/images/SQL%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0.png" alt="SQL聚集函数"></p><h4 id="（1）AVG-函数"><a href="#（1）AVG-函数" class="headerlink" title="（1）AVG()函数"></a>（1）AVG()函数</h4><p>​**AVG( )**通过对表中行数计数并计算特定列值之和，求得该列的平均值。AVG ( )可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。</p><p>下面的例子使用<strong>AVG()<strong>返回</strong>products</strong>表中所有产品的平均价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(prod_price) AS avg_price<br>FROMproducts;<br></code></pre></td></tr></table></figure><p>​此SELECT语句返回值<strong>avg_Price</strong>，它包含<strong>products</strong>表中所有产品的平均价格。<strong>avg_price</strong>是一个别名。</p><p>​**AVG()**也可以用来确定特定列或行的平均值。下面的例子返回特定供应商所提供产品的平均价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(prod_price) AS avg_price<br>FROMproducts<br>WHERE vend_id = 1003;<br></code></pre></td></tr></table></figure><blockquote><p>avg_price<br>13.212857</p></blockquote><p>​这条SELECT语句与前一条的不同之处在于它包含了<strong>WHERE</strong>子句。此<strong>WHERE</strong>子句仅过滤出<strong>vend_id</strong>为1003的产品，因此<br>​<strong>avg_price</strong>中返回的值只是该供应商的产品的平均值。</p><h4 id="（2）COUNT-函数"><a href="#（2）COUNT-函数" class="headerlink" title="（2）COUNT()函数"></a>（2）COUNT()函数</h4><p>​<em>*COUNT()<strong>函数进行计数。可利用</strong>COUNT()<strong>确定表中行的数目或符合特定条件的行的数目。<br>​COUNT( )函数有两种使用方式。<br>​使用</strong>COUNT(* )<strong>对表中行的数目进行计数,不管表列中包含的是空<br>值</strong>（NULL)<strong>还是非空值。<br>​使用</strong>COUNT (column)<strong>对特定列中具有值的行进行计数，忽略</strong>NULL</em>*值。<br>​下面的例子返回<strong>customers</strong>表中客户的总数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) AS num_cust <br>FROM customers;<br></code></pre></td></tr></table></figure><blockquote><p>num_cust<br>5</p></blockquote><p>​在此例子中，利用<strong>COUNT (*)<strong>对所有行计数，不管行中各列有什么值。计数值在</strong>num_cust</strong>中返回。</p><p>​下面的例子只对具有电子邮件地址的客户计数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(cust_email) AS num_cust <br>FROM customers;<br></code></pre></td></tr></table></figure><blockquote><p>num_cust<br>3</p></blockquote><p>​这条<strong>SELECT</strong>语句使用<strong>COUNT (cust_email)<strong>对</strong>cust_email</strong>列中有值的行进行计数。在此例子中,<strong>cust_email</strong>的计数为3(表示5个客户中只有3个客户有电子邮件地址)。</p><blockquote><p><strong>NULL</strong> 值如果指定列名，则指定列的值为空的行被COUNT()函数忽略，但如果**COUNT ()*<em>函数中用的是星号（</em>),则不忽略。</p></blockquote><h4 id="（3）MAX-函数"><a href="#（3）MAX-函数" class="headerlink" title="（3）MAX()函数"></a>（3）MAX()函数</h4><p>**MAX()**返回指定列中的最大值。MAX()要求指定列名，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX(prod_price) AS max_price <br>FROM products;<br></code></pre></td></tr></table></figure><blockquote><p>max_price<br>55.00</p></blockquote><p>​这里，<strong>MAX()<strong>返回</strong>products</strong>表中最贵的物品的价格。</p><h4 id="（4）MIN-函数"><a href="#（4）MIN-函数" class="headerlink" title="（4）MIN()函数"></a>（4）MIN()函数</h4><p>​<strong>MIN()<strong>的功能正好与MAX()功能相反，它返回指定列的</strong>最小值</strong>。与**MAX ()**一样，MIN()要求指定列名，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT min(prod_price) AS max_price <br>FROM products;<br></code></pre></td></tr></table></figure><blockquote><p>max_price<br>2.50</p></blockquote><h4 id="（5）SUM-函数"><a href="#（5）SUM-函数" class="headerlink" title="（5）SUM()函数"></a>（5）SUM()函数</h4><p>​SUM()用来返回指定列值的和（总计）。</p><p>​下面举一个例子，<strong>orderitems</strong>表包含订单中实际的物品，每个物品有相应的数量（ <strong>quantity</strong>)。可如下检索所订购物品的总数（所有<strong>quantity</strong>值之和):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(quantity) AS items_ordered <br>FROM orderitems<br>WHERE order_num = 20005;<br></code></pre></td></tr></table></figure><blockquote><p>items_ordered<br>19</p></blockquote><p>​<strong>SUM()<strong>也可以用来合计计算值。在下面的例子中，合计每项物品的</strong>item_price*quantity</strong>，得出总的订单金额:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(quantity * item_price) AS items_ordered <br>FROM orderitems<br>WHERE order_num = 20005;<br></code></pre></td></tr></table></figure><blockquote><p>items_ordered<br>149.87</p></blockquote><h3 id="2、聚集不同值-DISTINCT"><a href="#2、聚集不同值-DISTINCT" class="headerlink" title="2、聚集不同值 DISTINCT"></a>2、聚集不同值 DISTINCT</h3><p>​下面的例子使用<strong>AVG()<strong>函数返回特定供应商提供的产品的平均价格。它与上面的SELECT语句相同，但使用了</strong>DISTINCT</strong>参数，因此平均值只考虑各个不同的价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(DISTINCT prod_price) AS avg_price <br>FROM products<br>WHERE vend_id = 1003;<br></code></pre></td></tr></table></figure><blockquote><p>avg_price<br>15.998000</p></blockquote><p>​可以看到，在使用了<strong>DISTINCT</strong>后，此例子中的<strong>avg_price</strong>比较高，因为有多个物品具有相同的较低价格。排除它们提升了平均价格。</p><h3 id="3、组合聚集函数"><a href="#3、组合聚集函数" class="headerlink" title="3、组合聚集函数"></a>3、组合聚集函数</h3><p>​目前为止的所有聚集函数例子都只涉及单个函数。但实际上<strong>SELECT</strong>语句可根据需要包含多个聚集函数。请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) AS num_items,<br>MIN(prod_price) AS price_min,<br>MAX(prod_price) AS price_max,<br>AVG(prod_price) AS price_avg<br>FROM products;<br></code></pre></td></tr></table></figure><blockquote><p>num_itemsprice_minprice_maxprice_avg<br>142.5055.0016.133571</p></blockquote><p>​这里用单条SELECT语句执行了4个聚集计算，返回4个值( <strong>products</strong>表中物品的数目，产品价格的最高、最低以及平均值）。</p><h2 id="十三、分组数据"><a href="#十三、分组数据" class="headerlink" title="十三、分组数据"></a>十三、分组数据</h2><h3 id="1、数据分组"><a href="#1、数据分组" class="headerlink" title="1、数据分组"></a>1、数据分组</h3><p>​从上一章知道，SQL聚集函数可用来汇总数据。这使我们能够对行进行计数，计算和与平均数，获得最大和最小值而不用检索所有数据。<br>​目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。提示一下，下面的例子返回供应商1003提供的产品数目:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) AS num_prods <br>FROM products<br>WHERE vend_id = 1003;<br></code></pre></td></tr></table></figure><blockquote><p>num_prods<br>7</p></blockquote><p>​但如果要返回每个供应商提供的产品数目怎么办?或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办?<br>​这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。</p><h3 id="2、创建分组"><a href="#2、创建分组" class="headerlink" title="2、创建分组"></a>2、创建分组</h3><p>​分组是在SELECT语句的<strong>GROUP BY</strong>子句中建立的。理解分组的最好办法是看一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, COUNT(*) AS num_prods <br>FROM products<br>GROUP BY vend_id;<br></code></pre></td></tr></table></figure><blockquote><p>vend_idnum_prods<br>10013<br>10022<br>10037<br>10052</p></blockquote><p>​上面的SELECT语句指定了两个列，<strong>vend_id</strong>包含产品供应商的<strong>ID</strong>，<strong>num_prods</strong>为计算字段（用<strong>COUNT(*)<strong>函数建立)。GROUP BY<br>子句指示MySQL按</strong>vend_id</strong>排序并分组数据。这导致对每个<strong>vend_id</strong>而不是整个表计算<strong>num_prods</strong>一次。从输出中可以看到,供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。<br>因为使用了<strong>GROUP BY</strong>，就不必指定要计算和估值的每个组了。系统会自动完成。<strong>GROUP BY</strong>子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。<br>​在具体使用<strong>GROUP BY</strong>子句前，需要知道一些重要的规定。</p><ul><li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果在<strong>GROUP BY</strong>子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算(所以不能从个别的列取回数据)。</li><li><strong>GROUP BY</strong>子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在SELECT中使用表达式，则必须在<strong>GROUP BY</strong>子句中指定相同的表达式。不能使用别名。</li><li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li><li>如果分组列中具有<strong>NULL</strong>值，则<strong>NULL</strong>将作为一个分组返回。如果列中有多行<strong>NULL</strong>值，它们将分为一组。</li><li><strong>GROUP BY</strong>子句必须出现在WHERE子句之后，<strong>ORDER BY</strong>子句之前。</li></ul><h3 id="3、过滤分组"><a href="#3、过滤分组" class="headerlink" title="3、过滤分组"></a>3、过滤分组</h3><p>​除了能用<strong>GROUP BY</strong>分组数据外，MySQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，可能想要列出至少有两个订单的所有顾客。为得出这种数据，必须基于完整的分组而不是个别的行进行过滤。<br>​我们已经看到了<strong>WHERE</strong>子句的作用(第6章中引入)。但是，在这个例子中<strong>WHERE</strong>不能完成任务，因为<strong>WHERE</strong>过滤指定的是行而不是分组。事实上，<strong>WHERE</strong>没有分组的概念。<br>​那么，不使用<strong>WHERE</strong>使用什么呢? MySQL为此目的提供了另外的子句，那就是<strong>HAVING</strong>子句。<strong>HAVING</strong>非常类似于WHERE。事实上，目前为止所学过的所有类型的<strong>WHERE</strong>子句都可以用<strong>HAVING</strong>来替代。唯一的差别是<strong>WHERE</strong>过滤行，而<strong>HAVING</strong>过滤分组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, COUNT(*) AS orders<br>FROM orders<br>GROUP BY cust_id<br>HAVING COUNT(*) &gt;= 2;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorders<br>100012</p></blockquote><p>​这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(* ) &gt;&#x3D;2(两个以上的订单）的那些分组。</p><p>​那么，有没有在一条语句中同时使用<strong>WHERE</strong>和<strong>HAVING</strong>子句的需要呢﹖事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点,可增加一条<strong>WHERE</strong>子句，过滤出过去12个月内下过的订单。然后再增加<strong>HAVING</strong>子句过滤出具有两个以上订单的分组。</p><p>​为更好地理解，请看下面的例子，它列出具有<strong>2个</strong>（含)以上、价格10(含）以上的产品的供应商:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, COUNT(*) AS num_prods <br>FROM products<br>WHERE prod_price &gt;= 10<br>GROUP BY vend_id<br>HAVING COUNT(*) &gt;= 2<br></code></pre></td></tr></table></figure><blockquote><p>vend_idnum_prods<br>10034<br>10052</p></blockquote><p>​这条语句中，第一行是使用了聚集函数的基本SELECT，它与前面的例子很相像。WHERE子句过滤所有prod_price至少为10的行。然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。</p><p>​如果没有WHERE子句，将会多检索出两行（供应商1002，销售的所有产品价格都在10以下;供应商1001，销售3个产品，但只有一个产品的价格大于等于10):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, COUNT(*) AS num_prods <br>FROM products<br>GROUP BY vend_id<br>HAVING COUNT(*) &gt;= 2<br></code></pre></td></tr></table></figure><blockquote><p>vend_idnum_prods<br>10013<br>10022<br>10037<br>10052</p></blockquote><h3 id="4、分组和排序"><a href="#4、分组和排序" class="headerlink" title="4、分组和排序"></a>4、分组和排序</h3><p>​虽然<strong>GROUPBY</strong>和<strong>ORDER BY</strong>经常完成相同的工作，但它们是非常不同的。下面汇总了它们之间的差别。</p><p>ORDER BY</p><ul><li>排序产生的输出</li><li>任意列都可以使用(甚至非选择的列也可以使用)</li><li>不一定需要</li></ul><p>GROUP BY</p><ul><li>分组行。但输出可能不是分组的顺序</li><li>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</li><li>如果与聚集函数一起使用列（或表达式)，则必须使用</li></ul><p>​上面列出的第一项差别极为重要。我们经常发现用GROUP BY分组的数据确实是以分组顺序输出的。但情况并不总是这样，它并不是SQL规范所要求的。此外，用户也可能会要求以不同于分组的顺序排序。仅因为你以某种方式分组数据（获得特定的分组聚集值)，并不表示你需要以相同的方式排序输出。应该提供明确的ORDER BY子句，即使其效果等同于GROUP BY子句也是如此。</p><blockquote><p><strong>不要忘记ORDER</strong> BY一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p></blockquote><p>​为说明<strong>GROUP BY</strong>和ORDER BY的使用方法，请看一个例子。下面的SELECT语句类似于前面那些例子。它检索总计订单价格大于等于50的订单的订单号和总计订单价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT order_num, SUM(quantity * item_price) AS ordertotal <br>FROM orderitems<br>GROUP BY order_num <br>HAVING SUM(quantity * item_price) &gt;= 50<br></code></pre></td></tr></table></figure><blockquote><p>order_numordertotal<br>20005149.87<br>2000655.00<br>200071000.00<br>20008125.00</p></blockquote><p>​为按总计订单价格排序输出，需要添加<strong>ORDER BY</strong>子句，如下所示;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT order_num, SUM(quantity * item_price) AS ordertotal <br>FROM orderitems<br>GROUP BY order_num <br>HAVING SUM(quantity * item_price) &gt;= 50<br>ORDER BY ordertotal;<br></code></pre></td></tr></table></figure><blockquote><p>order_numordertotal<br>2000655.00<br>20008125.00<br>20005149.87<br>200071000.00</p></blockquote><p>​在这个例子中，<strong>GROUP BY</strong>子句用来按订单号(order_num列)分组数据，以便<em><em>SUM(</em> )<strong>函数能够返回总计订单价格。</strong>HAVING</em>*子句过滤数据，使得只返回总计订单价格大于等于<strong>50</strong>的订单。最后，用<strong>ORDER BY</strong>子句排序输出。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="十四、使用子查询"><a href="#十四、使用子查询" class="headerlink" title="十四、使用子查询"></a>十四、使用子查询</h2><h3 id="1、利用子查询进行过滤"><a href="#1、利用子查询进行过滤" class="headerlink" title="1、利用子查询进行过滤"></a>1、利用子查询进行过滤</h3><p>​订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。<br>现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索?下面列出具体的步骤。</p><p>​(1)检索包含物品TNT2的所有订单的编号。</p><p>​(2)检索具有前一步骤列出的订单编号的所有客户的ID。</p><p>​(3)检索前一步骤返回的所有客户ID的客户信息。</p><p>​上述每个步骤都可以单独作为一个查询来执行。可以把<strong>一条SELECT</strong>语句返回的结果<strong>用于另一条SELECT</strong>语句的WHERE子句。<br>​也可以使用子查询来把3个查询组合成一条语句。<br>​第一条SELECT语句的含义很明确,对于prod_id为TNT2的所有订单物品，它检索其order_num列。输出列出两个包含此物品的订单:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT order_num<br>FROM orderitems<br>WHERE prod_id = &#x27;TNT2&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>order_num<br>20005<br>20007</p></blockquote><p>​下一步，检索具有前一步骤列出的订单编号的所有客户的ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id<br>FROM orders<br>WHERE order_num IN (20005, 20007);<br></code></pre></td></tr></table></figure><blockquote><p>cust_id<br>10001<br>10004</p></blockquote><p>​现在，把第一个查询变为子查询，组合成两个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id<br>FROM orders<br>WHERE order_num IN (SELECT order_num<br>FROM orderitems<br>WHERE prod_id = &#x27;TNT2&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>cust_id<br>10001<br>10004</p></blockquote><p>​在<strong>SELECT</strong>语句中，子查询总是<strong>从内向外</strong>处理。在处理上面的SELECT语句时，MySQL实际上执行了两个操作。<br>首先，它执行下面的查询:<br><code>SELECT order_num FROM orderitems wHERE prod_id=&#39;TNT2&#39;</code><br>此查询返回两个订单号:20005和20007。然后，这两个值以IN操作符要求的逗号分隔的格式传递给外部查询的WHERE子句。外部查询变成:<br>​<code>SELECT cust_id FROM orders WHERE order_num IN (20005,20007)</code><br>可以看到，输出是正确的并且与前面硬编码WHERE子句所返回的值相同。</p><p>​现在得到了订购物品TNT2的所有客户的ID。下一步是检索这些客户ID的客户信息。检索两列的SQL语句为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE cust_id  IN (10001, 10004)<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact<br>Coyote Inc.Y Lee<br>Yosemite Place Y Sam</p></blockquote><p>​可以把其中的WHERE子句转换为子查询而不是硬编码这些客户ID:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE cust_id IN (SELECT cust_id<br>FROM orders<br>WHERE order_num IN (SELECT order_num<br>FROM orderitems<br>WHERE prod_id = &#x27;TNT2&#x27;))<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact<br>Coyote Inc.Y Lee<br>Yosemite Place Y Sam</p></blockquote><h3 id="2、作为计算字段使用子查询"><a href="#2、作为计算字段使用子查询" class="headerlink" title="2、作为计算字段使用子查询"></a>2、作为计算字段使用子查询</h3><p>​使用子查询的另一方法是创建计算字段。假如需要显示customers表中<strong>每个客户的订单总数</strong>。订单与相应的客户ID存储在orders表中。<br>为了执行这个操作，遵循下面的步骤。<br>​(1)从customers表中检索客户列表。<br>​(2)对于检索出的每个客户，统计其在orders表中的订单数目。</p><p>​为了对每个客户执行*<em>COUNT(</em>)<strong>计算，应该将</strong>COUNT (*)**作为一个子查询。请看下面的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>cust_name,<br>cust_state,<br>( SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id ) AS orders <br>FROM<br>customers <br>ORDER BY<br>cust_name<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_stateorders<br>Coyote Inc.MI2<br>E FuddIL 1<br>Mouse House   OH       0<br>Wascals  IN        1<br>Yosemite Place AZ1</p></blockquote><p>​这条SELECT语句对customers表中每个客户返回3列:cust_name、cust_state和orders。orders是一个<strong>计算字段</strong>，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一次。在此例子中，该子查询执行了5次，因为检索出了5个客户。<br>​子查询中的<strong>WHERE</strong>子句与前面使用的<strong>WHERE</strong>子句稍有不同,因为它使用了完全限定列名（在第4章中首次提到)。下面的语句告诉SQL比较<strong>orders表中的cust_id</strong>与<strong>当前正从customers</strong>表中检索的<strong>cust_id</strong>:<br><code>wHERE orders.cust_id = customers.cust_id</code></p><h2 id="十五、联结表"><a href="#十五、联结表" class="headerlink" title="十五、联结表"></a>十五、联结表</h2><h3 id="1、联结"><a href="#1、联结" class="headerlink" title="1、联结"></a>1、联结</h3><p>​SQL最强大的功能之一就是能在数据检索查询的执行中联结( join)表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是学习SQL的一个极为重要的组成部分。</p><h4 id="（1）关系表"><a href="#（1）关系表" class="headerlink" title="（1）关系表"></a>（1）关系表</h4><p>​理解关系表的最好方法是来看一个现实世界中的例子。<br>​假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。<br>​现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢?将这些数据与产品信息分开存储的理由如下。</p><ul><li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li><li>如果供应商信息改变（例如，供应商搬家或电话号码变动)，只需改动一次即可。</li><li>如果有重复数据（即每种产品都存储供应商信息)，很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li></ul><p>​关键是，相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系( relational ) )互相关联。<br>​在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。<strong>vendors</strong>表包含所有供应商信息，每个供应商占一行，<strong>每个供应商具有唯一</strong>的标识。此标识称为<strong>主键</strong>( primary key)(，可以是供应商ID或任何其他唯一值。<br>​<strong>products</strong>表只存储产品信息，它除了存储供应商ID(<strong>vendors</strong>表的主键）外不存储其他供应商信息。<strong>vendors表的主键</strong>又叫作<strong>products的外键</strong>，它将vendors表与products表关联，利用<strong>供应商ID</strong>能从vendors表中找出相应供应商的详细信息。</p><blockquote><p><strong>外键(foreign key)</strong>外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。<br>    这样做的好处如下:</p><ul><li>供应商信息不重复，从而不浪费时间和空间;</li><li>如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动;</li><li>由于数据无重复，显然数据是一致的，这使得处理数据更简单。</li></ul><p>​总之，关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。(foreign key)外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p></blockquote><blockquote><p><strong>可伸缩性(scale)</strong>能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好( scale well )。</p></blockquote><h4 id="（2）为什么要使用联结"><a href="#（2）为什么要使用联结" class="headerlink" title="（2）为什么要使用联结"></a>（2）为什么要使用联结</h4><p>​正如所述，分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。<br>​如果数据存储在多个表中，怎样用单条SELECT语句检索出数据?答案是使用<strong>联结</strong>。简单地说，联结是一种机制，用来在一条SELECT语句中<strong>关联表</strong>，因此称之为<strong>联结</strong>。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><h3 id="2、创建联结"><a href="#2、创建联结" class="headerlink" title="2、创建联结"></a>2、创建联结</h3><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可，请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, prod_name, prod_price<br>FROM vendors, products<br>WHERE vendors.vend_id = products.vend_id<br>ORDER BY vend_name, prod_name<br></code></pre></td></tr></table></figure><blockquote><p>vend_nameprod_nameprod_price<br>ACMEBird seed10.00<br>ACMECarrots2.50<br>ACMEDetonator13.00<br>ACMESafe50.00<br>ACMESling4.49<br>ACMETNT (1 stick)2.50<br>ACMETNT (5 sticks)10.00<br>Anvils R Us.5 ton anvil5.99<br>Anvils R Us1 ton anvil9.99<br>Anvils R Us2 ton anvil14.99<br>Jet SetJetPack 100035.00<br>Jet SetJetPack 200055.00<br>LT SuppliesFuses3.42<br>LT SuppliesOil can8.99</p></blockquote><p>​我们来考察一下此代码。SELECT语句与前面所有语句一样指定要检索的列。这里,最大的差别是所指定的两个列(prod_name<br>和prod_price)在一个表中，而另一个列(vend_name)在另一个表中。<br>​现在来看FROM子句。与以前的SELECT语句不一样，这条语句的FROM子句列出了两个表,分别是vendors和products。它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确联结，WHERE子句指示MySQL匹配<strong>vendors表中的vend_id</strong>和<strong>products表中的vend_id</strong>。<br>​可以看到要匹配的两个列以<strong>vendors.vend_id</strong>和<strong>products.vend_id</strong>指定。这里需要这种<strong>完全限定列名</strong>，因为如果只给出vend_id，则MySQL不知道指的是哪一个（它们有两个，每个表中一个)。</p><h4 id="（1）WHERE子句的重要性"><a href="#（1）WHERE子句的重要性" class="headerlink" title="（1）WHERE子句的重要性"></a>（1）WHERE子句的重要性</h4><p>​在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。<strong>WHERE</strong>子句作为<strong>过滤条件</strong>，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。</p><blockquote><p><strong>笛卡儿积(cartesian product)</strong>由没有联结条件的表关系返回的结果为<strong>笛卡儿积</strong>。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p></blockquote><p>​对于<strong>笛卡尔积</strong>的理解可以对比下述代码与上一个例子进行理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, prod_name, prod_price<br>FROM vendors, products<br>ORDER BY vend_name, prod_name<br></code></pre></td></tr></table></figure><blockquote><p>vend_nameprod_nameprod_price<br>ACME.5 ton anvil5.99<br>ACME1 ton anvil9.99<br>ACME2 ton anvil14.99<br>ACMEBird seed10.00<br>ACMECarrots2.50<br>ACMEDetonator13.00<br>ACMEFuses3.42<br>ACMEJetPack 100035.00<br>ACMEJetPack 200055.00<br>ACMEOil can8.99<br>ACMESafe50.00<br>ACMESling4.49<br>ACMETNT (1 stick)2.50<br>ACMETNT (5 sticks)10.00<br>Anvils R Us.5 ton anvil5.99<br>Anvils R Us1 ton anvil9.99<br>Anvils R Us2 ton anvil14.99<br>Anvils R UsBird seed10.00<br>Anvils R UsCarrots2.50<br>Anvils R UsDetonator13.00<br>Anvils R UsFuses3.42<br>Anvils R UsJetPack 100035.00<br>Anvils R UsJetPack 200055.00<br>Anvils R UsOil can8.99<br>Anvils R UsSafe50.00<br>Anvils R UsSling4.49<br>Anvils R UsTNT (1 stick)2.50<br>Anvils R UsTNT (5 sticks)10.00<br>Furball Inc..5 ton anvil5.99<br>Furball Inc.1 ton anvil9.99<br>Furball Inc.2 ton anvil14.99<br>Furball Inc.Bird seed10.00<br>Furball Inc.Carrots2.50<br>Furball Inc.Detonator13.00<br>Furball Inc.Fuses3.42<br>Furball Inc.JetPack 100035.00<br>Furball Inc.JetPack 200055.00<br>Furball Inc.Oil can8.99<br>Furball Inc.Safe50.00<br>Furball Inc.Sling4.49<br>Furball Inc.TNT (1 stick)2.50<br>Furball Inc.TNT (5 sticks)10.00<br>Jet Set.5 ton anvil5.99<br>Jet Set1 ton anvil9.99<br>Jet Set2 ton anvil14.99<br>Jet SetBird seed10.00<br>Jet SetCarrots2.50<br>Jet SetDetonator13.00<br>Jet SetFuses3.42<br>Jet SetJetPack 100035.00<br>Jet SetJetPack 200055.00<br>Jet SetOil can8.99<br>Jet SetSafe50.00<br>Jet SetSling4.49<br>Jet SetTNT (1 stick)2.50<br>Jet SetTNT (5 sticks)10.00<br>Jouets Et Ours.5 ton anvil5.99<br>Jouets Et Ours1 ton anvil9.99<br>Jouets Et Ours2 ton anvil14.99<br>Jouets Et OursBird seed10.00<br>Jouets Et OursCarrots2.50<br>Jouets Et OursDetonator13.00<br>Jouets Et OursFuses3.42<br>Jouets Et OursJetPack 100035.00<br>Jouets Et OursJetPack 200055.00<br>Jouets Et OursOil can8.99<br>Jouets Et OursSafe50.00<br>Jouets Et OursSling4.49<br>Jouets Et OursTNT (1 stick)2.50<br>Jouets Et OursTNT (5 sticks)10.00<br>LT Supplies.5 ton anvil5.99<br>LT Supplies1 ton anvil9.99<br>LT Supplies2 ton anvil14.99<br>LT SuppliesBird seed10.00<br>LT SuppliesCarrots2.50<br>LT SuppliesDetonator13.00<br>LT SuppliesFuses3.42<br>LT SuppliesJetPack 100035.00<br>LT SuppliesJetPack 200055.00<br>LT SuppliesOil can8.99<br>LT SuppliesSafe50.00<br>LT SuppliesSling4.49<br>LT SuppliesTNT (1 stick)2.50<br>LT SuppliesTNT (5 sticks)10.00</p></blockquote><p>​从上面的输出中可以看到，相应的笛卡儿积不是我们所想要的。这里返回的数据用每个供应商匹配了每个产品，它包括了<br>供应商不正确的产品。实际上有的供应商根本就没有产品。</p><h4 id="（2）内部联结"><a href="#（2）内部联结" class="headerlink" title="（2）内部联结"></a>（2）内部联结</h4><p>​目前为止所用的联结称为<strong>等值联结</strong>，它基于两个表之间的相等测试。这种联结也称为<strong>内部联结</strong>。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的SELECT语句返回与前面例子完全相同的数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, prod_name, prod_price<br>FROM vendors<br>INNER JOIN products <br>ON vendors.vend_id = products.vend_id<br></code></pre></td></tr></table></figure><blockquote><p>vend_nameprod_nameprod_price<br>Anvils R Us.5 ton anvil5.99<br>Anvils R Us1 ton anvil9.99<br>Anvils R Us2 ton anvil14.99<br>LT SuppliesFuses3.42<br>LT SuppliesOil can8.99<br>ACMEDetonator13.00<br>ACMEBird seed10.00<br>ACMECarrots2.50<br>ACMESafe50.00<br>ACMESling4.49<br>ACMETNT (1 stick)2.50<br>ACMETNT (5 sticks)10.00<br>Jet SetJetPack 100035.00<br>Jet SetJetPack 200055.00</p></blockquote><h4 id="（3）联结多个表"><a href="#（3）联结多个表" class="headerlink" title="（3）联结多个表"></a>（3）联结多个表</h4><p>​SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, vend_name, prod_price, quantity<br>FROM orderitems, products, vendors<br>WHERE products.vend_id = vendors.vend_id <br>AND orderitems.prod_id = products.prod_id<br>AND order_num = 20005<br></code></pre></td></tr></table></figure><blockquote><p>prod_namevend_nameprod_pricequantity<br>.5 ton anvilAnvils R Us5.9910<br>1 ton anvilAnvils R Us9.993<br>TNT (5 sticks)ACME10.005<br>Bird seedACME10.001</p></blockquote><p>​此例子显示编号为<strong>20005</strong>的订单中的物品。订单物品存储在<strong>orderitems</strong>表中。每个产品按其产品ID存储，它引用<strong>products</strong>表中的产品。这些产品通过供应商<strong>ID</strong>联结到<strong>vendors</strong>表中相应的供应商，供应商ID存储在每个产品的记录中。这里的<strong>FROM</strong>子句列出了3个表，而<strong>WHERE</strong>子句定义了这两个联结条件，而第三个联结条件用来过滤出订单<strong>20005</strong>中的物品。</p><h2 id="十六、创建高级联结"><a href="#十六、创建高级联结" class="headerlink" title="十六、创建高级联结"></a>十六、创建高级联结</h2><h3 id="1、使用表别名"><a href="#1、使用表别名" class="headerlink" title="1、使用表别名"></a>1、使用表别名</h3><p>​给列起别名的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CONCAT(RTrim(vend_name),&#x27;(&#x27;,RTRIM(vend_country), &#x27;)&#x27;) AS vend_title <br>FROM vendors<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><p>​<code>CONCAT(RTrim(vend_name), &#39;(&#39;, RTRIM(vend_country), &#39;)&#39;) AS vend_title</code>: 这个部分使用<code>CONCAT</code>函数将两个列的值组合在一起，创建了一个新的名为<code>vend_title</code>的列。<code>RTRIM</code>函数用于从列的末尾去掉空格，因此<code>RTRIM(vend_name)</code>和<code>RTRIM(vend_country)</code>将去除这些列中可能存在的多余空格。最终结果会将每个供应商的名称和国家组合成一个标题，并将其放在括号中</p><p>​别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由:</p><ul><li>缩短SQL语句;</li><li>允许在单条SELECT语句中多次使用相同的表。</li></ul><p>下面的例子，就是运用了别名的方式，其功能与上一章的例子基本相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers AS c, orders AS o, orderitems AS oi  <br>WHERE c.cust_id = o.cust_id<br>AND oi.order_num = o.order_num<br>AND prod_id = &#x27;TNT2&#x27;<br></code></pre></td></tr></table></figure><h3 id="2、使用不同类型的联结"><a href="#2、使用不同类型的联结" class="headerlink" title="2、使用不同类型的联结"></a>2、使用不同类型的联结</h3><h4 id="（1）自联结"><a href="#（1）自联结" class="headerlink" title="（1）自联结"></a>（1）自联结</h4><p>​如前所述，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表。下面举一个例子。<br>​假如你发现某物品(其<strong>ID</strong>为<strong>DTNTR</strong>）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产<strong>ID</strong>为<strong>DTNTR</strong>的物品的供应商，然后找出这个供应商生产的其他物品。下面是解决此问题的一种方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE vend_id = (SELECT vend_id<br> FROM products<br> WHERE prod_id = &#x27;DTNTR&#x27;);<br></code></pre></td></tr></table></figure><blockquote><p>prod_idprod_name<br>DTNTRDetonator<br>FBBird seed<br>FCCarrots<br>SAFESafe<br>SLINGSling<br>TNT1TNT (1 stick)<br>TNT2TNT (5 sticks)</p></blockquote><p>​这是第一种解决方案，它使用了<strong>子查询</strong>。内部的<strong>SELECT</strong>语句做了一个简单的检索，返回生产ID为DTNTR的物品供应商的vend_id。该ID用于外部查询的WHERE子句中，以便检索出这个供应商生产的所有物品（第14章中讲授了子查询的所有内容。更多信息请参阅该章)。</p><p>​下面是使用联结的相同查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT p1.prod_id, p1.prod_name<br>FROM products AS p1, products AS p2<br>WHERE p1.vend_id = p2.vend_id<br>AND p2.prod_id = &#x27;DTNTR&#x27;;<br></code></pre></td></tr></table></figure><p>​此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对<br>products的引用具有<strong>二义性</strong>，因为MySQL不知道你引用的是products表中的哪个实例。<br>​为解决此问题，使用了表别名。products的第一次出现为别名<strong>p1</strong>，第二次出现为别名p2。现在可以将这些别名用作表名。例如，SELECT语句使用<strong>p1前缀明确地给出所需列的全名</strong>。如果不这样，MySQL将返回错误，因为分别存在两个名为prod_id、prod_name的列。MySQL不知道想要的是哪一个列（即使它们事实上是同一个列)。WHERE（通过<strong>匹配p1中的vend_id和p2中的vend_id</strong>）首先联结两个表，然后按<strong>第二个表中的prod_id过滤数据</strong>，返回所需的数据。</p><h4 id="（2）自然联结"><a href="#（2）自然联结" class="headerlink" title="（2）自然联结"></a>（2）自然联结</h4><p>​自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符(SELECT *)，对所有其他表的列使用明确的子集来完成的。下面举一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price<br>FROM customers AS c, orders AS o, orderitems AS oi <br>WHERE c.cust_id = o.cust_id<br>AND oi.order_num = o.order_num<br>AND prod_id = &#x27;FB&#x27;<br></code></pre></td></tr></table></figure><p>​在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p><h4 id="（3）外部联结"><a href="#（3）外部联结" class="headerlink" title="（3）外部联结"></a>（3）外部联结</h4><p>​许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。例如，可能需要使用联结来完成以下工作:</p><ul><li>对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户;</li><li>列出所有产品以及订购数量，包括没有人订购的产品;</li><li>计算平均销售规模，包括那些至今尚未下订单的客户。</li></ul><p>​在上述例子中，联结<strong>包含了那些在相关表中没有关联行的行</strong>。这种类型的联结称为<strong>外部联结</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_id, orders.order_num<br>FROM customers INNER JOIN orders<br>ON customers.cust_id = orders.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_num<br>1000120005<br>1000120009<br>1000320006<br>1000420007<br>1000520008</p></blockquote><p>​可以看到只输出了有订单的客户，而那些没有订单的客户被忽略了，为了检索所有客户，可如下进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_id, orders.order_num<br>FROM customers LEFT OUTER JOIN orders<br>ON customers.cust_id = orders.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_num<br>1000120005<br>1000120009<br>10002NULL<br>1000320006<br>1000420007<br>1000520008</p></blockquote><p>​类似于上一章中所看到的内部联结,这条SELECT语句使用了关键字<code>OUTER JOIN</code>来指定联结的类型（而不是在WHERE子句中指定)。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用<code>OUTER JOIN</code>语法时，必须使用<strong>RIGHT</strong>或<strong>LEFT</strong>关键字指定包括其所有行的表（RIGHT指出的是<code>OUTER JOIN</code>右边的表，而LEFT指出的是<code>OUTER JOIN</code>左边的表)。上面的例子使用<code>LEFT OUTERJOIN</code>从FROM子句的左边表( <strong>customers</strong>表）中选择所有行。为了从右边的表中选择所有行，应该使用<code>RIGHT OUTER JOIN</code>，如下例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_id, orders.order_num<br>FROM customers RIGHT OUTER JOIN orders<br>ON customers.cust_id = orders.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_num<br>1000120005<br>1000120009<br>1000320006<br>1000420007<br>1000520008</p></blockquote><blockquote><p><strong>外部联结的类型</strong>存在两种基本的外部联结形式:左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说,左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此,两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。</p></blockquote><h3 id="3、使用带聚集函数的联结"><a href="#3、使用带聚集函数的联结" class="headerlink" title="3、使用带聚集函数的联结"></a>3、使用带聚集函数的联结</h3><p>​虽然至今为止聚集函数的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。<br>​请看下面的例子。如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT ()函数的代码可完成此工作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord <br>FROM customers INNER JOIN orders<br>ON customers.cust_id = orders.cust_id<br>GROUP BY customers.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_idnum_ord<br>Coyote Inc.   100012<br>Wascals 100031<br>Yosemite Place100041<br>E Fudd100051</p></blockquote><p>​此SELECT语句使用<strong>INNER JOIN</strong>将<strong>customers</strong>和<strong>orders</strong>表互相关联。GROUP BY子句按客户分组数据，因此，函数调用<code>COUNT (orders.order_num)</code>对每个客户的订单计数，将它作为<strong>num_ord</strong>返回。<br>​聚集函数也可以方便地与其他联结一起使用。请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord <br>FROM customers LEFT OUTER JOIN orders<br>ON customers.cust_id = orders.cust_id<br>GROUP BY customers.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_idnum_ord<br>Coyote Inc.100012<br>Mouse House100020<br>Wascals  100031<br>Yosemite Place10004 1<br>E Fudd 100051</p></blockquote><p>​这个例子使用左外部联结来包含所有客户，甚至包含那些没有任何下订单的客户。结果显示也包含了客户<strong>Mouse House</strong>，它<br>有0个订单。</p><h3 id="4、使用联结和联结条件"><a href="#4、使用联结和联结条件" class="headerlink" title="4、使用联结和联结条件"></a>4、使用联结和联结条件</h3><p>​汇总一下关于联结及其使用的某些要点。</p><ul><li>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</li><li>保证使用正确的联结条件，否则将返回不正确的数据。</li><li>应该总是提供联结条件，否则会得出笛卡儿积。</li><li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li></ul><h2 id="十七、组合查询"><a href="#十七、组合查询" class="headerlink" title="十七、组合查询"></a>十七、组合查询</h2><h3 id="1、组合查询"><a href="#1、组合查询" class="headerlink" title="1、组合查询"></a>1、组合查询</h3><pre><code class="hljs"> MySQL允许执行多个查询(多条SELECT语句)，并将结果作为单个查询结果集返回。这些组合查询通常称为并（ union)或复合查询。有两种基本情况，其中需要使用组合查询:</code></pre><ul><li>在单个查询中从不同的表返回类似结构的数据;</li><li>对单个表执行多个查询，按单个查询返回数据。</li></ul><h3 id="2、创建组合查询"><a href="#2、创建组合查询" class="headerlink" title="2、创建组合查询"></a>2、创建组合查询</h3><h4 id="（1）使用UNION"><a href="#（1）使用UNION" class="headerlink" title="（1）使用UNION"></a>（1）使用UNION</h4><p>​<strong>UNION</strong>的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字<strong>UNION</strong>。<br>​举一个例子，假如需要价格<strong>小于等于5</strong>的所有物品的一个列表，而且还想包括供应商<strong>1001</strong>和1002<strong>生产</strong>的所有物品（不考虑价格)。当然，可以利用WHERE子句来完成此工作，不过这次我们将使用UNION。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION<br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (1001, 1002)<br></code></pre></td></tr></table></figure><blockquote><p>vend_idprod_idprod_price<br>1003FC2.50<br>1002FU13.42<br>1003SLING4.49<br>1003TNT12.50<br>1001ANV015.99<br>1001ANV029.99<br>1001ANV0314.99<br>1002OL18.99</p></blockquote><p>​第一条SELECT检索<strong>价格不高于5</strong>的所有物品。第二条SELECT使用IN找出供应商<strong>1001</strong>和<strong>1002</strong>生产的所有物品。<strong>UNION</strong>指示MySQL<strong>执行</strong>两条SELECT语句，并把输出组<strong>合成</strong>单个查询结果集。</p><h4 id="（2）UNION规则"><a href="#（2）UNION规则" class="headerlink" title="（2）UNION规则"></a>（2）UNION规则</h4><pre><code class="hljs"> **UNION**的使用规则如下：</code></pre><ul><li><strong>UNION</strong>必须由<strong>两条</strong>或两条以上的SELECT语句组成，语句之间用关键字<strong>UNION</strong>分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字)。</li><li><strong>UNION</strong>中的每个查询必须包含<strong>相同的列</strong>、<strong>表达式</strong>或聚集函数（不过各个列不需要以相同的次序列出)。</li><li>列数据类型必须兼容:类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型)。</li></ul><p>​如果遵守了这些基本规则或限制,则可以将并用于任何数据检索任务。</p><h4 id="（3）包含或取消重复的行"><a href="#（3）包含或取消重复的行" class="headerlink" title="（3）包含或取消重复的行"></a>（3）包含或取消重复的行</h4><p>​上面的例子的两个SELECT语句，如果分别执行的话，是有9行输出结果的，但使用UNION关键字的话，只输出8行，这是因为有一行重复元素。</p><p>​这是因为在使用UNION时，重复的行被自动取消，这是默认行为，但如果需要，可以改变它。只需要使用<strong>UNION ALL</strong>而不是<strong>UNION</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION ALL<br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (1001, 1002)<br></code></pre></td></tr></table></figure><blockquote><p>vend_idprod_price<br>10032.50<br>10023.42<br>10034.49<br>10032.50<br>10015.99<br>10019.99<br>100114.99<br>10023.42<br>10028.99</p></blockquote><h4 id="（4）对组成查询结果排序"><a href="#（4）对组成查询结果排序" class="headerlink" title="（4）对组成查询结果排序"></a>（4）对组成查询结果排序</h4><p>​SELECT语句的输出用<strong>ORDER BY</strong>子句排序。在用UNION组合查询时，只能使用一条<strong>ORDER BY</strong>子句，它必须出现在<strong>最后一条SELECT语句之后</strong>。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句，上一个例子排序后的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION <br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (1001, 1002)<br>ORDER BY vend_id, prod_price<br></code></pre></td></tr></table></figure><blockquote><p>vend_idprod_idprod_price<br>1001ANV015.99<br>1001ANV029.99<br>1001ANV0314.99<br>1002FU13.42<br>1002OL18.99<br>1003FC2.50<br>1003TNT12.50<br>1003SLING4.49</p></blockquote><p>​这条UNION在最后一条SELECT语句后使用了ORDER BY子句。虽然ORDER BY子句似乎只是最后一条SELECT语句的组成部分，但实际上MySQL将用它来<strong>排序</strong>所有SELECT语句返回的<strong>所有结果</strong>。</p><h2 id="十八、全文本搜索"><a href="#十八、全文本搜索" class="headerlink" title="十八、全文本搜索"></a>十八、全文本搜索</h2><h3 id="1、理解全文本搜索"><a href="#1、理解全文本搜索" class="headerlink" title="1、理解全文本搜索"></a>1、理解全文本搜索</h3><pre><code class="hljs"> 在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们)，哪些词不匹配，它们匹配的频率，等等。</code></pre><h3 id="2、使用全文本搜索"><a href="#2、使用全文本搜索" class="headerlink" title="2、使用全文本搜索"></a>2、使用全文本搜索</h3><h3 id="（1）创建全文本搜索"><a href="#（1）创建全文本搜索" class="headerlink" title="（1）创建全文本搜索"></a>（1）创建全文本搜索</h3><p>​一般在创建表时启用全文本搜索。CREATE TABLE语句(第21章中介绍）接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。<br>下面的CREATE语句演示了FULLTEXT子句的使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE productnotes<br>(<br>note_id INT NOT NULL auto_INCREMENT,<br>prod_id char(10) NOT NULL,<br>note_date DATETIME NOT NULL,<br>note_text TEXT NULL,<br>PRIMARY KEY(note_id),<br>FULLTEXT(note_text)<br>)ENGINE=MyISAM;<br></code></pre></td></tr></table></figure><p>​第21章将详细考察<strong>CREATE TABLE</strong>语句。现在，只需知道这条<br>CREATE TABLE语句定义表<strong>productnotes</strong>并列出它所包含的<br>列即可。这些列中有一个名为<strong>note_text</strong>的列，为了进行全文本搜索，MySQL根据子句<strong>FULLTEXT</strong> ( note_text)的指示对它进行索引。这里的FULLTEXT索引单个列，如果需要也可以指定多个列。<br>​在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，<br>索引随之自动更新。</p><h3 id="（2）进行全文本搜索"><a href="#（2）进行全文本搜索" class="headerlink" title="（2）进行全文本搜索"></a>（2）进行全文本搜索</h3><p>​在索引之后，使用两个函数<strong>Match ( )<strong>和</strong>Against()<strong>执行全文本搜索，其中Match()指定被</strong>搜索的列</strong>，Against()指定要使用的<strong>搜索表达式</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT note_text<br>FROM productnotes<br>WHERE MATCH(note_text) Against(&#x27;rabbit&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>note_text<br>Customer complaint: rabbit has been able to detect trap, food apparently less effective now.<br>Quantity varies, sold by the sack load.<br>All guaranteed to be bright and orange, and suitable for use as rabbit bait.</p></blockquote><p>​此SELECT语句检索单个列<strong>note_text</strong>。由于WHERE子句，一个全文本搜索被执行。<strong>Match(note_text)<strong>指示</strong>MySQL</strong>针对指定的列进行搜索，Against <strong>( ‘ rabbit ‘ )<strong>指定词</strong>rabbit</strong>作为搜索文本。由于有两行包含词<strong>rabbit</strong>，这两个行被返回。</p><h3 id="（3）使用查询扩展"><a href="#（3）使用查询扩展" class="headerlink" title="（3）使用查询扩展"></a>（3）使用查询扩展</h3><p>​<strong>查询扩展</strong>用来设法放宽所返回的全文本搜索结果的范围。考虑下面的情况。你想找出所有<strong>提到anvils</strong>的注释。只有一个注释包含词anvils,但你还想找出可能<strong>与你的搜索有关</strong>的所有其他行，即使它们不包含词anvils。<br>​这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索:</p><ul><li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行;</li><li>其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简要地解释MySQL如何断定什么有用，什么无用)。</li><li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</li></ul><p>​利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词。</p><p> 下面是一个简单的全文本搜索，没有查询扩展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT note_text<br>FROM productnotes<br>WHERE MATCH(note_text) Against(&#x27;anvils&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>note_text<br>Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.</p></blockquote><p>​下面是相同的查询，但这次使用查询扩展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT note_text<br>FROM productnotes<br>WHERE MATCH(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION)<br></code></pre></td></tr></table></figure><blockquote><p>note_text<br>Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.<br>Customer complaint:<br>Sticks not individually wrapped, too easy to mistakenly detonate all at once.<br>Recommend individual wrapping.<br>Customer complaint:<br>Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.<br>Please note that no returns will be accepted if safe opened using explosives.<br>Customer complaint: rabbit has been able to detect trap, food apparently less effective now.<br>Customer complaint:<br>Circular hole in safe floor can apparently be easily cut with handsaw.<br>Matches not included, recommend purchase of matches or detonator (item DTNTR).</p></blockquote><p>​这次返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关,但因为它包含第一行中的两个词(customer和recommend)，所以也被检索出来。第3行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名)。<br>​正如所见，查询扩展极大地增加了返回的行数，但这样做也增加了你实际上并不想要的行的数目。</p><h2 id="十九、插入数据"><a href="#十九、插入数据" class="headerlink" title="十九、插入数据"></a>十九、插入数据</h2><h3 id="1、数据插入"><a href="#1、数据插入" class="headerlink" title="1、数据插入"></a>1、数据插入</h3><p>​顾名思义，<strong>INSERT</strong>是用来插入（或添加）行到数据库表的。插入可以用几种方式使用:</p><ul><li>插入完整的行;</li><li>插入行的一部分;</li><li>插入多行;</li><li>插入某些查询的结果。</li></ul><h3 id="2、插入完整的行"><a href="#2、插入完整的行" class="headerlink" title="2、插入完整的行"></a>2、插入完整的行</h3><p>​把数据插入表中最简单的方法是使用基本的<strong>INSERT</strong>语法，它要求指定表名和被插入到新行的值。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO customers<br>VALUES<br>( NULL, &#x27;Pep E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL );<br></code></pre></td></tr></table></figure><p>​此例子插入一个新客户到customers表。存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。如果某个列没有值(如上面的cust_contact和cust_email列),应该使用NULL值（假定表允许对该列指定空值)。各个列必须以它们在表定义中出现的次序填充。第一列cust_id也为NULL。这是因为每次插入一个新行时，该列由MySQL自动增量。你不想给出一个值（这是MySQL的工作)，又不能省略此列（如前所述，必须给出每个列)，所以指定一个NULL值（它被MySQL忽略，MySQL在这里插入下一个可用的cust_id值)。<br>​虽然这种语法很简单，但并不安全，应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。因此，编写依赖于特定列次序的SQL语句是很不安全的。如果这样做，有时难免会出问题。<br>​编写INSERT语句的更安全（不过更烦琐）的方法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO customers ( cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email )<br>VALUES<br>( &#x27;Pep E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL );<br></code></pre></td></tr></table></figure><p>​因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。你会发现cust_id的NULL值是不必要的，cust_id列并没有出现在列表中，所以不需要任何值。</p><h3 id="3、插入多个行"><a href="#3、插入多个行" class="headerlink" title="3、插入多个行"></a>3、插入多个行</h3><p>​有两种方法：</p><ul><li><p>可以使用多条INSERT语句，每条语句用一个分号结束，如下：</p></li><li><pre><code class="mysql">INSERT INTO TABLE_NAME(...) VALUES(...);INSERT INTO TABLE_NAME(...) VALUES(...);...<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>- ```mysql<br>  INSERT INTO <span class="hljs-built_in">TABLE_NAME</span>(...)<br>  <span class="hljs-built_in">VALUES</span>(...),(...)...;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="4、插入检索出的数据"><a href="#4、插入检索出的数据" class="headerlink" title="4、插入检索出的数据"></a>4、插入检索出的数据</h3><p>​INSERT一般用来给表插入一个指定列值的行。但是，INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中。这就是所谓的INSERT SELECT,顾名思义，它是由一条INSERT语句和一条SELECT语句组成的。<br>​假如你想从另一表中合并客户列表到你的customers表。不需要每次读取一行，然后再将它用INSERT插入，可以如下进行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO customers ( cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country ) SELECT<br>cust_id,<br>cust_contact,<br>cust_email,<br>cust_name,<br>cust_address,<br>cust_city,<br>cust_state,<br>cust_zip,<br>cust_country <br>FROM<br>custnew;<br></code></pre></td></tr></table></figure><p>​这个例子使用INSERT SELECT从custnew中将所有数据导入customers。SELECT语句从custnew检索出要插入的值，而不是列出它们。SELECT中列出的每个列对应于customers表名后所跟的列表中的每个列。这条语句将插入多少行有赖于custnew表中有多少行。如果这个表为空，则没有行被插入（也不产生错误，因为操作仍然是合法的)。如果这个表确实含有数据，则所有数据将被插入到customers。<br>​这个例子导入了cust_id（假设你能够确保cust_id的值不重复)。你也可以简单地省略这列（从INSERT和SELECT中)，这样MySQL就会生成新值。<br>​INSERT SELECT中的列名为简单起见,这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上,MySQL甚至不关心SELECT返回的列名,它使用的是列的位置,因此SELECT中的第一列(不管其列名）将用来填充表列中指定的第一个列,第二列将用来填充表列中指定的第二个列，如此等等,这对于从使用不同列名的表中导入数据是非常有用的。<br>​INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据。</p><h2 id="二十、更新和删除数据"><a href="#二十、更新和删除数据" class="headerlink" title="二十、更新和删除数据"></a>二十、更新和删除数据</h2><h3 id="1、更新数据"><a href="#1、更新数据" class="headerlink" title="1、更新数据"></a>1、更新数据</h3><p>​为了更新（修改）表中的数据，可使用UPDATE语句。可采用两种方式使用<strong>UPDATE</strong>:</p><ul><li>更新表中特定行;</li><li>更新表中所有行。</li></ul><p>下面分别对它们进行介绍。</p><p>​UPDATE语句非常容易使用，甚至可以说是太容易使用了。基本的UPDATE语句由3部分组成，分别是:</p><ul><li>要更新的表;</li><li>列名和它们的新值;</li><li>确定要更新行的过滤条件。</li></ul><p>​举一个简单例子。客户10005现在有了电子邮件地址，因此他的记录需要更新，语句如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE customers<br>SET cust_email = &#x27;elmer@fudd.com&#x27;<br>WHERE cust_id = 10005<br></code></pre></td></tr></table></figure><p>​更新多个列的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE customers <br>SET cust_email = &#x27;elmer@fudd.com&#x27;,<br>cust_name = &#x27;The Fudds&#x27; <br>WHERE<br>cust_id = 10005<br></code></pre></td></tr></table></figure><p>​在更新多个列时，只需要使用单个SET命令，每个“列&#x3D;值”对之间用逗号分隔。</p><p>​为了删除某个列的值，可以设置它为NULL，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE customers <br>SET cust_email = NULL <br>WHERE<br>cust_id = 10005<br></code></pre></td></tr></table></figure><h3 id="2、删除数据"><a href="#2、删除数据" class="headerlink" title="2、删除数据"></a>2、删除数据</h3><p>​为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方式使用DELETE:</p><ul><li>从表中删除特定的行;</li><li>从表中删除所有行。</li></ul><p>​下面的语句从customers表中删除一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM customers<br>WHERE cust_id = 10006<br></code></pre></td></tr></table></figure><p>​上述例子，只删除客户10006，若省略WHERE子句，它将删除表中每个客户。</p><p>​DELETE不需要列名或通配符。<strong>DELETE</strong>删除整行而不是删除列。为了删除指定的列，请使用<strong>UPDATE</strong>语句。</p><h3 id="3、更新和删除的指导原则"><a href="#3、更新和删除的指导原则" class="headerlink" title="3、更新和删除的指导原则"></a>3、更新和删除的指导原则</h3><p>​前一节中使用的UPDATE和DELETE语句全都具有WHERE子句，这样做的理由很充分。如果省略了WHERE子句，则UPDATE或DELETE将被应用到表中所有的行。换句话说，如果执行UPDATE而不带WHERE子句，则表中每个行都将用新值更新。类似地，如果执行DELETE语句而不带WHERE子句，表的所有数据都将被删除。<br>​下面是许多SQL程序员使用UPDATE或DELETE时所遵循的习惯。除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。<br>​保证每个表都有主键(如果忘记这个内容，请参阅第15章)，尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围)。在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。使用强制实施引用完整性的数据库（关于这个内容，请参阅第15章)，这样MySQL将不允许删除具有与其他表相关联的数据的行。</p><h2 id="二十一、创建和操作表"><a href="#二十一、创建和操作表" class="headerlink" title="二十一、创建和操作表"></a>二十一、创建和操作表</h2><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><p>​<strong>MySQL</strong>不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。</p><p>​创建表的方法有两种：</p><ul><li>使用具有交互创建和管理表的工具；</li><li>表也可以直接用<strong>MySQL</strong>语句操纵。</li></ul><p>可以使用<strong>CREATE TABLE</strong>创建表。在使用交互工具时，实际上使用的是<strong>MySQL</strong>语句。但是这些语句不上用户编写的，界面工具会自动生成并执行相应的<strong>MySQL</strong>语句（改现有表等操作也是如此）。</p><h4 id="（1）表创建基础"><a href="#（1）表创建基础" class="headerlink" title="（1）表创建基础"></a>（1）表创建基础</h4><p>​使用<strong>CREATE TABLE</strong>创建表时，必须给出下列信息：</p><ul><li>新表的名字，在关键字<strong>CREATE TABLE</strong></li><li>表列的名字和定义，用逗号隔开</li></ul><p><strong>CREATE TABLE</strong>语句也可能会包括其他关键字或选项，但至少包括<strong>表名</strong>和<strong>列的细节</strong>。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE customers (<br>  cust_id int NOT NULL AUTO_INCREMENT,<br>  cust_name char(50) NOT NULL,<br>  cust_address char(50) DEFAULT NULL,<br>  cust_city char(50) DEFAULT NULL,<br>  cust_state char(5) DEFAULT NULL,<br>  cust_zip char(10) DEFAULT NULL,<br>  cust_country char(50) DEFAULT NULL,<br>  cust_contact char(50) DEFAULT NULL,<br>  cust_email char(255) DEFAULT NULL,<br>  PRIMARY KEY (cust_id)<br>) ENGINE=InnoDB<br></code></pre></td></tr></table></figure><p>​从上面的例子可以看到，表名紧跟在<strong>CREATE TABLE</strong>关键字后面，实际的表定义(所有列)括在圆括号中。各列之间用逗号隔开。这个表由9列组成，每列的定义以列名（在表中必须是唯一的）开始，后跟列的数据类型。表的的主键可以在创建表时用<strong>PRIMARY KEY</strong>关键字指定。</p><h4 id="（2）使用NULL值"><a href="#（2）使用NULL值" class="headerlink" title="（2）使用NULL值"></a>（2）使用NULL值</h4><p>​<strong>NULL</strong>值就是没用值或缺值。允许<strong>NULL</strong>即允许插入列时不给出该列的值，不允许<strong>NULL</strong>值的列不接受该列没有值的行，换句话说，在插入或更新行时，该列必须有值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE orders (<br>  order_num int NOT NULL AUTO_INCREMENT,<br>  order_date datetime NOT NULL,<br>  cust_id int NOT NULL,<br>  PRIMARY KEY (order_num),<br>  KEY fk_orders_customers (cust_id),<br>  CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id)<br>) ENGINE=InnoDB <br></code></pre></td></tr></table></figure><p>​上面这个例子，创建了orders表。该表包括3个列，分别是订单号、订单日期、客户ID，由于3个列都需要，因此每个列的定义都包含<strong>NOT NULL</strong>。如果试图插入没用值的列，将会返回错误，且插入失败。</p><p>​下一个例子混合了<strong>NULL</strong>和<strong>NOT NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE vendors (<br>  vend_id int NOT NULL AUTO_INCREMENT,<br>  vend_name char(50) NOT NULL,<br>  vend_address char(50) DEFAULT NULL,<br>  vend_city char(50) DEFAULT NULL,<br>  vend_state char(5) DEFAULT NULL,<br>  vend_zip char(10) DEFAULT NULL,<br>  vend_country char(50) DEFAULT NULL,<br>  PRIMARY KEY (vend_id)<br>) ENGINE=InnoDB<br></code></pre></td></tr></table></figure><p>​由于供应商和供应商名字子列是必需的，因此使用<strong>NOT NULL</strong>，其余5个列都允许<strong>NULL</strong>值。<strong>NULL</strong>为默认值，如果不指定<strong>NOT NULL</strong>，则认定为<strong>NULL</strong>。</p><h4 id="（3）主键再介绍"><a href="#（3）主键再介绍" class="headerlink" title="（3）主键再介绍"></a>（3）主键再介绍</h4><p>​主键值必须唯一。即主键如果使用单个列，则其值必须唯一；如果使用多个列，则这些列的组合之必须唯一。</p><p>​下面是单个列作为主键的语句定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">PRIMARY KEY (vend_id)<br></code></pre></td></tr></table></figure><p>​为创建多个列组成的主键，应该以逗号分隔的列给出各列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE orderitems (<br>  order_num int NOT NULL,<br>  order_item int NOT NULL,<br>  prod_id char(10) NOT NULL,<br>  quantity int NOT NULL,<br>  item_price decimal(8,2) NOT NULL,<br>  PRIMARY KEY (order_num,order_item),<br>  KEY fk_orderitems_products (prod_id),<br>  CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num),<br>  CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id)<br>) ENGINE=InnoDB <br></code></pre></td></tr></table></figure><p>​每个订单有多项物品，但每个订单任何时候都只有1个第一项物品，1个第二项物品，如此等待。因此订单号（order_num列）和订单物品（order_item列）的组合是唯一的，因此可以作为主键。</p><h4 id="（4）AUTO-INCREMENT"><a href="#（4）AUTO-INCREMENT" class="headerlink" title="（4）AUTO_INCREMENT"></a>（4）AUTO_INCREMENT</h4><p>​观察一下<strong>customers</strong>表和<strong>orders</strong>表。<strong>customers</strong>表中的顾客列由<strong>cust_id</strong>唯一标识，每个顾客有一个唯一的编号。</p><p>​只要能保证每个顾客的编号不同，其值是多少都可以，为了方便我们引入<strong>AUTO_INCREMENT</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">cust_id int NOT NULL AUTO_INCREMENT,<br></code></pre></td></tr></table></figure><p>​<strong>AUTO_INCREMENT</strong>告诉<strong>MySQL</strong>，本列每当增加一行时自动增量。每次执行<strong>INSERT</strong>操作时，<strong>MySQL</strong>自动对该列增量，给该列赋予下一个可用的值，这样给每个行分配一个唯一的cust_id，从而可用用作主键的值。</p><p>​每个表只允许一个<strong>AUTO_INCREMENT</strong>列，而且它必须被索引。</p><h4 id="（5）指定默认值"><a href="#（5）指定默认值" class="headerlink" title="（5）指定默认值"></a>（5）指定默认值</h4><p>​如果在插入行时没有给出值，<strong>MySQL</strong>允许指定此时使用的默认值。默认值用<strong>CREATE TABLE</strong>语句的列定义中的<strong>DEFAULT</strong>关键字指定。</p><blockquote><p>​<strong>不允许函数</strong>：与大多数<strong>DBMS</strong>不一样，<strong>MySQL</strong>不允许使用函数作为默认值，它只支持常量。</p><p>​<strong>使用默认值而不是NULL值</strong> 许多数据库开发人员使用默认值而不是<strong>NULL</strong>列。</p></blockquote><h4 id="（6）引擎类型"><a href="#（6）引擎类型" class="headerlink" title="（6）引擎类型"></a>（6）引擎类型</h4><p>​迄今为止使用的<strong>CREATE TABLE</strong>语句全都以<strong>ENGINE&#x3D;InnoDB</strong>语句结束。</p><p>​与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候此引擎都隐藏在DBMS内，不需要过多关注它。</p><p>​但MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。<br>为什么要发行多种引擎呢?因为它们具有各自不同的功能和特性为不同的任务选择正确的引擎能获得良好的功能和灵活性。</p><p>当然，你完全可以忽略这些数据库引擎。如果省略ENGINE&#x3D;语句则使用默认引擎(很可能是MyISAM)，多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE&#x3D;语句很重要的原因(也就是为什么本书的样列表中使用两种引的原因)。</p><p>以下是几个需要知道的引擎:</p><ul><li>InnoDB是一个可靠的事务处理引擎(参见第26章)，它不支持全文本搜索;</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存(不是磁盘)中，速度很快(特别适合于临时表);</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索(参见第18章)，但不支持事务处理。</li></ul><h3 id="2、更新表"><a href="#2、更新表" class="headerlink" title="2、更新表"></a>2、更新表</h3><p>​更新表，可以使用<strong>ALTER TABLE</strong>语句。</p><p>​想要更新表，必须给出以下信息：</p><ul><li>在<strong>ALTER TABLE</strong>后给出要更改的表名。</li><li>所做更改的列表。</li></ul><p>​下面的例子给<strong>vendors</strong>表添加一个<strong>vend_phone</strong>列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table vendors<br>add vend_phone char(20);<br></code></pre></td></tr></table></figure><p>​删除刚刚增加的列，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table vendors<br>DROP COLUMN vend_phone;<br></code></pre></td></tr></table></figure><h3 id="3、删除表"><a href="#3、删除表" class="headerlink" title="3、删除表"></a>3、删除表</h3><p>​使用<strong>DROP TABLE</strong> 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE xx<br></code></pre></td></tr></table></figure><h3 id="4、重命名表"><a href="#4、重命名表" class="headerlink" title="4、重命名表"></a>4、重命名表</h3><p>使用<strong>RENAME TABLE</strong>即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RENAME TABLE xx TO yy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协程</title>
    <link href="/2023/04/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/04/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于协程，下面说法正确的是（ ）</p><ul><li>A. 协程和线程都可以实现程序的并发执行；</li><li>B. 线程比协程更轻量级；</li><li>C. 协程不存在死锁问题；</li><li>D. 通过 channel 来进行协程间的通信；</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>、D<br></code></pre></td></tr></table></figure><h4 id="解析如下："><a href="#解析如下：" class="headerlink" title="解析如下："></a>解析如下：</h4><p>A. 协程和线程都可以实现程序的并发执行：协程和线程都是在并发编程中使用的技术，它们可以让程序在同时处理多个任务时更高效地运行。协程和线程之间的主要区别在于它们的执行方式和使用的资源，但都可以实现程序的并发执行。</p><p>B. 线程比协程更轻量级：这个说法是不准确的，因为线程和协程之间的比较并不是简单的轻重量级的问题。协程相对于线程来说，它们的初始栈大小更小，创建和销毁的开销更小，上下文切换的开销也更小，所以在大量并发的情况下，协程的表现要优于线程。但是，在一些需要密集计算或者I&#x2F;O操作较多的场景下，线程的表现可能更好。</p><p>C. 协程不存在死锁问题：这个说法是不准确的，因为协程和线程都存在死锁问题，而且在协程中，由于存在共享数据和共享锁的情况，死锁问题可能更加严重。</p><p>D. 通过 channel 来进行协程间的通信：协程之间的通信通常是通过channel来实现的。Channel提供了一种安全且高效的机制，允许协程在不同的执行线程中进行通信和数据交换。通常，一个协程将数据放入通道中，而另一个协程从通道中读取该数据。通过这种方式，协程之间可以实现同步、互斥和数据共享。</p><h4 id="扩展知识："><a href="#扩展知识：" class="headerlink" title="扩展知识："></a>扩展知识：</h4><blockquote><p>协程和线程都是并发执行的基本单位，但它们有着不同的特点和应用场景。</p><p><strong>相同点：</strong></p><ol><li>都可以实现并发执行，从而提高程序的性能；</li><li>都可以被抢占（即暂停执行，并让出CPU资源）；</li><li>都可以与其他并发执行的单位（协程或线程）进行通信和同步。</li></ol><p><strong>不同点：</strong></p><ol><li>线程是由操作系统调度的，而协程是由程序自己调度的。线程的调度是由操作系统内核实现的，而协程的调度则是在用户空间中完成的，这使得协程的切换比线程更加轻量级，开销更小。</li><li>在创建和销毁的开销方面，协程的代价更小。线程需要占用较多的内存和系统资源，而协程只需要占用少量的栈空间和调度器资源。</li><li>线程之间的切换需要进行上下文切换（即保存当前线程的状态，以便恢复执行），而协程的切换则不需要进行上下文切换，只需要保存协程的上下文信息即可。</li><li>线程之间的通信和同步需要使用诸如锁、信号量、条件变量等同步机制，而协程之间的通信和同步则可以通过channel等更为简单的方式实现。</li></ol><p>总的来说，协程更适合于IO密集型的任务，如网络编程和文件处理等，而线程更适合于CPU密集型的任务，如图像处理和大数据计算等。在实际应用中，可以根据任务的特点和需求选择合适的并发执行方式。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for-range 又又又来了</title>
    <link href="/2023/04/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range-map/"/>
    <url>/2023/04/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range-map/</url>
    
    <content type="html"><![CDATA[<h2 id="下面代码里的ocounter的输出值？"><a href="#下面代码里的ocounter的输出值？" class="headerlink" title="下面代码里的ocounter的输出值？"></a>下面代码里的ocounter的输出值？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">21</span>,<br><span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">22</span>,<br><span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">23</span>,<br>&#125;<br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;A&quot;</span>)<br>&#125;<br>counter++<br>fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">2</span>或者<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>​因为for range map是无序的，故如果第一次循环到A,则输出3，否则输出2。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找两个正序数组的中位数</title>
    <link href="/2023/04/22/%E5%88%B7%E9%A2%98/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2023/04/22/%E5%88%B7%E9%A2%98/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目：寻找两个正序数组的中位数"><a href="#题目：寻找两个正序数组的中位数" class="headerlink" title="题目：寻找两个正序数组的中位数"></a>题目：寻找两个正序数组的中位数<span id="more"></span></h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p> 示例 1：</p><blockquote><p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p></blockquote><p>提示：</p><ul><li><p>nums1.length &#x3D;&#x3D; m</p></li><li><p>nums2.length &#x3D;&#x3D; n</p></li><li><p>0 &lt;&#x3D; m &lt;&#x3D; 1000</p></li><li><p>0 &lt;&#x3D; n &lt;&#x3D; 1000</p></li><li><p>1 &lt;&#x3D; m + n &lt;&#x3D; 2000</p></li><li><p>-106 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 106</p></li></ul><p>来源：力扣（LeetCode）</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><h4 id="（1）暴力"><a href="#（1）暴力" class="headerlink" title="（1）暴力"></a>（1）暴力</h4><p>​直接将两个数组合并，然后进行排序，直接算出中位数:</p><ul><li>数组长度为奇数，数组的中位数为<code>a[len / 2]</code></li><li>数组长度为偶数，数组的中位数为<code>(a[len / 2] + a[len / 2 - 1]) / 2</code></li></ul><p>​这题的时间复杂度的上限在排序，是<code>O((n + m)long(n + m))</code>，显然没有达到题目的要求， 但也勉强可以AC。</p><p>​代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i ++)<br>            res.<span class="hljs-built_in">push_back</span>(nums1[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i ++)<br>            res.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> len = res.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len &amp; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> res[len / <span class="hljs-number">2</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>((res[len / <span class="hljs-number">2</span>] + res[len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2.0</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>递归</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="/2023/04/22/%E5%88%B7%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2023/04/22/%E5%88%B7%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目：无重复字符的最长子串"><a href="#题目：无重复字符的最长子串" class="headerlink" title="题目：无重复字符的最长子串"></a>题目：无重复字符的最长子串<span id="more"></span></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><blockquote><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:</p><blockquote><p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p>输入: s &#x3D; “pwwkew”<br>输出: 3</p></blockquote><p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：</p><ul><li><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</p></li><li><p>s 由英文字母、数字、符号和空格组成</p></li></ul><p>来源：力扣（LeetCode）</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​用哈希表<code>map&lt;char, int&gt;</code>将每一个字符与其出现次数作为键值对存起来，然后利用双指针从前往后扫描即可：</p><ol><li>如果当前字符只出现了一次，则更新最长串的长度，并继续向后扫描</li><li>如果当前字符出现了不止一次，则将尾指针向前挪，挪至当前字符只出现一次为止，然后更新最长串的长度，并继续向后扫描。</li></ol><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            hash[s[i]] ++;<br>            <span class="hljs-keyword">while</span> (hash[s[i]] &gt; <span class="hljs-number">1</span>) &#123;<br>                hash[s[j]] --;<br>                j ++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>LeetCode</tag>
      
      <tag>双指针算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2023/04/22/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2023/04/22/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目：两数之和"><a href="#题目：两数之和" class="headerlink" title="题目：两数之和"></a>题目：两数之和<span id="more"></span></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><blockquote><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.</p></blockquote><p>示例 2：</p><blockquote><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p></blockquote><p>示例 3：</p><blockquote><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p></blockquote><p>提示：</p><ul><li><p>每个链表中的节点数在范围 [1, 100] 内</p></li><li><p>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</p></li><li><p>题目数据保证列表表示的数字不含前导零</p></li></ul><p>来源：力扣（LeetCode）</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​这题的思想和高精度类似，都是从低位开始算，然后逐渐进位到高位，只不过这里的用的链表的形式。</p><p>​在模拟需要注意：</p><ol><li>​从低位到高位，逐位相加，如果和大于10，就保留个位，即<code>t % 10</code></li><li>如果最高位有进位，则在最前面补1</li></ol><p>​这里还用到了一个做链表题目的小技巧：</p><blockquote><p>​添加一个虚拟头节点：<code>ListNode *head = new ListNode(-1);</code>，这样可以不用特判处理完后的链表是否为空，返回的形式都是res -&gt; next</p></blockquote><p>下面是链表进行加入一个数的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>cur-&gt;next = temp;<br>cur = temp;<br></code></pre></td></tr></table></figure><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = head;<br>        <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || t)&#123;<br>            <span class="hljs-keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>            cur = cur-&gt;next;<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>模拟</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for-range又来啦~</title>
    <link href="/2023/04/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E5%8F%88%E6%9D%A5%E4%BA%86/"/>
    <url>/2023/04/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h2 id="下面这段代码输出结果正确吗？"><a href="#下面这段代码输出结果正确吗？" class="headerlink" title="下面这段代码输出结果正确吗？"></a>下面这段代码输出结果正确吗？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123;<br>bar <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []Foo&#123;<br>&#123;<span class="hljs-string">&quot;A&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;B&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;C&quot;</span>&#125;,<br>&#125;<br>s2 := <span class="hljs-built_in">make</span>([]*Foo, <span class="hljs-built_in">len</span>(s1))<br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> s1 &#123;<br>s2[i] = &amp;value<br>&#125;<br>fmt.Println(s1[<span class="hljs-number">0</span>], s1[<span class="hljs-number">1</span>], s1[<span class="hljs-number">2</span>])<br>fmt.Println(s2[<span class="hljs-number">0</span>], s2[<span class="hljs-number">1</span>], s2[<span class="hljs-number">2</span>])<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输出：<br>&#123;A&#125; &#123;B&#125; &#123;C&#125;<br>&amp;&#123;A&#125; &amp;&#123;B&#125; &amp;&#123;C&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>​s2输出的结果是<code>&amp;&#123;C&#125;&amp;&#123;C&#125;&amp;&#123;C&#125;</code>，故上述的输出是错误的。</p><p>​在前面的题目，我们提到过，for-range使用短变量声明(:&#x3D;)的形式迭代变量时，变量i、value每次在循环题中都会被重用，而不是重新声明。故s2每次填充的都说value的地址，而在组后一次循环中，value被赋值为{C}。因此s2输出显示三个&amp;{C}。</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s1 &#123;<br>s2[i] = &amp;s1[i]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2023/04/21/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2023/04/21/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目：两数之和"><a href="#题目：两数之和" class="headerlink" title="题目：两数之和"></a>题目：两数之和<span id="more"></span></h2><p>​给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>​你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>​你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p></blockquote><p>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p></blockquote><p>提示：</p><blockquote><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9<br>只会存在一个有效答案</p></blockquote><p>题目来源：力扣（LeetCode）</p><h4 id="解题思路一："><a href="#解题思路一：" class="headerlink" title="解题思路一："></a>解题思路一：</h4><p>​题意很清楚，就是要从一个数组里找到唯一存在的一对数的和为<code>target</code>，并返回他们的下标，很容易就能想到暴力：两层循环分别枚举一遍数组，如果<code>nums[i] + nums[j] == target</code>，就找到了答案，然后将其放入<code>vector</code>中返回即可，时间复杂度O(n^2)，勉强能过。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(i), res.<span class="hljs-built_in">push_back</span>(j);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解题思路二："><a href="#解题思路二：" class="headerlink" title="解题思路二："></a>解题思路二：</h4><p>​这题比较友好，n的数据范围比较小，但如果n的范围更大，显然是过不了的，故我们需要想一想别的 方法。</p><p>​这里有一种非常巧妙的方法：哈希表。</p><p>​我们只需要枚举一次数组，然后在每一次枚举时，我们需要做：</p><blockquote><ol><li>判断<code>target - nums[i]</code>是否存在哈希表中</li><li>将nums[i]插入哈希表中</li></ol></blockquote><p>​然后就能找到答案了。</p><p>​解释：由于数据只有一组解，假设答案为[i, j]（i &lt; j），则当我们循环到j时，nums[i]一定会存在哈希表中，且有nums[i] + nums[j] &#x3D; target，故一定能找到解。</p><p>​时间复杂度：只扫描一遍数组，且哈希表的插入和查询操作的复杂度是O(1)，故总时间复杂度为O(n)</p><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> another = target - nums[i];<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(another))<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i), res.<span class="hljs-built_in">push_back</span>(hash[another]);<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>暴力</tag>
      
      <tag>哈希表</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组与slice</title>
    <link href="/2023/04/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87/"/>
    <url>/2023/04/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="问题：下面这段代码输出什么？"><a href="#问题：下面这段代码输出什么？" class="headerlink" title="问题：下面这段代码输出什么？"></a>问题：下面这段代码输出什么？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>​这一题与前面的 <a href="https://oyto.github.io/2023/04/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range/">for - range</a>很相似，一眼就能看出来，因为for-range执行前是将原数组进行拷贝，所以在循环里改变的数组，是不会影响到我们循环时的副本的，所以答案为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>​但事实并非如此，我们在之前的题目中，a是数组，而在这里a是slice。slice是引用类型，故其是一个指向底层数组的指针，因此我们在循环使用的副本依旧是一个指向原底层数组的副本，故对切片所有的操作，都会影响到底层数组，所以考研通过v获得修改后的数组元素。</p><p>​你学会了吗？</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slice</title>
    <link href="/2023/04/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/slice/"/>
    <url>/2023/04/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/slice/</url>
    
    <content type="html"><![CDATA[<h2 id="问题：下面这段代码输出什么？"><a href="#问题：下面这段代码输出什么？" class="headerlink" title="问题：下面这段代码输出什么？"></a>问题：下面这段代码输出什么？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(s ...<span class="hljs-type">int</span>)</span></span> &#123;<br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)<br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>slice[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>change(slice...)<br>fmt.Println(slice)<br>change(slice[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]...)<br>fmt.Println(slice)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案如下"><a href="#答案如下" class="headerlink" title="答案如下"></a>答案如下</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>​第一次调用change函数时，在函数内需要往切片里加入一个元素，但此时slice切片的长度已经达到了容量的上限，故需要扩容。当一个slice需要扩容时，Go会创建一个新的数组，将原有数组的元素复制到新数组中，并将新的元素插入到新数组中，故原slice的底层数组不变</p><p>​第二次调用change函数时，使用了操作符<code>[i,j]</code>获得一个新的切片，假定为 slice1，它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，没有达到容量的上限，所以在使用 change() 函数中对 slice1增加元素时，底层数组的修改会影响到原切片。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for-range</title>
    <link href="/2023/04/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range/"/>
    <url>/2023/04/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range/</url>
    
    <content type="html"><![CDATA[<h2 id="下面这段代码输出什么？"><a href="#下面这段代码输出什么？" class="headerlink" title="下面这段代码输出什么？"></a>下面这段代码输出什么？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>​range 表达式是副本参与循环，即对于<code>range x</code>，我们复制了x，这里假设将其拷贝到b，在for循环里执行的时候，每次遍历的就是x的副本b，在例子里，就是每次遍历的是a的副本b，而不是a本身，则实际的range循环代码是下面这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = a<span class="hljs-comment">//相当于这里在循环之前，隐式先将a数组拷贝到b里</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> b &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>​因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。</p><p>​如果想要 r 和 a 一样输出，修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> &amp;a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>​输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>​修改后的代码是将地址传入了range表达式，其副本依旧是一个指向原数组a的指针，因此后续所有循环中均是&amp;a指向的原数组参与的，故v能从&amp;a中指向的原数组取出修改后的值。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解defer吗？</title>
    <link href="/2023/04/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%BD%A0%E4%BA%86%E8%A7%A3defer%E5%90%97%EF%BC%9F/"/>
    <url>/2023/04/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%BD%A0%E4%BA%86%E8%A7%A3defer%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="你了解defer吗？"><a href="#你了解defer吗？" class="headerlink" title="你了解defer吗？"></a>你了解defer吗？<span id="more"></span></h2><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += n<br><span class="hljs-built_in">recover</span>()<br>&#125;()<br><br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">defer</span> f()<br>f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f(<span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题：上面的代码会输出什么？为什么？"><a href="#问题：上面的代码会输出什么？为什么？" class="headerlink" title="问题：上面的代码会输出什么？为什么？"></a>问题：上面的代码会输出什么？为什么？</h3><h3 id="首先我们先来了解一下go语言中的defer："><a href="#首先我们先来了解一下go语言中的defer：" class="headerlink" title="首先我们先来了解一下go语言中的defer："></a>首先我们先来了解一下go语言中的defer：</h3><p>​defer顾名思义，延迟。它是go语言中的一个关键字，主要用在函数或方法前面，作用是用于函数和方法的延迟调用，在语法上，<code>defer</code>与普通的函数调用没有什么区别。</p><p>​在使用上非常简单，只需要弄清楚以下几点即可：</p><ol><li>延迟的函数的什么时候被调用？<ol><li>函数return的时候</li><li>发生panic的时候</li></ol></li><li>延迟调用的语法规则<ol><li>defer关键字后面表达式必须是函数或者方法调用</li><li>延迟内容不能被括号括起来</li></ol></li><li>当一个函数中有多个defer时，他们的执行顺序是<strong>先进后出</strong></li><li>在函数执行return的过程可以分为三步：<ol><li>设置返回值</li><li>执行defer语句</li><li>将结果返回</li></ol></li><li>defer 定义的延迟函数的参数在 defer 语句出时就已经确定下来了</li></ol><p>​知道了这些，上面的题目久很好理解了。</p><p>​正确答案是<strong>7</strong>。</p><p>​当然，很有可能你的答案和正确答案一样，但分析不一定正确，所以接着往下看。</p><p>​这里只对<code>函数f</code>进行讲解：</p><blockquote><ol><li>首先使用defer关键字注册了一个匿名函数，然后这个匿名函数在<code>函数f</code>返回时执行。在这个匿名函数里，使用了<code>recover()</code>，这意味着它可以恢复panic。</li><li>接着定义了一个<code>变量f</code>，类型为<code>func()</code>，这里由于只声明了，但是没有定义，故<code>变量f</code>是一个<code>nil</code>函数。</li><li>然后使用defer关键字将<code>f变量</code>注册成延迟函数，这个延迟函数在<code>函数f</code>返回时会执行，但这个匿名函数是一个<code>nil函数</code>，因此在执行这个延迟函数时会触发panic</li><li>接下来是对<code>变量f</code>的定义 </li><li><code>return n + 1</code>此时，返回值变量<code>r = n + 1</code>，接着执行defer注册的延迟函数，因为defer函数的执行顺序是先进后出的，故先执行<code>变量f</code>，但由于这里注册的是一个<code>nil函数</code>，因此触发panic，接着执行最开始注册的匿名函数，此时<code>r = n + 1 + n</code>，遇到了recover()，所以恢复了panic，将r的值返回</li><li>最后返回给主函数的值<code>r = n + 1 + n = 7</code></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大上升子序列和</title>
    <link href="/2023/04/17/%E5%88%B7%E9%A2%98/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    <url>/2023/04/17/%E5%88%B7%E9%A2%98/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：最大上升子序列和"><a href="#题目：最大上升子序列和" class="headerlink" title="题目：最大上升子序列和"></a>题目：最大上升子序列和<span id="more"></span></h1><p>一个数的序列 bi，当 b1&lt;b2&lt;…&lt;bS 的时候，我们称这个序列是上升的。</p><p>对于给定的一个序列(a1,a2,…,aN)，我们可以得到一些上升的子序列(ai1,ai2,…,aiK)，这里1≤i1&lt;i2&lt;…&lt;iK≤N。</p><p>比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。</p><p>这些子序列中和最大为18，为子序列(1,3,5,9)的和。</p><p>你的任务，就是对于给定的序列，求出最大上升子序列和。</p><p>注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行是序列的长度N。</p><p>第二行给出序列中的N个整数，这些整数的取值范围都在0到10000(可能重复)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大上升子序列和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">18<br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析:"></a>题目分析:</h4><p>​一看题目就知道是最长上升子序列模型，只不过这里求的是最大和，只需要对代码进行一部分修改即可。</p><p>​DP分析过程如下：</p><p>​<img src="/images/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C.png" alt="最大上升子序列和"></p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = a[i];<span class="hljs-comment">//求的是最大和，故需要加上当前数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + a[i]);<span class="hljs-comment">//状态转移方程</span><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最长上升子序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由数据范围反推算法复杂度以及算法内容</title>
    <link href="/2023/04/16/%E6%9D%82%E7%B1%BB/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/"/>
    <url>/2023/04/16/%E6%9D%82%E7%B1%BB/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="见下图："><a href="#见下图：" class="headerlink" title="见下图："></a>见下图：<span id="more"></span></h1><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4.png" alt="来自y总的总结"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>杂类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞机降落</title>
    <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E9%A3%9E%E6%9C%BA%E9%99%8D%E8%90%BD/"/>
    <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E9%A3%9E%E6%9C%BA%E9%99%8D%E8%90%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：飞机降落"><a href="#题目：飞机降落" class="headerlink" title="题目：飞机降落"></a>题目：飞机降落<span id="more"></span></h1><p>有 N 架飞机准备降落到某个只有一条跑道的机场。</p><p>其中第 i 架飞机在 Ti 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 Di 个单位时间，即它最早可以于 Ti 时刻开始降落，最晚可以于 Ti+Di 时刻开始降落。</p><p>降落过程需要 Li 个单位时间。</p><p>一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。</p><p>请你判断 N 架飞机是否可以全部安全降落。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多组数据。</p><p>第一行包含一个整数 T，代表测试数据的组数。</p><p>对于每组数据，第一行包含一个整数 N。</p><p>以下 N 行，每行包含三个整数：Ti，Di 和 Li。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组数据，输出 <code>YES</code> 或者 <code>NO</code>，代表是否可以全部安全降落。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 30%30% 的数据，N≤2。<br>对于 100%100% 的数据，1≤T≤10，1≤N≤10，0≤Ti,Di,Li≤10^5</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">100</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">20</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">NO</span><br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>对于第一组数据，可以安排第 33 架飞机于 00 时刻开始降落，2020 时刻完成降落。安排第 22 架飞机于 2020 时刻开始降落，3030 时刻完成降落。安排第 11 架飞机于 3030 时刻开始降落，4040 时刻完成降落。</p><p>对于第二组数据，无论如何安排，都会有飞机不能及时降落。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​根据题给数据范围n &lt;&#x3D; 10，我们可以大概猜一下是贪心的做法，关于根据数据范围推断算法，可以参考<a href="https://www.acwing.com/blog/content/32/">由数据范围反推算法复杂度以及算法内容</a>。</p><p>​我们可以暴搜所有的方案，即所有飞机的全排列，在暴搜的同时，进行判断 ，当前飞机是否可以放在前一个飞机后面。如果可以，则继续搜索，如果全部的飞机都搜索到了，说明这种顺序是满足条件的，返回True;如果不可以，则停止搜索。</p><p>​判断的条件是：当前飞机的最晚起飞时间需要 &gt;&#x3D; 前一个飞机的降落时间。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Plane</span><br>&#123;<br>    <span class="hljs-type">int</span> t, d, l;<br>&#125;p[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = p[i].t, d = p[i].d, l = p[i].l;<br>        <span class="hljs-keyword">if</span> (!st[i] &amp;&amp; t + d &gt;= last)<span class="hljs-comment">//当前飞机没有被放过且当前飞机能放在前一个飞机后面</span><br>        &#123;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//最早起飞时间需要在前一个飞机的降落之后也需要在该飞机的最早起飞时间之后，故取两者之最</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(last, t) + l)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <br>    <span class="hljs-keyword">while</span> (t --)<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> t, d, l;<br>            cin &gt;&gt; t &gt;&gt; d &gt;&gt; l;<br>            p[i] = &#123;t, d, l&#125;;<br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dfs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>友好城市</title>
    <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/"/>
    <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：友好城市"><a href="#题目：友好城市" class="headerlink" title="题目：友好城市"></a>题目：友好城市<span id="more"></span></h1><p>Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。</p><p>北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。</p><p>每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。</p><p>编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第1行，一个整数N，表示城市数。</p><p>第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>仅一行，输出一个整数，表示政府所能批准的最多申请数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤5000<br>0≤xi≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">22 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">12</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">17 </span><span class="hljs-number">17</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​（1）每个城市上只能建立一座桥</p><p>​（2）所有的桥与桥之间不能相交<br>​目标：最多可以建立多少桥？</p><p>​贪心 + LIS：</p><p>​（1）用pair将每对友好城市绑定在一起，进行排序<br>​（2）对第二关键字求其LIS最长上升子序列的最大值即可</p><p>为何将其中一岸城市从小到大排序即可？<br>    因为如果将一岸的城市从小到大排好序，如果要满足题目要求不相交，则必须满足对岸也是从小到大排序的，否则就会有相交方案，则将某一岸排好序，再对另一岸求一遍<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">最长上升子序列</a>即可。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N];<br>PII q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;<br>    <span class="hljs-built_in">sort</span>(q, q + n); <span class="hljs-comment">//高度从低到高排序</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)    <span class="hljs-comment">//故求的时候也要求的是从低到高的最长上升子序列</span><br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (q[i].second &gt; q[j].second) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LIS</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合唱队形</title>
    <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2/"/>
    <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="题目：合唱队形"><a href="#题目：合唱队形" class="headerlink" title="题目：合唱队形"></a>题目：合唱队形<span id="more"></span></h1><p>N 位同学站成一排，音乐老师要请其中的 (N−K)位同学出列，使得剩下的 K 位同学排成合唱队形。     </p><p>合唱队形是指这样的一种队形：设 K 位同学从左到右依次编号为 1，2…，K，他们的身高分别为 T1，T2，…，TK,则他们的身高满足 T1&lt;…<Ti>Ti+1&gt;…&gt;TK(1≤i≤K)。  </p><p>你的任务是，已知所有 N 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行是一个整数 N，表示同学的总数。</p><p>第二行有 N 个整数，用空格分隔，第 i 个整数 Ti是第 i 位同学的身高(厘米)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤N≤100<br>130≤Ti≤230</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">220</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​要求最少需要几位同学出列，即求合唱队形最多由多少人组成。</p><p>​这题与 <a href="https://oyto.github.io/2023/04/16/%E5%88%B7%E9%A2%98/%E7%99%BB%E5%B1%B1/">登山</a>同出一辙，都是需要求出以某个人的身高为最高点，该点的最长上升子序列最长和下降子序列，求出来之后，枚举所有人的身高，找出最长上升子序列最长与下降子序列之和的最大值，这个最大值就是我们能组成的合唱队形的最大人数，我们再用总的同学数<code>n</code> - <code>最大人数</code>，即可以求出需要最少出列同学数。</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i --)<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j --)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);  <span class="hljs-comment">//中间点求了两次需要减去一次</span><br><br>    cout &lt;&lt; n - res &lt;&lt;  endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登山</title>
    <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E7%99%BB%E5%B1%B1/"/>
    <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E7%99%BB%E5%B1%B1/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="题目：登山"><a href="#题目：登山" class="headerlink" title="题目：登山"></a>题目：登山<span id="more"></span></h1><p>五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。</p><p>同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。</p><p>队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数N，表示景点数量。</p><p>第二行包含N个整数，表示每个景点的海拔。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最多能浏览的景点数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤N≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">220</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​题目中说按照顺序来浏览这些景点，即只能往右走，不能往左走；不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了，即路线一定是<code>先上后下</code>，这很明显是最长上升子序列模型，我们只需要求出所有景点的最长上升子序列和最长下降子序列，最后枚举所有景点，求出最长上升子序列与最长下降子序列和的最大值即可。</p><p>​这里还需要注意的是，由于求出来的是<code>最长上升子序列与最长下降子序列和的最大值</code>这里的顶点被算了两次，故最后的答案需要减去一次。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i --)<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j --)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);  <span class="hljs-comment">//中间点求了两次需要减去一次</span><br><br>    cout &lt;&lt; res &lt;&lt;  endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怪盗基德的滑翔翼</title>
    <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E6%80%AA%E7%9B%97%E5%9F%BA%E5%BE%B7%E7%9A%84%E6%BB%91%E7%BF%94%E7%BF%BC/"/>
    <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E6%80%AA%E7%9B%97%E5%9F%BA%E5%BE%B7%E7%9A%84%E6%BB%91%E7%BF%94%E7%BF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：怪盗基德的滑翔翼"><a href="#题目：怪盗基德的滑翔翼" class="headerlink" title="题目：怪盗基德的滑翔翼"></a>题目：怪盗基德的滑翔翼<span id="more"></span></h1><p>怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。</p><p>而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。</p><p>有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。</p><p>不得已，怪盗基德只能操作受损的滑翔翼逃脱。</p><p>假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。</p><p>初始时，怪盗基德可以在任何一幢建筑的顶端。</p><p>他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。</p><p>因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。</p><p>他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。</p><p>请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入数据第一行是一个整数K，代表有K组测试数据。</p><p>每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤K≤100<br>1≤N≤100<br>0&lt;h&lt;10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">300 </span><span class="hljs-number">207</span> <span class="hljs-number">155</span> <span class="hljs-number">299</span> <span class="hljs-number">298</span> <span class="hljs-number">170</span> <span class="hljs-number">158</span> <span class="hljs-number">65</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">65 </span><span class="hljs-number">158</span> <span class="hljs-number">170</span> <span class="hljs-number">298</span> <span class="hljs-number">299</span> <span class="hljs-number">155</span> <span class="hljs-number">207</span> <span class="hljs-number">300</span><br><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>6<br>9<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​分析题目，我们可以发现，怪盗基德每次可以往左边或者往右边从高的建筑滑向低的建筑，这个模型正于最长上升子序列模型相符，不同的是：这里还需要求最长下降子序列。</p><p>​关于最长上升子序列模型的讲解，见<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">⭐</a></p><p>​知道了最长上升子序列，只需要从后面往前求一遍最长上升子序列，就可以得到最长下降子序列。</p><p>​最后的答案，即为最长上升子序列和最长下降子序列的最大值。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br><br>    <span class="hljs-keyword">while</span> (T --)<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br><br>        <span class="hljs-comment">//正向求解LIS问题</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//反向求解LIS问题</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i --)<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j --)<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方格取数</title>
    <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/"/>
    <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：方格取数"><a href="#题目：方格取数" class="headerlink" title="题目：方格取数"></a>题目：方格取数<span id="more"></span></h1><p>设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif"></p><p>某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。</p><p>在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。</p><p>此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行为一个整数N，表示 N×N 的方格图。</p><p>接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。</p><p>行和列编号从 11 开始。</p><p>一行“0 0 0”表示结束。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示两条路径上取得的最大的和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>N≤10</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">14</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">3</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">14</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">67<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​从左上角走到右下角，于是想到DP中的数字三角形模型。关于数字三角形模型，可以去看这篇文章[线性DP](<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">线性DP - 小樱桃 (oyto.github.io)</a>&#x2F;)。</p><p>​这题的不同点是，这里要取两次数，于是进行DP过程：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs llvm">f[<span class="hljs-type">i1</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-type">i2</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">2</span>]表示所有从(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)分别走到(<span class="hljs-type">i1</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-type">i2</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">2</span>)路径的最大值。<br><br>如何处理“同一个格子不能被重复选择”？<br>    分析后发现，只有当<span class="hljs-type">i1</span> + j<span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-type">i2</span> + j<span class="hljs-number">2</span>时，两条路径的格子才可能重合，<br>    于是可以根据这条性质将思维优化成三维，<br><br>集合：f[k<span class="hljs-punctuation">,</span><span class="hljs-type">i1</span><span class="hljs-punctuation">,</span><span class="hljs-type">i2</span>]表示所有从(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)走到(<span class="hljs-type">i1</span><span class="hljs-punctuation">,</span>k-<span class="hljs-type">i1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-type">i2</span><span class="hljs-punctuation">,</span>k-<span class="hljs-type">i2</span>)的路径的最大值<br>    k表示两条路线当前走到的格子的横纵坐标之和<br><br>属性：<span class="hljs-keyword">max</span><br><br>状态计算：<br>    以最后一步是从往下走还是往右走进行划分，因为有两次走法，所以被分成了四种情况<br>        下下、下右、右下、右右<br></code></pre></td></tr></table></figure><p>​<strong>为什么下面四个状态转移方程能代表四种状态？</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">原因是，因为k 变小了<span class="hljs-number">1</span>，先不看最后一步，如果i变小<span class="hljs-number">1</span>，则j就不用变；如果i没有变，则j就需要变小<span class="hljs-number">1</span>；<br>上述两种情况刚好对应了最后一步是向下、右走，的横纵坐标变化情况，又因为是两次一起走，故有四种情况。<br><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> f[k - <span class="hljs-number">1</span>][<span class="hljs-type">i1</span> - <span class="hljs-number">1</span>][<span class="hljs-type">i2</span> - <span class="hljs-number">1</span>] + t)<span class="hljs-comment">;   //下 下</span><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> f[k - <span class="hljs-number">1</span>][<span class="hljs-type">i1</span> - <span class="hljs-number">1</span>][<span class="hljs-type">i2</span>] + t)<span class="hljs-comment">;       //下 右</span><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> f[k - <span class="hljs-number">1</span>][<span class="hljs-type">i1</span>][<span class="hljs-type">i2</span> - <span class="hljs-number">1</span>] + t)<span class="hljs-comment">;       //右 下</span><br></code></pre></td></tr></table></figure><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N * <span class="hljs-number">2</span>][N][N], g[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) g[a][b] = c;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= n + n; k ++)   <span class="hljs-comment">//枚举横纵坐标之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++)    <span class="hljs-comment">//枚举第一次走的横坐标</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++)    <span class="hljs-comment">//枚举第二次走的横坐标</span><br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;   <span class="hljs-comment">//计算出两次走的纵坐标</span><br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= n)<br>                &#123;<br>                    <span class="hljs-type">int</span> t = g[i1][j1];  <span class="hljs-comment">//如果两个坐标相等，只加一次，因为第二次走这里，已经被拿走清空了</span><br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += g[i2][j2];   <span class="hljs-comment">//坐标不相同，就两个位置全加上</span><br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>] + t);   <span class="hljs-comment">//下 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2] + t);       <span class="hljs-comment">//下 右</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>] + t);       <span class="hljs-comment">//右 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2] + t);            <span class="hljs-comment">//右 右</span><br>                &#125;<br>            &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n + n][n][n]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字三角形模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最低通行费</title>
    <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9/"/>
    <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：最低通行费"><a href="#题目：最低通行费" class="headerlink" title="题目：最低通行费"></a>题目：最低通行费<span id="more"></span></h1><p>一个商人穿过一个 N×N 的正方形的网格，去参加一个非常重要的商务活动。</p><p>他要从网格的左上角进，右下角出。</p><p>每穿越中间 1 个小方格，都要花费 1 个单位时间。</p><p>商人必须在 (2N−1) 个单位时间穿越出去。</p><p>而在经过中间的每个小方格时，都需要缴纳一定的费用。</p><p>这个商人期望在规定时间内用最少费用穿越出去。</p><p>请问至少需要多少费用？</p><p>注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个整数，表示正方形的宽度 N。</p><p>后面 N 行，每行 N 个不大于 100 的正整数，为网格上每个小方格的费用。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示至少需要的费用。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤100</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span> <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span>  <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span> <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">15</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">6 </span> <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">18</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">23</span> <span class="hljs-number">25</span> <span class="hljs-number">29</span> <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">109<br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>样例中，最小值为 109&#x3D;1+2+5+7+9+12+19+21+33。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​从左上角走到右下角的问题，自然想到DP中的[数字三角形模型](<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">线性DP - 小樱桃 (oyto.github.io)</a>)。</p><p>​唯一不同的是，本题是求路径和的最小值，故这里需要先进行初始化。</p><p>​<strong>为什么要进行初始化呢？</strong></p><p>​因为我们做数字三角形模型是求路径和的最大值，于是我们默认dp数组f[i][j]为0即可，但这里求的是最小值，若我们不进行初始化，最次取的都是0，就会忽略路径上的值，导致答案错误。</p><p>​<strong>初始化</strong></p><p>​我们可以按照下面的方式进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j ++)<br>            f[i][j] = INF;<br></code></pre></td></tr></table></figure><p>​<strong>为什么要从0开始呢？</strong></p><ul><li>​因为第一行的元素进行状态转移的时候，会用到第0行，故如果不初始化第0行的话，会导致第一行求值出错，进而导致答案错误。</li></ul><p>​还有一个细节就是，我们需要初始化<code>f[1][1] = g[1][1]</code>，否则起点就会出错。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            cin &gt;&gt; g[i][j];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j ++)<br>            f[i][j] = INF;<br>            <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + g[i][j];<br>    <br>    cout &lt;&lt; f[n][n];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字三角形模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摘花生</title>
    <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%91%98%E8%8A%B1%E7%94%9F/"/>
    <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%91%98%E8%8A%B1%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：摘花生"><a href="#题目：摘花生" class="headerlink" title="题目：摘花生"></a>题目：摘花生<span id="more"></span></h1><p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p><p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p><p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p><p>Hello Kitty只能向东或向南走，不能向西或向北走。</p><p>问Hello Kitty最多能够摘到多少颗花生。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数T，代表一共有多少组数据。</p><p>接下来是T组数据。</p><p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p><p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤T≤100,1≤R,C≤100,0≤M≤1000</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>16<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​从左上角走到右下角，且每次只能向东或向南走，即往右或者往下走，裸的数字三角形模型，关于数字三角形模型，可以去看这篇文章[线性DP](<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">线性DP - 小樱桃 (oyto.github.io)</a>&#x2F;)。</p><p>​只需要注意，这题是多组输入数据，注意清理上次用过的g, f数组即可。（这题可以不用清零，因为每次需要用到的地方，都会被重新计算进行覆盖）</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <br>    <span class="hljs-keyword">while</span> (t --)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> g);<br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>        <br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>                cin &gt;&gt; g[i][j];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]) + g[i][j];<br>        <br>        cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字三角形模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冶炼金属</title>
    <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E/"/>
    <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E/</url>
    
    <content type="html"><![CDATA[<h4 id="题目：冶炼金属"><a href="#题目：冶炼金属" class="headerlink" title="题目：冶炼金属"></a>题目：冶炼金属<span id="more"></span></h4><p>小蓝有一个神奇的炉子用于将普通金属 O 冶炼成为一种特殊金属 X。</p><p>这个炉子有一个称作转换率的属性 V，V 是一个正整数，这意味着消耗 V 个普通金属 O 恰好可以冶炼出一个特殊金属 X，当普通金属 O 的数目不足 V 时，无法继续冶炼。</p><p>现在给出了 N 条冶炼记录，每条记录中包含两个整数 A 和 B，这表示本次投入了 A 个普通金属 O，最终冶炼出了 B 个特殊金属 X。</p><p>每条记录都是独立的，这意味着上一次没消耗完的普通金属 O 不会累加到下一次的冶炼当中。</p><p>根据这 N 条冶炼记录，请你推测出转换率 V 的最小值和最大值分别可能是多少，题目保证评测数据不存在无解的情况。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数 N，表示冶炼记录的数目。</p><p>接下来输入 N 行，每行两个整数 A、B，含义如题目所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出两个整数，分别表示 V 可能的最小值和最大值，中间用空格分开。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 30% 的评测用例，1≤N≤102。对于 60% 的评测用例，1≤N≤103。<br>对于 100% 的评测用例，1≤N≤104，1≤B≤A≤109。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">75 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">53 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">59 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">20 </span><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>当 V&#x3D;20 时，有：⌊7520⌋&#x3D;3，⌊5320⌋&#x3D;2，⌊5920⌋&#x3D;2，可以看到符合所有冶炼记录。</p><p>当 V&#x3D;25 时，有：⌊7525⌋&#x3D;3，⌊5325⌋&#x3D;2，⌊5925⌋&#x3D;2，可以看到符合所有冶炼记录。</p><p>且再也找不到比 20 更小或者比 25 更大的符合条件的 V 值了。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​读过题目后，可以发现题目需要分别找到一个最大值和最小值满足所给条件，而且对于找到的值，我们可以通过判断，能判断出它是大于我们的答案还是小于我们的答案，存在二段性，故可以采用二分做。</p><p>​check函数的书写，对于每个需要检查的值，我们通过其与所有组的数据进行判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> t = a[i] / x;<br><br><span class="hljs-keyword">if</span> (t &lt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-comment">//说明我们找到的这个数太大了，以至于不能转化出的金属不足要求</span><br><span class="hljs-keyword">if</span> (t &gt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> <span class="hljs-comment">//说明我们找到的这个数太大了，以至于转化出的金属超量</span><br><br><span class="hljs-comment">//如果所有的数据都没有出现上述情况，则说明当前这个数，是我们要找的答案</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>​</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = a[i] / x;<br>        <span class="hljs-keyword">if</span> (t &gt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (t &lt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i] &gt;&gt; b[i];<br>    <br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span> || t == <span class="hljs-number">3</span>) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span> || t == <span class="hljs-number">2</span>) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Go版本</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N <span class="hljs-type">int</span> = <span class="hljs-number">10010</span><br><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a, b [N]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> in = bufio.NewReader(os.Stdin)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Fscan(in, &amp;n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>fmt.Fscan(in, &amp;a[i], &amp;b[i])<br>&#125;<br>l, r := <span class="hljs-number">1</span>, <span class="hljs-type">int</span>(<span class="hljs-number">1e9</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> l &gt;= r &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>mid := (l + r) / <span class="hljs-number">2</span><br>t := check(mid)<br><span class="hljs-keyword">if</span> t == <span class="hljs-number">1</span> || t == <span class="hljs-number">3</span> &#123;<br>r = mid<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l = mid + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, l)<br>l, r = <span class="hljs-number">1</span>, <span class="hljs-type">int</span>(<span class="hljs-number">1e9</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> l &gt;= r &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>mid := (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>t := check(mid)<br><span class="hljs-keyword">if</span> t == <span class="hljs-number">1</span> || t == <span class="hljs-number">2</span> &#123;<br>l = mid<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>t := a[i] / x<br><span class="hljs-keyword">if</span> t &gt; b[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">if</span> t &lt; b[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>二分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接龙数列</title>
    <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97/"/>
    <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：接龙"><a href="#题目：接龙" class="headerlink" title="题目：接龙"></a>题目：接龙<span id="more"></span></h1><p>对于一个长度为 K 的整数数列：A1,A2,…,AK，我们称之为接龙数列当且仅当 Ai 的首位数字恰好等于 Ai−1的末位数字 (2≤i≤K)。</p><p>例如 12,23,35,56,61,1112,23,35,56,61,11 是接龙数列；12,23,34,5612,23,34,56 不是接龙数列，因为 5656 的首位数字不等于 3434 的末位数字。</p><p>所有长度为 11 的整数数列都是接龙数列。</p><p>现在给定一个长度为 N的数列 A1,A2,…,AN，请你计算最少从中删除多少个数，可以使剩下的序列是接龙序列？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 N。</p><p>第二行包含 N个整数 A1,A2,…,AN。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数代表答案。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 20%20% 的数据，1≤N≤20<br>对于 50%50% 的数据，1≤N≤10000<br>对于 100%100% 的数据，1≤N≤10^5，1≤Ai≤10^9。所有 Ai 保证不包含前导 00。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">11 </span><span class="hljs-number">121</span> <span class="hljs-number">22</span> <span class="hljs-number">12</span> <span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>删除 2222，剩余 11,121,12,202311,121,12,2023 是接龙数列。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​题目要求最少删除多少个数，即求最长的接龙数列长度。</p><p>​只要前一个数的结尾能和后一个数的开头一样，则可以进行接龙，这一点跟最长上升子序列模型相似：都是前一个数与后一个数存在某一种关系就可以接在一起。</p><p>​DP分析如下：</p><p><img src="/images/%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97DP%E8%BF%87%E7%A8%8B.png" alt="接龙数列"></p><p>​分析到这里，代码就可以写了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> l[N], r[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">char</span> num[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        cin &gt;&gt; num;<br>        l[i] = num[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>, r[i] = num[<span class="hljs-built_in">strlen</span>(num) - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (l[i] == r[j]) f[i] = <span class="hljs-built_in">max</span>(f[j] + <span class="hljs-number">1</span>, f[i]);<br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    cout &lt;&lt; n - res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​如果觉得这题就这么结束了，那就大错特错了。</p><p>​我们可以观察数据范围：<code>n &lt;= 100010</code>，而我们的算法的时间复杂度是O(n^2)的，故需要进行优化。</p><p>​我们发现只有当<code>l[i]</code> &#x3D;<code> r[j]</code>时，我们才需要更新状态，故我们可以用一个辅助数组，存下以<code>k</code>结尾的接龙数列有多少个，在更新时直接用<code>f[i] = max(f[i], g[l[i]])</code>进行更新状态即可，紧接着记得要更新<code>g[r[i]] = max(f[i], g[r[i]])</code>。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], g[N];<br><span class="hljs-type">int</span> l[N], r[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">char</span> num[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        cin &gt;&gt; num;<br>        l[i] = num[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>, r[i] = num[<span class="hljs-built_in">strlen</span>(num) - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        f[i] = <span class="hljs-built_in">max</span>(f[i], g[l[i]] + <span class="hljs-number">1</span>);<span class="hljs-comment">//更新状态</span><br>        g[r[i]] = <span class="hljs-built_in">max</span>(f[i], g[r[i]]);<span class="hljs-comment">//更新g数组</span><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    cout &lt;&lt; n - res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>DP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最长上升子序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="/2023/04/13/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2023/04/13/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h4><p>​编写一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。</p><p>例如如下的先序遍历字符串： <code>abc##de#g##f###</code> 其中 <code>#</code> 表示的是空格，空格字符代表空树。</p><p>建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>共一行，包含一个字符串，表示先序遍历字符串。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，输出将输入字符串建立二叉树后中序遍历的序列，字符之间用空格隔开。</p><p>注意，输出中不用包含 <code>#</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>输入字符串长度不超过 100100，且只包含小写字母和 <code>#</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">abc##de#g##f###<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">c <span class="hljs-selector-tag">b</span> e g d f <span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​给定先序遍历，求中序遍历。</p><p>​首先我们要知道什么是先序遍历和后序遍历。</p><blockquote><ul><li>先序遍历（Preorder Traversal）：先访问根节点，再递归地遍历左子树和右子树。先序遍历的顺序是根节点 -&gt; 左子树 -&gt; 右子树。</li><li>中序遍历（Inorder Traversal）：先递归地遍历左子树，再访问根节点，最后递归地遍历右子树。中序遍历的顺序是左子树 -&gt; 根节点 -&gt; 右子树。</li><li>后序遍历（Postorder Traversal）：先递归地遍历左子树和右子树，再访问根节点。后序遍历的顺序是左子树 -&gt; 右子树 -&gt; 根节点。</li></ul></blockquote><p>​于是我们以样例为例，画出先序遍历，如下图</p><p>​<img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="二叉树的遍历"></p><p>​然后我们就可以发现，只要我们在每次搜到空树的时候，即回溯到该节点的父节点后，将当前节点（上一个节点的父节点）时，将其输出就能得到中序遍历。因为每次回溯到的点，都是一个父亲节点，且回溯到了这个点，说明其子节点也已经回溯过了，即输出过了。</p><h4 id="AC代码如下："><a href="#AC代码如下：" class="headerlink" title="AC代码如下："></a>AC代码如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> k;<br>string str;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (str[k] == <span class="hljs-string">&#x27;#&#x27;</span>)  <span class="hljs-comment">//遍历到了空树，回溯的同时，遍历下一个节点</span><br>    &#123;<br>        k ++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> t = str[k ++];     <span class="hljs-comment">//记录当前节点</span><br>    <span class="hljs-built_in">dfs</span>();  <span class="hljs-comment">//遍历左子树，直至走到空树，</span><br>    cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">dfs</span>();  <span class="hljs-comment">//遍历右节点，直至走到空树</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; str;<br>    <br>    <span class="hljs-built_in">dfs</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Go语言版</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> in = bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">var</span> k <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> str[k] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>        k ++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    t := str[k]<br>    k ++<br>    dfs()<br>    fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, t)<br>    dfs()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Fscan(in, &amp;str)<br>    <br>    dfs()<br>    <br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
      <category>dfs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs</tag>
      
      <tag>树的遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2023/04/11/test./index/"/>
    <url>/2023/04/11/test./index/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架示例</title>
    <link href="/2023/04/11/%E6%A1%86%E6%9E%B6/Gin%E6%A1%86%E6%9E%B6%E7%A4%BA%E4%BE%8B/"/>
    <url>/2023/04/11/%E6%A1%86%E6%9E%B6/Gin%E6%A1%86%E6%9E%B6%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Gin框架示例"><a href="#Gin框架示例" class="headerlink" title="Gin框架示例"></a>Gin框架示例<span id="more"></span></h1><h2 id="1、AsciiJSON"><a href="#1、AsciiJSON" class="headerlink" title="1、AsciiJSON"></a>1、AsciiJSON</h2><blockquote><p>​使用 AsciiJSON 生成具有转义的非 ASCII 字符的 ASCII-only JSON。</p></blockquote><h4 id="（1）完整代码"><a href="#（1）完整代码" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎</span><br><br>r.GET(<span class="hljs-string">&quot;/someJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 注册一个 GET 路由，并定义处理函数</span><br>data := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123; <span class="hljs-comment">// 定义一个 map 类型的数据，用于构造 JSON 响应</span><br><span class="hljs-string">&quot;lang&quot;</span>: <span class="hljs-string">&quot;GO语言&quot;</span>,   <span class="hljs-comment">// 设置 &quot;lang&quot; 键的值为 &quot;GO语言&quot;</span><br><span class="hljs-string">&quot;tag&quot;</span>:  <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>, <span class="hljs-comment">// 设置 &quot;tag&quot; 键的值为 &quot;&lt;br&gt;&quot;</span><br>&#125;<br><br>c.AsciiJSON(http.StatusOK, data) <span class="hljs-comment">// 使用 c.AsciiJSON() 方法将 map 数据转换为 ASCII JSON 格式，并作为响应发送给客户端</span><br>&#125;)<br><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 Gin web 服务器，监听在 8080 端口</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点"><a href="#（2）知识点" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>gin.Default()</code>: 这是 Gin 框架的一个方法，用于创建一个带有默认中间件的路由引擎，包括了 <code>logger</code> 和 <code>recovery</code> 中间件，用于记录请求日志和在出现 panic 时进行恢复，防止程序崩溃。</li><li><code>r.GET(&quot;/someJSON&quot;, ...)</code>：路由注册方法，指定一个路径为”&#x2F;someJSON”的GET请求，当客户端请求”some&#x2F;JSON”路径时，会调用后面的处理函数来处理该请求。</li><li><code>fun(c *gin.Context) &#123;...&#125;</code>：这是一个匿名函数，作为路由处理函数，接收一个<code>gin.Context</code>参数。</li><li><code>gin.Context</code>：是Gin框架的一个上下文对象，用于在处理<code>HTTP</code>请求和生成<code>HTTP</code>响应时传递和管理数据。每当 Gin 框架处理一个<code> HTTP</code> 请求时，都会创建一个新的 <code>gin.Context</code> 对象，并将其传递给注册的路由处理函数。它包含了很多有用的方法和属性，用于访问HTTP请求的各种信息，如请求路径、HTTP方法、球请求参数、请求头、请求体等。</li><li><code>data := map[string]interface&#123;&#125;&#123;...&#125;</code>：创建了一个<code>map[string]interface&#123;&#125;</code>类型的变量<code>data</code>，用于构造要返回的<code>JSON</code>数据。这里使用了一个简单的map，包含了连个键值对，分别是”lang”和”tag”。</li><li><code>c.AsciiJSON(http.StatusOK, data)</code>：这是<code>gin.Context</code>的方法，用于将data变量的内容作为<code>ASCII JSON</code>格式的响应返回给客户端。<code>http.StatusOK</code>是HTTP状态码，表示请求成功，这里将其作为响应的状态码。data 变量作为响应的主体内容，通过 <code>ASCII JSON</code> 格式进行序列化，并设置了响应的 <code>Content-Type </code>为 “application&#x2F;json; charset&#x3D;utf-8”。最终，这个处理函数会将生成的响应发送给客户端。</li></ul><h4 id="（3）示例大意"><a href="#（3）示例大意" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>导入了 <code>gin</code> 和 <code>net/http</code> 包，引入了 Gin 框架和标准库中处理 HTTP 请求和响应的功能。</li><li>创建了一个默认的 Gin 路由引擎 <code>r</code>，作为 HTTP 请求的入口。</li><li>注册了一个 GET 路由，路径为 “&#x2F;someJSON”，并定义了一个处理函数，处理函数使用 <code>c.AsciiJSON()</code> 方法将一个定义好的 map 数据转换为 ASCII JSON 格式，并作为响应发送给客户端。</li><li>使用 <code>r.Run()</code> 方法启动了一个 Gin web 服务器，并监听在 8080 端口，等待客户端的 HTTP 请求。</li><li>当客户端通过浏览器或其他 HTTP 客户端访问 “&#x2F;someJSON” 路径时，服务器会返回一个 JSON 格式的响应，包含了定义好的 <code>data</code> 数据，其中 “lang” 键的值为 “GO语言”，”tag” 键的值为 “<br>“。这个响应的内容类型为 ASCII JSON。</li></ol></blockquote><h2 id="2、绑定表单数据至自定义结构体"><a href="#2、绑定表单数据至自定义结构体" class="headerlink" title="2、绑定表单数据至自定义结构体"></a>2、绑定表单数据至自定义结构体</h2><blockquote><p>​下述代码实现了一个简单的Web应用程序，通过Gin框架处理HTTP请求，将从请求中获取的数据绑定到结构体变量，并生成JSON格式的HTTP响应体。</p></blockquote><h4 id="（1）完整代码-1"><a href="#（1）完整代码-1" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-keyword">type</span> StructA <span class="hljs-keyword">struct</span> &#123;<br>FieldA <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_a&quot;`</span> <span class="hljs-comment">// FieldA 是 StructA 的字段，使用 form 标签 &quot;field_a&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StructB <span class="hljs-keyword">struct</span> &#123;<br>NestedStruct StructA <span class="hljs-comment">// NestedStruct 是 StructB 的字段，类型为 StructA</span><br>FieldB       <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_b&quot;`</span> <span class="hljs-comment">// FieldB 是 StructB 的字段，使用 form 标签 &quot;field_b&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StructC <span class="hljs-keyword">struct</span> &#123;<br>NestedStructPointer *StructA <span class="hljs-comment">// NestedStructPointer 是 StructC 的指针字段，指向 StructA</span><br>FieldC              <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_c&quot;`</span> <span class="hljs-comment">// FieldC 是 StructC 的字段，使用 form 标签 &quot;field_c&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StructD <span class="hljs-keyword">struct</span> &#123;<br>NestedAnonyStruct <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// NestedAnonyStruct 是 StructD 的匿名结构体字段</span><br>FieldX <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_x&quot;`</span> <span class="hljs-comment">// FieldX 是匿名结构体的字段，使用 form 标签 &quot;field_x&quot;</span><br>&#125;<br>FieldD <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_d&quot;`</span> <span class="hljs-comment">// FieldD 是 StructD 的字段，使用 form 标签 &quot;field_d&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDataB</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> b StructB<br>c.Bind(&amp;b) <span class="hljs-comment">// 将请求数据绑定到 StructB</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;a&quot;</span>: b.NestedStruct, <span class="hljs-comment">// 返回 NestedStruct 的值作为响应，键名为 &quot;a&quot;</span><br><span class="hljs-string">&quot;b&quot;</span>: b.FieldB,       <span class="hljs-comment">// 返回 FieldB 的值作为响应，键名为 &quot;b&quot;</span><br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDataC</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> b StructC<br>c.Bind(&amp;b) <span class="hljs-comment">// 将请求数据绑定到 StructC</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;a&quot;</span>: b.NestedStructPointer, <span class="hljs-comment">// 返回 NestedStructPointer 的值作为响应，键名为 &quot;a&quot;</span><br><span class="hljs-string">&quot;c&quot;</span>: b.FieldC,              <span class="hljs-comment">// 返回 FieldC 的值作为响应，键名为 &quot;c&quot;</span><br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDataD</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> b StructD<br>c.Bind(&amp;b) <span class="hljs-comment">// 将请求数据绑定到 StructD</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;x&quot;</span>: b.NestedAnonyStruct, <span class="hljs-comment">// 返回 NestedAnonyStruct 的值作为响应，键名为 &quot;x&quot;</span><br><span class="hljs-string">&quot;d&quot;</span>: b.FieldD,            <span class="hljs-comment">// 返回 FieldD 的值作为响应，键名为 &quot;d&quot;</span><br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/getb&quot;</span>, GetDataB) <span class="hljs-comment">// 注册 GetDataB 作为 GET /getb 路由的处理函数</span><br>r.GET(<span class="hljs-string">&quot;/getc&quot;</span>, GetDataC) <span class="hljs-comment">// 注册 GetDataC 作为 GET /getc 路由的处理函数</span><br>r.GET(<span class="hljs-string">&quot;/getd&quot;</span>, GetDataD) <span class="hljs-comment">// 注册 GetDataD 作为 GET /getd 路由的处理函数</span><br><br>r.Run() <span class="hljs-comment">// 启动 Gin web 服务器</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-1"><a href="#（2）知识点-1" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>c.Bind(&amp;b)</code>：使用了Gin框架的<code>Bind</code>方法，将从HTTP请求中获取的数据绑定到<code>b</code>变量。<code>&amp;b</code>表示传递<code>b</code>的指针，以便将数据绑定到<code>b</code>变量的字段。</li><li><code>c.JSON(200, gin.H&#123;&quot;a&quot;: b.NestedStruct, &quot;b&quot;: b.FieldB&#125;)</code>：使用Gin框架的<code>JSON</code>方法，生成HTTP响应的JSON格式。<code>200</code>表示HTTP响应的状态码为200，<code>gin.H</code>是Gin框架提供的一种快捷方式，表示一个<code>map[string]interface&#123;&#125;</code>类型的数据结构，用于构造<code>JSON</code>响应体。在这里，构造了一个包含两个键值对的<code>JSON</code>响应体，其中键为<code>a</code>和<code>b</code>，值分别为<code>b.NestedStruct</code>和<code>b.FieldB</code>，这些值来自之前绑定的<code>b</code>变量的字段。</li><li>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，通常用于在不同应用程序之间传输和存储数据。JSON采用键值对的形式表示数据，使用文本格式进行序列化，具有简洁、易读、易解析的特点。</li></ul><h4 id="（3）示例大意-1"><a href="#（3）示例大意-1" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义了四个结构体类型：<code>StructA</code>、<code>StructB</code>、<code>StructC</code>、<code>StructD</code>，分别包含了不同的字段和标签。</li><li>在<code>GetDataB</code>处理函数中，从HTTP请求中绑定数据到<code>StructB</code>类型的变量<code>b</code>，然后生成JSON响应体，包含了<code>b.NestedStruct</code>和<code>b.FieldB</code>字段的值。</li><li>在<code>GetDataC</code>处理函数中，从HTTP请求中绑定数据到<code>StructC</code>类型的变量<code>b</code>，然后生成JSON响应体，包含了<code>b.NestedStructPointer</code>和<code>b.FieldC</code>字段的值。</li><li>在<code>GetDataD</code>处理函数中，从HTTP请求中绑定数据到<code>StructD</code>类型的变量<code>b</code>，然后生成JSON响应体，包含了<code>b.NestedAnonyStruct</code>和<code>b.FieldD</code>字段的值。</li><li>在<code>main</code>函数中，创建了一个Gin的默认路由器，并注册了三个路由（<code>/getb</code>、<code>/getc</code>、<code>/getd</code>），并将对应的处理函数（<code>GetDataB</code>、<code>GetDataC</code>、<code>GetDataD</code>）作为处理函数。最后调用<code>r.Run()</code>启动Gin的web服务器，监听并处理HTTP请求。</li></ol></blockquote><h4 id="（4）使用-curl-命令结果："><a href="#（4）使用-curl-命令结果：" class="headerlink" title="（4）使用 curl 命令结果："></a>（4）使用 <code>curl</code> 命令结果：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">命令行输入：curl <span class="hljs-string">&quot;http://localhost:8080/getb?field_a=hello&amp;field_b=world&quot;</span><br>终端显示：&#123;<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;FieldA&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-string">&quot;world&quot;</span>&#125;<br>命令行输入：curl <span class="hljs-string">&quot;http://localhost:8080/getc?field_a=hello&amp;field_c=world&quot;</span><br>终端显示：&#123;<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;FieldA&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;,<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-string">&quot;world&quot;</span>&#125;<br>命令行输入：curl <span class="hljs-string">&quot;http://localhost:8080/getd?field_x=hello&amp;field_d=world&quot;</span><br>终端显示：&#123;<span class="hljs-string">&quot;d&quot;</span>:<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>:&#123;<span class="hljs-string">&quot;FieldX&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="3、绑定-HTML-复选框"><a href="#3、绑定-HTML-复选框" class="headerlink" title="3、绑定 HTML 复选框"></a>3、绑定 HTML 复选框</h2><h4 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h4><blockquote><p>​在main.go文件的同目录下，存在<code>views/form.html</code>目录，且<code>form.html</code>文件里存放了HTML模板文件，如下：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Form Template<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Check some colors<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>Red<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colors[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span>Green<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colors[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;green&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span>Blue<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colors[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;blue&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）完整代码"><a href="#（2）完整代码" class="headerlink" title="（2）完整代码"></a>（2）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> myForm <span class="hljs-keyword">struct</span> &#123;<br>Colors []<span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;colors[]&quot;`</span> <span class="hljs-comment">/* 定义一个结构体 myForm，其中包含一个 Colors 字段，</span><br><span class="hljs-comment">    用于接收表单提交的 colors[] 参数*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><br>r.LoadHTMLGlob(<span class="hljs-string">&quot;views/*&quot;</span>) <span class="hljs-comment">// 加载 views 目录下的 HTML 模板文件</span><br><br>r.GET(<span class="hljs-string">&quot;/&quot;</span>, indexHandler) <span class="hljs-comment">// 处理根路径的 GET 请求，调用 indexHandler 函数</span><br>r.POST(<span class="hljs-string">&quot;/&quot;</span>, formHandler) <span class="hljs-comment">// 处理根路径的 POST 请求，调用 formHandler 函数</span><br><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 Gin 服务器监听在 8080 端口</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.HTML(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;form.html&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 在响应中渲染 form.html 模板并返回 200 状态码</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">formHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> fakeForm myForm<br>c.Bind(&amp;fakeForm)                 <span class="hljs-comment">// 绑定请求参数到 myForm 结构体</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;color&quot;</span>: fakeForm.Colors&#125;) <span class="hljs-comment">/* 返回 JSON 格式的响应，</span><br><span class="hljs-comment">包含 fakeForm 结构体中的 Colors 字段值*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）知识点"><a href="#（3）知识点" class="headerlink" title="（3）知识点"></a>（3）知识点</h4><ul><li><code>r.LoadHTMLGlob(&quot;views/*&quot;)</code>: 加载<code>views</code>目录下的HTML模板文件，用于后续的HTML模板渲染。<code>LoadHTMLGlob()</code>方法接受一个模板文件路径的参数，使用通配符<code>*</code>可以匹配指定目录下的所有文件。</li><li><code>r.GET(&quot;/&quot;, indexHandler)</code>: 注册一个处理根路径的GET请求的路由，当客户端发送GET请求到根路径”&#x2F;“时，Gin会调用<code>indexHandler</code>函数进行处理。<code>indexHandler</code>函数是自定义的处理函数，用于处理根路径的GET请求。</li><li><code>r.POST(&quot;/&quot;, formHandler)</code>: 注册一个处理根路径的POST请求的路由，当客户端发送POST请求到根路径”&#x2F;“时，Gin会调用<code>formHandler</code>函数进行处理。<code>formHandler</code>函数是自定义的处理函数，用于处理根路径的POST请求。</li></ul><h4 id="（4）示例大意"><a href="#（4）示例大意" class="headerlink" title="（4）示例大意"></a>（4）示例大意</h4><blockquote><ol><li>定义了一个名为<code>myForm</code>的结构体，其中包含一个<code>Colors</code>字段，用于接收表单提交的<code>colors[]</code>参数。<code>Colors</code>字段使用了<code>form:&quot;colors[]&quot;</code>标签，表示在表单中使用<code>colors[]</code>作为参数名。</li><li>在<code>main()</code>函数中创建了一个Gin引擎实例，并设置了默认的中间件。</li><li>使用<code>r.LoadHTMLGlob(&quot;views/*&quot;)</code>加载了<code>views</code>目录下的HTML模板文件，用于后续的HTML模板渲染。</li><li>使用<code>r.GET(&quot;/&quot;, indexHandler)</code>注册了一个处理根路径的GET请求的路由，当客户端发送GET请求到根路径”&#x2F;“时，Gin会调用<code>indexHandler</code>函数进行处理。</li><li>使用<code>r.POST(&quot;/&quot;, formHandler)</code>注册了一个处理根路径的POST请求的路由，当客户端发送POST请求到根路径”&#x2F;“时，Gin会调用<code>formHandler</code>函数进行处理。</li><li>定义了<code>indexHandler</code>函数，用于处理根路径的GET请求。该函数通过调用<code>c.HTML()</code>方法，在响应中渲染名为<code>form.html</code>的HTML模板，并返回200状态码。</li><li>定义了<code>formHandler</code>函数，用于处理根路径的POST请求。该函数首先定义了一个名为<code>fakeForm</code>的<code>myForm</code>类型的变量，然后通过调用<code>c.Bind()</code>方法，将请求参数绑定到<code>fakeForm</code>结构体中。最后，通过调用<code>c.JSON()</code>方法，返回一个JSON格式的响应，包含<code>fakeForm</code>结构体中的<code>Colors</code>字段值。</li></ol></blockquote><h2 id="4、绑定查询字符串或表单数据"><a href="#4、绑定查询字符串或表单数据" class="headerlink" title="4、绑定查询字符串或表单数据"></a>4、绑定查询字符串或表单数据</h2><h4 id="（1）完整代码-2"><a href="#（1）完整代码-2" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name     <span class="hljs-type">string</span>    <span class="hljs-string">`form:&quot;name&quot;`</span>                     <span class="hljs-comment">// 表单参数 &quot;name&quot;</span><br>    Address  <span class="hljs-type">string</span>    <span class="hljs-string">`form:&quot;address&quot;`</span>                  <span class="hljs-comment">// 表单参数 &quot;address&quot;</span><br>    Birthday time.Time <span class="hljs-string">`form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;`</span> <br>    <span class="hljs-comment">// 表单参数 &quot;birthday&quot;，使用指定的时间格式和转换为 UTC 时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    route := gin.Default() <span class="hljs-comment">// 创建默认的 Gin 路由引擎</span><br><br>    route.GET(<span class="hljs-string">&quot;/testing&quot;</span>, startPage) <span class="hljs-comment">// 注册 GET 请求处理函数 &quot;/testing&quot;</span><br><br>    route.Run(<span class="hljs-string">&quot;:8085&quot;</span>) <span class="hljs-comment">// 启动 Gin 服务并监听在 8085 端口</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startPage</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> person Person <span class="hljs-comment">// 创建一个 Person 结构体变量用于存储请求参数</span><br><br>    <span class="hljs-comment">// 使用 Gin 的 ShouldBind 方法将请求参数绑定到 Person 结构体变量上</span><br>    <span class="hljs-comment">// 如果请求是 GET 请求，则使用 Form 绑定引擎（query）进行参数绑定</span><br>    <span class="hljs-comment">// 如果请求是 POST 请求，则首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）绑定引擎</span><br>    <span class="hljs-comment">// 详细绑定规则可以参考：https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L48</span><br>    <span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;person); err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//绑定成功时返回nil，反之返回错误信息</span><br>log.Println(person.Name)<span class="hljs-comment">// 输出绑定后的 Name 字段值</span><br>log.Println(person.Address)<span class="hljs-comment">// 输出绑定后的 Address 字段值</span><br>log.Println(person.Birthday)<span class="hljs-comment">// 输出绑定后的 Birthday 字段值</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>&#125;<br><br>    c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Success&quot;</span>) <span class="hljs-comment">// 返回 &quot;Success&quot; 字符串作为响应</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-2"><a href="#（2）知识点-2" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li>​<code>ShouldBind</code> 是 Gin 框架提供的一个方法，用于将 HTTP 请求中的参数绑定到一个结构体变量上。<code>ShouldBind</code> 方法会根据请求中的参数名称和目标结构体的字段名称进行自动匹配，并将对应的参数值绑定到结构体字段上。在示例代码中的 <code>Person</code> 结构体定义中使用了 <code>form</code> 标签来指定参数的来源和绑定规则，如 <code>form:&quot;name&quot;</code>、<code>form:&quot;address&quot;</code> 和 <code>form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;</code>。这样，在调用 <code>ShouldBind</code> 方法时，Gin 会根据请求中的表单参数名称和结构体字段的标签进行自动匹配和绑定。需要注意的是，<code>ShouldBind</code> 方法在绑定参数时会根据目标结构体字段的类型和标签进行自动转换和验证，如果绑定失败会返回错误信息。因此，在使用 <code>ShouldBind</code> 方法时，需要进行错误处理，可以通过判断返回的错误是否为 <code>nil</code> 来判断参数绑定是否成功。如果绑定失败，可以通过错误信息来获取详细的错误原因，并做相应的处理。</li></ul><h4 id="（3）代码大意"><a href="#（3）代码大意" class="headerlink" title="（3）代码大意"></a>（3）代码大意</h4><blockquote><ol><li>定义了一个 <code>Person</code> 结构体，用于存储请求参数。<code>Person</code> 结构体包含了三个字段：<code>Name</code>、<code>Address</code> 和 <code>Birthday</code>，分别对应请求中的表单参数 “name”、”address” 和 “birthday”。</li><li>创建了一个 Gin 路由引擎 <code>route</code>，使用了默认的中间件。</li><li>注册了一个 HTTP GET 请求的处理函数 <code>startPage</code>，该处理函数通过调用 Gin 的 <code>ShouldBind</code> 方法将请求参数绑定到 <code>Person</code> 结构体变量 <code>person</code> 上。<code>ShouldBind</code> 方法会根据请求的类型（GET 或 POST）和请求的 content-type 自动选择合适的绑定引擎（Form 或 JSON&#x2F;XML 绑定引擎）进行参数绑定。</li><li>在 <code>startPage</code> 函数中，通过打印 <code>person</code> 结构体的字段值来验证参数绑定是否成功。</li><li>最后，返回了一个 HTTP 200 OK 响应，内容为 “Success” 字符串。</li></ol><p>总的来说，这段代码实现了一个简单的 HTTP GET 请求处理函数，使用 Gin 框架来绑定请求参数并处理请求。当请求到达 <code>/testing</code> 路径时，会触发 <code>startPage</code> 函数，将请求参数绑定到 <code>Person</code> 结构体变量，并输出字段值。如果参数绑定失败，则输出错误信息。最后返回一个 “Success” 字符串作为响应。</p></blockquote><h4 id="（4）测试"><a href="#（4）测试" class="headerlink" title="（4）测试"></a>（4）测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">http:<span class="hljs-comment">//localhost:8085/testing?name=ft&amp;address=China&amp;birthday=2023-04-11</span><br></code></pre></td></tr></table></figure><p>若响应成功，可以看到页面中会显示<code>Success</code>；</p><p>若响应成功，且信息匹配成功，终端中会打印出信息。</p><h2 id="5、绑定-Uri"><a href="#5、绑定-Uri" class="headerlink" title="5、绑定 Uri"></a>5、绑定 Uri</h2><h4 id="（1）完整代码-3"><a href="#（1）完整代码-3" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-comment">// Person 结构体用于绑定 URI 参数</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">string</span> <span class="hljs-string">`uri:&quot;id&quot; binding:&quot;required,uuid&quot;`</span> <span class="hljs-comment">// 将 URI 中的 id 参数绑定到 ID 字段，并指定必填和 UUID 格式验证</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`uri:&quot;name&quot; binding:&quot;required&quot;`</span>    <span class="hljs-comment">// 将 URI 中的 name 参数绑定到 Name 字段，并指定必填验证</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>route := gin.Default()<span class="hljs-comment">// 创建默认的 Gin 路由引擎</span><br><br><span class="hljs-comment">// 定义路由处理函数</span><br>route.GET(<span class="hljs-string">&quot;/:name/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> person Person<br><span class="hljs-comment">// 使用 ShouldBindUri 方法将 URI 参数绑定到 Person 结构体</span><br><span class="hljs-keyword">if</span> err := c.ShouldBindUri(&amp;person); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//绑定成功，返回nil</span><br>c.JSON(<span class="hljs-number">400</span>, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: err.Error()&#125;) <span class="hljs-comment">// 如果绑定失败，返回错误信息</span><br><span class="hljs-keyword">return</span><br>&#125;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;name&quot;</span>: person.Name, <span class="hljs-string">&quot;uuid&quot;</span>: person.ID&#125;) <span class="hljs-comment">// 如果绑定成功，返回绑定后的值</span><br>&#125;)<br><br>route.Run(<span class="hljs-string">&quot;:8088&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-3"><a href="#（2）知识点-3" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>c.ShouldBindUri(&amp;person)</code>: 这是 <code>*gin.Context</code> 上下文对象的方法，用于将 URI 参数绑定到结构体变量 <code>person</code> 上。<code>ShouldBindUri</code> 方法会自动根据结构体字段的 <code>uri</code> 标签和 URI 路径中的参数名称进行匹配和绑定。在示例代码中，<code>ID</code> 字段的 <code>uri</code> 标签指定了参数名称为 <code>id</code>，<code>Name</code> 字段的 <code>uri</code> 标签指定了参数名称为 <code>name</code>。同时，结构体字段的 <code>binding</code> 标签还指定了参数的验证规则，例如 <code>required</code> 表示参数必填，<code>uuid</code> 表示参数的值必须是 UUID 格式。</li><li><code>c.JSON(400, gin.H&#123;&quot;msg&quot;: err.Error()&#125;)</code>: 这是 <code>*gin.Context</code> 上下文对象的方法，用于构建一个 JSON 格式的 HTTP 响应。其中，<code>400</code> 表示 HTTP 状态码为 400（Bad Request），<code>gin.H&#123;&quot;msg&quot;: err.Error()&#125;</code> 表示响应的 JSON 数据，包含一个名为 <code>msg</code> 的字段，值为错误信息的字符串。</li><li><code>c.JSON(200, gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;)</code>: 这是 <code>*gin.Context</code> 上下文对象的方法，用于构建一个 JSON 格式的 HTTP 响应。其中，<code>200</code> 表示 HTTP 状态码为 200（OK），<code>gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;</code> 表示响应的 JSON 数据，包含两个字段，分别为 <code>name</code> 和 <code>uuid</code>，值分别为 <code>person.Name</code> 和 <code>person.ID</code> 的值，即绑定后的 URI 参数值。</li></ul><h4 id="（3）示例大意-2"><a href="#（3）示例大意-2" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><p>上述代码使用了 Gin 框架来创建一个 HTTP 服务器，并定义了一个 GET 请求处理函数，该处理函数绑定了两个 URI 参数（<code>:name</code> 和 <code>:id</code>）到一个自定义的结构体 <code>Person</code> 的字段上。具体而言，代码实现了以下几个功能：</p><ol><li>导入了 <code>github.com/gin-gonic/gin</code> 包，该包是 Gin 框架的核心库，提供了用于构建 Web 应用的 HTTP 路由和中间件功能。</li><li>定义了一个名为 <code>Person</code> 的结构体，该结构体包含了两个字段 <code>ID</code> 和 <code>Name</code>，分别用于绑定 URI 参数 <code>id</code> 和 <code>name</code>。</li><li>创建了一个默认的 Gin 路由引擎实例 <code>route</code>，用于处理 HTTP 请求和路由。</li><li>定义了一个路由处理函数，处理 HTTP GET 请求，该处理函数绑定了路由路径中的 <code>:name</code> 和 <code>:id</code> 参数到 <code>Person</code> 结构体的字段上，并在绑定成功后返回绑定后的值，否则返回错误信息。</li><li>使用 <code>c.ShouldBindUri(&amp;person)</code> 方法将 URI 参数绑定到 <code>Person</code> 结构体的字段上。<code>ShouldBindUri</code> 方法会根据结构体字段的标签信息来解析和验证 URI 参数，并将解析后的值赋给结构体字段。</li><li>如果 URI 参数绑定失败（例如，缺少必填参数或参数格式不符合预期），则通过 <code>c.JSON</code> 方法返回 HTTP 状态码 400（Bad Request）和错误信息。</li><li>如果 URI 参数绑定成功，则通过 <code>c.JSON</code> 方法返回 HTTP 状态码 200（OK）和绑定后的值，包括 <code>Person</code> 结构体中的 <code>Name</code> 和 <code>ID</code> 字段的值。</li><li>最后，通过 <code>route.Run(&quot;:8088&quot;)</code> 启动 HTTP 服务器，监听在本地的 8088 端口上。一旦有请求到达该端口，将会由 Gin 路由引擎处理并调用相应的路由处理函数。</li></ol></blockquote><h4 id="（4）测试-1"><a href="#（4）测试-1" class="headerlink" title="（4）测试"></a>（4）测试</h4><p>网页：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">http:<span class="hljs-comment">//localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3</span><br>http:<span class="hljs-comment">//localhost:8088/thinkerou/not-uuid</span><br></code></pre></td></tr></table></figure><p>终端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">Invoke-WebRequest -Uri <span class="hljs-string">&quot;http://localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3&quot;</span> -Method GET<br><br>Invoke-WebRequest -Uri <span class="hljs-string">&quot;http://localhost:8088/thinkerou/not-uuid&quot;</span> -Method GET<br></code></pre></td></tr></table></figure><h2 id="6、控制Log高亮输出"><a href="#6、控制Log高亮输出" class="headerlink" title="6、控制Log高亮输出"></a>6、控制Log高亮输出</h2><blockquote><p>默认是会高亮（当然这基于你使用的 TTY）。</p></blockquote><h4 id="（1）完整代码-4"><a href="#（1）完整代码-4" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>如果你不想使用日志高亮：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 关闭高亮</span><br>    gin.DisableConsoleColor()<br><br>    <span class="hljs-comment">// 创建一个带有默认中间件（logger和recovery）的gin路由器</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 处理GET请求，路径为&quot;/ping&quot;</span><br>    router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>) <span class="hljs-comment">// 向客户端返回字符串&quot;pong&quot;，状态码为200</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 启动HTTP服务器，监听在端口8080上，等待客户端请求</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>手动设置高亮：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 强制开启日志高亮显示</span><br>    gin.ForceConsoleColor()<br><br>    <span class="hljs-comment">// 创建一个带有默认中间件（logger和recovery）的gin路由器</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 处理GET请求，路径为&quot;/ping&quot;</span><br>    router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>) <span class="hljs-comment">// 向客户端返回字符串&quot;pong&quot;，状态码为200</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 启动HTTP服务器，监听在端口8080上，等待客户端请求</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-4"><a href="#（2）知识点-4" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>gin.ForceConsoleColor()</code>: 这是 Gin 框架的一个方法，用于强制开启日志的高亮显示。它可以让 Gin 框架在控制台输出的日志信息更加醒目和易读。</li><li><code>gin.DisableConsoleColor()</code>: 这是 Gin 框架的一个方法，用于关闭日志的高亮显示。当调用了这个方法后，Gin 框架在控制台输出的日志信息将不再具有高亮效果，变为普通的文本显示。</li></ul><h2 id="7、自定义HTTP配置"><a href="#7、自定义HTTP配置" class="headerlink" title="7、自定义HTTP配置"></a>7、自定义HTTP配置</h2><h4 id="（1）完整代码-5"><a href="#（1）完整代码-5" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>​直接使用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例，使用默认的中间件：日志和恢复中间件</span><br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, router) <span class="hljs-comment">// 启动 HTTP 服务器，监听在端口 8080 上，使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>或</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例，使用默认的中间件：日志和恢复中间件</span><br><br>    <span class="hljs-comment">// 创建一个自定义的 http.Server 实例</span><br>    s := &amp;http.Server&#123;<br>        Addr:           <span class="hljs-string">&quot;:8080&quot;</span>,                        <span class="hljs-comment">// 监听的地址和端口</span><br>        Handler:        router,                         <span class="hljs-comment">// 使用创建的路由引擎处理请求</span><br>        ReadTimeout:    <span class="hljs-number">10</span> * time.Second,               <span class="hljs-comment">// 读取请求超时时间</span><br>        WriteTimeout:   <span class="hljs-number">10</span> * time.Second,               <span class="hljs-comment">// 写入响应超时时间</span><br>        MaxHeaderBytes: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>,                         <span class="hljs-comment">// 最大请求头大小</span><br>    &#125;<br><br>    s.ListenAndServe() <span class="hljs-comment">// 启动 HTTP 服务器，监听在指定的地址和端口，并使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-5"><a href="#（2）知识点-5" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><p><code>http.ListenAndServe(&quot;:8080&quot;, router)</code>: 这是 Go 标准库 <code>net/http</code> 提供的一个方法，用于启动一个 HTTP 服务器并监听指定的地址和端口，并使用传入的路由引擎处理请求。在这里，我们指定监听地址为空字符串，表示监听所有可用的网卡，端口为 8080。<code>router</code> 是之前创建的 Gin 路由引擎实例，用于处理请求。</p></li><li><p><code>s := &amp;http.Server&#123;...&#125;</code>这段代码创建了一个 <code>http.Server</code> 实例，并设置了以下配置项：</p></li><li><ol><li><code>Addr</code>：指定服务器监听的地址和端口，这里设置为 <code>:8080</code>，表示监听在本地的 8080 端口。</li><li><code>Handler</code>：设置处理请求的路由引擎，这里使用了之前创建的 <code>router</code>，即 Gin 路由引擎。</li><li><code>ReadTimeout</code>：设置读取请求的超时时间，这里设置为 10 秒，表示如果在 10 秒内没有读取到完整的请求，服务器会关闭连接。</li><li><code>WriteTimeout</code>：设置写入响应的超时时间，这里设置为 10 秒，表示如果在 10 秒内没有完成响应的写入操作，服务器会关闭连接。</li><li><code>MaxHeaderBytes</code>：设置最大请求头的大小，这里设置为 1 &lt;&lt; 20，即 1MB，表示请求头的大小不超过 1MB。</li></ol></li><li><p>这些配置项可以根据具体的需求进行调整，用于自定义 HTTP 服务器的行为，例如设置超时时间、限制请求头大小等。在创建完 <code>http.Server</code> 实例后，可以通过调用 <code>ListenAndServe()</code> 方法来启动服务器，开始监听指定的地址和端口，并使用设置的路由引擎来处理请求。</p></li><li><p><code>s.ListenAndServe()</code>: 这是 http.Server 的一个方法，用于启动 HTTP 服务器，并监听在指定的地址和端口，使用创建的路由引擎处理请求。在这里，<code>s</code> 是之前创建的自定义 http.Server 实例，通过调用 <code>ListenAndServe()</code> 方法来启动服务器。</p></li></ul><h4 id="（3）示例大意-3"><a href="#（3）示例大意-3" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>创建一个默认的 Gin 路由引擎实例，使用了默认的中间件包括日志和恢复中间件。</li><li>创建一个自定义的 <code>http.Server</code> 实例，设置了监听的地址和端口为 <code>:8080</code>，使用之前创建的路由引擎 <code>router</code> 来处理请求，设置了读取请求的超时时间为 10 秒，写入响应的超时时间为 10 秒，最大请求头大小为 1MB。</li><li>调用 <code>ListenAndServe()</code> 方法启动 HTTP 服务器，开始监听指定的地址和端口，并使用创建的路由引擎来处理请求。</li></ol><p>这段代码的目的是创建一个自定义的 HTTP 服务器，使用 Gin 框架来处理请求，并设置了一些自定义的配置项，如超时时间和最大请求头大小。最后通过调用 <code>ListenAndServe()</code> 方法启动服务器，使其开始监听客户端请求。</p></blockquote><h2 id="8、-自定义-Log-文件"><a href="#8、-自定义-Log-文件" class="headerlink" title="8、 自定义 Log 文件"></a>8、 自定义 Log 文件</h2><h4 id="（1）完整代码-6"><a href="#（1）完整代码-6" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 路由引擎实例，不使用默认的中间件</span><br><br><span class="hljs-comment">// 添加自定义的日志中间件，将日志格式化为自定义格式</span><br>router.Use(gin.LoggerWithFormatter(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(param gin.LogFormatterParams)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 自定义日志格式</span><br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s - [%s] \&quot;%s %s %s %d %s \&quot;%s\&quot; %s\&quot;\n&quot;</span>,<br>param.ClientIP,                       <span class="hljs-comment">//客户端 IP 地址</span><br>param.TimeStamp.Format(time.RFC1123), <span class="hljs-comment">//时间戳</span><br>param.Method,                         <span class="hljs-comment">//请求方法</span><br>param.Path,                           <span class="hljs-comment">//请求路径</span><br>param.Request.Proto,                  <span class="hljs-comment">//请求协议版本</span><br>param.StatusCode,                     <span class="hljs-comment">//响应状态码</span><br>param.Latency,                        <span class="hljs-comment">//请求耗时</span><br>param.Request.UserAgent(),            <span class="hljs-comment">//客户端 UserAgent 信息</span><br>param.ErrorMessage,                   <span class="hljs-comment">// 错误信息（若有错误发生时）</span><br>)<br>&#125;))<br><br>router.Use(gin.Recovery()) <span class="hljs-comment">// 添加恢复中间件，用于恢复从 panic 中恢复</span><br><br>router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器，监听在指定的地址和端口，并使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-6"><a href="#（2）知识点-6" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><p><code>router.Use()</code>: 此方法用于向 Gin 路由引擎添加中间件。中间件是处理 HTTP 请求的函数，在请求到达实际的路由处理器之前被执行。在这段代码中，使用 <code>router.Use()</code> 添加了两个中间件函数：</p></li><li><p><code>router.Use()</code>: 此方法用于向 Gin 路由引擎添加中间件。中间件是处理 HTTP 请求的函数，在请求到达实际的路由处理器之前被执行。在这段代码中，使用 <code>router.Use()</code> 添加了两个中间件函数：</p></li><li><p><code>gin.LoggerWithFormatter()</code>: 这个中间件函数用于以自定义格式记录 HTTP 请求日志。<code>param</code> 参数是 <code>gin.LogFormatterParams</code> 类型的实例，包含了有关 HTTP 请求和响应的信息。在给定的代码中，<code>param</code> 被用于格式化一个自定义的日志字符串，其中包括了客户端 IP 地址、时间戳、HTTP 方法、请求路径、协议版本、响应状态码、请求耗时、客户端 UserAgent 信息和错误消息（如果有的话）。</p></li><li><p><code>gin.Recovery()</code>: 这个中间件函数用于从可能在处理 HTTP 请求时发生的 panic 中恢复。如果发生 panic，这个中间件会从中恢复，并向客户端返回一个 500 内部服务器错误的响应。</p></li></ul><h4 id="（3）示例大意-4"><a href="#（3）示例大意-4" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li><p>导入了 <code>fmt</code>、<code>github.com/gin-gonic/gin</code> 和 <code>time</code> 包。</p></li><li><p>在 <code>main()</code> 函数中，创建了一个新的 Gin 路由引擎实例 <code>router</code>，并使用 <code>gin.New()</code> 方法创建了一个不使用默认中间件的路由引擎。</p></li><li><p>使用 <code>router.Use()</code> 方法添加了两个自定义中间件：</p><p>a. <code>gin.LoggerWithFormatter()</code> 中间件，用于将日志格式化为自定义格式。在回调函数中，通过 <code>gin.LogFormatterParams</code> 参数获取了请求和响应的信息，然后使用自定义的格式将这些信息组合成一个日志字符串。</p><p>b. <code>gin.Recovery()</code> 中间件，用于从 panic 中恢复。这将确保在处理请求时发生 panic 时，服务器不会崩溃，而是能够从中恢复，并返回一个 500 内部服务器错误的响应。</p></li><li><p>使用 <code>router.GET()</code> 方法定义了一个处理 HTTP GET 请求的路由，路径为 “&#x2F;ping”。在回调函数中，使用 <code>c.String()</code> 方法向客户端发送一个状态码为 200 的 “pong” 字符串响应。</p></li><li><p>最后，使用 <code>router.Run()</code> 方法启动了 HTTP 服务器，监听在地址 “:8080” 上，并使用创建的路由引擎处理传入的请求。</p></li></ol><p>这段代码的功能是创建一个简单的 HTTP 服务器，监听在端口 8080，当访问 “&#x2F;ping” 路径时，返回一个 “pong” 的响应。同时，还添加了自定义的日志中间件和恢复中间件，以增强服务器的健壮性和可靠性。</p></blockquote><h2 id="9、自定义中间件"><a href="#9、自定义中间件" class="headerlink" title="9、自定义中间件"></a>9、自定义中间件</h2><h4 id="（1）完整代码-7"><a href="#（1）完整代码-7" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Logger</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        t := time.Now() <span class="hljs-comment">// 记录当前时间</span><br><br>        c.Set(<span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>) <span class="hljs-comment">// 设置一个名为 &quot;example&quot; 的自定义变量到 Gin 上下文中</span><br><br>        <span class="hljs-comment">// 请求前的处理逻辑</span><br><br>        c.Next() <span class="hljs-comment">// 执行下一个处理函数</span><br><br>        <span class="hljs-comment">// 请求后的处理逻辑</span><br>        latency := time.Since(t) <span class="hljs-comment">// 计算请求耗时</span><br>        log.Print(latency) <span class="hljs-comment">// 打印请求耗时</span><br><br>        status := c.Writer.Status() <span class="hljs-comment">// 获取响应状态码</span><br>        log.Println(status) <span class="hljs-comment">// 打印响应状态码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 路由引擎实例</span><br><br>    r.Use(Logger()) <span class="hljs-comment">// 使用自定义的 Logger 中间件</span><br><br>    r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        example := c.MustGet(<span class="hljs-string">&quot;example&quot;</span>).(<span class="hljs-type">string</span>) <span class="hljs-comment">// 从 Gin 上下文中获取之前设置的 &quot;example&quot; 变量</span><br><br>        <span class="hljs-comment">// 打印：&quot;12345&quot;</span><br>        log.Println(example)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器，监听在指定的地址和端口，并使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-7"><a href="#（2）知识点-7" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><p><code>time.Now()</code>: 这是 Go 语言中的时间包 <code>time</code> 中的函数，用于获取当前时间。在这段代码中，用于记录请求处理开始的时间 <code>t</code>，以便后续计算请求耗时。</p></li><li><p><code>c.Set(key string, value interface&#123;&#125;)</code>: 这是 Gin 框架中 <code>Context</code> 对象的方法，用于在 Gin 上下文中设置一个自定义的键值对。在这段代码中，使用该方法将一个名为 “example” 的自定义变量设置到 Gin 上下文中，值为字符串 “12345”。</p></li><li><p><code>c.Next()</code>: 这是 Gin 框架中 <code>Context</code> 对象的方法，用于执行下一个处理函数。在这段代码中，用于将请求传递给下一个处理函数，通常在中间件中使用，确保请求能够继续向后处理。</p></li><li><p><code>time.Since(t)</code>: 这是 Go 语言中的时间包 <code>time</code> 中的函数，用于计算当前时间与给定时间 <code>t</code> 的时间差。在这段代码中，用于计算请求耗时，即当前时间与请求处理开始时间 <code>t</code> 的时间差。</p></li><li><p><code>log.Print(v ...interface&#123;&#125;)</code>: 这是 Go 语言中的日志包 <code>log</code> 中的函数，用于将日志消息打印到标准输出。在这段代码中，用于打印请求耗时 <code>latency</code>和用于打印响应状态码。</p></li><li><p><code>c.Writer.Status()</code>: 这是 Gin 框架中 <code>Context</code> 对象的方法，用于获取响应状态码。在这段代码中，用于获取响应状态码，以便后续打印到日志中。</p></li></ul><h4 id="（3）示例执行过程"><a href="#（3）示例执行过程" class="headerlink" title="（3）示例执行过程"></a>（3）示例执行过程</h4><blockquote><ol><li>在 <code>main()</code> 函数中，首先创建了一个新的 Gin 路由引擎实例 <code>r</code>。</li><li>使用 <code>r.Use(Logger())</code> 将自定义的 <code>Logger</code> 中间件注册到路由引擎 <code>r</code> 中，以便在处理请求时自动调用。</li><li>定义了一个处理 HTTP GET 请求的路由处理函数，路径为 “&#x2F;test”。在这个处理函数中，使用 <code>c.MustGet(&quot;example&quot;)</code> 从 Gin 上下文中获取之前在 <code>Logger</code> 中间件中设置的名为 “example” 的自定义变量，并将其转换为字符串类型。</li><li>在路由处理函数中，使用日志包 <code>log</code> 将获取到的 “example” 变量打印到日志中。</li><li>使用 <code>r.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在地址 “:8080” 并使用创建的路由引擎 <code>r</code> 处理请求。</li><li>当有请求到达时，Gin 框架会依次执行注册到路由引擎的中间件和路由处理函数。</li><li><code>Logger()</code> 中间件会在请求前记录当前时间，并设置一个名为 “example” 的自定义变量到 Gin 上下文中。然后，它会调用 <code>c.Next()</code> 执行下一个处理函数，即路由处理函数。</li><li>路由处理函数会从 Gin 上下文中获取 “example” 变量，并将其打印到日志中。</li><li>当路由处理函数执行完毕后，控制权会返回到 <code>Logger()</code> 中间件，它会计算请求耗时，并将请求耗时和响应状态码打印到日志中。</li><li>最后，HTTP 服务器会根据定义的路由引擎 <code>r</code> 处理请求，并在指定的地址和端口上监听。</li></ol></blockquote><h2 id="10、自定义验证器"><a href="#10、自定义验证器" class="headerlink" title="10、自定义验证器"></a>10、自定义验证器</h2><blockquote><p>可能有问题。略</p></blockquote><h4 id="（1）完整代码-8"><a href="#（1）完整代码-8" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin/binding&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-playground/validator/v10&quot;</span><br>)<br><br><span class="hljs-comment">// Booking contains binded and validated data.</span><br><span class="hljs-keyword">type</span> Booking <span class="hljs-keyword">struct</span> &#123;<br>    CheckIn  time.Time <span class="hljs-string">`form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;`</span><br>    CheckOut time.Time <span class="hljs-string">`form:&quot;check_out&quot; binding:&quot;required,gtfield=CheckIn,bookabledate&quot; time_format:&quot;2006-01-02&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bookableDate validator.Func = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(fl validator.FieldLevel)</span></span> <span class="hljs-type">bool</span> &#123;<br>    date, ok := fl.Field().Interface().(time.Time)<br>    <span class="hljs-keyword">if</span> ok &#123;<br>        today := time.Now()<br>        <span class="hljs-keyword">if</span> today.After(date) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    route := gin.Default()<br><br>    <span class="hljs-comment">// 注册自定义验证器函数</span><br>    <span class="hljs-keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;<br>        v.RegisterValidation(<span class="hljs-string">&quot;bookabledate&quot;</span>, bookableDate)<br>    &#125;<br><br>    <span class="hljs-comment">// 定义路由</span><br>    route.GET(<span class="hljs-string">&quot;/bookable&quot;</span>, getBookable)<br><br>    <span class="hljs-comment">// 启动服务</span><br>    route.Run(<span class="hljs-string">&quot;:8085&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBookable</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> b Booking<br>    <span class="hljs-keyword">if</span> err := c.ShouldBindWith(&amp;b, binding.Query); err == <span class="hljs-literal">nil</span> &#123;<br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Booking dates are valid!&quot;</span>&#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-8"><a href="#（2）知识点-8" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><p><code>type Booking struct</code>: 定义了一个结构体类型 <code>Booking</code>，用于存储从请求中绑定和验证后的数据。</p></li><li><p><code>var bookableDate validator.Func</code>: 定义了一个自定义验证器函数 <code>bookableDate</code>，用于验证日期是否可预订。该函数会在后续的验证中使用。</p></li><li><p><code>binding.Validator.Engine()</code>: 获取 Gin 框架中的验证器引擎实例，用于注册自定义验证器函数。</p></li><li><p><code>v.RegisterValidation(&quot;bookabledate&quot;, bookableDate)</code>: 使用 <code>v.RegisterValidation()</code> 方法将自定义验证器函数 <code>bookableDate</code> 注册到 Gin 的验证器引擎中，并指定了验证器的名称为 “bookabledate”。这样，在后续的验证中就可以通过该名称来使用这个自定义验证器函数。</p></li><li><p><code>var bookableDate validator.Func</code>: 定义了一个自定义验证器函数 <code>bookableDate</code>，用于验证日期是否可预订。该函数会在后续的验证中使用。</p></li><li><p><code>c.ShouldBindWith(&amp;b, binding.Query)</code>: 在 <code>getBookable</code> 处理函数中，使用 <code>c.ShouldBindWith()</code> 方法将请求中的数据绑定到 <code>b</code> 变量，并使用 <code>binding.Query</code> 标签指定了从查询参数中获取数据。这样，请求中的数据就会被绑定到 <code>Booking</code> 结构体的字段，并且会进行后续的验证。</p></li><li><p><code>c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</code>: 在验证失败时，使用 <code>c.JSON()</code> 方法将一个 JSON 格式的错误响应发送给客户端，其中包含了一个键值对，键为 “error”，值为验证失败的错误信息。HTTP 状态码被设置为 <code>http.StatusBadRequest</code>，表示请求参数错误。</p></li><li><p>自定义验证器函数，用于验证日期是否可预订，具体实现如下：</p><ul><li><code>func(fl validator.FieldLevel) bool</code>: 这是一个函数类型，参数为 <code>validator.FieldLevel</code>，返回值为 <code>bool</code>。<code>validator.FieldLevel</code> 是一个接口，用于在验证器中获取字段的相关信息，如字段的值、字段的标签等。</li><li><code>fl.Field().Interface().(time.Time)</code>: 使用 <code>fl.Field()</code> 方法获取字段的值，并使用 <code>Interface()</code> 方法将其转换为 <code>interface&#123;&#125;</code> 类型。然后使用类型断言将其转换为 <code>time.Time</code> 类型的值。这样，我们可以在函数中使用字段的实际值进行验证。</li><li><code>today := time.Now()</code>: 使用 <code>time.Now()</code> 函数获取当前的时间，并将其赋值给 <code>today</code> 变量，表示当前的日期时间。</li><li><code>if today.After(date) &#123; return false &#125;</code>: 使用 <code>today.After()</code> 方法比较当前时间和字段值的时间，如果当前时间晚于字段值的时间，则返回 <code>false</code>，表示验证失败，日期不可预订。</li><li><code>return true</code>: 如果验证通过，即当前时间不晚于字段值的时间，返回 <code>true</code>，表示日期可预订。</li></ul><p>总的来说，这个函数的实现逻辑是通过比较当前时间和字段值的时间来判断日期是否可预订，如果当前时间晚于字段值的时间，则认为日期不可预订，返回 <code>false</code>，否则返回 <code>true</code>。</p></li></ul></blockquote><h4 id="（3）示例大意-5"><a href="#（3）示例大意-5" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义了一个 <code>Booking</code> 结构体，包含了两个字段 <code>CheckIn</code> 和 <code>CheckOut</code>，分别表示入住日期和离店日期。这两个字段使用了 Gin 的 <code>form</code> 标签指定了它们在请求参数中的名称，并使用了 <code>binding</code> 标签来指定了验证规则。</li><li>定义了一个名为 <code>bookableDate</code> 的自定义验证器函数，用于验证日期是否可预订。这个函数在验证器中注册为 <code>bookabledate</code>，并在验证过程中获取字段的实际值，比较当前时间和字段值的时间来判断日期是否可预订。</li><li>在 <code>main</code> 函数中，创建了一个 Gin 的默认引擎，用于处理 HTTP 请求。然后使用 <code>binding.Validator.Engine()</code> 方法获取到验证器引擎，并使用 <code>v.RegisterValidation()</code> 方法注册了自定义验证器函数 <code>bookableDate</code>。</li><li>定义了一个名为 <code>getBookable</code> 的处理函数，用于处理 <code>/bookable</code> 路由的 GET 请求。在这个处理函数中，首先创建了一个 <code>Booking</code> 结构体实例 <code>b</code>，然后使用 <code>c.ShouldBindWith()</code> 方法将请求参数绑定到 <code>b</code> 上，并进行验证。如果验证通过，则返回 HTTP 状态码为 200 的 JSON 响应，表示预订日期有效；否则，返回 HTTP 状态码为 400 的 JSON 响应，表示验证失败并返回错误信息。</li><li>启动了 Gin 服务，并监听在 8085 端口上。</li></ol></blockquote><h2 id="11、定义路由日志的格式"><a href="#11、定义路由日志的格式" class="headerlink" title="11、定义路由日志的格式"></a>11、定义路由日志的格式</h2><h4 id="（1）完整代码-9"><a href="#（1）完整代码-9" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 实例作为路由引擎</span><br><br><span class="hljs-comment">// 设置 DebugPrintRouteFunc 函数，用于在控制台打印路由信息</span><br>gin.DebugPrintRouteFunc = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(httpMethod, absolutePath, handlerName <span class="hljs-type">string</span>, nuHandlers <span class="hljs-type">int</span>)</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;endpoint %v %v %v %v\n&quot;</span>, httpMethod, absolutePath, handlerName, nuHandlers)<br>&#125;<br><br><span class="hljs-comment">// 定义 POST /foo 路由，处理函数返回 JSON 响应 &quot;foo&quot;</span><br>r.POST(<span class="hljs-string">&quot;/foo&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;foo&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 定义 GET /bar 路由，处理函数返回 JSON 响应 &quot;bar&quot;</span><br>r.GET(<span class="hljs-string">&quot;/bar&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;bar&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 定义 GET /status 路由，处理函数返回 JSON 响应 &quot;ok&quot;</span><br>r.GET(<span class="hljs-string">&quot;/status&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;ok&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-9"><a href="#（2）知识点-9" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>gin.DebugPrintRouteFunc</code>: 这是 Gin 框架中的一个变量，用于设置在控制台打印路由信息的函数。您在代码中通过给该变量赋值一个函数来自定义路由信息的打印方式。在您的示例中，设置了一个自定义的打印函数，用于在控制台输出 HTTP 方法、URL 路径、处理函数名和处理函数的数量。其中，<code>httpMethod</code> 是 HTTP 请求方法（如 “GET”、”POST” 等），<code>absolutePath</code> 是路由的完整路径，<code>handlerName</code> 是处理函数的名称，<code>nuHandlers</code> 是处理函数的数量，通过调用 <code>log.Printf</code> 函数将路由调试打印的信息输出到控制台。</li><li><code>r.GET(&quot;/bar&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: 这是 Gin 框架中的一个方法，用于定义一个处理 HTTP GET 请求的路由。在这里，您定义了一个处理 <code>/bar</code> 路径的 GET 请求的路由，并传入一个匿名函数作为处理函数。可以在浏览器中输入网址<code>[localhost:8080/bar](http://localhost:8080/bar)</code>访问。</li><li><code>r.POST(&quot;/foo&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: 这是 Gin 框架中的一个方法，用于定义一个处理 HTTP POST 请求的路由。在这里，您定义了一个处理 <code>/foo</code> 路径的 POST 请求的路由，并传入一个匿名函数作为处理函数。这个匿名函数会在请求到达时被调用，其中 <code>c *gin.Context</code> 是处理函数的参数，表示当前请求的上下文。不能在浏览器中直接输入网址访问，因为这里的是POST请求，需要在客户端输入<code>curl -X POST http://localhost:8080/foo</code>或者在 PowerShell 中发送 HTTP 请求并指定请求方法访问<code>Invoke-RestMethod -Uri &#39;http://localhost:8080/foo&#39; -Method Post</code></li></ul></blockquote><h4 id="（3）示例大意-6"><a href="#（3）示例大意-6" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>导入了所需的包，包括日志处理、HTTP 相关的包以及 Gin 框架的包。</li><li>在 <code>main</code> 函数中创建了一个 Gin 实例 <code>r</code>，作为路由引擎。</li><li>使用 <code>gin.DebugPrintRouteFunc</code> 函数设置了一个自定义的路由调试打印函数，用于在控制台打印路由信息。</li><li>定义了一个处理 POST 请求的路由 <code>/foo</code>，当该路由接收到 POST 请求时，会执行传入的匿名函数，该函数会在 HTTP 响应中返回 JSON 格式的响应 “foo”。</li><li>定义了一个处理 GET 请求的路由 <code>/bar</code>，当该路由接收到 GET 请求时，会执行传入的匿名函数，该函数会在 HTTP 响应中返回 JSON 格式的响应 “bar”。</li><li>定义了一个处理 GET 请求的路由 <code>/status</code>，当该路由接收到 GET 请求时，会执行传入的匿名函数，该函数会在 HTTP 响应中返回 JSON 格式的响应 “ok”。</li><li>调用 <code>r.Run()</code> 启动 HTTP 服务，监听地址为 0.0.0.0:8080。</li></ol></blockquote><h2 id="12、在中间件中使用-Goroutine"><a href="#12、在中间件中使用-Goroutine" class="headerlink" title="12、在中间件中使用 Goroutine"></a>12、在中间件中使用 Goroutine</h2><h4 id="（1）完整代码-10"><a href="#（1）完整代码-10" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br><br>    <span class="hljs-comment">// 定义 /long_async 路由</span><br>    r.GET(<span class="hljs-string">&quot;/long_async&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 创建在 goroutine 中使用的副本</span><br>        cCp := c.Copy()<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-comment">// 用 time.Sleep() 模拟一个长任务。</span><br>            time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><br>            <span class="hljs-comment">// 请注意您使用的是复制的上下文 &quot;cCp&quot;，这一点很重要</span><br>            log.Println(<span class="hljs-string">&quot;Done! in path &quot;</span> + cCp.Request.URL.Path)<br>        &#125;()<br>    &#125;)<br><br>    <span class="hljs-comment">// 定义 /long_sync 路由</span><br>    r.GET(<span class="hljs-string">&quot;/long_sync&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 用 time.Sleep() 模拟一个长任务。</span><br>        time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><br>        <span class="hljs-comment">// 因为没有使用 goroutine，不需要拷贝上下文</span><br>        log.Println(<span class="hljs-string">&quot;Done! in path &quot;</span> + c.Request.URL.Path)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-10"><a href="#（2）知识点-10" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>c.Copy()</code>：创建一个上下文的副本，用于在 goroutine 中使用。在多个 goroutine 中处理请求时，需要使用上下文的副本，以避免竞态条件和并发访问的问题。</li><li><code>go func() &#123; ... &#125;()</code>：这段代码是一个匿名的 Go 语言协程（goroutine），通过 <code>go</code> 关键字开启一个新的并发执行的函数。这个函数中的逻辑很简单，首先通过 <code>time.Sleep(5 * time.Second)</code> 模拟一个耗时的操作，即暂停当前 goroutine 的执行 5 秒钟。在这个暂停期间，当前的 goroutine 不会继续执行，而是让出 CPU 时间给其他 goroutine，从而实现了并发执行。当 <code>time.Sleep()</code> 结束后，该 goroutine 会继续执行剩下的代码。这段代码通过调用 <code>log.Println()</code> 在日志中打印一条消息，内容为 “Done! int path “ + cCp.Request.URL.Path。其中，<code>cCp</code> 是在创建这个 goroutine 时通过 <code>c.Copy()</code> 创建的当前请求上下文的副本，用于记录请求的路径。</li><li><code>time.Sleep()</code>：模拟一个长时间运行的任务，暂停当前 goroutine 的执行一段时间，以模拟耗时的操作。在这段代码中，使用 <code>time.Sleep(5 * time.Second)</code> 暂停当前 goroutine 的执行 5 秒。</li><li><code>c.Request.URL.Path</code>：获取当前请求的路径，用于在日志中记录处理请求的路径。</li><li>通过分别访问<code>long_async</code>目录和<code>long_sync</code>目录，会发现：前者每次刷新页面，后台就会立即打印日志，过五秒后才会打印输出路径；反观后者，每次刷新页面需要过五秒，后台才会同时输出日志和打印路径。<code>long_async</code>当前的 goroutine 不会继续执行，而是让出 CPU 时间给其他 goroutine，从而实现了并发执行。</li></ul></blockquote><h4 id="（3）示例大意-7"><a href="#（3）示例大意-7" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>使用 <code>gin.Default()</code> 创建了一个默认的 Gin 引擎 <code>r</code>，用于处理 HTTP 请求和响应。</li><li>定义了两个路由：<ul><li><code>/long_async</code> 路由，使用 <code>r.GET</code> 方法注册了一个处理 GET 请求的处理函数。在这个处理函数中，通过 <code>c.Copy()</code> 创建了一个上下文副本 <code>cCp</code>，然后使用 <code>go</code> 关键字启动了一个 goroutine，在 goroutine 中使用 <code>time.Sleep()</code> 模拟了一个长时间运行的任务，最后在日志中打印了请求路径信息。</li><li><code>/long_sync</code> 路由，同样使用 <code>r.GET</code> 方法注册了一个处理 GET 请求的处理函数。在这个处理函数中，也使用了 <code>time.Sleep()</code> 模拟了一个长时间运行的任务，但没有使用 goroutine，因此不需要拷贝上下文，直接通过 <code>c</code> 访问了请求路径信息，并在日志中打印了请求路径信息。</li></ul></li><li>使用 <code>r.Run(&quot;:8080&quot;)</code> 启动了一个 web 服务器，监听在本地的 8080 端口上，等待接收来自客户端的请求。</li></ol></blockquote><h2 id="13、优雅地重启或停止"><a href="#13、优雅地重启或停止" class="headerlink" title="13、优雅地重启或停止"></a>13、优雅地重启或停止</h2><h4 id="（1）完整代码-11"><a href="#（1）完整代码-11" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build go1.8</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;os/signal&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个默认的 Gin 路由实例</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 注册一个处理函数到 &quot;/&quot; 路径的 GET 请求</span><br>    router.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 模拟一个长任务，暂停 5 秒</span><br>        time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>        c.String(http.StatusOK, <span class="hljs-string">&quot;Welcome Gin Server&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 创建一个 http.Server 实例，配置监听地址和 Gin 路由作为处理器</span><br>    srv := &amp;http.Server&#123;<br>        Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>        Handler: router,<br>    &#125;<br><br>    <span class="hljs-comment">// 启动一个 goroutine 监听和处理 HTTP 请求</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 启动 HTTP 服务器，监听和处理请求</span><br>        <span class="hljs-keyword">if</span> err := srv.ListenAndServe(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;<br>            log.Fatalf(<span class="hljs-string">&quot;listen: %s\n&quot;</span>, err)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）</span><br>    quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>    signal.Notify(quit, os.Interrupt)<br>    &lt;-quit<br>    log.Println(<span class="hljs-string">&quot;Shutdown Server ...&quot;</span>)<br><br>    <span class="hljs-comment">// 创建一个超时上下文，设置 5 秒超时</span><br>    ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">5</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    <span class="hljs-comment">// 关闭服务器，等待未完成的请求完成或超时</span><br>    <span class="hljs-keyword">if</span> err := srv.Shutdown(ctx); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;Server Shutdown:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;Server exiting&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-11"><a href="#（2）知识点-11" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>srv := &amp;http.Server&#123;        Addr:    &quot;:8080&quot;,        Handler: router,    &#125;</code>创建了一个 <code>http.Server</code> 实例，用于配置 HTTP 服务器的监听地址和请求处理器.<ul><li><code>Addr: &quot;:8080&quot;</code>：指定了服务器监听的地址和端口号。在这里，服务器会监听在本地的 8080 端口上，表示可以通过访问 <code>http://localhost:8080</code> 来与服务器进行通信。</li><li><code>Handler: router</code>：指定了服务器的请求处理器。在这里，使用了 Gin 框架创建的路由实例 <code>router</code> 作为服务器的请求处理器。Gin 路由可以用于注册不同的 HTTP 请求处理函数，根据请求的 URL 路径和 HTTP 方法来进行路由和处理。</li></ul></li><li><code>srv.ListenAndServe()</code>：这是 <code>http.Server</code> 的方法，用于启动服务器并开始监听和处理请求。它会一直在后台运行，直到服务器关闭或发生错误。</li><li><code>err := srv.ListenAndServe()</code>：将 <code>srv.ListenAndServe()</code> 的返回值赋给变量 <code>err</code>，用于捕获可能发生的错误。</li><li><code>err != nil &amp;&amp; err != http.ErrServerClosed</code>：通过条件判断语句检查 <code>err</code> 是否不为空且不等于 <code>http.ErrServerClosed</code>，即判断是否有错误发生且错误不是因为服务器被关闭导致的。</li><li><code>log.Fatalf(&quot;listen: %s\n&quot;, err)</code>：如果有错误发生，使用 <code>log.Fatalf()</code> 方法将错误信息格式化并输出到标准错误（stderr），然后调用 <code>log.Fatal()</code> 方法终止程序的运行。<code>log.Fatalf()</code> 是 <code>log</code> 包的一个函数，它会在输出错误信息后直接调用 <code>os.Exit(1)</code> 终止程序。</li><li><code>quit := make(chan os.Signal)</code>：创建了一个用于接收信号的通道 <code>quit</code>，该通道的类型是 <code>os.Signal</code>，用于接收操作系统发送的信号。</li><li><code>signal.Notify(quit, os.Interrupt)</code>：通过 <code>signal</code> 包的 <code>Notify</code> 函数，将 <code>os.Interrupt</code>（表示中断信号，通常由用户在终端中按下 Ctrl+C 产生）注册到 <code>quit</code> 通道，表示当收到中断信号时，将向 <code>quit</code> 通道发送该信号。</li><li><code>&lt;-quit</code>：通过从 <code>quit</code> 通道中接收信号，代码会一直阻塞在这里，直到接收到中断信号。一旦收到中断信号，代码会继续执行下一行。</li><li><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</code>：通过 <code>context.WithTimeout</code> 函数创建了一个带有超时的上下文 <code>ctx</code>，超时时间设置为 5 秒。<code>context.Background()</code> 返回一个空的上下文作为父上下文。</li><li><code>defer cancel()</code>：使用 <code>defer</code> 语句延迟调用 <code>cancel()</code> 函数，确保在函数执行完毕后取消上下文，以避免资源泄漏。</li><li><code>if err := srv.Shutdown(ctx); err != nil</code>：调用 <code>srv.Shutdown</code> 方法来优雅地关闭服务器，传入之前创建的带有超时的上下文 <code>ctx</code>。该方法会等待服务器处理完当前的请求后再关闭服务器，以实现优雅关闭。</li><li><code>log.Fatal(&quot;Server Shutdown:&quot;, err)</code>：如果服务器关闭过程中发生错误，使用 <code>log.Fatal</code> 输出错误信息并终止程序运行。</li></ul></blockquote><h4 id="（3）示例大意-8"><a href="#（3）示例大意-8" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><p>首先，创建了一个默认的 Gin 路由实例，注册了一个处理函数到 “&#x2F;“ 路径的 GET 请求，其中模拟了一个长任务，暂停 5 秒，然后返回 “Welcome Gin Server” 字符串作为响应。</p><p>接着，创建了一个 http.Server 实例，配置了监听地址为 “:8080”，并将 Gin 路由作为处理器。</p><p>然后，通过启动一个 goroutine 来监听和处理 HTTP 请求，调用 <code>srv.ListenAndServe()</code> 方法来启动 HTTP 服务器。</p><p>接下来，通过使用 <code>os/signal</code> 包来等待中断信号（如 Ctrl+C），一旦接收到中断信号，服务器将开始优雅地关闭。</p><p>创建了一个超时上下文 <code>ctx</code>，设置了 5 秒的超时时间，并通过 <code>srv.Shutdown()</code> 方法来优雅地关闭服务器，等待未完成的请求完成或超时。</p><p>最后，使用 <code>log.Fatal()</code> 输出错误信息并终止程序运行，或者输出 “Server exiting” 消息表示服务器成功退出。</p></blockquote><h2 id="14、路由组"><a href="#14、路由组" class="headerlink" title="14、路由组"></a>14、路由组</h2><h4 id="（1）完整代码-12"><a href="#（1）完整代码-12" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由引擎实例</span><br><br>    <span class="hljs-comment">// 简单的路由组: v1</span><br>    v1 := router.Group(<span class="hljs-string">&quot;/v1&quot;</span>) <span class="hljs-comment">// 创建一个名为 &quot;/v1&quot; 的路由组</span><br>    &#123;<br>        v1.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint) <span class="hljs-comment">// 在 &quot;/v1&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/login&quot;，并将该路由与名为 loginEndpoint 的处理函数绑定</span><br>        v1.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint) <span class="hljs-comment">// 在 &quot;/v1&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/submit&quot;，并将该路由与名为 submitEndpoint 的处理函数绑定</span><br>        v1.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint) <span class="hljs-comment">// 在 &quot;/v1&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/read&quot;，并将该路由与名为 readEndpoint 的处理函数绑定</span><br>    &#125;<br><br>    <span class="hljs-comment">// 简单的路由组: v2</span><br>    v2 := router.Group(<span class="hljs-string">&quot;/v2&quot;</span>) <span class="hljs-comment">// 创建一个名为 &quot;/v2&quot; 的路由组</span><br>    &#123;<br>        v2.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint) <span class="hljs-comment">// 在 &quot;/v2&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/login&quot;，并将该路由与名为 loginEndpoint 的处理函数绑定</span><br>        v2.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint) <span class="hljs-comment">// 在 &quot;/v2&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/submit&quot;，并将该路由与名为 submitEndpoint 的处理函数绑定</span><br>        v2.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint) <span class="hljs-comment">// 在 &quot;/v2&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/read&quot;，并将该路由与名为 readEndpoint 的处理函数绑定</span><br>    &#125;<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-12"><a href="#（2）知识点-12" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>router.Group(&quot;/v1&quot;)&#123;...&#125;</code>: 这是创建了一个名为 “&#x2F;v1” 的路由组。路由组可以用来对一组路由进行分组，方便管理和配置共享的中间件。</li></ul></blockquote><h4 id="（3）示例大意-9"><a href="#（3）示例大意-9" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li><code>func main()</code>: 这是 Go 语言的入口函数，是程序的入口点。</li><li><code>router := gin.Default()</code>: 创建了一个默认的 Gin 路由引擎实例。<code>gin.Default()</code> 函数返回一个默认配置的 Gin 路由引擎，包含了常用的中间件，如日志、恢复等。</li><li><code>v1 := router.Group(&quot;/v1&quot;)</code>: 创建了一个名为 “&#x2F;v1” 的路由组。路由组用于将多个路由进行分组管理，可以对这些路由应用相同的中间件、路由组级别的处理函数等。</li><li><code>v1.POST(&quot;/login&quot;, loginEndpoint)</code>: 在 “&#x2F;v1” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;login”，并将该路由与名为 loginEndpoint 的处理函数绑定。这表示当客户端发送 HTTP POST 请求到 “&#x2F;v1&#x2F;login” 时，将调用 loginEndpoint 函数来处理该请求。</li><li><code>v1.POST(&quot;/submit&quot;, submitEndpoint)</code>: 在 “&#x2F;v1” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;submit”，并将该路由与名为 submitEndpoint 的处理函数绑定。这表示当客户端发送 HTTP POST 请求到 “&#x2F;v1&#x2F;submit” 时，将调用 submitEndpoint 函数来处理该请求。</li><li><code>v1.POST(&quot;/read&quot;, readEndpoint)</code>: 在 “&#x2F;v1” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;read”，并将该路由与名为 readEndpoint 的处理函数绑定。这表示当客户端发送 HTTP POST 请求到 “&#x2F;v1&#x2F;read” 时，将调用 readEndpoint 函数来处理该请求。</li><li><code>v2 := router.Group(&quot;/v2&quot;)</code>: 创建了一个名为 “&#x2F;v2” 的路由组，类似于上面的 “&#x2F;v1” 路由组。</li><li><code>v2.POST(&quot;/login&quot;, loginEndpoint)</code>: 在 “&#x2F;v2” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;login”，并将该路由与名为 loginEndpoint 的处理函数绑定。</li><li><code>v2.POST(&quot;/submit&quot;, submitEndpoint)</code>: 在 “&#x2F;v2” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;submit”，并将该路由与名为 submitEndpoint 的处理函数绑定。</li><li><code>v2.POST(&quot;/read&quot;, readEndpoint)</code>: 在 “&#x2F;v2” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;read”，并将该路由与名为 readEndpoint 的处理函数绑定。</li><li><code>router.Run(&quot;:8080&quot;)</code>: 启动 HTTP 服务器并监听在端口 8080。一旦服务器启动，就会开始接受来自客户端的请求，并根据定义的路由规则和处理函数来处理这些请求。</li></ol></blockquote><h2 id="15、如何记录日志"><a href="#15、如何记录日志" class="headerlink" title="15、如何记录日志"></a>15、如何记录日志</h2><h4 id="（1）完整代码-13"><a href="#（1）完整代码-13" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 禁用控制台颜色，将日志写入文件时不需要控制台颜色。</span><br>    gin.DisableConsoleColor()<br><br>    <span class="hljs-comment">// 记录到文件。</span><br>    f, _ := os.Create(<span class="hljs-string">&quot;gin.log&quot;</span>) <span class="hljs-comment">// 创建一个名为 &quot;gin.log&quot; 的文件用于记录日志</span><br>    gin.DefaultWriter = io.MultiWriter(f) <span class="hljs-comment">// 设置 Gin 的默认日志写入器为同时写入文件 f</span><br><br>    <span class="hljs-comment">// 如果需要同时将日志写入文件和控制台，请使用以下代码。</span><br>    <span class="hljs-comment">// gin.DefaultWriter = io.MultiWriter(f, os.Stdout)</span><br><br>    router := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由引擎实例</span><br>    router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义一个 HTTP GET 方法的路由 &quot;/ping&quot;</span><br>        c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>) <span class="hljs-comment">// 在请求处理函数中返回字符串 &quot;pong&quot;</span><br>    &#125;)<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-13"><a href="#（2）知识点-13" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><p><code>gin.DisableConsoleColor()</code>: 禁用控制台颜色输出，这样在将日志写入文件时不会包含控制台颜色信息。</p></li><li><p><code>f, _ := os.Create(&quot;gin.log&quot;)</code>: 创建一个名为 “gin.log” 的文件用于记录日志，并将文件对象保存在变量 f 中。如果创建文件出现错误，错误会被忽略。</p></li><li><p><code>gin.DefaultWriter = io.MultiWriter(f)</code>: 将文件 f 设置为 Gin 框架的默认日志写入器，这样日志将同时写入文件 f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">wd, err := os.Getwd()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;获取当前工作目录失败:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>logFilePath := wd + <span class="hljs-string">&quot;/gin.log&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;gin.log 文件路径:&quot;</span>, logFilePath)<br></code></pre></td></tr></table></figure><p>可以用这段代码获取当前工作目录，<code>gin.log</code>文件就在该路径下。</p></li></ul></blockquote><h4 id="（3）示例大意-10"><a href="#（3）示例大意-10" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>调用 <code>gin.DisableConsoleColor()</code> 禁用控制台颜色输出，因为日志将被写入文件，不需要控制台颜色。</li><li>调用 <code>os.Create(&quot;gin.log&quot;)</code> 创建一个名为 “gin.log” 的文件，用于记录日志，并将返回的文件对象赋值给变量 <code>f</code>。</li><li>将 <code>f</code> 设置为 Gin 框架的默认日志写入器，通过调用 <code>gin.DefaultWriter = io.MultiWriter(f)</code>。这样，Gin 框架的日志将同时写入 <code>gin.log</code> 文件和控制台（如果需要同时写入文件和控制台，可以注释掉当前行，将下一行的注释取消）。</li><li>调用 <code>gin.Default()</code> 创建一个默认的 Gin 路由引擎实例，并将返回的引擎对象赋值给变量 <code>router</code>。</li><li>使用 <code>router.GET(&quot;/ping&quot;, ...)</code> 定义一个 HTTP GET 方法的路由 “&#x2F;ping”，并传入一个请求处理函数，该函数会在收到请求时返回字符串 “pong”。</li><li>调用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，并监听在端口 8080，等待接收客户端请求。一旦接收到请求，就会调用之前定义的请求处理函数进行处理。</li></ol></blockquote><h2 id="16、HTML渲染"><a href="#16、HTML渲染" class="headerlink" title="16、HTML渲染"></a>16、HTML渲染</h2><h4 id="（1）完整代码-14"><a href="#（1）完整代码-14" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><h4 id="（2）代码解释"><a href="#（2）代码解释" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><h2 id="17、HTTP2-server-推送"><a href="#17、HTTP2-server-推送" class="headerlink" title="17、HTTP2 server 推送"></a>17、HTTP2 server 推送</h2><h4 id="（1）完整代码-15"><a href="#（1）完整代码-15" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;html/template&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个 HTML 模板</span><br><span class="hljs-keyword">var</span> html = template.Must(template.New(<span class="hljs-string">&quot;https&quot;</span>).Parse(<span class="hljs-string">`</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">  &lt;title&gt;Https Test&lt;/title&gt;</span><br><span class="hljs-string">  &lt;script src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">  &lt;h1 style=&quot;color:red;&quot;&gt;Welcome, Ginner!&lt;/h1&gt;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">`</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由引擎实例</span><br>    r.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;./assets&quot;</span>) <span class="hljs-comment">// 将静态文件夹 &quot;./assets&quot; 注册为 &quot;/assets&quot; 的静态资源路径</span><br>    r.SetHTMLTemplate(html) <span class="hljs-comment">// 设置 HTML 模板</span><br><br>    r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义一个 HTTP GET 方法的路由 &quot;/&quot;</span><br>        <span class="hljs-keyword">if</span> pusher := c.Writer.Pusher(); pusher != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 判断是否支持服务器推送</span><br>            <span class="hljs-comment">// 使用 pusher.Push() 做服务器推送</span><br>            <span class="hljs-keyword">if</span> err := pusher.Push(<span class="hljs-string">&quot;/assets/app.js&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Printf(<span class="hljs-string">&quot;Failed to push: %v&quot;</span>, err) <span class="hljs-comment">// 如果推送失败，则记录日志</span><br>            &#125;<br>        &#125;<br>        c.HTML(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;https&quot;</span>, gin.H&#123; <span class="hljs-comment">// 返回 HTML 模板，并设置状态码和数据</span><br>            <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 https://127.0.0.1:8080 上启动服务，使用 TLS 加密</span><br>    r.RunTLS(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-string">&quot;./testdata/server.pem&quot;</span>, <span class="hljs-string">&quot;./testdata/server.key&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-14"><a href="#（2）知识点-14" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>var html = template.Must(template.New(&quot;https&quot;).Parse(...))</code>: 定义了一个名为 <code>html</code> 的 HTML 模板。<code>template.Must</code> 是一个辅助函数，用于将模板解析为 <code>template.Template</code> 对象，并在解析过程中检查是否出错。</li><li><code>r.Static(&quot;/assets&quot;, &quot;./assets&quot;)</code>: 将静态文件夹 <code>&quot;./assets&quot;</code> 注册为 “&#x2F;assets” 的静态资源路径，这样当客户端请求 “&#x2F;assets&#x2F;app.js” 时，会返回位于本地文件系统的 “.&#x2F;assets&#x2F;app.js” 文件作为响应。</li><li><code>r.SetHTMLTemplate(html)</code>: 设置之前定义的 <code>html</code> 模板为 Gin 框架的 HTML 模板。</li><li><code>r.GET(&quot;/&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: 定义一个 HTTP GET 方法的路由 “&#x2F;“，并传入一个请求处理函数，该函数会在收到请求时执行。在这个例子中，请求处理函数中通过 <code>c.Writer.Pusher()</code> 检查是否支持服务器推送。如果支持，通过 <code>pusher.Push(&quot;/assets/app.js&quot;, nil)</code> 进行服务器推送，推送的资源路径为 “&#x2F;assets&#x2F;app.js”。然后使用 <code>c.HTML()</code> 返回之前定义的 HTML 模板，并设置状态码为 200 和数据为 <code>gin.H&#123;&quot;status&quot;: &quot;success&quot;&#125;</code>。</li><li><code>r.RunTLS(&quot;:8080&quot;, &quot;./testdata/server.pem&quot;, &quot;./testdata/server.key&quot;)</code>: 启动 HTTP 服务器，并监听在 8080 端口，并使用 TLS 加密进行安全通信。第二个参数 “.&#x2F;testdata&#x2F;server.pem” 是 TLS 证书文件的路径，第三个参数 “.&#x2F;testdata&#x2F;server.key” 是 TLS 私钥文件的路径，用于在服务器端进行 TLS 握手和加密通信。这样，服务器将通过 HTTPS 监听客户端的请求。</li></ul></blockquote><h4 id="（3）示例大意-11"><a href="#（3）示例大意-11" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义 HTML 模板：使用 <code>template.Must</code> 函数创建了一个名为 “https” 的 HTML 模板，用于返回给客户端。</li><li>创建 Gin 路由引擎实例：使用 <code>gin.Default()</code> 函数创建了一个默认的 Gin 路由引擎实例。</li><li>注册静态文件路径：使用 <code>r.Static()</code> 方法将静态文件夹 “.&#x2F;assets” 注册为 “&#x2F;assets” 的静态资源路径，使得客户端可以通过访问 “&#x2F;assets” 路径来获取静态文件。</li><li>设置 HTML 模板：使用 <code>r.SetHTMLTemplate()</code> 方法设置了之前定义的 HTML 模板。</li><li>定义根路由处理函数：使用 <code>r.GET()</code> 方法定义了一个 HTTP GET 方法的根路由处理函数，该处理函数会返回之前定义的 HTML 模板，并在响应头中设置了支持服务器推送的信息。</li><li>启动 HTTPS 服务器：使用 <code>r.RunTLS()</code> 方法在 “<a href="https://127.0.0.1:8080/">https://127.0.0.1:8080</a>“ 地址上启动了一个监听 TLS 加密的 HTTPS 服务器，使用了之前定义的 TLS 证书和私钥文件。</li></ol></blockquote><h2 id="18、-JSONP"><a href="#18、-JSONP" class="headerlink" title="18、 JSONP"></a>18、 JSONP</h2><blockquote><p>使用 JSONP 向不同域的服务器请求数据。如果查询参数存在回调，则将回调添加到响应体中。</p></blockquote><h4 id="（1）完整代码-16"><a href="#（1）完整代码-16" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><br>r.GET(<span class="hljs-string">&quot;/JSONP&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>data := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 获取 callback 参数值</span><br>callback := c.Query(<span class="hljs-string">&quot;callback&quot;</span>)<br><br><span class="hljs-comment">// 使用 JSONP 格式返回数据</span><br>c.JSONP(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;callback&quot;</span>: callback,<br><span class="hljs-string">&quot;data&quot;</span>:     data,<br>&#125;)<br>&#125;)<br><br><span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-15"><a href="#（2）知识点-15" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>c.Query(&quot;callback&quot;)</code>: <code>c.Query</code> 方法用于获取 HTTP 请求中的查询参数。这里使用 <code>c.Query(&quot;callback&quot;)</code> 获取了名为 “callback” 的查询参数的值</li><li><code>c.JSONP(http.StatusOK, gin.H&#123;...&#125;)</code>: <code>c.JSONP</code> 方法用于将 JSON 数据以 JSONP 格式返回给客户端。<code>http.StatusOK</code> 表示 HTTP 响应状态码为 200，<code>gin.H&#123;...&#125;</code> 表示要返回的 JSON 数据。这里返回了一个包含 “callback” 和 “data” 两个字段的 JSON 数据，其中 “callback” 字段的值为上一步获取的查询参数 “callback” 的值，”data” 字段的值为一个包含 “foo” 字段的 map 数据。</li></ul></blockquote><h2 id="19、Multipart-x2F-Urlencoded-绑定"><a href="#19、Multipart-x2F-Urlencoded-绑定" class="headerlink" title="19、Multipart&#x2F;Urlencoded 绑定"></a>19、Multipart&#x2F;Urlencoded 绑定</h2><h4 id="（1）完整代码-17"><a href="#（1）完整代码-17" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> LoginForm <span class="hljs-keyword">struct</span> &#123;<br>User     <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;user&quot; binding:&quot;required&quot;`</span>     <span class="hljs-comment">// 表单字段 user，使用 binding:&quot;required&quot; 标签表示必填</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;password&quot; binding:&quot;required&quot;`</span> <span class="hljs-comment">// 表单字段 password，使用 binding:&quot;required&quot; 标签表示必填</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br>router.POST(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 使用 c.ShouldBind 方法将请求数据绑定到 LoginForm 结构体</span><br><span class="hljs-keyword">var</span> form LoginForm<br><span class="hljs-keyword">if</span> c.ShouldBind(&amp;form) == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果绑定成功</span><br><span class="hljs-keyword">if</span> form.User == <span class="hljs-string">&quot;user&quot;</span> &amp;&amp; form.Password == <span class="hljs-string">&quot;password&quot;</span> &#123; <span class="hljs-comment">// 判断用户名和密码是否正确</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">401</span>, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">401</span>, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;missing params&quot;</span>&#125;) <span class="hljs-comment">// 如果请求数据缺少必填字段，则返回错误状态</span><br>&#125;<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-16"><a href="#（2）知识点-16" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>type LoginForm struct &#123; ... &#125;</code>: <code>LoginForm</code> 是一个自定义的结构体类型，用于表示登录表单的数据结构。结构体中包含了两个字段：<code>User</code> 和 <code>Password</code>，分别对应表单中的 “user” 和 “password” 字段。</li><li><code>router.POST(&quot;/login&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: <code>router.POST</code> 方法注册了一个 HTTP POST 方法的路由，路由路径为 “&#x2F;login”。当客户端发送 HTTP POST 请求到 “&#x2F;login” 路径时，Gin 会调用传入的匿名函数作为该路由的处理函数。</li><li><code>c.ShouldBind(&amp;form)</code>: <code>c.ShouldBind</code> 方法用于将 HTTP 请求中的数据绑定到指定的结构体对象。这里使用 <code>c.ShouldBind(&amp;form)</code> 将请求数据绑定到 <code>form</code> 变量，该变量是上一步定义的 <code>LoginForm</code> 结构体对象。</li><li><code>c.JSON(200, gin.H&#123;...&#125;)</code>: <code>c.JSON</code> 方法用于将 JSON 数据作为响应发送给客户端。<code>200</code> 表示 HTTP 响应状态码为 200，<code>gin.H&#123;...&#125;</code> 表示要返回的 JSON 数据。这里返回了一个包含 “status” 字段的 JSON 数据，字段的值根据登录表单的用户名和密码进行判断而定。</li><li><code>c.JSON(401, gin.H&#123;...&#125;)</code>: 同样地，<code>c.JSON</code> 方法也可以用于返回 HTTP 响应状态码为 401 的错误响应。这里通过 <code>c.JSON(401, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)</code> 和 <code>c.JSON(401, gin.H&#123;&quot;status&quot;: &quot;missing params&quot;&#125;)</code> 分别返回了未授权和缺少必填字段的错误信息。</li></ul></blockquote><h4 id="（3）示例大意-12"><a href="#（3）示例大意-12" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义了一个 LoginForm 结构体，用于绑定 POST 请求中的表单数据。该结构体包含了两个字段，分别是 User 和 Password，使用了 Gin 框架的表单绑定标签进行验证，要求这两个字段都是必填的。</li><li>在 main 函数中创建了一个 Gin 路由实例 router。</li><li>设置了一个 POST 路由 “&#x2F;login”，并定义了处理函数。在该处理函数中，使用 c.ShouldBind 方法将请求数据绑定到 LoginForm 结构体。</li><li>如果绑定成功，即表单数据满足要求，那么进一步判断用户名和密码是否正确，如果正确，则返回 HTTP 状态码 200 和一个 JSON 格式的成功消息；否则，返回 HTTP 状态码 401 和一个 JSON 格式的未授权消息。</li><li>如果请求数据缺少必填字段，即绑定失败，那么返回 HTTP 状态码 401 和一个 JSON 格式的缺少参数消息。</li><li>最后，通过调用 router.Run(“:8080”) 启动 HTTP 服务器并监听在端口 8080，等待客户端请求。</li></ol></blockquote><h2 id="20、表单"><a href="#20、表单" class="headerlink" title="20、表单"></a>20、表单</h2><h4 id="（1）完整代码-18"><a href="#（1）完整代码-18" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br>router.POST(<span class="hljs-string">&quot;/form_post&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>message := c.PostForm(<span class="hljs-string">&quot;message&quot;</span>) <span class="hljs-comment">// 获取表单中的 &quot;message&quot; 字段值</span><br>nick := c.DefaultPostForm(<span class="hljs-string">&quot;nick&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>) <span class="hljs-comment">// 获取表单中的 &quot;nick&quot; 字段值，如果为空则默认为 &quot;anonymous&quot;</span><br><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  <span class="hljs-string">&quot;posted&quot;</span>,<br><span class="hljs-string">&quot;message&quot;</span>: message,<br><span class="hljs-string">&quot;nick&quot;</span>:    nick,<br>&#125;)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-17"><a href="#（2）知识点-17" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>c.PostForm(&quot;message&quot;)</code>: 使用 <code>c</code> 上下文对象的 <code>PostForm</code> 方法获取表单中名为 “message” 的字段的值。</li><li><code>c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;)</code>: 使用 <code>c</code> 上下文对象的 <code>DefaultPostForm</code> 方法获取表单中名为 “nick” 的字段的值，如果该字段为空，则返回默认值 “anonymous”。</li></ul></blockquote><h4 id="（3）示例大意-13"><a href="#（3）示例大意-13" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>导入了 “github.com&#x2F;gin-gonic&#x2F;gin” 包，引入 Gin 框架的依赖。</li><li>创建了一个 Gin 路由引擎，使用了默认的中间件。</li><li>定义了一个处理 POST 请求的路由 “&#x2F;form_post”，并传入一个处理函数。</li><li>在处理函数中，使用了 c.PostForm 方法获取表单中的 “message” 字段值，并保存到变量 message 中。</li><li>使用了 c.DefaultPostForm 方法获取表单中的 “nick” 字段值，并保存到变量 nick 中，如果 “nick” 字段为空，则默认值为 “anonymous”。</li><li>使用了 c.JSON 方法返回 JSON 格式的响应，包含了三个键值对： “status”、”message” 和 “nick”。</li><li>调用 router.Run 方法启动 HTTP 服务器并监听在端口 8080，等待客户端的请求。</li></ol></blockquote><h2 id="21、只绑定-url-查询字符串"><a href="#21、只绑定-url-查询字符串" class="headerlink" title="21、只绑定 url 查询字符串"></a>21、只绑定 url 查询字符串</h2><h4 id="（1）完整代码-19"><a href="#（1）完整代码-19" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;name&quot;`</span><br>Address <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;address&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br><span class="hljs-comment">// 定义路由 &quot;/testing&quot;，并将请求交给 startPage 函数处理</span><br>router.Any(<span class="hljs-string">&quot;/testing&quot;</span>, startPage)<br><br>router.Run(<span class="hljs-string">&quot;:8085&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8085</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startPage</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> person Person<br><br><span class="hljs-comment">// 使用 ShouldBindQuery 方法将请求中的 Query String 绑定到 person 对象</span><br><span class="hljs-keyword">if</span> c.ShouldBindQuery(&amp;person) == <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;====== Only Bind By Query String ======&quot;</span>)<br>log.Println(person.Name)<br>log.Println(person.Address)<br>&#125;<br><br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Success&quot;</span>) <span class="hljs-comment">// 返回 &quot;Success&quot; 字符串作为响应</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-1"><a href="#（2）代码解释-1" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了一个路由处理函数 <code>startPage</code> 用于处理 “&#x2F;testing” 的请求，可以处理 GET、POST、PUT、DELETE 等任何请求方法。在路由处理函数中，通过 <code>c.ShouldBindQuery()</code> 方法将请求中的 Query String 绑定到 <code>person</code> 对象，其中 <code>person.Name</code> 和 <code>person.Address</code> 分别对应了请求中的 “name” 和 “address” 参数。</p><p>接着使用 <code>log.Println()</code> 方法输出绑定后的字段值到控制台。</p><p>最后，通过调用 <code>c.String()</code> 方法返回状态码 200 和 “Success” 字符串作为响应，表示处理成功。HTTP 服务器监听在端口 8085，并通过 <code>router.Run()</code> 启动。</p></blockquote><h2 id="22、路径中的参数"><a href="#22、路径中的参数" class="headerlink" title="22、路径中的参数"></a>22、路径中的参数</h2><h4 id="（1）完整代码-20"><a href="#（1）完整代码-20" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br><span class="hljs-comment">// 这个处理函数将匹配 /user/john，但不会匹配 /user/ 或 /user</span><br>router.GET(<span class="hljs-string">&quot;/user/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>c.String(http.StatusOK, <span class="hljs-string">&quot;Hello %s&quot;</span>, name)<br>&#125;)<br><br><span class="hljs-comment">// 这个处理函数将匹配 /user/john/ 和 /user/john/send</span><br><span class="hljs-comment">// 如果没有其他路由匹配 /user/john，它将重定向到 /user/john/</span><br>router.GET(<span class="hljs-string">&quot;/user/:name/*action&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>action := c.Param(<span class="hljs-string">&quot;action&quot;</span>)<br>message := name + <span class="hljs-string">&quot; is &quot;</span> + action<br>c.String(http.StatusOK, message)<br>&#125;)<br><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-2"><a href="#（2）代码解释-2" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了两个路由处理函数。第一个处理函数通过路由 “&#x2F;user&#x2F;:name” 匹配 URL 中的 “:name” 参数，并将其值绑定到变量 name 中，然后通过 <code>c.String()</code> 方法返回 “Hello %s” 字符串，其中 %s 会被 name 的值替代。</p><p>第二个处理函数通过路由 “&#x2F;user&#x2F;:name&#x2F;*action” 匹配 URL 中的 “:name” 参数和 “*action” 参数，”*action” 表示匹配 “&#x2F;user&#x2F;:name” 后面的任意路径，将其值绑定到变量 name 和 action 中，然后通过 <code>c.String()</code> 方法返回包含 name 和 action 的消息字符串。</p><p>在 Gin 框架中，路由参数可以通过 <code>:paramName</code> 的方式定义，表示在 URL 中匹配该位置的任意字符串，并将其值作为参数传递给路由处理函数。同时，Gin 还支持通配符 “*”，可以匹配任意路径片段，用于处理较为复杂的路由需求。</p></blockquote><h2 id="23、PureJSON"><a href="#23、PureJSON" class="headerlink" title="23、PureJSON"></a>23、PureJSON</h2><blockquote><p>​通常，JSON 使用 unicode 替换特殊 HTML 字符，例如 &lt; 变为 \ u003c。如果要按字面对这些字符进行编码，则可以使用 PureJSON。Go 1.6 及更低版本无法使用此功能。</p></blockquote><h4 id="（1）完整代码-21"><a href="#（1）完整代码-21" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><br><span class="hljs-comment">// 提供 unicode 实体</span><br>r.GET(<span class="hljs-string">&quot;/json&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;html&quot;</span>: <span class="hljs-string">&quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;</span>,<br>&#125;)<br>&#125;)<br><br><span class="hljs-comment">// 提供字面字符</span><br>r.GET(<span class="hljs-string">&quot;/purejson&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.PureJSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;html&quot;</span>: <span class="hljs-string">&quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;</span>,<br>&#125;)<br>&#125;)<br><br><span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-3"><a href="#（2）代码解释-3" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了三个路由处理函数。其中 <code>/json</code> 路由使用 <code>c.JSON()</code> 方法返回 JSON 格式的响应体，其中包含一个名为 “html” 的字段，值为 “<b>Hello, world!</b>“。<code>c.JSON()</code> 方法会将响应体序列化为 JSON 格式并设置相应的 Content-Type 头，使得返回的响应体在客户端以 JSON 格式展示。</p><p>而 <code>/purejson</code> 路由使用 <code>c.PureJSON()</code> 方法同样返回 JSON 格式的响应体，但不会对响应体中的特殊字符进行转义，保留原始字符。这在某些情况下可能有用，例如当需要返回包含 HTML 标签等特殊字符的响应体时。</p><p>最后，通过调用 <code>r.Run()</code> 方法在 0.0.0.0:8080 上启动 HTTP 服务器并监听请求。Gin 框架的 <code>Run()</code> 方法会自动选择可用的端口并启动服务器。</p></blockquote><h2 id="24、POST-表单中的-URL-参数"><a href="#24、POST-表单中的-URL-参数" class="headerlink" title="24、POST 表单中的 URL 参数"></a>24、POST 表单中的 URL 参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">POST /post?id=<span class="hljs-number">1234</span>&amp;page=<span class="hljs-number">1</span> HTTP/<span class="hljs-number">1.1</span><br>Content-Type: application/x-www-form-urlencoded<br><br>name=manu&amp;message=this_is_great<br></code></pre></td></tr></table></figure><h4 id="（1）完整代码-22"><a href="#（1）完整代码-22" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br>router.POST(<span class="hljs-string">&quot;/post&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><br>id := c.Query(<span class="hljs-string">&quot;id&quot;</span>)               <span class="hljs-comment">// 获取 URL 查询参数 &quot;id&quot;</span><br>page := c.DefaultQuery(<span class="hljs-string">&quot;page&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">// 获取 URL 查询参数 &quot;page&quot;，如果不存在则默认为 &quot;0&quot;</span><br>name := c.PostForm(<span class="hljs-string">&quot;name&quot;</span>)         <span class="hljs-comment">// 获取 POST 表单字段 &quot;name&quot;</span><br>message := c.PostForm(<span class="hljs-string">&quot;message&quot;</span>)   <span class="hljs-comment">// 获取 POST 表单字段 &quot;message&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;id: %s; page: %s; name: %s; message: %s&quot;</span>, id, page, name, message)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-4"><a href="#（2）代码解释-4" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了一个处理 POST 请求的路由处理函数。该处理函数从请求中获取 URL 查询参数 “id” 和 “page”，以及 POST 表单字段 “name” 和 “message” 的值，并将其打印输出。</p><p>使用 <code>c.Query()</code> 方法可以获取 URL 查询参数的值，其中参数为参数名。而使用 <code>c.PostForm()</code> 方法可以获取 POST 表单字段的值，同样参数为字段名。如果 POST 表单中没有指定的字段，可以使用 <code>c.DefaultPostForm()</code> 方法设置一个默认值。</p><p>最后，通过调用 <code>router.Run()</code> 方法在 “:8080” 上启动 HTTP 服务器并监听请求。Gin 框架的 <code>Run()</code> 方法会自动选择可用的端口并启动服务器。</p></blockquote><h2 id="25、查询字符串参数"><a href="#25、查询字符串参数" class="headerlink" title="25、查询字符串参数"></a>25、查询字符串参数</h2><h4 id="（1）完整代码-23"><a href="#（1）完整代码-23" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br><span class="hljs-comment">// 使用现有的基础请求对象解析查询字符串参数。</span><br><span class="hljs-comment">// 示例 URL： /welcome?firstname=Jane&amp;lastname=Doe</span><br>router.GET(<span class="hljs-string">&quot;/welcome&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>firstname := c.DefaultQuery(<span class="hljs-string">&quot;firstname&quot;</span>, <span class="hljs-string">&quot;Guest&quot;</span>) <span class="hljs-comment">// 获取查询参数 &quot;firstname&quot;，如果不存在则默认为 &quot;Guest&quot;</span><br>lastname := c.Query(<span class="hljs-string">&quot;lastname&quot;</span>)                   <span class="hljs-comment">// 获取查询参数 &quot;lastname&quot;</span><br><br>c.String(http.StatusOK, <span class="hljs-string">&quot;Hello %s %s&quot;</span>, firstname, lastname)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-5"><a href="#（2）代码解释-5" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了一个处理 GET 请求的路由处理函数。该处理函数从 URL 查询参数 “firstname” 和 “lastname” 的值，并将其组合成字符串后作为响应返回。</p><p>使用 <code>c.Query()</code> 方法可以获取 URL 查询参数的值，其中参数为参数名。而使用 <code>c.DefaultQuery()</code> 方法可以获取 URL 查询参数的值，并设置一个默认值，当查询参数不存在时使用。这在示例中用于获取 “firstname” 的值，并设置默认值为 “Guest”。</p><p>Gin 框架的 <code>Run()</code> 方法会自动选择可用的端口并启动 HTTP 服务器，通过调用 <code>router.Run(&quot;:8080&quot;)</code> 在 “:8080” 上启动 HTTP 服务器并监听请求。</p></blockquote><h2 id="26、重定向"><a href="#26、重定向" class="headerlink" title="26、重定向"></a>26、重定向</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    c.Redirect(http.StatusMovedPermanently, <span class="hljs-string">&quot;http://www.google.com/&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="（1）完整代码-24"><a href="#（1）完整代码-24" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    c.Request.URL.Path = <span class="hljs-string">&quot;/test2&quot;</span><br>    r.HandleContext(c)<br>&#125;)<br>r.GET(<span class="hljs-string">&quot;/test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-6"><a href="#（2）代码解释-6" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>​当访问 <code>/test</code> 时，请求的 URL 路径被修改为 <code>/test2</code>，然后再次处理请求。由于 <code>/test2</code> 路径有对应的路由处理函数，所以会返回 <code>&#123;&quot;hello&quot;: &quot;world&quot;&#125;</code> JSON 响应。</p></blockquote><h2 id="27、运行多个服务"><a href="#27、运行多个服务" class="headerlink" title="27、运行多个服务"></a>27、运行多个服务</h2><h4 id="（1）完整代码-25"><a href="#（1）完整代码-25" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;golang.org/x/sync/errgroup&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>g errgroup.Group <span class="hljs-comment">// 全局 errgroup.Group 对象，用于管理多个 Goroutine</span><br>)<br><br><span class="hljs-comment">// 创建并返回一个 Gin 实例，作为 server01 的路由处理器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">router01</span><span class="hljs-params">()</span></span> http.Handler &#123;<br>e := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 实例</span><br>e.Use(gin.Recovery()) <span class="hljs-comment">// 添加 Recovery 中间件，用于处理请求中的错误</span><br>e.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义根路径的 GET 请求处理函数</span><br>c.JSON(<br>http.StatusOK,<br>gin.H&#123;<br><span class="hljs-string">&quot;code&quot;</span>:  http.StatusOK,<br><span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;Welcome server 01&quot;</span>,<br>&#125;,<br>)<br>&#125;)<br><br><span class="hljs-keyword">return</span> e<br>&#125;<br><br><span class="hljs-comment">// 创建并返回一个 Gin 实例，作为 server02 的路由处理器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">router02</span><span class="hljs-params">()</span></span> http.Handler &#123;<br>e := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 实例</span><br>e.Use(gin.Recovery()) <span class="hljs-comment">// 添加 Recovery 中间件，用于处理请求中的错误</span><br>e.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义根路径的 GET 请求处理函数</span><br>c.JSON(<br>http.StatusOK,<br>gin.H&#123;<br><span class="hljs-string">&quot;code&quot;</span>:  http.StatusOK,<br><span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;Welcome server 02&quot;</span>,<br>&#125;,<br>)<br>&#125;)<br><br><span class="hljs-keyword">return</span> e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>server01 := &amp;http.Server&#123;<br>Addr:         <span class="hljs-string">&quot;:8080&quot;</span>,         <span class="hljs-comment">// server01 监听的地址和端口</span><br>Handler:      router01(),      <span class="hljs-comment">// server01 使用 router01 作为路由处理器</span><br>ReadTimeout:  <span class="hljs-number">5</span> * time.Second, <span class="hljs-comment">// server01 读取超时时间</span><br>WriteTimeout: <span class="hljs-number">10</span> * time.Second, <span class="hljs-comment">// server01 写入超时时间</span><br>&#125;<br><br>server02 := &amp;http.Server&#123;<br>Addr:         <span class="hljs-string">&quot;:8081&quot;</span>,         <span class="hljs-comment">// server02 监听的地址和端口</span><br>Handler:      router02(),      <span class="hljs-comment">// server02 使用 router02 作为路由处理器</span><br>ReadTimeout:  <span class="hljs-number">5</span> * time.Second, <span class="hljs-comment">// server02 读取超时时间</span><br>WriteTimeout: <span class="hljs-number">10</span> * time.Second, <span class="hljs-comment">// server02 写入超时时间</span><br>&#125;<br><br><span class="hljs-comment">// 使用 errgroup 管理多个 Goroutine，分别启动 server01 和 server02</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> server01.ListenAndServe()<br>&#125;)<br><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> server02.ListenAndServe()<br>&#125;)<br><br><span class="hljs-keyword">if</span> err := g.Wait(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 等待两个 Goroutine 结束</span><br>log.Fatal(err) <span class="hljs-comment">// 如果有错误发生，则输出错误日志</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-7"><a href="#（2）代码解释-7" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用 Gin 框架创建了两个独立的 HTTP 服务器，分别监听不同的端口。<code>router01</code> 和 <code>router02</code> 函数分别定义了两个 Gin 路由处理器，分别处理根路径的 GET 请求，并返回不同的 JSON 响应。</p><p>通过 <code>errgroup</code> 包管理两个 Goroutine，分别启动了 <code>server01</code> 和 <code>server02</code> 的监听操作。每个服务器都使用了不同的监听地址和端口，以及不同的路由处理器。</p><p>如果有错误发生，<code>errgroup.Wait()</code> 方法会等待两个 Goroutine 结束，并返回错误。如果返回的错误不为空，则使用 <code>log.Fatal()</code> 输出错误日志并终止程序运行。</p><p>这段代码的主要作用是创建并同时启动两个独立的 HTTP 服务器，它们分别监听不同的端口，并使用 Gin 框架处理路由请求。使用 <code>errgroup</code> 包可以方便地管理多个 Goroutine，并在任何一个 Goroutine 发生错误时及时捕获和处理。这种方式可以有效地提高服务器的可靠性和稳定性。</p></blockquote><h2 id="28、SecureJSON"><a href="#28、SecureJSON" class="headerlink" title="28、SecureJSON"></a>28、SecureJSON</h2><blockquote><p>使用 SecureJSON 防止 json 劫持。如果给定的结构是数组值，则默认预置 <code>&quot;while(1),&quot;</code> 到响应体。</p></blockquote><h4 id="（1）完整代码-26"><a href="#（1）完整代码-26" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()  <span class="hljs-comment">// 创建一个默认的 Gin 实例</span><br><br>    <span class="hljs-comment">// 你也可以使用自己的 SecureJSON 前缀</span><br>    <span class="hljs-comment">// r.SecureJsonPrefix(&quot;)]&#125;&#x27;,\n&quot;)</span><br><br>    r.GET(<span class="hljs-string">&quot;/someJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  <span class="hljs-comment">// 注册处理路由 &quot;/someJSON&quot; 的 GET 请求的处理函数</span><br>        names := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;lena&quot;</span>, <span class="hljs-string">&quot;austin&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>&#125;  <span class="hljs-comment">// 创建一个字符串切片 names</span><br><br>        <span class="hljs-comment">// 将 names 切片作为 JSON 响应返回给客户端</span><br>        <span class="hljs-comment">// 使用 http.StatusOK 表示 HTTP 响应的状态码为 200 OK</span><br>        <span class="hljs-comment">// 并在返回的 JSON 数据前加上安全前缀，防止 JSON 劫持攻击</span><br>        c.SecureJSON(http.StatusOK, names)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-8"><a href="#（2）代码解释-8" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用 Gin 框架创建一个 HTTP 服务器，并定义了一个路由处理函数。代码的主要逻辑如下：</p><ol><li>使用 <code>gin.Default()</code> 创建一个默认的 Gin 实例 <code>r</code>，它包含了一些常用的中间件，如日志、恢复等。</li><li>注册一个处理路由 <code>/someJSON</code> 的 GET 请求的处理函数。该处理函数接收一个 <code>gin.Context</code> 对象 <code>c</code>，用于处理 HTTP 请求和构建 HTTP 响应。</li><li>在处理函数中，创建一个字符串切片 <code>names</code>，包含了三个字符串元素。</li><li>使用 <code>c.SecureJSON(http.StatusOK, names)</code> 将 <code>names</code> 切片作为 JSON 响应返回给客户端。这里使用了 <code>http.StatusOK</code> 表示 HTTP 响应的状态码为 200 OK，并且在返回的 JSON 数据前加上了安全前缀，防止 JSON 劫持攻击。</li><li>调用 <code>r.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在 0.0.0.0:8080 地址上。</li></ol><p>这段代码的功能是创建一个简单的 HTTP 服务器，当客户端通过 <code>/someJSON</code> 路径发送 GET 请求时，返回一个包含三个字符串元素的 JSON 数组作为响应。服务器监听在 0.0.0.0:8080 地址上，并使用 Gin 框架处理路由和构建 HTTP 响应。</p></blockquote><h2 id="29、从-reader-读取数据"><a href="#29、从-reader-读取数据" class="headerlink" title="29、从 reader 读取数据"></a>29、从 reader 读取数据</h2><h4 id="（1）完整代码-27"><a href="#（1）完整代码-27" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个默认的 Gin 路由引擎</span><br>router := gin.Default()<br><br><span class="hljs-comment">// 定义处理路由 /someDataFromReader 的 GET 请求的处理函数</span><br>router.GET(<span class="hljs-string">&quot;/someDataFromReader&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 发起 HTTP GET 请求获取远程文件</span><br>response, err := http.Get(<span class="hljs-string">&quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || response.StatusCode != http.StatusOK &#123;<br><span class="hljs-comment">// 如果请求出错或者响应状态码不是 200 OK，则返回 503 Service Unavailable 状态码</span><br>c.Status(http.StatusServiceUnavailable)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 获取响应的 Body、ContentLength 和 ContentType</span><br>reader := response.Body<br>contentLength := response.ContentLength<br>contentType := response.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<br><br><span class="hljs-comment">// 构建额外的响应头</span><br>extraHeaders := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;Content-Disposition&quot;</span>: <span class="hljs-string">`attachment; filename=&quot;gopher.png&quot;`</span>,<br>&#125;<br><br><span class="hljs-comment">// 使用 c.DataFromReader 方法将文件数据作为响应返回给客户端</span><br>c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)<br>&#125;)<br><br><span class="hljs-comment">// 启动 HTTP 服务器并监听在 :8080 地址上</span><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-9"><a href="#（2）代码解释-9" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并注册了一个处理路由 “&#x2F;someDataFromReader” 的 GET 请求的处理函数。</p><ol><li><code>gin.Default()</code> 创建了一个默认的 Gin 路由引擎。</li><li><code>router.GET(&quot;/someDataFromReader&quot;, func(c *gin.Context) &#123; ... &#125;)</code> 定义了处理路由 “&#x2F;someDataFromReader” 的 GET 请求的处理函数。函数体中的代码会在接收到 “&#x2F;someDataFromReader” 的 GET 请求时执行。</li><li><code>http.Get(&quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&quot;)</code> 发起了一个 HTTP GET 请求，获取远程文件的内容。如果请求出错或者响应状态码不是 200 OK，会返回 503 Service Unavailable 状态码给客户端。</li><li><code>c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)</code> 使用 Gin 提供的 <code>c.DataFromReader</code> 方法将文件数据作为响应返回给客户端。<code>http.StatusOK</code> 是响应的状态码，<code>contentLength</code> 是文件的长度，<code>contentType</code> 是文件的 MIME 类型，<code>reader</code> 是文件的内容，<code>extraHeaders</code> 是一些额外的响应头，这里设置了 Content-Disposition 头，指定文件名为 “gopher.png”。</li><li><code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器并监听在 “:8080” 地址上，开始接受客户端的请求。</li></ol><p>总体来说，这段代码实现了一个简单的 HTTP 服务器，通过处理 GET 请求获取远程文件内容，并将文件数据作为响应返回给客户端，同时设置了文件的 Content-Disposition 头，指定文件名为 “gopher.png”。</p></blockquote><h2 id="30、-静态文件服务"><a href="#30、-静态文件服务" class="headerlink" title="30、 静态文件服务"></a>30、 静态文件服务</h2><h4 id="（1）完整代码-28"><a href="#（1）完整代码-28" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br>    <span class="hljs-comment">// 注册静态文件路由，将请求 &quot;/assets&quot; 的静态文件从当前目录下的 &quot;./assets&quot; 目录中返回给客户端</span><br>    router.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;./assets&quot;</span>)<br><br>    <span class="hljs-comment">// 注册基于文件系统的静态文件路由，将请求 &quot;/more_static&quot; 的静态文件从指定的文件系统路径 &quot;my_file_system&quot; 中返回给客户端</span><br>    router.StaticFS(<span class="hljs-string">&quot;/more_static&quot;</span>, http.Dir(<span class="hljs-string">&quot;my_file_system&quot;</span>))<br><br>    <span class="hljs-comment">// 注册单个文件的静态文件路由，将请求 &quot;/favicon.ico&quot; 的静态文件从当前目录下的 &quot;./resources/favicon.ico&quot; 文件返回给客户端</span><br>    router.StaticFile(<span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;./resources/favicon.ico&quot;</span>)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-10"><a href="#（2）代码解释-10" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>以上代码使用 Gin 框架创建了一个简单的静态文件服务器。通过注册静态文件路由，可以将指定目录下的静态文件返回给客户端，例如图片、CSS、JavaScript 等资源文件，以供客户端的浏览器进行访问和加载。这对于构建前端应用或者提供静态资源文件的需求非常有用。在代码中使用了不同的静态文件路由注册方式，包括 <code>router.Static()</code>、<code>router.StaticFS()</code> 和 <code>router.StaticFile()</code>，用于处理不同的静态文件请求。最后，通过调用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听地址为 “0.0.0.0:8080”，并开始接收并处理客户端的请求。</p></blockquote><h2 id="31、-设置和获取-Cookie"><a href="#31、-设置和获取-Cookie" class="headerlink" title="31、 设置和获取 Cookie"></a>31、 设置和获取 Cookie</h2><h4 id="（1）完整代码-29"><a href="#（1）完整代码-29" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br>router.GET(<span class="hljs-string">&quot;/cookie&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 注册 &quot;/cookie&quot; 路由的 GET 方法处理函数</span><br>cookie, err := c.Cookie(<span class="hljs-string">&quot;gin_cookie&quot;</span>) <span class="hljs-comment">// 获取名为 &quot;gin_cookie&quot; 的 Cookie</span><br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果获取 Cookie 发生错误，则设置一个默认值</span><br>cookie = <span class="hljs-string">&quot;NotSet&quot;</span><br>c.SetCookie(<span class="hljs-string">&quot;gin_cookie&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 设置名为 &quot;gin_cookie&quot; 的 Cookie 值为 &quot;test&quot;，过期时间为 3600 秒，路径为 &quot;/&quot;，域名为 &quot;localhost&quot;，不限制 HTTPS 连接，允许 JS 访问</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Cookie value: %s \n&quot;</span>, cookie) <span class="hljs-comment">// 在控制台打印 Cookie 的值</span><br>&#125;)<br><br>router.Run() <span class="hljs-comment">// 启动 HTTP 服务器，开始接收并处理客户端的请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-11"><a href="#（2）代码解释-11" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>​以上代码使用 Gin 框架创建了一个简单的 HTTP 服务器，并注册了一个 “&#x2F;cookie” 路由的 GET 方法处理函数。在处理函数中，通过 <code>c.Cookie(&quot;gin_cookie&quot;)</code> 获取名为 “gin_cookie” 的 Cookie 值，并在控制台打印出来。如果获取 Cookie 发生错误（例如不存在），则设置一个默认值，并通过 <code>c.SetCookie()</code> 方法设置名为 “gin_cookie” 的 Cookie 值为 “test”，过期时间为 3600 秒，路径为 “&#x2F;“，域名为 “localhost”，不限制 HTTPS 连接，允许 JS 访问。最后，通过调用 <code>router.Run()</code> 启动 HTTP 服务器，监听默认的地址和端口（0.0.0.0:8080），并开始接收并处理客户端的请求。</p></blockquote><h2 id="32、支持-Let’s-Encrypt"><a href="#32、支持-Let’s-Encrypt" class="headerlink" title="32、支持 Let’s Encrypt"></a>32、支持 Let’s Encrypt</h2><h4 id="（1）完整代码-30"><a href="#（1）完整代码-30" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>一行代码支持 LetsEncrypt HTTPS servers 示例。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/autotls&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br><span class="hljs-comment">// 注册 &quot;/ping&quot; 路由的 GET 方法处理函数</span><br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 使用 Autotls 启动 HTTP 服务器并监听域名 &quot;example1.com&quot; 和 &quot;example2.com&quot;</span><br>log.Fatal(autotls.Run(r, <span class="hljs-string">&quot;example1.com&quot;</span>, <span class="hljs-string">&quot;example2.com&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自定义 autocert manager 示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/autotls&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;golang.org/x/crypto/acme/autocert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br><span class="hljs-comment">// 注册 &quot;/ping&quot; 路由的 GET 方法处理函数</span><br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 创建一个 Autocert 管理器，用于配置 Let&#x27;s Encrypt 自动证书管理</span><br>m := autocert.Manager&#123;<br>Prompt:     autocert.AcceptTOS,                    <span class="hljs-comment">// 接受服务条款</span><br>HostPolicy: autocert.HostWhitelist(<span class="hljs-string">&quot;example1.com&quot;</span>, <span class="hljs-string">&quot;example2.com&quot;</span>), <span class="hljs-comment">// 允许的域名白名单</span><br>Cache:      autocert.DirCache(<span class="hljs-string">&quot;/var/www/.cache&quot;</span>),   <span class="hljs-comment">// 证书缓存目录</span><br>&#125;<br><br><span class="hljs-comment">// 使用 Autotls 启动 HTTP 服务器并监听域名 &quot;example1.com&quot; 和 &quot;example2.com&quot;，并配置自动证书管理器</span><br>log.Fatal(autotls.RunWithManager(r, &amp;m))<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="（2）代码解释-12"><a href="#（2）代码解释-12" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>以上代码使用 Gin 框架创建了一个简单的 HTTP 服务器，并注册了一个 “&#x2F;ping” 路由的 GET 方法处理函数，用于处理 “&#x2F;ping” 路径的请求，并返回 “pong” 字符串。然后，通过调用 <code>autotls.Run()</code> 方法使用 Autotls 启动 HTTP 服务器并监听域名 “example1.com” 和 “example2.com”，这将自动为这两个域名配置 HTTPS，并使用 Let’s Encrypt 证书进行 TLS 加密。如果启动服务器出现错误，会通过 <code>log.Fatal()</code> 方法记录并输出错误信息，并终止程序的运行。</p></blockquote><blockquote><p>以上代码使用 Gin 框架创建了一个简单的 HTTP 服务器，并注册了一个 “&#x2F;ping” 路由的 GET 方法处理函数，用于处理 “&#x2F;ping” 路径的请求，并返回 “pong” 字符串。然后，通过创建一个 Autocert 管理器来配置 Let’s Encrypt 自动证书管理，包括接受服务条款、允许的域名白名单和证书缓存目录等参数。最后，通过调用 <code>autotls.RunWithManager()</code> 方法使用 Autotls 启动 HTTP 服务器并监听域名 “example1.com” 和 “example2.com”，并配置自动证书管理器。如果启动服务器出现错误，会通过 <code>log.Fatal()</code> 方法记录并输出错误信息，并终止程序的运行。</p></blockquote><h2 id="33、将-request-body-绑定到不同的结构体中"><a href="#33、将-request-body-绑定到不同的结构体中" class="headerlink" title="33、将 request body 绑定到不同的结构体中"></a>33、将 request body 绑定到不同的结构体中</h2><h4 id="（1）完整代码-31"><a href="#（1）完整代码-31" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>一般通过调用 <code>c.Request.Body</code> 方法绑定数据，但不能多次调用这个方法。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> formA <span class="hljs-keyword">struct</span> &#123;<br>Foo <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;foo&quot; xml:&quot;foo&quot; binding:&quot;required&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> formB <span class="hljs-keyword">struct</span> &#123;<br>Bar <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;bar&quot; xml:&quot;bar&quot; binding:&quot;required&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SomeHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>objA := formA&#123;&#125;<br>objB := formB&#123;&#125;<br><br><span class="hljs-comment">// 尝试使用 c.ShouldBind() 方法将请求体绑定到 formA 结构体对象</span><br><span class="hljs-keyword">if</span> errA := c.ShouldBind(&amp;objA); errA == <span class="hljs-literal">nil</span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">`the body should be formA`</span>)<br><span class="hljs-comment">// 如果绑定失败，则尝试将请求体绑定到 formB 结构体对象</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errB := c.ShouldBind(&amp;objB); errB == <span class="hljs-literal">nil</span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">`the body should be formB`</span>)<br><span class="hljs-comment">// 如果两次绑定都失败，则执行其他逻辑</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-13"><a href="#（2）代码解释-13" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>以上代码是一个使用 Gin 框架的 HTTP 请求处理函数 SomeHandler，它通过两次调用 c.ShouldBind() 方法尝试将请求体绑定到两个不同的结构体对象 formA 和 formB。首先尝试将请求体绑定到 formA 对象，如果绑定成功，则返回一个字符串 “the body should be formA”。如果绑定失败，则尝试将请求体绑定到 formB 对象，如果绑定成功，则返回一个字符串 “the body should be formB”。如果两次绑定都失败，则执行其他逻辑。需要注意的是，c.ShouldBind() 方法使用了 c.Request.Body，一旦读取，请求体将变为 EOF，无法再次使用，因此在使用该方法时需要注意不可重用的特性。</p></blockquote><h2 id="34、-单文件上传"><a href="#34、-单文件上传" class="headerlink" title="34、 单文件上传"></a>34、 单文件上传</h2><h4 id="（1）完整代码-32"><a href="#（1）完整代码-32" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span><br>    <span class="hljs-comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span><br><br>    <span class="hljs-comment">// 定义上传文件的接口路由为 &quot;/upload&quot;，使用 POST 方法</span><br>    router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 获取上传的文件对象</span><br>        file, _ := c.FormFile(<span class="hljs-string">&quot;file&quot;</span>) <span class="hljs-comment">// 通过 c.FormFile() 方法获取上传的文件，&quot;file&quot; 是上传文件的字段名</span><br>        log.Println(file.Filename) <span class="hljs-comment">// 打印上传文件的文件名</span><br><br>        <span class="hljs-comment">// 上传文件至指定目录</span><br>        <span class="hljs-comment">// c.SaveUploadedFile(file, dst) // 使用 c.SaveUploadedFile() 方法将文件保存到指定的目录</span><br><br>        c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename)) <span class="hljs-comment">// 返回上传成功的信息</span><br>    &#125;)<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 Gin 服务器，监听在 8080 端口</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-14"><a href="#（2）代码解释-14" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>首先，创建了一个默认的 Gin 路由引擎 <code>router := gin.Default()</code>。</li><li>设置了一个上传文件的接口路由为 “&#x2F;upload”，并使用 POST 方法处理文件上传请求：<code>router.POST(&quot;/upload&quot;, func(c *gin.Context) &#123;...&#125;)</code>。这里使用了匿名函数作为路由处理函数，接收一个 <code>c *gin.Context</code> 参数，用于处理 HTTP 请求和响应。</li><li>在路由处理函数中，通过 <code>c.FormFile(&quot;file&quot;)</code> 获取上传的文件对象。<code>c.FormFile</code> 方法是 Gin 框架提供的用于获取上传文件的方法，其中 “file” 是上传文件的字段名。如果没有找到对应的文件字段，会返回错误。</li><li>使用 <code>log.Println(file.Filename)</code> 打印上传文件的文件名。这里只是简单地将文件名打印到控制台，实际应用中可能需要根据需求进行文件名的处理。</li><li>可以通过 <code>c.SaveUploadedFile(file, dst)</code> 将文件保存到指定目录。其中 <code>file</code> 是上传的文件对象，<code>dst</code> 是目标保存路径。在实际应用中，需要根据需求设置合适的目标保存路径，并处理文件名重复等情况。</li><li>使用 <code>c.String(http.StatusOK, fmt.Sprintf(&quot;&#39;%s&#39; uploaded!&quot;, file.Filename))</code> 返回上传成功的信息。这里使用了 Gin 框架提供的 <code>c.String</code> 方法，设置 HTTP 响应状态码为 200，返回一个字符串作为响应体，其中包含上传文件的文件名。</li><li>最后，通过 <code>router.Run(&quot;:8080&quot;)</code> 启动 Gin 服务器，监听在 8080 端口，等待接收文件上传请求。</li></ol></blockquote><h2 id="35、-多文件上传"><a href="#35、-多文件上传" class="headerlink" title="35、 多文件上传"></a>35、 多文件上传</h2><h4 id="（1）完整代码-33"><a href="#（1）完整代码-33" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建默认的 Gin 路由引擎</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span><br>    <span class="hljs-comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span><br><br>    <span class="hljs-comment">// 设置文件上传的接口路由为 &quot;/upload&quot;，使用 POST 方法处理文件上传请求</span><br>    router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 获取上传的 multipart form 数据</span><br>        form, _ := c.MultipartForm()<br><br>        <span class="hljs-comment">// 获取上传的文件对象列表</span><br>        files := form.File[<span class="hljs-string">&quot;upload[]&quot;</span>]<br><br>        <span class="hljs-comment">// 遍历文件对象列表</span><br>        <span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>            log.Println(file.Filename)<br>            <span class="hljs-comment">// 这里可以根据需求处理文件，比如保存文件到指定目录、处理文件名重复等情况</span><br>            <span class="hljs-comment">// c.SaveUploadedFile(file, dst)</span><br>        &#125;<br><br>        <span class="hljs-comment">// 返回上传成功的信息，包含上传的文件数量</span><br>        c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;%d files uploaded!&quot;</span>, <span class="hljs-built_in">len</span>(files)))<br>    &#125;)<br><br>    <span class="hljs-comment">// 启动 Gin 服务器，监听在 8080 端口，等待接收文件上传请求</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-15"><a href="#（2）代码解释-15" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>创建 Gin 路由引擎：通过 <code>gin.Default()</code> 创建了一个默认的 Gin 路由引擎，用于处理 HTTP 请求。</li><li>设置文件上传接口：使用 <code>router.POST(&quot;/upload&quot;, ...)</code> 将文件上传接口设置为 “&#x2F;upload”，并指定 HTTP 方法为 POST。这意味着该接口将处理客户端发送的 POST 请求。</li><li>获取上传的 multipart form 数据：在接口的处理函数中，使用 <code>c.MultipartForm()</code> 方法获取上传的 multipart form 数据，其中 <code>c</code> 是 <code>*gin.Context</code> 类型的请求上下文对象。</li><li>获取上传的文件对象列表：从 <code>multipart.Form</code> 结构体中的 <code>File</code> 字段获取上传的文件对象列表。这里使用了 “upload[]” 作为文件字段的名称，表示可以上传多个文件，且字段名为 “upload[]”。</li><li>处理上传的文件：通过遍历文件对象列表，可以对每个文件进行处理，例如获取文件名、保存文件到指定目录、处理文件名重复等。这里的处理逻辑通过注释进行了简单说明，实际应用中需要根据需求进行具体处理。</li><li>返回上传成功的信息：通过 <code>c.String()</code> 方法返回上传成功的信息，包含上传的文件数量。</li><li>启动 HTTP 服务器：使用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在 8080 端口，等待接收文件上传请求。</li></ol><p>需要注意的是，这段代码还有一部分注释掉的代码，包括了设置 <code>router.MaxMultipartMemory</code> 限制内存大小的功能。可以根据实际需求取消注释并设置合适的内存限制。同时，这段代码还没有处理文件上传过程中可能出现的错误情况，如文件大小限制、文件类型限制等，需要根据具体需求进行完善。</p></blockquote><h2 id="36、-使用-BasicAuth-中间件"><a href="#36、-使用-BasicAuth-中间件" class="headerlink" title="36、  使用 BasicAuth 中间件"></a>36、  使用 BasicAuth 中间件</h2><h4 id="（1）完整代码-34"><a href="#（1）完整代码-34" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 模拟一些私人数据</span><br><span class="hljs-keyword">var</span> secrets = gin.H&#123;<br>    <span class="hljs-string">&quot;foo&quot;</span>:    gin.H&#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;foo@bar.com&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;123433&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;austin&quot;</span>: gin.H&#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;austin@example.com&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;666&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;lena&quot;</span>:   gin.H&#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;lena@guapa.com&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;523443&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br><br>    <span class="hljs-comment">// 路由组使用 gin.BasicAuth() 中间件</span><br>    <span class="hljs-comment">// gin.Accounts 是 map[string]string 的一种快捷方式</span><br>    authorized := r.Group(<span class="hljs-string">&quot;/admin&quot;</span>, gin.BasicAuth(gin.Accounts&#123;<br>        <span class="hljs-string">&quot;foo&quot;</span>:    <span class="hljs-string">&quot;bar&quot;</span>,<br>        <span class="hljs-string">&quot;austin&quot;</span>: <span class="hljs-string">&quot;1234&quot;</span>,<br>        <span class="hljs-string">&quot;lena&quot;</span>:   <span class="hljs-string">&quot;hello2&quot;</span>,<br>        <span class="hljs-string">&quot;manu&quot;</span>:   <span class="hljs-string">&quot;4321&quot;</span>,<br>    &#125;))<br><br>    <span class="hljs-comment">// /admin/secrets 端点</span><br>    <span class="hljs-comment">// 触发 &quot;localhost:8080/admin/secrets</span><br>    authorized.GET(<span class="hljs-string">&quot;/secrets&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 获取用户，它是由 BasicAuth 中间件设置的</span><br>        <span class="hljs-comment">// 使用 c.MustGet() 方法获取经过 BasicAuth 中间件处理后的用户信息</span><br>        user := c.MustGet(gin.AuthUserKey).(<span class="hljs-type">string</span>)<br>        <span class="hljs-keyword">if</span> secret, ok := secrets[user]; ok &#123;<br>            <span class="hljs-comment">// 根据用户信息获取对应的私人数据</span><br>            c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;user&quot;</span>: user, <span class="hljs-string">&quot;secret&quot;</span>: secret&#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果用户信息不存在于私人数据中，返回默认的信息</span><br>            c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;user&quot;</span>: user, <span class="hljs-string">&quot;secret&quot;</span>: <span class="hljs-string">&quot;NO SECRET :(&quot;</span>&#125;)<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-16"><a href="#（2）代码解释-16" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>定义了一个 <code>secrets</code> 变量，模拟了一些私人数据，使用了 <code>gin.H</code> 来表示 key-value 结构的 map。</li><li>创建了一个默认的 Gin 路由引擎 <code>r</code>。</li><li>使用 <code>r.Group()</code> 方法创建了一个路由组 <code>/admin</code>，并在该路由组上应用了 <code>gin.BasicAuth()</code> 中间件。<code>gin.BasicAuth()</code> 中间件用于进行 HTTP 基本身份验证，需要传入一个 <code>gin.Accounts</code> 类型的参数，其中包含了允许访问的用户名和密码的键值对。</li><li>在路由组中定义了一个 GET 请求的处理函数，处理 <code>/admin/secrets</code> 路径的请求。在该处理函数中，使用 <code>c.MustGet()</code> 方法获取经过 <code>gin.BasicAuth()</code> 中间件处理后的用户信息，其中 <code>gin.AuthUserKey</code> 是 Gin 框架中用于存储经过认证的用户信息的上下文键名。</li><li>根据用户信息从 <code>secrets</code> 变量中获取对应的私人数据，如果存在则返回用户信息和私人数据，否则返回默认的信息。</li><li>使用 <code>r.Run()</code> 方法启动 HTTP 服务器，监听在 0.0.0.0:8080 地址上。</li></ol></blockquote><h2 id="37、-使用-HTTP-方法"><a href="#37、-使用-HTTP-方法" class="headerlink" title="37、   使用 HTTP 方法"></a>37、   使用 HTTP 方法</h2><h4 id="（1）完整代码-35"><a href="#（1）完整代码-35" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 禁用控制台颜色</span><br>    <span class="hljs-comment">// gin.DisableConsoleColor()</span><br><br>    <span class="hljs-comment">// 使用默认中间件（logger 和 recovery 中间件）创建 gin 路由</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 注册不同的 HTTP 方法对应的处理函数</span><br>    router.GET(<span class="hljs-string">&quot;/someGet&quot;</span>, getting)       <span class="hljs-comment">// 处理 HTTP GET 请求</span><br>    router.POST(<span class="hljs-string">&quot;/somePost&quot;</span>, posting)     <span class="hljs-comment">// 处理 HTTP POST 请求</span><br>    router.PUT(<span class="hljs-string">&quot;/somePut&quot;</span>, putting)       <span class="hljs-comment">// 处理 HTTP PUT 请求</span><br>    router.DELETE(<span class="hljs-string">&quot;/someDelete&quot;</span>, deleting) <span class="hljs-comment">// 处理 HTTP DELETE 请求</span><br>    router.PATCH(<span class="hljs-string">&quot;/somePatch&quot;</span>, patching)   <span class="hljs-comment">// 处理 HTTP PATCH 请求</span><br>    router.HEAD(<span class="hljs-string">&quot;/someHead&quot;</span>, head)         <span class="hljs-comment">// 处理 HTTP HEAD 请求</span><br>    router.OPTIONS(<span class="hljs-string">&quot;/someOptions&quot;</span>, options) <span class="hljs-comment">// 处理 HTTP OPTIONS 请求</span><br><br>    <span class="hljs-comment">// 默认在 8080 端口启动服务，除非定义了一个 PORT 的环境变量。</span><br>    router.Run()<br>    <span class="hljs-comment">// router.Run(&quot;:3000&quot;) 可以硬编码指定端口号</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-17"><a href="#（2）代码解释-17" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>以上代码使用 Gin 框架创建了一个 HTTP 服务器，并注册了不同的 HTTP 方法对应的处理函数。每个处理函数在接收到对应的 HTTP 请求时会被调用，从而进行相应的处理逻辑。<code>router.Run()</code> 函数会在默认端口 8080 上启动 HTTP 服务，可以通过设置环境变量 <code>PORT</code> 来修改端口号。如果需要固定端口号，可以通过 <code>router.Run(&quot;:3000&quot;)</code> 来指定特定的端口号</li></ol></blockquote><h2 id="38、使用中间件"><a href="#38、使用中间件" class="headerlink" title="38、使用中间件"></a>38、使用中间件</h2><h4 id="（1）完整代码-36"><a href="#（1）完整代码-36" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 新建一个没有任何默认中间件的路由</span><br>    r := gin.New()<br><br>    <span class="hljs-comment">// 全局中间件</span><br>    <span class="hljs-comment">// Logger 中间件将日志写入 gin.DefaultWriter，即使你将 GIN_MODE 设置为 release。</span><br>    <span class="hljs-comment">// 默认情况下 gin.DefaultWriter = os.Stdout</span><br>    r.Use(gin.Logger())<br><br>    <span class="hljs-comment">// Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500。</span><br>    r.Use(gin.Recovery())<br><br>    <span class="hljs-comment">// 你可以为每个路由添加任意数量的中间件。</span><br>    r.GET(<span class="hljs-string">&quot;/benchmark&quot;</span>, MyBenchLogger(), benchEndpoint)<br><br>    <span class="hljs-comment">// 认证路由组</span><br>    <span class="hljs-comment">// authorized := r.Group(&quot;/&quot;, AuthRequired())</span><br>    <span class="hljs-comment">// 和使用以下两行代码的效果完全一样:</span><br>    authorized := r.Group(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment">// 路由组中间件! 在此例中，我们在 &quot;authorized&quot; 路由组中使用自定义创建的 </span><br>    <span class="hljs-comment">// AuthRequired() 中间件</span><br>    authorized.Use(AuthRequired())<br>    &#123;<br>        authorized.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint)<br>        authorized.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint)<br>        authorized.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint)<br><br>        <span class="hljs-comment">// 嵌套路由组</span><br>        testing := authorized.Group(<span class="hljs-string">&quot;testing&quot;</span>)<br>        testing.GET(<span class="hljs-string">&quot;/analytics&quot;</span>, analyticsEndpoint)<br>    &#125;<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-18"><a href="#（2）代码解释-18" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>创建 Gin 路由：代码通过 <code>gin.New()</code> 函数创建了一个新的 Gin 路由实例，并赋值给变量 <code>r</code>。这个路由实例没有任何默认的中间件。</li><li>全局中间件：代码通过 <code>r.Use()</code> 函数注册了两个全局中间件，分别是 <code>gin.Logger()</code> 和 <code>gin.Recovery()</code>。<code>gin.Logger()</code> 用于记录日志，<code>gin.Recovery()</code> 用于恢复从处理函数中的 panic。</li><li>路由和处理函数：代码通过 <code>r.GET()</code>、<code>r.POST()</code> 等方法注册了多个路由，并指定了相应的处理函数。例如，<code>r.GET(&quot;/benchmark&quot;, MyBenchLogger(), benchEndpoint)</code> 注册了一个 GET 请求的路由 “&#x2F;benchmark”，并使用了自定义的中间件 <code>MyBenchLogger()</code> 和处理函数 <code>benchEndpoint()</code>。</li><li>路由组和嵌套路由组：代码通过 <code>r.Group()</code> 方法创建了一个名为 “authorized” 的路由组，并在其中注册了多个路由和处理函数。这些路由和处理函数都位于 “authorized” 路由组下，并且共享路由组中注册的中间件 <code>AuthRequired()</code>，用于认证授权。另外，代码还演示了如何在路由组内创建嵌套的路由组，例如 <code>testing := authorized.Group(&quot;testing&quot;)</code>。</li><li>启动 HTTP 服务：代码通过 <code>r.Run(&quot;:8080&quot;)</code> 启动了一个 HTTP 服务，并监听在 0.0.0.0:8080 上。这将使服务在这个地址上接受来自客户端的请求。</li></ol></blockquote><h2 id="39、-映射查询字符串或表单参数"><a href="#39、-映射查询字符串或表单参数" class="headerlink" title="39、 映射查询字符串或表单参数"></a>39、 映射查询字符串或表单参数</h2><h4 id="（1）完整代码-37"><a href="#（1）完整代码-37" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-19"><a href="#（2）代码解释-19" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote></blockquote><h2 id="40、模型绑定和验证"><a href="#40、模型绑定和验证" class="headerlink" title="40、模型绑定和验证"></a>40、模型绑定和验证</h2><h4 id="（1）完整代码-38"><a href="#（1）完整代码-38" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Login 是一个结构体，用于绑定登录请求的 JSON、XML、HTML 表单数据</span><br><span class="hljs-keyword">type</span> Login <span class="hljs-keyword">struct</span> &#123;<br>    User     <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot;  binding:&quot;required&quot;`</span> <span class="hljs-comment">// User 字段，对应请求中的 &quot;user&quot; 参数，使用 form、json、xml 格式进行绑定，并设置为必需字段</span><br>    Password <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;`</span> <span class="hljs-comment">// Password 字段，对应请求中的 &quot;password&quot; 参数，使用 form、json、xml 格式进行绑定，并设置为必需字段</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由实例</span><br><br>    <span class="hljs-comment">// 绑定 JSON 请求 (&quot;/loginJSON&quot;)</span><br>    router.POST(<span class="hljs-string">&quot;/loginJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> json Login<br>        <span class="hljs-keyword">if</span> err := c.ShouldBindJSON(&amp;json); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 使用 ShouldBindJSON 方法将请求中的 JSON 数据绑定到 Login 结构体，并检查是否出现错误</span><br>            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;) <span class="hljs-comment">// 若绑定失败，返回错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> json.User != <span class="hljs-string">&quot;manu&quot;</span> || json.Password != <span class="hljs-string">&quot;123&quot;</span> &#123; <span class="hljs-comment">// 检查登录信息是否匹配</span><br>            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;) <span class="hljs-comment">// 若登录信息不匹配，返回未授权状态码和错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;) <span class="hljs-comment">// 登录成功，返回状态码和登录成功信息到客户端</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 绑定 XML 请求 (&quot;/loginXML&quot;)</span><br>    router.POST(<span class="hljs-string">&quot;/loginXML&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> xml Login<br>        <span class="hljs-keyword">if</span> err := c.ShouldBindXML(&amp;xml); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 使用 ShouldBindXML 方法将请求中的 XML 数据绑定到 Login 结构体，并检查是否出现错误</span><br>            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;) <span class="hljs-comment">// 若绑定失败，返回错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> xml.User != <span class="hljs-string">&quot;manu&quot;</span> || xml.Password != <span class="hljs-string">&quot;123&quot;</span> &#123; <span class="hljs-comment">// 检查登录信息是否匹配</span><br>            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;) <span class="hljs-comment">// 若登录信息不匹配，返回未授权状态码和错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;) <span class="hljs-comment">// 登录成功，返回状态码和登录成功信息到客户端</span><br>    &#125;)<br><span class="hljs-comment">// 绑定 HTML 表单 (user=manu&amp;password=123)</span><br>    router.POST(<span class="hljs-string">&quot;/loginForm&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> form Login<br>        <span class="hljs-comment">// 根据 Content-Type Header 推断使用哪个绑定器。</span><br>        <span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;form); err != <span class="hljs-literal">nil</span> &#123;<br>            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> form.User != <span class="hljs-string">&quot;manu&quot;</span> || form.Password != <span class="hljs-string">&quot;123&quot;</span> &#123;<br>            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;)<br>            <span class="hljs-keyword">return</span><br>        &#125; <br><br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-20"><a href="#（2）代码解释-20" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>定义了一个名为 <code>Login</code> 的结构体，其中包含了 <code>User</code> 和 <code>Password</code> 两个字段，用于接收登录请求中的用户和密码信息。结构体中使用了标签（tag）来指定了字段在不同请求中的绑定方式，如 <code>form:&quot;user&quot;</code> 表示在 HTML 表单中使用 <code>user</code> 字段名进行绑定，<code>json:&quot;user&quot;</code> 表示在 JSON 中使用 <code>user</code> 字段名进行绑定，<code>xml:&quot;user&quot;</code> 表示在 XML 中使用 <code>user</code> 字段名进行绑定。</li><li>在 <code>main</code> 函数中，创建了一个默认的 Gin 路由实例，并注册了三个路由处理函数分别处理 <code>/loginJSON</code>、<code>/loginXML</code>、<code>/loginForm</code> 这三个不同的路由。</li><li><code>/loginJSON</code> 路由处理函数通过 <code>c.ShouldBindJSON(&amp;json)</code> 方法将请求体中的 JSON 数据绑定到 <code>json</code> 结构体变量中，如果绑定失败，则返回错误信息；如果绑定成功，则判断 <code>json.User</code> 和 <code>json.Password</code> 是否符合预期的值，如果不符合，则返回未授权的状态码和错误信息，否则返回登录成功的状态码和信息。</li><li><code>/loginXML</code> 路由处理函数通过 <code>c.ShouldBindXML(&amp;xml)</code> 方法将请求体中的 XML 数据绑定到 <code>xml</code> 结构体变量中，如果绑定失败，则返回错误信息；如果绑定成功，则判断 <code>xml.User</code> 和 <code>xml.Password</code> 是否符合预期的值，如果不符合，则返回未授权的状态码和错误信息，否则返回登录成功的状态码和信息。</li><li><code>/loginForm</code> 路由处理函数通过 <code>c.ShouldBind(&amp;form)</code> 方法根据请求头中的 <code>Content-Type</code> 判断请求体中的数据类型，并将数据绑定到 <code>form</code> 结构体变量中，如果绑定失败，则返回错误信息；如果绑定成功，则判断 <code>form.User</code> 和 <code>form.Password</code> 是否符合预期的值，如果不符合，则返回未授权的状态码和错误信息，否则返回登录成功的状态码和信息。</li><li>最后通过 <code>router.Run(&quot;:8080&quot;)</code> 启动了服务，监听在 <code>0.0.0.0:8080</code> 地址上。</li></ol></blockquote><h2 id="41、-路由参数"><a href="#41、-路由参数" class="headerlink" title="41、 路由参数"></a>41、 路由参数</h2><h4 id="（1）完整代码-39"><a href="#（1）完整代码-39" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个默认的 gin 路由引擎</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 注册一个处理器函数，处理匹配到的路由 /user/:name</span><br>    <span class="hljs-comment">// :name 表示该路由段为参数，可以匹配任何字符串，并将其作为参数传递给处理器函数</span><br>    router.GET(<span class="hljs-string">&quot;/user/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 从路由参数中获取名字参数值</span><br>        name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>        <span class="hljs-comment">// 在响应中返回 &quot;Hello &#123;name&#125;&quot; 字符串</span><br>        c.String(http.StatusOK, <span class="hljs-string">&quot;Hello %s&quot;</span>, name)<br>    &#125;)<br><br>    <span class="hljs-comment">// 注册一个处理器函数，处理匹配到的路由 /user/:name/*action</span><br>    <span class="hljs-comment">// :name 和 *action 都表示参数，:name 匹配一个字符串，*action 匹配多个字符串</span><br>    <span class="hljs-comment">// 如果没有其他路由匹配 /user/:name，该处理器函数将处理该请求并进行重定向到 /user/:name/</span><br>    router.GET(<span class="hljs-string">&quot;/user/:name/*action&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 从路由参数中获取名字和动作参数值</span><br>        name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>        action := c.Param(<span class="hljs-string">&quot;action&quot;</span>)<br>        <span class="hljs-comment">// 根据参数值构建消息字符串</span><br>        message := name + <span class="hljs-string">&quot; is &quot;</span> + action<br>        <span class="hljs-comment">// 在响应中返回消息字符串</span><br>        c.String(http.StatusOK, message)<br>    &#125;)<br><br>    <span class="hljs-comment">// 启动 HTTP 服务器并监听在 :8080 上</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-21"><a href="#（2）代码解释-21" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>第一个处理器函数处理了路由 <code>/user/:name</code>。<code>:name</code> 表示该路由段为参数，可以匹配任何字符串，并将其作为参数传递给处理器函数。在处理器函数中，通过 <code>c.Param(&quot;name&quot;)</code> 获取路由参数中的 <code>name</code> 值，并使用 <code>c.String(http.StatusOK, &quot;Hello %s&quot;, name)</code> 在响应中返回 “Hello {name}” 字符串。</li><li>第二个处理器函数处理了路由 <code>/user/:name/*action</code>。<code>:name</code> 和 <code>*action</code> 都表示参数，其中 <code>:name</code> 匹配一个字符串，<code>*action</code> 匹配多个字符串。在处理器函数中，通过 <code>c.Param(&quot;name&quot;)</code> 和 <code>c.Param(&quot;action&quot;)</code> 获取路由参数中的 <code>name</code> 和 <code>action</code> 值，并根据这些参数值构建消息字符串。然后，使用 <code>c.String(http.StatusOK, message)</code> 在响应中返回该消息字符串。需要注意的是，如果没有其他路由匹配 <code>/user/:name</code>，该处理器函数将处理该请求并进行重定向到 <code>/user/:name/</code>。</li></ol><p>最后，通过调用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器并监听在 <code>:8080</code> 端口上。一旦服务器启动成功，它将开始监听来自客户端的 HTTP 请求，并根据注册的路由处理器函数来处理这些请求。Gin 框架提供了很多方便的方法来处理路由、请求和响应，使得构建 HTTP 服务器变得简单和高效。</p></blockquote><h2 id="42、静态资源嵌入"><a href="#42、静态资源嵌入" class="headerlink" title="42、静态资源嵌入"></a>42、静态资源嵌入</h2><h4 id="（1）完整代码-40"><a href="#（1）完整代码-40" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 路由实例</span><br><br>    t, err := loadTemplate() <span class="hljs-comment">// 调用 loadTemplate() 函数加载模板</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// 如果加载模板过程中出现错误，则触发 panic</span><br>    &#125;<br>    r.SetHTMLTemplate(t) <span class="hljs-comment">// 将加载好的模板设置到 Gin 路由实例的 HTML 模板中</span><br><br>    r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义路由处理函数，处理 HTTP GET 请求，路径为 &quot;/&quot;</span><br>        c.HTML(http.StatusOK, <span class="hljs-string">&quot;/html/index.tmpl&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 返回 HTML 响应，使用加载的模板渲染数据，并设置 HTTP 状态码为 200</span><br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器，监听在端口 8080 上</span><br>&#125;<br><br><span class="hljs-comment">// loadTemplate 加载由 go-assets-builder 嵌入的模板</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadTemplate</span><span class="hljs-params">()</span></span> (*template.Template, <span class="hljs-type">error</span>) &#123;<br>    t := template.New(<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">// 创建一个空的模板</span><br>    <span class="hljs-keyword">for</span> name, file := <span class="hljs-keyword">range</span> Assets.Files &#123; <span class="hljs-comment">// 遍历由 go-assets-builder 嵌入的文件</span><br>        <span class="hljs-keyword">if</span> file.IsDir() || !strings.HasSuffix(name, <span class="hljs-string">&quot;.tmpl&quot;</span>) &#123;<br>            <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 如果文件是目录或者不是以 .tmpl 后缀结尾，则跳过</span><br>        &#125;<br>        h, err := ioutil.ReadAll(file) <span class="hljs-comment">// 读取文件内容</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err <span class="hljs-comment">// 如果读取文件内容过程中出现错误，则返回错误</span><br>        &#125;<br>        t, err = t.New(name).Parse(<span class="hljs-type">string</span>(h)) <span class="hljs-comment">// 将文件内容解析为模板，并将其命名为 name，与之前的模板形成模板链</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err <span class="hljs-comment">// 如果解析过程中出现错误，则返回错误</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t, <span class="hljs-literal">nil</span> <span class="hljs-comment">// 返回加载好的模板和 nil 错误，表示加载模板成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-22"><a href="#（2）代码解释-22" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>上述代码是一个简单的 Go 语言程序，使用了 Gin 框架和 go-assets-builder 库来创建一个 HTTP 服务器，并加载嵌入在程序中的模板文件进行渲染。下面对代码进行详细的分析：</p><ol><li><code>func main()</code> 是 Go 语言程序的入口函数，程序从这里开始执行。</li><li><code>gin.New()</code> 创建了一个新的 Gin 路由实例，用于处理 HTTP 请求和定义路由。</li><li><code>loadTemplate()</code> 函数用于加载由 go-assets-builder 嵌入的模板文件，并返回解析后的模板和可能的错误。</li><li><code>r.SetHTMLTemplate(t)</code> 将加载好的模板设置到 Gin 路由实例的 HTML 模板中，以便后续使用模板进行渲染。</li><li><code>r.GET(&quot;/&quot;, func(c *gin.Context) &#123; ... &#125;)</code> 定义了一个路由处理函数，处理根路径的 HTTP GET 请求。当用户访问根路径时，Gin 框架会调用这个处理函数来处理请求。</li><li><code>c.HTML(http.StatusOK, &quot;/html/index.tmpl&quot;, nil)</code> 在路由处理函数中调用 <code>c.HTML()</code> 方法返回一个 HTML 响应。这个方法使用加载的模板渲染数据，并设置 HTTP 状态码为 200（http.StatusOK）。</li><li><code>r.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在 8080 端口上，开始接收和处理 HTTP 请求。</li><li><code>loadTemplate()</code> 函数遍历由 go-assets-builder 嵌入的文件，读取文件内容并解析为模板，并将其命名为文件名，形成一个模板链。最终返回加载好的模板和可能的错误。</li></ol><p>总的来说，这段代码通过 Gin 框架创建了一个简单的 HTTP 服务器，加载了由 go-assets-builder 嵌入的模板文件，用于渲染 HTML 响应。这种方式可以将模板文件嵌入到 Go 语言程序中，方便部署和分发，同时避免了外部文件的依赖和管理。</p></blockquote><h2 id="43、不使用默认的中间件"><a href="#43、不使用默认的中间件" class="headerlink" title="43、不使用默认的中间件"></a>43、不使用默认的中间件</h2><h4 id="（1）完整代码-41"><a href="#（1）完整代码-41" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.New()<br>代替<br><span class="hljs-comment">// Default 使用 Logger 和 Recovery 中间件</span><br>r := gin.Default()<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-23"><a href="#（2）代码解释-23" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><h2 id="44、-XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染"><a href="#44、-XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染" class="headerlink" title="44、 XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染"></a>44、 XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染</h2><h4 id="（1）完整代码-42"><a href="#（1）完整代码-42" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由实例</span><br><br>    r.GET(<span class="hljs-string">&quot;/someJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;hey&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: http.StatusOK&#125;)<br>        <span class="hljs-comment">// 处理 &quot;/someJSON&quot; 路由的 GET 请求，返回一个 JSON 响应</span><br>        <span class="hljs-comment">// 使用 gin.H 快捷方式创建一个 map[string]interface&#123;&#125; 类型的数据作为 JSON 数据</span><br>        <span class="hljs-comment">// JSON 数据包含 &quot;message&quot; 和 &quot;status&quot; 两个字段，值分别为 &quot;hey&quot; 和 http.StatusOK</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/moreJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 可以使用结构体来定义 JSON 数据</span><br>        <span class="hljs-keyword">var</span> msg <span class="hljs-keyword">struct</span> &#123;<br>            Name    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;user&quot;`</span> <span class="hljs-comment">// 可以使用 `json:&quot;...&quot;` 标签定义 JSON 字段名</span><br>            Message <span class="hljs-type">string</span><br>            Number  <span class="hljs-type">int</span><br>        &#125;<br>        msg.Name = <span class="hljs-string">&quot;Lena&quot;</span><br>        msg.Message = <span class="hljs-string">&quot;hey&quot;</span><br>        msg.Number = <span class="hljs-number">123</span><br>        <span class="hljs-comment">// 定义一个结构体变量 msg，设置其字段的值</span><br>        <span class="hljs-comment">// 注意 msg.Name 在 JSON 中变成了 &quot;user&quot;</span><br>        <span class="hljs-comment">// 将输出：&#123;&quot;user&quot;: &quot;Lena&quot;, &quot;Message&quot;: &quot;hey&quot;, &quot;Number&quot;: 123&#125;</span><br>        c.JSON(http.StatusOK, msg)<br>        <span class="hljs-comment">// 处理 &quot;/moreJSON&quot; 路由的 GET 请求，返回一个 JSON 响应</span><br>        <span class="hljs-comment">// 使用结构体变量 msg 作为 JSON 数据</span><br>        <span class="hljs-comment">// JSON 数据包含三个字段，分别为 &quot;user&quot;、&quot;Message&quot; 和 &quot;Number&quot;，对应结构体的字段值</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/someXML&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.XML(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;hey&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: http.StatusOK&#125;)<br>        <span class="hljs-comment">// 处理 &quot;/someXML&quot; 路由的 GET 请求，返回一个 XML 响应</span><br>        <span class="hljs-comment">// 使用 gin.H 快捷方式创建一个 map[string]interface&#123;&#125; 类型的数据作为 XML 数据</span><br>        <span class="hljs-comment">// XML 数据包含 &quot;message&quot; 和 &quot;status&quot; 两个字段，值分别为 &quot;hey&quot; 和 http.StatusOK</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/someYAML&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.YAML(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;hey&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: http.StatusOK&#125;)<br>        <span class="hljs-comment">// 处理 &quot;/someYAML&quot; 路由的 GET 请求，返回一个 YAML 响应</span><br>        <span class="hljs-comment">// 使用 gin.H 快捷方式创建一个 map[string]interface&#123;&#125; 类型的数据作为 YAML 数据</span><br>        <span class="hljs-comment">// YAML 数据包含 &quot;message&quot; 和 &quot;status&quot; 两个字段，值分别为 &quot;hey&quot; 和 http.StatusOK</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/someProtoBuf&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        reps := []<span class="hljs-type">int64</span>&#123;<span class="hljs-type">int64</span>(<span class="hljs-number">1</span>), <span class="hljs-type">int64</span>(<span class="hljs-number">2</span>)&#125;<br>        label := <span class="hljs-string">&quot;test&quot;</span><br>        <span class="hljs-comment">// 定义一个切片 reps 和一个字符串 label</span><br>        <span class="hljs-comment">// 用于创建一个 protoexample.Test 结构体变量 data</span><br><br>        data := &amp;protoexample.Test&#123;<br>            Label: &amp;label,<br>            Reps:  reps,<br>        &#125;<br>        <span class="hljs-comment">// 请注意，数据在响应中变为二进制数据</span><br>        <span class="hljs-comment">// 将输出被 protoexample.Test protobuf 序列化了的数据</span><br>        c.ProtoBuf(http.StatusOK, data)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-24"><a href="#（2）代码解释-24" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>导入了 Gin 框架和 net&#x2F;http 包，以及一个自定义的 Protocol Buffers 文件包 protoexample。</li><li>创建了一个 Gin 的默认引擎实例 r，用于处理 HTTP 请求。</li><li>定义了路由处理函数，通过 r.GET() 方法将路由路径和处理函数绑定起来。</li><li>第一个路由处理函数处理 “&#x2F;someJSON” 路径的 GET 请求，返回一个 JSON 格式的响应，其中包含一个 “message” 字段和一个 “status” 字段，值分别为 “hey” 和 http.StatusOK。</li><li>第二个路由处理函数处理 “&#x2F;moreJSON” 路径的 GET 请求，返回一个 JSON 格式的响应，其中包含一个结构体 msg，结构体有三个字段，分别为 “Name”、”Message” 和 “Number”，通过结构体字面量赋值后作为响应的内容。</li><li>第三个路由处理函数处理 “&#x2F;someXML” 路径的 GET 请求，返回一个 XML 格式的响应，其中包含一个 “message” 字段和一个 “status” 字段，值分别为 “hey” 和 http.StatusOK。</li><li>第四个路由处理函数处理 “&#x2F;someYAML” 路径的 GET 请求，返回一个 YAML 格式的响应，其中包含一个 “message” 字段和一个 “status” 字段，值分别为 “hey” 和 http.StatusOK。</li><li>第五个路由处理函数处理 “&#x2F;someProtoBuf” 路径的 GET 请求，返回一个 Protocol Buffers 格式的响应，其中包含一个自定义的 Test 结构体，结构体有两个字段，分别为 “Label” 和 “Reps”，通过结构体字面量赋值后作为响应的内容。</li><li>最后通过 r.Run() 方法启动 HTTP 服务器，在地址 0.0.0.0:8080 上监听请求。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go的HTTP网络编程</title>
    <link href="/2023/04/11/Go/go%E7%9A%84HTTP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/04/11/Go/go%E7%9A%84HTTP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="go的HTTP网络编程"><a href="#go的HTTP网络编程" class="headerlink" title="go的HTTP网络编程"></a>go的HTTP网络编程<span id="more"></span></h1><h2 id="1、http编程–server示例"><a href="#1、http编程–server示例" class="headerlink" title="1、http编程–server示例"></a>1、http编程–server示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 注册处理函数，定义 URL 路由和对应的处理函数</span><br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, Hello)         <span class="hljs-comment">// 根路径 &quot;/&quot; 的请求交给 Hello 函数处理</span><br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, Login)   <span class="hljs-comment">// &quot;/login&quot; 路径的请求交给 Login 函数处理</span><br><br><span class="hljs-comment">// 启动 HTTP 服务器，监听指定的地址和端口</span><br>err := http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, <span class="hljs-literal">nil</span>)   <span class="hljs-comment">// 启动服务器，监听地址 &quot;0.0.0.0:8080&quot;，使用默认的路由器和处理器</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;HTTP 服务器启动失败&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 处理根路径 &quot;/&quot; 的请求</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World!&quot;</span>)   <span class="hljs-comment">// 将 &quot;Hello, World!&quot; 写入 http.ResponseWriter，作为 HTTP 响应的内容</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Login</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 处理 &quot;/login&quot; 路径的请求</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Login page&quot;</span>)   <span class="hljs-comment">// 将 &quot;Login page&quot; 写入 http.ResponseWriter，作为 HTTP 响应的内容</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="示例说明："><a href="#示例说明：" class="headerlink" title="示例说明："></a>示例说明：</h3><blockquote><ul><li><code>http.HandleFunc(&quot;/&quot;, Hello)</code>：注册处理函数 <code>Hello</code>，将根路径 “&#x2F;“ 的请求交给 <code>Hello</code> 函数处理。</li><li><code>http.HandleFunc(&quot;/login&quot;, Login)</code>：注册处理函数 <code>Login</code>，将 “&#x2F;login” 路径的请求交给 <code>Login</code> 函数处理。</li><li><code>http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</code>：启动一个 HTTP 服务器，监听地址为 “0.0.0.0:8080”，传入 <code>nil</code> 作为处理器，表示使用默认的路由器和处理器。</li><li><code>Hello</code> 函数和 <code>Login</code> 函数分别是处理根路径和 “&#x2F;login” 路径请求的处理函数，它们接收一个 <code>http.ResponseWriter</code> 和一个 <code>http.Request</code> 参数，分别用于写入响应和读取请求信息。</li><li><code>fmt.Fprintf(w, ...)</code>：使用 <code>Fprintf</code> 函数将字符串写入到 <code>http.ResponseWriter</code> 中，作为 HTTP 响应的内容。</li></ul></blockquote><h2 id="2、http编程–Client示例"><a href="#2、http编程–Client示例" class="headerlink" title="2、http编程–Client示例"></a>2、http编程–Client示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个 HTTP 客户端</span><br>client := http.Client&#123;&#125;<br><br><span class="hljs-comment">// 构建 GET 请求</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建请求失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 发送请求</span><br>res, err := client.Do(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;请求失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> res.Body.Close() <span class="hljs-comment">// 在函数结束时关闭响应的 Body</span><br><br><span class="hljs-comment">// 读取响应的内容</span><br>data, err := ioutil.ReadAll(res.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 输出响应的内容</span><br>fmt.Println(<span class="hljs-type">string</span>(data))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例说明：-1"><a href="#示例说明：-1" class="headerlink" title="示例说明："></a>示例说明：</h3><blockquote><ul><li><code>http.Client&#123;&#125;</code>：创建一个 HTTP 客户端，用于发送 HTTP 请求。</li><li><code>http.NewRequest(&quot;GET&quot;, &quot;https://www.example.com&quot;, nil)</code>：构建一个 GET 请求，并指定请求的 URL、请求方法和请求体。</li><li><code>client.Do(req)</code>：发送请求并获取响应，返回一个 <code>http.Response</code> 对象。</li><li><code>defer res.Body.Close()</code>：在函数结束时关闭响应的 Body，确保资源被正确释放。</li><li><code>ioutil.ReadAll(res.Body)</code>：从响应的 Body 中读取内容，返回一个字节数组。</li><li><code>fmt.Println(string(data))</code>：将读取到的响应内容转换为字符串并输出。</li></ul></blockquote><h2 id="3、常见HTTP请求方法"><a href="#3、常见HTTP请求方法" class="headerlink" title="3、常见HTTP请求方法"></a>3、常见HTTP请求方法</h2><blockquote><ol><li>GET：从服务器获取资源。客户端向服务器请求获取指定 URL 对应的资源，并从服务器返回该资源的内容。GET 请求通常用于获取数据，而不对服务器上的资源进行修改。</li><li>POST：向服务器提交数据。客户端向服务器提交数据，请求服务器对该数据进行处理。POST 请求通常用于向服务器提交数据，如表单数据、上传文件等。</li><li>PUT：更新服务器上的资源。客户端向服务器传送数据，请求服务器更新指定 URL 对应的资源。PUT 请求通常用于更新资源。</li><li>DELETE：删除服务器上的资源。客户端向服务器请求删除指定 URL 对应的资源。DELETE 请求通常用于删除资源。</li><li>HEAD：类似于 GET 请求，但只返回响应头部，不返回响应体。用于获取资源的元信息，如文件大小、文件类型等，而不获取实际的资源内容。</li><li>OPTIONS：请求服务器返回对指定 URL 支持的通信选项。服务器将返回支持的 HTTP 请求方法、头部字段等信息，用于客户端了解服务器的功能和约束。</li><li>PATCH：对服务器上的资源进行部分更新。客户端向服务器传送数据，请求服务器对指定 URL 对应的资源进行部分更新。</li><li>CONNECT：建立网络隧道。通常用于代理服务器，用于在客户端和目标服务器之间建立隧道，用于安全的加密通信。</li><li>TRACE：用于调试，请求服务器返回对请求和响应的诊断信息。不常用于实际生产环境。</li></ol></blockquote><h2 id="4、下面是一个简单的-Go-语言程序，演示了如何使用-HTTP-请求方法进行基本的-HTTP-请求："><a href="#4、下面是一个简单的-Go-语言程序，演示了如何使用-HTTP-请求方法进行基本的-HTTP-请求：" class="headerlink" title="4、下面是一个简单的 Go 语言程序，演示了如何使用 HTTP 请求方法进行基本的 HTTP 请求："></a>4、下面是一个简单的 Go 语言程序，演示了如何使用 HTTP 请求方法进行基本的 HTTP 请求：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// GET 请求示例</span><br>resp, err := http.Get(<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>) <span class="hljs-comment">// 发起 GET 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;GET 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close() <span class="hljs-comment">// 确保在函数退出前关闭响应体</span><br><br>data, err := ioutil.ReadAll(resp.Body) <span class="hljs-comment">// 读取响应体数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;GET 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data)) <span class="hljs-comment">// 打印响应数据</span><br><br><span class="hljs-comment">// POST 请求示例</span><br>resp, err = http.Post(<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 发起 POST 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;POST 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>data, err = ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;POST 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data))<br><br><span class="hljs-comment">// PUT 请求示例</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 创建 PUT 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建 PUT 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>client := &amp;http.Client&#123;&#125;<br>resp, err = client.Do(req) <span class="hljs-comment">// 发起 PUT 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;PUT 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>data, err = ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;PUT 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data))<br><br><span class="hljs-comment">// DELETE 请求示例</span><br>req, err = http.NewRequest(<span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 创建 DELETE 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建 DELETE 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>resp, err = client.Do(req) <span class="hljs-comment">// 发起 DELETE 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;DELETE 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>data, err = ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;DELETE 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习记录</title>
    <link href="/2023/04/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/04/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP/"/>
    <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP<span id="more"></span></h2><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><blockquote><p>​子串的匹配算法。</p></blockquote><h4 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h4><blockquote><p>KMP算法分为两个部分：求next数组 和匹配字符串</p><p>（1）求next数组：<br>    （1.1）先让子串最近一个与其相同的位置，然后继续判断，直至能匹配上或者回到第一个字符位置。<br>    （1.2）回到能匹配到的地方后，继续开始匹配，匹配成功，则j向后移，<br>    （1.3）记录当前子串字符i的能匹配上的位置<br>    （1.4）遍历整个子串，便能找出子串中能匹配上的位置<br>（2）匹配字符串：利用子串的next数组进行匹配，优化，不用每次匹配失败都回到子串的第一个字符<br>    （2.1）匹配不成功，每次匹配前，先让子串回到能与主串匹配的位置<br>    （2.2）然后进行匹配，如果匹配成功，就把子串匹配的位置向后移<br>    （2.3）如果子串j匹配完了，即j &#x3D;&#x3D; n时，说明在主串中找到了子串匹配串，则进行输出该位置，并且将j回到能匹配的位置<br>    （2.4）逐一匹配主串中所有字符即可</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求next数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ ) <span class="hljs-comment">//第一位肯定是0，直接从第二位开始计算</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>])j = ne[j];        <span class="hljs-comment">//当j退到0或者，主串和子串的值对不上的时候，让j回到能对上的位置，直到找到或者无路可退为止</span><br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>])j ++;                     <span class="hljs-comment">//if能对上就让子串继续往后对</span><br>        ne[i] = j;                                    <span class="hljs-comment">//记录下该点时的next数组值</span><br>    &#125;<br><br><span class="hljs-comment">//开始匹配</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>])j = ne[j];        <span class="hljs-comment">//当j退到0或者，主串和子串的值对不上的时候，让j回到能对上的位置，直到找到或者无路可退为止</span><br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>])j ++;                     <span class="hljs-comment">//if能对上就让子串继续往后对</span><br>        <span class="hljs-keyword">if</span>(j == n)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i - n);                     <span class="hljs-comment">//输出此时的起始下标（该位置减去子串总长度，即子串起始下标）</span><br>            j = ne[j];                                <span class="hljs-comment">//将子串恢复到他下次能够匹配的位置</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表<span id="more"></span></h2><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><blockquote><p>​将较大的数值映射到较小的数组下标里。</p></blockquote><h4 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h4><blockquote><p>1、开放取址法<br>可以怎么去理解呢？<br>每次先找到插入数或者查找数的映射值，然后从该映射值开始找<br>插入的时候往后找空位，如果找到了空位，就停止，返回空位的下标<br>查询的时候，往后找，一个一个对比是否存在查找的数，直至查到空位位置，说明不存在这个数，<br>因为每一个数，一定是存在其映射数后面的，如果找到了空位，说明映射到这个数的后面的数已经找完了，说明不存在该数</p><p>需要注意的是：数组长度最好开到题给的2~3倍<br>实现：<br>（1）映射数： t &#x3D; (x % N + N) % N;<br>（2）这里将查找和插入进行同步操作：<br>while (h !&#x3D; null &amp;&amp; h[t] !&#x3D; x)<br>没有找到需要的东西（插入：空位，查找：相同的值或者空位）就继续查找：t ++;<br>找了数组末尾没有找到，就从数组开头继续查找 if (t &#x3D;&#x3D; N) t &#x3D; 0;<br>（3）最后返回目标下标即可 return t</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">//返回 查找后或者放入后x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = (x % N + N) % N; <span class="hljs-comment">//哈希函数，将大范围的值，全部映射到数组下标内</span><br><br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)   <span class="hljs-comment">//如果当前位置已经有值了，并且不等于那个值</span><br>    &#123;<br>        t ++;   <span class="hljs-comment">//往后找</span><br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>; <span class="hljs-comment">//找到了最后，仍然没有找到，从头开始找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> t;   <span class="hljs-comment">//返回x的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆<span id="more"></span></h2><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​堆有两个操作：down和up</p></blockquote><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>    <span class="hljs-comment">//down操作，将每个节点与其左右儿子比较，判断其是否需要进行下移</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;  <span class="hljs-comment">//t记录的是该节点以及其左右两个儿子中最小的值</span><br>    <span class="hljs-keyword">while</span> (u * <span class="hljs-number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;  <span class="hljs-comment">//先与左儿子进行比较</span><br>    <span class="hljs-keyword">while</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <span class="hljs-comment">//再与右儿子进行比较</span><br>    <span class="hljs-keyword">if</span> (t != u) <span class="hljs-comment">//若不等于，说明t发生了变化，必须进行下移</span><br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[t], h[u]);   <span class="hljs-comment">//将t位置的值，与u位置的值进行交换位置</span><br>        <span class="hljs-built_in">down</span>(t); <span class="hljs-comment">//递归，直至其不再需要下移为止</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span> <span class="hljs-params">(<span class="hljs-type">int</span> u)</span> <span class="hljs-comment">//up操作， 判断一个节点是否需要根据小根堆的特性进行上移操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])    <span class="hljs-comment">//判断，只要存在父节点，且父节点的值大于该节点的值，则需要进行交换</span><br>    &#123;   <br>        <span class="hljs-built_in">swap</span>(u, u / <span class="hljs-number">2</span>); <span class="hljs-comment">//同样进行所有信息的交换</span><br>        u &gt;&gt;= <span class="hljs-number">1</span>;        <span class="hljs-comment">//交换后，将该节点往上移，while继续判断是否需要上移</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集<span id="more"></span></h1><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><blockquote><p>​可以快速地做到下列两个操作：（1）将两个集合合并（2）询问两个元素是否在一个集合</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h4><blockquote><p>  find函数的实现</p><p>（1）int find(int x)<br>    {<br>        if(p[x]!&#x3D;x) p[x]&#x3D;find(p[x]); &#x2F;&#x2F;只要没有找到祖宗节点，就一直找，因为只有祖宗节点的p[x] &#x3D; x;<br>        return p[x]&#x3D;x; &#x2F;&#x2F;找到了祖宗节点，便返回祖宗节点的值<br>    }<br>        这个函数既实现了找到祖宗节点的功能，又实现了将所有儿子节点直接指向祖宗节点，即路径压缩<br>（2）合并两个集合，即将其中一个集合的祖宗节点变成另一个祖宗节点的子节点<br>p[find(a)] &#x3D; find(b);<br>（3）判断两个集合是否在同一个集合：则判断其祖宗节点是否为是否为同一个节点即可<br>if(find(a) &#x3D;&#x3D; find(b))printf(“Yes\n”);<br>else printf(“No\n”);</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并<span id="more"></span></h2><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​合并所有有交集的区间。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​可以用vector&lt;pair&lt;int, int&gt;&gt; 进行存储所有的区间</p><p>（1）先将所有的区间进行从小到大排序<br>（2）然后用所有的小区间去维护一个大区间<br>    （2.1）依次去遍历每一个小区间<br>    （2.2）如果当前区间和上一个区间没有交集，则进将前一个区间放入答案中，然后开始维护当前区间<br>    （2.3）如果当前区间和上一个区间有交集，就更新右边界为较大的那个值<br>（3）最后特判一个，如果最后一个区间不为空，就将最后一个区间放入到答案中<br>（4）将答案赋值给原集合即可</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        segs.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;); <br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//先将所有区间从小到大排序, 先看第一位，再看第二位，依次推类</span><br><br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;   <span class="hljs-comment">//定义区间的左右边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)    <span class="hljs-comment">//该区间和下一个区间没有交集</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<span class="hljs-comment">//特判没有交集的是不是第一个区间是不是最开始维护空区间</span><br>            st = seg.first, ed = seg.second;    <span class="hljs-comment">//更新区间， 第一次更新区间，直接将第一个区间的左右边界放进来</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ed = <span class="hljs-built_in">max</span>(ed, seg.second);   <span class="hljs-comment">//将区间右边界更新为较大的那个值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);    <span class="hljs-comment">//将最后一个区间加入</span><br><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）需要先对原区间集合进行排序</p><p>​（2）需要特判没有交集的是不是第一个区间，是不是最开始维护的空区间</p><p>​（3）在将区间集合遍历结束后，需要判断，只要维护的区间被更新过，那么加一定存在一个区间还没有加入答案，因为它还没有遇到一个与他没有交集的区间。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化<span id="more"></span></h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​所存的值域大，但个数小，为了避免空间的浪费，可以使用离散化。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）离散后一定要映射到1, 2, 3, … n，故需要在二分查找离散化的值的时候，返回找到的下标 + 1的位置</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算<span id="more"></span></h2><h3 id="1、返回n的最后一位1："><a href="#1、返回n的最后一位1：" class="headerlink" title="1、返回n的最后一位1："></a>1、返回n的最后一位1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br>       <br>   求一个数x，其二进制表示下<span class="hljs-number">1</span>的个数。<br>       <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x)<br>       &#123;<br>           res ++;<br>           x -= <span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>cout &lt;&lt; res;<br></code></pre></td></tr></table></figure><p>2、求n的第k位数字: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &gt;&gt; k &amp; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针算法</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法<span id="more"></span></h2><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分<span id="more"></span></h2><h3 id="1、一维前缀和"><a href="#1、一维前缀和" class="headerlink" title="1、一维前缀和"></a>1、一维前缀和</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​可以在O(1)的时间算出一段区间内的所有数的和。</p></blockquote><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];   <span class="hljs-comment">//预处理  计算前缀和数组</span><br><br><span class="hljs-type">int</span> l, r;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//进行每一段的求和</span><br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​前缀和与差分数组下标都必须从1开始。</p></blockquote><h3 id="2、二维前缀和"><a href="#2、二维前缀和" class="headerlink" title="2、二维前缀和"></a>2、二维前缀和</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​能够在O(1)的时间内算出一个矩阵中所有数的和。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）数组下标都从1开始，便于后续的处理<br>（2）遍历二维数组中的每一个点<br>构造：每一个点执行s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] + a[i][j] - s[i - 1][j - 1];<br>（3）获取(x1, y1)与(x2, y2)之间的子矩阵的所有数的和<br>构造完成后的二维前缀和数组，直接输出<br>s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]，即可获得该子矩阵的所有数的和</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];    <span class="hljs-comment">//求二维前缀和数组</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x2][y1 - <span class="hljs-number">1</span>] - s[x1 - <span class="hljs-number">1</span>][y2] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//想要的矩阵之内的所有数之和</span><br></code></pre></td></tr></table></figure><h3 id="3、一维差分"><a href="#3、一维差分" class="headerlink" title="3、一维差分"></a>3、一维差分</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​用于给某个区间快速地加上或者减去某个数。</p></blockquote><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）构造差分数组<br>    （1.1）将差分数组看作原本都是0，a[i]是原数组，b[i]是差分数组<br>    （1.2）然后将原数组中的每一个数，都插入到差分数组中，<br>        b[l] +&#x3D; c, &#x2F;&#x2F;a[l]后的数都会+c<br>        b[r + 1] -&#x3D; c; &#x2F;&#x2F;a[r + 1]后的数都会-c，【补丁】<br>        最后达到的效果就是a[l] ~a[r]之间的每一个数都加上了c<br>（2）然后根据题目要求在差分数组中指定区间中的每一个数都加上一个数，即在差分数组中的该区域中插入该数<br>（3）将差分数组还原成原数组（前缀和数组）输出即可 b[i] +&#x3D; b[i - 1];</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);   <span class="hljs-comment">//输入原数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">insert</span>(i, i, a[i]);   <span class="hljs-comment">//将原数组变成差分数组，此时原数组为该数组的前缀和数组</span><br><br><span class="hljs-comment">//给区间[l, r]上的数都加上c</span><br><span class="hljs-built_in">insert</span>(l, r, c);    <span class="hljs-comment">//将差分数组的第l个，加上c，后续在还原原数组的时候，后续到r的数，都会加上c</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) b[i] += b[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//将差分数组还原成原数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i]);  <span class="hljs-comment">//输出原数组</span><br></code></pre></td></tr></table></figure><h3 id="4、二维差分"><a href="#4、二维差分" class="headerlink" title="4、二维差分"></a>4、二维差分</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​快速地将一个矩阵中所有数全部加上或者减去一个数，并求出多次操作后的结果。</p></blockquote><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）差分矩阵的构造：<br>    （1.1）将差分数组看作全部都是0，将原数组中的数处理后，一个一个插入到差分数组中<br>    （1.2）先全部上c，再将不需要加上c的地方进行补丁，即减去c<br>        b[x1][y1] +&#x3D; c;  &#x2F;&#x2F;以(x1, y1)为左上角顶点的所有矩阵中的元素全部加上了c这个数<br>        b[x2 + 1][y1] -&#x3D; c; &#x2F;&#x2F;以(x2 + 1, y1)为左上角顶点的所有矩阵中的元素全部减去了c这个数<br>        b[x1][y2 + 1] -&#x3D; c; &#x2F;&#x2F;以(x1, y2 + 1)为左上角顶点的所有矩阵中的元素全部减去了c这个数<br>        b[x2 + 1][y2 + 1] +&#x3D; c; &#x2F;&#x2F;以(x2 + 1, y2 + 1)为左上角顶点的所有矩阵中的元素加上c这个数，前面多减了一次<br>（2）然后根据题目要求在差分数组中指定区间中的每一个数都加上一个数，即在差分数组中的该区域中插入该数<br>（3）将差分数组还原成原数组（前缀和数组）输出即可<br>    b[i][j] +&#x3D; b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1];</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span>  <span class="hljs-comment">//初始化差分数组</span></span><br><span class="hljs-function"></span>&#123;<br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)   <span class="hljs-comment">//读取原数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>     <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);    <span class="hljs-comment">//初始化差分数组</span><br>            <br><span class="hljs-comment">//将点(x1, y1)与点(x2, y2)形成的矩阵的所有数都加上c</span><br><span class="hljs-built_in">insert</span>(x1, y1, x2, y2, c);  <span class="hljs-comment">//进行插入数字的操作 </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            b[i][j] += b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]; <span class="hljs-comment">//将差分数组还原成原数组，即还原成前缀和数组</span><br>            <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i][j]);    <span class="hljs-comment">//输出还原后的数组即可            </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度算法</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法<span id="more"></span></h2><h3 id="1、高精度加法"><a href="#1、高精度加法" class="headerlink" title="1、高精度加法"></a>1、高精度加法</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>求两个大正整数相加的和。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​（1）用可变长数组vectorA，B存储</p><p>​（2）将输入的大数用字符串a，b读入，并逆序存入A，B</p><p>​（3）进行套用高精度模板</p><p>​（4）最后逆序输出答案即可</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">Add</span>(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, C[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>最后可能会存在一位进位，需要特判，若存在直接push进答案最后即可</p></blockquote><h3 id="2、高精度减法"><a href="#2、高精度减法" class="headerlink" title="2、高精度减法"></a>2、高精度减法</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​求两个大正整数A，B的差。</p></blockquote><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>高精度减法：大数A - 大数B<br>（1）用可变长数组vector存储A，B<br>（2）将字符串a、b逆序存入数组A、B中<br>（3）为了计算方便，我们再计算之前先保证较大的数减去较小的数，即我们要先判读出A、B谁大<br>    （3.1）自定一个比较大小的cmp函数，用于返回若 A &gt; B,返回true，反之返回false<br>    （3.2）cmp函数的构造分为两种情况    位数相同 和  位数不同<br>    （3.3）位数不同：肯定是位数长的数大<br>    （3.4）位数相同，我们就需要从后向前遍历两个数组（因为我们已经逆序存储了），<br>    找到第一个不相同的数进行比较，谁大，说明该数组表示的数大<br>（4）高精度减法的构造<br>    （4.1）定义一个答案数组和临时变量t（存放借位）<br>    （4.2）从前到后遍历较大数组（因为是逆序存储，所以原本低位相减变成了现在的前面的数相减）：<br>    （4.3）每一次遍历，先让较大的数减去借位，然后再减去较小的数中（需要判读较小的数是否还剩于）<br>    （4.4）因为有可能相减为负数，这里利用一个技巧直接将(t + 10) % 10的结果加入答案末尾即可，这里保证了加入的一定是相减结果的绝对值<br>    （4.5）更新借位，<br>        如果t为负数，说明在相减的时候，借位了，让 t &#x3D; 1，表示借了一位，保留到下一次计算进行减去<br>        如果t为正数，说明在相减的时候，没有借位，让借位置零即可<br>    （4.6）最后再进行去前导0即可<br>        如果答案的长度大于1，且答案最后有0，就将0弹出即可<br>（5）最后逆序输出答案即可</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (A[i] != B[i]) <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(A, B)) C = <span class="hljs-built_in">sub</span>(A, B);<br>    <span class="hljs-keyword">else</span> C = <span class="hljs-built_in">sub</span>(B, A), cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) cout &lt;&lt; C[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）首先一定要保证是用大于减小数，故需要实现一个cmp函数</p><p>​（2）其次由于保证了是大数减小数，故不存在剩一位的情况，一定能减得下，故一定会被存进答案里</p><p>​（3）由于高位在后，低位在前，故有可能存在前导零，故需要取前导零。</p></blockquote><h3 id="3、高精度乘法"><a href="#3、高精度乘法" class="headerlink" title="3、高精度乘法"></a>3、高精度乘法</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​求一个大正整数与一个数的乘积。</p></blockquote><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）用可变长数组vector存储A</p><p>（2）将字符串a逆序存入数组A中<br>（3）高精度乘法的构造：<br>    （3.1）定义一个答案数组，并且初始化进位t<br>    （3.2）从头到尾遍历大数A，<br>    （3.3）将每一位与b的乘积的计算结果放入t中<br>    （3.4）将t % 10的结果放入答案数组的末尾<br>    （3.5）更新进位t<br>    （3.6）看进位t是否还有数，如果还有，就在答案数组末尾加入该数<br>    （3.7）去前导0<br>（4）逆序输出答案数组即可</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) cout &lt;&lt; C[i];<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）由于可能最后的答案可能为0，故需要去除前导零的情况。</p><p>​（2）由于可能最后一位计算后大于了10，还没有进位，故需要判断是否还有剩位，有则直接放在答案末尾即可。</p></blockquote><h3 id="4、高精度除法"><a href="#4、高精度除法" class="headerlink" title="4、高精度除法"></a>4、高精度除法</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​求一个一个非负大整数A与一个整数b的商和余数。</p></blockquote><h5 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>高精度除法：大数A &#x2F; 小数b<br>（1）用可变长数组vector存储A<br>（2）将字符串a逆序存入数组A中<br>（3）构造高精度除法<br>    （3.1）定义答案数组，以及初始化余数t，由于余数最后要输出， 可以定义成全局变量<br>    （3.2）从后往前遍历大数（大数是逆序存储到数组的，但这里除法需要从高位开始计算，所以从最后一位即大数的高位开始）<br>    （3.3）每一位数 + 余数 * 10 ，进行计算<br>    （3.4）将上一步的结果 除 b 的结果放入答案数组<br>    （3.5）最后更新余数 t %&#x3D; b<br>    （3.6）将答案数组翻转，因为最后的输出是逆序输出的<br>    （3.7）去前导0<br>（4）逆序输出答案数组即可</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>    &#123;<br>        t = A[i] + t * <span class="hljs-number">10</span>;<br>        C.<span class="hljs-built_in">push_back</span>(t / b);<br>        t %= b;<br>    &#125;<br><br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) cout &lt;&lt; C[i];<br>    cout &lt;&lt; endl &lt;&lt; t;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）由于做除法只能从高位做，且模板都是逆序存，逆序输出，为了统一模板，则在除法模板中写的有些复杂</p><p>​（2）除法模板与其他模板不同，需要逆序逐位除，即高位往低位算</p><p>​（3）算出来之后，由于我们需要逆序输出，故我们要将求出来的答案用reverse进行翻转</p><p>​（4）然后由于可能前几位除不下，故需要进行去前导零。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找<span id="more"></span></h2><h3 id="1、整数二分："><a href="#1、整数二分：" class="headerlink" title="1、整数二分："></a>1、整数二分：</h3><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (l &lt; r)       <span class="hljs-comment">//当l &gt;= r 时，遍历结束，停止循环</span><br>&#123;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;   <span class="hljs-comment">//check函数 当这个点，大于等于x，说明答案在左边，从右边缩小范围</span><br><span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">//反之，答案在右边，从左边缩小范围</span><br>&#125;<br><br> <span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br><span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;   <span class="hljs-comment">//check函数，当这个点，小于等于x时，答案在右边，从左边缩小范围</span><br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;   <span class="hljs-comment">//反之，答案在左边，从右边缩小范围</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、小数二分"><a href="#2、小数二分" class="headerlink" title="2、小数二分"></a>2、小数二分</h3><h5 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> eps; <span class="hljs-comment">//一般比题目要求多两位</span><br><br><span class="hljs-keyword">while</span> (r - l &gt; eps)  <span class="hljs-comment">//只要 r - l 不小于该大小，就不断进行二分，找值</span><br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid * mid &gt;= n) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序<span id="more"></span></h2><h3 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h3><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）定义出口<br>（2）选取一个随机点，以及确定左右边界<br>（3）i，j两个指针从左右两个边界向中间移动<br>    （3.1）左指针找到需要交换的值（大于参考点的值），就停下来<br>    （3.2）右指针找到需要交换的值（小于参考点的值），就停下来<br>    （3.3）当两个指针都停下来，且i指针在j指针左边时，交换两个值<br>（4）递归将每一个部分都进行同样的操作，直至细分到最小时，就满足了整个区间从左到右有序排列</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//边界条件 </span><br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;                         <span class="hljs-comment">//当左指针大于等于右指针说明两指针已经遍历了全部数据 </span><br>    <span class="hljs-comment">//确定分界点 </span><br>    <span class="hljs-type">int</span> x=q[l+r&gt;&gt;<span class="hljs-number">1</span>], i= l - <span class="hljs-number">1</span> ,j = r + <span class="hljs-number">1</span>;        <span class="hljs-comment">//随机选取一个数据中的值作为参考值  用i,j表示左右指针，但注意定义时，需要定义在数据外围外 </span><br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++ ; <span class="hljs-keyword">while</span>(q[i]&lt;x);          <span class="hljs-comment">//直到找到第一个不小于参考值x的值，左指针停止 ， 否则左指针不断后移 </span><br>        <span class="hljs-keyword">do</span> j-- ; <span class="hljs-keyword">while</span>(q[j]&gt;x);          <span class="hljs-comment">//直到找到第一个不大于参考值x的值，右指针停止 ， 否则右指针不断左移 </span><br>        <span class="hljs-keyword">if</span>(i &lt; j)<span class="hljs-built_in">swap</span>(q[i],q[j]);        <span class="hljs-comment">//当左右指针都停下，则说明两指针都找到了需要交换的值，则交换两值 </span><br>    &#125;<br><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);                 <span class="hljs-comment">//将左边部分作为一个新串传入， </span><br>    <span class="hljs-built_in">quick_sort</span>(q, j+<span class="hljs-number">1</span>, r);               <span class="hljs-comment">//将右边部分作为一个新串传入， </span><br>    <span class="hljs-comment">//经过上面的递归则可以完成整个数据的排序 </span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h3><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）定义出口 l &gt;&#x3D; r<br>（2）先确定中间点，然后进行左右区间的递归，此时返回的序列为两个有序序列<br>（3）定义左右两个序列的开头<br>（4）同时遍历左右两个序列，每次将两个序列中最小的值拿出来，放到答案里（由于此时两个序列都是有序序列，所以只需要比较两个序列的开头就行了）<br>（5）判断两个序列是否还有元素没有加入，有则直接全部加入即可<br>（6）最后将排好序的数组重新赋值给原数组即可</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;     <span class="hljs-comment">//出口</span><br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;     <span class="hljs-comment">//确定分界点</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;  <span class="hljs-comment">//用于计算存到了多少个了</span><br><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);       <span class="hljs-comment">//将序列递归成两个有序序列</span><br><br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>;     <span class="hljs-comment">//定义左右序列的开头</span><br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)  <span class="hljs-comment">//判断两个序列是否有一个序列已经遍历完成</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) temp[k ++] = q[i++];<br>        <span class="hljs-keyword">else</span> temp[k ++] = q[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k ++] = q[i++];   <span class="hljs-comment">//将剩余序列的元素直接加入</span><br>    <span class="hljs-keyword">while</span> (j &lt;= r) temp[k ++] = q[j++];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) q[i] = temp[j]; <span class="hljs-comment">//将数组复原</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2023/04/05/%E6%9D%82%E7%B1%BB/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/04/05/%E6%9D%82%E7%B1%BB/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="n进制下的数s转换为m"><a href="#n进制下的数s转换为m" class="headerlink" title="n进制下的数s转换为m"></a>n进制下的数s转换为m<span id="more"></span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span> <span class="hljs-comment">//字符转数字</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;B&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;C&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;D&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;E&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;F&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(a - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">11</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">14</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;E&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">15</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;F&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">char</span> (a + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, m, p = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;   <span class="hljs-comment">//p为当前位次（百位，千位，万位等。）</span><br>    string s, res = <span class="hljs-string">&quot;&quot;</span>;<br><br>    cin &gt;&gt; n &gt;&gt; s &gt;&gt; m; <span class="hljs-comment">//前进制，数，后进制</span><br><br>    <span class="hljs-comment">//从低位到高位，将字符转换为数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>    &#123;<br>        sum += <span class="hljs-built_in">fun1</span>(s[i]) * p ;   <span class="hljs-comment">//当前位等于转为为数字之后，乘上当前位次</span><br>        p *= n; <span class="hljs-comment">//更新位次</span><br>    &#125;<br>    <span class="hljs-comment">//因为可能存在16进制，将当前数转换为字符串输出</span><br>    <span class="hljs-keyword">while</span> (sum != <span class="hljs-number">0</span>)<br>    &#123;<br>        res = <span class="hljs-built_in">fun2</span>(sum % m) + res;   <span class="hljs-comment">//由低位向高位逐级求出，然后放入答案</span><br>        sum /= m; <span class="hljs-comment">//更新数字</span><br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>杂类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP<span id="more"></span></h2><h3 id="1、石子合并："><a href="#1、石子合并：" class="headerlink" title="1、石子合并："></a>1、石子合并：</h3><blockquote><p>​每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。</p><p>​每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>​问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>核心思路：从小区间逐步扩展区间，最后得到整个区间的最优解</p><p>（1）区间长度从小到大枚举</p><p>（2）每种长度都进行所有起点的枚举<br>（3）将区间(l, r)合并所需要的代价初始化为无穷大<br>（4）然后对该区间进行状态转移，每次都拿出最后一个状态，进行比较</p></blockquote><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; s[i];  <span class="hljs-comment">//读入数组</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] += s[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//求其前缀和</span><br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++) <span class="hljs-comment">//枚举长度</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i ++) <span class="hljs-comment">//从前到后，枚举不同长度下，给左边区域和右边区域分配不同数量是的代价，求最小值</span><br>       &#123;<br>           <span class="hljs-type">int</span> l = i, r = i + len - <span class="hljs-number">1</span>; <span class="hljs-comment">//以当前位置为左边部分（只有一个数），剩余部分都是右边部分</span><br>           f[l][r] = <span class="hljs-number">1e8</span>;  <span class="hljs-comment">//先将所有从第l堆石子到第r堆石子合并到一堆石子的代价置为无穷</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l; k &lt; r; k ++)    <span class="hljs-comment">//逐渐将右边的数拿给左边求代价，右边至少留一个</span><br>               f[l][r] = <span class="hljs-built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="hljs-number">1</span>][r] + s[r] - s[l - <span class="hljs-number">1</span>]);<br>       &#125;<br><br>   <span class="hljs-comment">//所有将第1堆石子到第n堆石子合并的所有方式的代价最小值</span><br>   cout &lt;&lt; f[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h5 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h5><blockquote><p>​区间合并的问题，通用的一个模板：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;         <span class="hljs-comment">// 区间长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123; <span class="hljs-comment">// 枚举起点</span><br>        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 区间终点</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            dp[i][j] = 初始值<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;        <span class="hljs-comment">// 枚举分割点，构造状态转移方程</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性DP</title>
    <link href="/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP<span id="more"></span></h2><h3 id="1、数字三角形模型"><a href="#1、数字三角形模型" class="headerlink" title="1、数字三角形模型"></a>1、数字三角形模型</h3><h5 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h5><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​从某个顶点出发，走到最底层或者最底层的某个点，求该路径的数字和的最大值。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>状态表示：f[i][j]<br>集合：所有从起点走到(i, j)的路径<br>属性：MAX</p><p>集合划分：以最后一个点是由左上方来的，还是右上方来的进行划分。</p><p>状态转移方程：f[i][j] &#x3D; max(f[i - 1][j - 1], f[i - 1][j]) + g[i][j];</p></blockquote><p><img src="/images/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt="数字三角形"></p><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n + <span class="hljs-number">1</span>; j ++)<br>            f[i][j] = <span class="hljs-number">-2e9</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]) + g[i][j];<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​在这里DP问题时，初始化需要特别注意。</p><p>​这里的初始化有两种，目的都是为了处理负数的情况：</p><p>​（1）第一种是按照模板那样写</p><p>​（2）第二种是，直接用memset函数，将f数组全部设置为-INF，memset(f, -0x3f, sizeof g);</p><p>​此时需要将特判第一个点，将起点赋值为f[1][1] &#x3D; g[1][1]，并在循环里从第二行开始处理，即跳过已经处理过的起点</p></blockquote><h5 id="拓展1："><a href="#拓展1：" class="headerlink" title="拓展1："></a>拓展1：</h5><blockquote><p>​若地图是一个矩形，且求的是最小值，题目见</p><p>[最低通行费]: <a href="https://www.acwing.com/problem/content/1020/">https://www.acwing.com/problem/content/1020/</a>“ “</p></blockquote><h6 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h6><blockquote><p>​初始化时由于我们发现第一排只能是从左到右更新，第一列只能是从上到下更新，故需要特判，具体见下述代码。但我们发现这样会导致起点无法遍历，故需要直接单独处理起点。</p></blockquote><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + g[i][j], f[i][j]);<br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][j - <span class="hljs-number">1</span>] + g[i][j]);<br>            &#125;<br></code></pre></td></tr></table></figure><h5 id="拓展2："><a href="#拓展2：" class="headerlink" title="拓展2："></a>拓展2：</h5><blockquote><p>​若整个地图走了两遍，该如何处理？例题，见</p><p>[方格取数]: <a href="https://www.acwing.com/problem/content/1029/">https://www.acwing.com/problem/content/1029/</a>“ “</p><p>​题目类似的还有</p><p>[传纸条]: <a href="https://www.acwing.com/problem/content/277/">https://www.acwing.com/problem/content/277/</a>“传纸条”</p></blockquote><h6 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h6><blockquote><p>​只走一次：</p><p>​f[i][j]表示所有从(1,1)走到(i,j)的路径的最大值</p><p>​f[i][j] &#x3D; max(f[i - 1][j], f[i][j - 1]) + w[i][j]；</p><p>​走两次：</p><p>​f[i1,j1,i2,j2]表示所有从(1,1),(1,1)分别走到(i1,j1),(i2,j2)路径的最大值。</p><p>​如何处理“同一个格子不能被重复选择”？<br>​    分析后发现，只有当i1 + j1 &#x3D;&#x3D; i2 + j2时，两条路径的格子才可能重合，<br>​    于是可以根据这条性质将思维优化成三维，</p><p>​集合：f[k,i1,i2]表示所有从(1,1),(1,1)走到(i1,k-i1),(i2,k-i2)的路径的最大值<br>   ​ k表示两条路线当前走到的格子的横纵坐标之和</p><p>​属性：max</p><p>​状态计算：<br>​    以最后一步是从往下走还是往右走进行划分，因为有两次走法，所以被分成了四种情况<br>​        下下、下右、右下、右右</p></blockquote><h6 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= n + n; k ++)   <span class="hljs-comment">//枚举横纵坐标之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++)    <span class="hljs-comment">//枚举第一次走的横坐标</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++)    <span class="hljs-comment">//枚举第二次走的横坐标</span><br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;   <span class="hljs-comment">//计算出两次走的纵坐标</span><br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= n)<br>                &#123;<br>                    <span class="hljs-type">int</span> t = g[i1][j1];  <span class="hljs-comment">//如果两个坐标相等，只加一次，因为第二次走这里，已经被拿走清空了</span><br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += g[i2][j2];   <span class="hljs-comment">//坐标不相同，就两个位置全加上</span><br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>] + t);   <span class="hljs-comment">//下 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2] + t);       <span class="hljs-comment">//下 右</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>] + t);       <span class="hljs-comment">//右 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2] + t);            <span class="hljs-comment">//右 右</span><br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h6 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h6><blockquote><p>（1）为什么下面四个状态转移方程能代表四种状态？</p><p>​原因是，因为k 变小了1，先不看最后一步，如果i变小1，则j就不用变；如果i没有变，则j就需要变小1；</p><p>​上述两种情况刚好对应了最后一步是向下、右走，的横纵坐标变化情况，又因为是两次一起走，故有四种情况。</p><p>​x &#x3D; max(x, f[k - 1][i1 - 1][i2 - 1] + t);   &#x2F;&#x2F;下 下<br>​x &#x3D; max(x, f[k - 1][i1 - 1][i2] + t);       &#x2F;&#x2F;下 右<br>​x &#x3D; max(x, f[k - 1][i1][i2 - 1] + t);       &#x2F;&#x2F;右 下<br>​x &#x3D; max(x, f[k - 1][i1][i2] + t);            &#x2F;&#x2F;右 右</p><p>​（2）在开数组的时候，第一维即横纵坐标之和一定要开数据范围的两倍</p></blockquote><h3 id="2、最短编辑距离"><a href="#2、最短编辑距离" class="headerlink" title="2、最短编辑距离"></a>2、最短编辑距离</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​对一个字符串A进行和删除、插入、替换的操作，使得A字符串与给定的B字符串相等，求最少的操作次数。</p></blockquote><h5 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​根据最后一步操作的不同进行分析：<br>​（1）删掉ai后，a与b一模一样，则需要满足a的1 ~ i - 1个字母与b的1 ~ j个字母匹配才能满足，所以先去掉最后一步，去找a的1 ~ i - 1变成b的1 ~ j - 1个字母匹配所需要的步数的最小值f[i - 1][j] + 1<br>​（2）增加一个字母，a与b一模一样，则需要满足增加之前，a的1 ~ i个字母与b的 1 ~ j - 1个字母匹配f[i][j - 1] + 1<br>​（3）改掉ai后，a与b一模一样，则需要满足的是a的1 ~ i - 1个字母与b的 1 ~ j - 1个字母匹配才行，这里分为两种情况，<br>​一种是ai与bi一样，不需要改，步数不用增加f[i - 1][j - 1],<br>​一种是ai与bi不一样，需要改，步数需要增加f[i - 1][j - 1] + 1;</p><p>​需要初始化的两种边界情况：<br>​（1）a的前0个字母去匹配b的前j个字母时，只能通过增加的方式，且增加的步数为b的前j个字母的长度<br>​（2）a的前i个字母去匹配b的前0个字母时，只能通过删除的方式，且删除的步数为a的前i个字母的长度</p><p>​集合：f[i][j]，将第一个子串前i个字符与第二个字串前j个字符变成一样的操作方法<br>​属性：min</p><p>​集合划分：删除、插入、替换三种不同操作<br>​状态计算：<br>​（1）删除：需要a[1<del>i - 1] &#x3D; b[1</del>j]<br>​（2）插入：需要a[1<del>i] &#x3D; b[1</del>j-1]<br>​（3）替换：需要a[1<del>i-1] &#x3D; b[1</del>j-1]</p></blockquote><p><img src="/images/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.png" alt="编辑距离"></p><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++) f[<span class="hljs-number">0</span>][i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) f[i][<span class="hljs-number">0</span>] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>        &#123;<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);    <span class="hljs-comment">//删和增</span><br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//改</span><br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​由于做dp需要涉及 i - 1 和 j - 1，故字符串的下标需要从1开始</p></blockquote><h3 id="3、最长上升子序列模型"><a href="#3、最长上升子序列模型" class="headerlink" title="3、最长上升子序列模型"></a>3、最长上升子序列模型</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。</p></blockquote><h5 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>集合：f[i]表示所有以数字i结尾的上升子序列的集合<br>属性：max</p><p>状态划分：以倒数第二个数为1，2，3，4，，，，i - 1进行划分<br>只要倒数第二个数满足条件：a[j] &lt; a[i]，则可以用下面的状态方程进行转移<br>f[i] &#x3D; max(f[i], f[j] + 1);</p></blockquote><p><img src="/images/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="最长上升子序列模型"></p><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j ++)<br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[i]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>        res = <span class="hljs-built_in">max</span>(f[i], res);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）if (a[j] &lt; a[i])    &#x2F;&#x2F;用前面已经算好的最长上升序列更新第i个值的最长上升子序列，所以需要满足a[j]&lt;a[i]，只要满足该条件，就说明目前的最长上升子序列为a[j]+1或者f[i]，f[i]指之前算出过的该点的最长上升子序列。</p><p>​（2）关于为什么要初始化f[i] &#x3D; 1？</p><p>​有一个边界，若前面没有比i小的，f[i]为1（自己为结尾）</p></blockquote><p>​</p><h3 id="4、最长公共子序列"><a href="#4、最长公共子序列" class="headerlink" title="4、最长公共子序列"></a>4、最长公共子序列</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B的子序列的字符串长度最长是多少。</p></blockquote><h5 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>集合f[i][j]:表示所有在第一个序列前i个字母中出现，且在第二个序列前j个字母中出现的子序列<br>集合划分：以a[i],b[j]是否出现在子序列中划分<br>（1）00：都没有出现，f[i - 1][j - 1]<br>（2）01：a[i]没有出现，b[j]出现，由于直接求不好求，这里用f[i - 1][j]进行替代<br>（3）10：a[i]出现，b[j]没有出现，由于直接求不好求，这里用f[i][j - 1]进行替代<br>（4）11：a[i]、b[j]都出现，f[i - 1][j - 1] + 1</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>        &#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（2）、（3）步中的替代是不影响最终结果的：（2）中因为f[i - 1][j]表示所有在第一个序列中前i - 1个字母中出现，且在第二个序列前j个字母中出现的子序列，这里包含了a[i]不出现，b[j]出现的情况，虽然有部分重复，但由于我们求的是最大值，即使重复求，也不会影响我们所求的最大值，（3）同理。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推公式</title>
    <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%A8%E5%85%AC%E5%BC%8F/"/>
    <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%A8%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式<span id="more"></span></h2><h3 id="1、耍杂技的牛"><a href="#1、耍杂技的牛" class="headerlink" title="1、耍杂技的牛"></a>1、耍杂技的牛</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​有N头牛，每头牛都有自己的 重量W 和强壮程度 S，奶牛们站在彼此的身上，形成一个高高的垂直堆叠，一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>​您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​按照wi + si从小到大排序，最大的危险系数一定是最小的。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> w, s;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);<br>        cow[i] = &#123;s + w, w&#125;;<br>    &#125;<br><br><span class="hljs-built_in">sort</span>(cow, cow + n);<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">-2e9</span>, sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br>    <span class="hljs-comment">//取出当前牛的重量和强壮值</span><br>    <span class="hljs-type">int</span> w = cow[i].second, s = cow[i].first - w;<br>    res = <span class="hljs-built_in">max</span>(res, sum - s);    <span class="hljs-comment">//更新最大的危险系数</span><br>    sum += w;   <span class="hljs-comment">//更新后一头牛所需要承担的重量</span><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绝对值不等式</title>
    <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式<span id="more"></span></h2><h3 id="1、货舱选址："><a href="#1、货舱选址：" class="headerlink" title="1、货舱选址："></a>1、货舱选址：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​在数轴上建立一家货仓，每天清晨，从货仓到数轴上每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​仓库建立在所有商家的中间，即数轴的中位数。即只需要进行排序然后分别求出每个店家与所有店家中位数的距离相加即答案。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<br><span class="hljs-built_in">sort</span>(a, a + n);<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) res += <span class="hljs-built_in">abs</span>(a[i] - a[n / <span class="hljs-number">2</span>]);<br><br>cout &lt;&lt; res;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​数组下标从0或者1开始，与其对应的中位数索引不同。</p><p>​（1）下标从0开始：中位数a[n &#x2F; 2 + 1]</p><p>​（2）下标从1开始：中位数a[n &#x2F; 2]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序不等式</title>
    <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式<span id="more"></span></h2><h3 id="1、排队打水："><a href="#1、排队打水：" class="headerlink" title="1、排队打水："></a>1、排队打水：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​有n个人排队到1个水龙头打水，第i个人装满水桶所需要的时间是t，如何安排他们的打水顺序，才能使所有人等待的时间之和最小？</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​按照打水时间从小到大排序即可，总时间最小</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<span class="hljs-comment">//读入</span><br><br><span class="hljs-built_in">sort</span>(a, a + n);<span class="hljs-comment">//排序</span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span>  res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br>    res += a[i] * (n - i - <span class="hljs-number">1</span>); <span class="hljs-comment">//每次打水，后面都会有 n - i - 1个人等他</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Huffman树</title>
    <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/Huffman%E6%A0%91/"/>
    <url>/2023/04/04/%E8%B4%AA%E5%BF%83/Huffman%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树<span id="more"></span></h2><h3 id="1、合并果子："><a href="#1、合并果子：" class="headerlink" title="1、合并果子："></a>1、合并果子：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​将若干堆果子合并到一堆，每次可以将任意两堆进行合并。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​每次选取最少的两堆进行合并即可，采用优先队列，即小根堆进行存储所有果子。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap; <span class="hljs-comment">//小根堆定义</span><br>    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    heap.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">//入堆</span><br>&#125;<br><br><span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-type">int</span> a = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//取出堆顶并剔除</span><br>    <span class="hljs-type">int</span> b = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>    res += a + b;<br>        <br>    heap.<span class="hljs-built_in">push</span>(a + b);<span class="hljs-comment">//将合并得到的新堆加入堆中</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​很容易忽略的一点是，没有将合并得到的新堆加入堆中。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间贪心</title>
    <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/"/>
    <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="四种区间贪心问题"><a href="#四种区间贪心问题" class="headerlink" title="四种区间贪心问题"></a>四种区间贪心问题<span id="more"></span></h2><h3 id="1、区间选点"><a href="#1、区间选点" class="headerlink" title="1、区间选点"></a>1、区间选点</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>   给定 N 个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。<br>   输出选择的点的最小数量。</p></blockquote><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​（1）定义一个pair&lt;int, int&gt;类型的数组，进行所有区间的维护，将所有区间按右端点从小到大进行排序<br>​（2）从前往后遍历所有区间，如果当前区间与后一个区间没有交集（即后一个区间的左端点大于前一个区间的右端点），相当于把有交集的区间用一个点进行替代，然后答案 ++，更新新区间的右端点<br>​（3）有交集则不用进行任何处理，因为右端点是按照从小到大进行排序的，我们正需要保证右端点是最小的，故当前枚举到的区间右端点就是最小的</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//区间维护</span><br>   PII e[N];<br><br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span> <span class="hljs-comment">//自定义右端点排序</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>   &#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<span class="hljs-comment">//输入区间</span><br>   <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n, cmp);<span class="hljs-comment">//排序</span><br>   <br>   <span class="hljs-type">int</span> ed = <span class="hljs-number">-0x3f3f3f3f</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<span class="hljs-comment">//进行枚举</span><br>   &#123;<br>       <span class="hljs-keyword">if</span> (e[i].x &gt; ed) res ++, ed = e[i].y;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​在区间有交集的时候，一定不要更新右端点了，因为我们需要的就是选定区间中的最小右端点，这与我们按照右端点进行从小到大排序是刚好符合的。</p></blockquote><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote><h3 id="2、最大不相交区间数量"><a href="#2、最大不相交区间数量" class="headerlink" title="2、最大不相交区间数量"></a>2、最大不相交区间数量</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定N个区间[a, b]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。输出可选取区间的最大数量。</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​将所有有交集的区间看作一个区间，因为每次只能选择有交集中的一个，故这样假设没有错，即我们在前往后枚举每个区间的时候，遇到有交集的区间就跳过，只需要在每次遇到没有交集的区间的时候进行统计，步骤如下：</p><p>（1）定义一个pair&lt;int, int&gt;类型的数组，进行所有区间的维护，将所有区间按右端点从小到大进行排序<br>（2）从前往后遍历所有区间，如果当前区间与后一个区间没有交集（即后一个区间的左端点大于前一个区间的右端点），相当于把有交集的区间看作一个区间，然后在遇到没有交集的区间时，答案 ++，更新新区间的右端点<br>（3）有交集则不用进行任何处理，因为我们将他们看作一个区间</p></blockquote><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//区间维护</span><br>   PII e[N];<br><br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span> <span class="hljs-comment">//自定义右端点排序</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>   &#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<span class="hljs-comment">//输入区间</span><br>   <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n, cmp);<span class="hljs-comment">//排序</span><br>   <br>   <span class="hljs-type">int</span> ed = <span class="hljs-number">-0x3f3f3f3f</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<span class="hljs-comment">//进行枚举</span><br>   &#123;<br>       <span class="hljs-keyword">if</span> (e[i].x &gt; ed) res ++, ed = e[i].y;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote><h3 id="3、区间分组"><a href="#3、区间分组" class="headerlink" title="3、区间分组"></a>3、区间分组</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>给定N个闭区间[a, b]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使组数尽可能小。</p></blockquote><h5 id="核心思路：-2"><a href="#核心思路：-2" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​我们需要思考，想要将当前区间加入到已有的集合中，则必选满足当前区间与某个集合中的所有区间都没有交集，即当前区间的左端点要大于某个集合的所有右端点，贪心一下，我们只需要维护一个小根堆，存入每个组的最大右端点，在判断能否加入当前组的时候，就与堆顶元素（所有组里最小的最大右区间）步骤如下：</p><p>​（1）先将所有区间按照左端点从小到大排序</p><p>​（2）从前往后处理每一个区间</p><p>​（3）判断是否能放入当前某一个组内：能放的条件是当前一个组都没有或者现有的组中，存在一个组的最大右区间，可以用小根堆的堆顶元素作为边界，大于则可以放入现有组，小于等于则无法放入</p><p>​（4）存在这样的组，就把该区间放入组中，更新当前组的max_r</p><p>​（5）不存在这样的组，就重新创建一个组，将该区间放入</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br>PII e[N];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<br>    <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n);<br><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">empty</span>() || e[i].x &lt;= heap.<span class="hljs-built_in">top</span>()) heap.<span class="hljs-built_in">push</span>(e[i].y);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            heap.<span class="hljs-built_in">pop</span>();<br>            heap.<span class="hljs-built_in">push</span>(e[i].y);<br>        &#125;<br>    &#125;<br>cout &lt;&lt; heap.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>这里用小根堆（优先队列），进行维护每一个组的所有区间最大右区间，则堆顶就是所有组的最大右区间的最小值，<br>也就是一个新区间想要加入现有组的条件，即新区间的左端点要大于该条件</p></blockquote><h5 id="证明：-2"><a href="#证明：-2" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote><h3 id="4、区间覆盖"><a href="#4、区间覆盖" class="headerlink" title="4、区间覆盖"></a>4、区间覆盖</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定N个闭区间[a, b]以及一个线性区间[s, t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</p></blockquote><h5 id="核心思路：-3"><a href="#核心思路：-3" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​（1）按照左端点进行排序</p><p>​（2）用双指针算法线性扫描一下所有区间，每次扫描 找出 能覆盖还未覆盖的区间 的左端点的 所有区间中，右端点最大的区间，将start更新为其左端点。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br>PII e[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<span class="hljs-comment">//输入</span><br>    <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n, cmp);<span class="hljs-comment">//排序</span><br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">//答案</span><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//标志位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i, r = <span class="hljs-number">-2e9</span>;<span class="hljs-comment">//获取当前区间，即e[i] ~ ed</span><br>        <span class="hljs-keyword">while</span> (j &lt;= n &amp;&amp; e[j].x &lt;= st)<span class="hljs-comment">//双指针扫描</span><br>        &#123;<br>            r = <span class="hljs-built_in">max</span>(r, e[j].y);<br>            j ++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (r &lt; st) <span class="hljs-comment">//后面区间无法覆盖，提前结束</span><br>        &#123;<br>            res = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        res ++;<span class="hljs-comment">//可以覆盖，所用区间 ++</span><br>        <br>        <span class="hljs-keyword">if</span> (r &gt;= ed) <span class="hljs-comment">//完全覆盖，标志成功，结束扫描</span><br>        &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        st = r;<span class="hljs-comment">//更新未扫描区间</span><br>        <br>        i = j - <span class="hljs-number">1</span>;<span class="hljs-comment">//由于for循环中i ++,故这里i更新为需要扫描的点j的前一个点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!flag) res = <span class="hljs-number">-1</span>;<br>    cout &lt;&lt; res;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）需要注意的点是几个特判：如果更新后r &lt; st说明剩余区间没有一个区间能够覆盖剩余部分，直接结束扫描，反之则所用的区间 ++；<br>​（2）是当前区间的r &gt;&#x3D; ed，说明需要覆盖的区间已经完全覆盖，标志位设置为true，结束遍历即可。<br>​（3）最后根据标志位判断是否覆盖了全部区间。</p><p>（4）避免遍历重复的区间，但为什么是i &#x3D; j - 1，而不是i &#x3D; j，    因为前j个区间我们已经判断过了，需要判断第j个区间，    但由于for循环结束会i++，如果这里i &#x3D; j，再算上循环结束的i++，    下一次循环遍历的就会是第j + 1个区间，而导致跳过了第j个区间</p></blockquote><h5 id="证明：-3"><a href="#证明：-3" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2023/04/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/04/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="五种背包问题"><a href="#五种背包问题" class="headerlink" title="五种背包问题"></a>五种背包问题<span id="more"></span></h2><h3 id="1、01背包："><a href="#1、01背包：" class="headerlink" title="1、01背包："></a>1、01背包：</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><blockquote><p>从n个物品中选，每个物品只能选一次或者不选，总体积不超过m的情况下，<br>    求总价值最大。</p></blockquote><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​O(nm)</p><h5 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p>​    状态表示：f[i][j]，从前i个物品中选，其总体积不超过j的前提下，所有选法的总价值的最大值<br>​        属性：max<br>​        状态计算：以最后一个物品是否选择进行划分：<br>​        （1）不选：f[i][j] &#x3D; f[i - 1][j];<br>​        （2）选：if (j &gt;&#x3D; v[i]) f[i][j] &#x3D; max(f[i][j], f[i - 1][j - v[i]] + w[i])<br>​    求方案数时，注意是否需要初始化。<br>​        枚举体积一维的时候，注意是从1开始还是0开始，且枚举体积时由于每次用的是上一层的状态，故需要从后往前枚举。</p></blockquote><h5 id="状态转移方程："><a href="#状态转移方程：" class="headerlink" title="状态转移方程："></a>状态转移方程：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">f[i][j] = f[i - <span class="hljs-number">1</span>][j];  <span class="hljs-comment">//不含i的一定存在</span><br>           <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<span class="hljs-comment">//只有背包装的下第i个物品时，才存在这种情况</span><br></code></pre></td></tr></table></figure><h3 id="2、完全背包："><a href="#2、完全背包：" class="headerlink" title="2、完全背包："></a>2、完全背包：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>从n个物品中选，每个物品可以选无数次，总体积不超过m的情况下，求总价值的<br>    最大值。</p></blockquote><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>O(nm)</p></blockquote><h5 id="分析过程：-1"><a href="#分析过程：-1" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p>状态表示：f[i][j]，从前i个物品中选，其总体积不超过j的前提下，所有选法的总价值的最大值。<br>    属性：max<br>    状态计算：以最后一个物品是否选择划分：<br>    （1）不选：f[i][j] &#x3D; f[i - 1][j]<br>    （2）选：if (j &gt;&#x3D; v[i]) f[i][j] &#x3D; max(f[i][j], f[i][j - v[i]] + w[i]);（优化后的状态转移方程）</p><pre><code class="hljs">求方案数时，注意是否需要初始化。枚举体积一维的时候，注意是从1开始还是0开始，枚举体积时，由于每次用的是本层的状态，故需要从前往后枚举。</code></pre></blockquote><h5 id="状态转移方程：-1"><a href="#状态转移方程：-1" class="headerlink" title="状态转移方程："></a>状态转移方程：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - v[i]] + w[i]);<br></code></pre></td></tr></table></figure><h3 id="3、多重背包："><a href="#3、多重背包：" class="headerlink" title="3、多重背包："></a>3、多重背包：</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>从n个物品中选，每个物品只能选若干次，总体积不超过m的情况下，求总价值的<br>    最大值。</p></blockquote><h5 id="分析过程：-2"><a href="#分析过程：-2" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p> 状态表示：从前i个物品中选，其总体积不超过j的前提下，所有选法的总价值的最大值。<br>    属性：max<br>    状态计算：以最后一个物品是否选择划分：<br>    （1）不选：f[i][j] &#x3D; f[i - 1][j]<br>    （2）选：由于每个物品可以选k次，故需要另外加一层循环，枚举每个物品选几个。<br>        for (int k &#x3D; 0; k &lt;&#x3D; s[i]; k ++)  O(n^3)<br>            if (j &gt;&#x3D; k * v[i]) f[i][j] &#x3D; max(f[i][j], f[i - 1][j - k * v[i]] + w[i] * k);</p><pre><code class="hljs">二进制优化：O(nlogsm)    将每种物品的k个物品，根据二进制进行打包成新的物品，全部打包后看作01背包做即可，注意此时的物品数量就不再是n了，而需要重新计算，并且需要注意此时的空间可能会爆掉，需要优化成一维数组，在优化的时候，由于每次用到的是上一层的状态，故不能先更新前面的状态，否则会影响结果，故需要从大到小枚举体积。    这里开数组时，需要多开一些空间，因为重新打包，物品种类就大于了N</code></pre><p>最坏情况，每种物品都有2000个，1000个物品，就需要打包成log2 * 1000 &#x3D; 11000，再加上我们的数组下标是从1开始存的，所以数组空间至少要开11001；</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++">暴力解：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i]; k ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= v[i] * k) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i] * k] + w[i] * k);<br>            &#125;<br>二进制优化：     <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15000</span>;<br><br>    <span class="hljs-type">int</span> v[N], w[N];<br>    <span class="hljs-type">int</span> f[N];<br>    <span class="hljs-type">int</span> n, m;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-comment">//种数和容量</span><br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> a, b, s;    <span class="hljs-comment">//体积、价值、数量</span><br>            cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br><br>            <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt;= s)<br>            &#123;<br>                cnt ++;<br>                v[cnt] = a * k;<br>                w[cnt] = b * k;<br>                s -= k;<br>                k *= <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                cnt ++;<br>                v[cnt] = a * s;<br>                w[cnt] = b * s;<br>            &#125;<br>        &#125;<br><br>        n = cnt;        <span class="hljs-comment">//更新种数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)<br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>        cout &lt;&lt; f[m];<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4、分组背包："><a href="#4、分组背包：" class="headerlink" title="4、分组背包："></a>4、分组背包：</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>从n组物品中选，每组物品有若干个，同一组的物品只能选择一个，求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p></blockquote><h5 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(nms)</p></blockquote><h5 id="分析过程：-3"><a href="#分析过程：-3" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p>集合：从n组物品中选，每组物品有若干个，同一组的物品只能选择一个，在总体积不超过j的情况下，所有选法的价值的最大值。<br>    属性：max<br>    状态计算：以最后一个组是否选择划分：<br>    （1）不选，f[i][j] &#x3D; f[i - 1][j]<br>    （2）选，由于每组有k个物品，故需要枚举这k个物品<br>        for (int k &#x3D; 1; k &lt;&#x3D; cnt[i]; k ++)<br>            if (j &gt;&#x3D; v[i][k]) f[i][j] &#x3D; max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)   <span class="hljs-comment">//每组物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j --)  <span class="hljs-comment">//容量</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k ++) <span class="hljs-comment">//枚举所有的选择</span><br>                <span class="hljs-keyword">if</span> (v[i][k] &lt;= j)   <span class="hljs-comment">//只有当容量能装得下，才有选的必要</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br></code></pre></td></tr></table></figure><h3 id="5、混合背包："><a href="#5、混合背包：" class="headerlink" title="5、混合背包："></a>5、混合背包：</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>有 N 种物品和一个容量是 V 的背包。物品有三种，分别是01背包，完全背包，多重背包，求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p></blockquote><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><blockquote><p>01背包、完全背包、多重背包三种背包问题放在一起，在计算状态的时候，判断是哪种背包，就用哪种状态转移方程即可。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> v, w, s;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>)     <span class="hljs-comment">//完全背包</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v; j &lt;= m; j ++) f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">//01背包是特殊的多重背包可以一起写，01背包是每种物品只有1件的多重背包</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-number">-1</span>) s = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s; k *= <span class="hljs-number">2</span>) <span class="hljs-comment">//二进制优化多重背包，枚举几个物品分成一个新物品</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= k * v; j --)   <span class="hljs-comment">//枚举每个新物品的体积</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - k * v] + k * w);<br>                s -= k;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (s)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= s * v; j --)   <span class="hljs-comment">//将剩余不够分成新物品的物品，分成一组，枚举其体积</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - s * v] + s * w);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓扑排序</title>
    <link href="/2023/04/03/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/04/03/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序<span id="more"></span>：</h3><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    关键点就是将入度为0的点全部放入队列中，直到遍历完所有的点，如果队列中点的个数等于图中点的个数，<br>​    说明该图存在拓扑序列。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> res[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (d[i] == <span class="hljs-number">0</span>) <br>        &#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        res[ ++ cnt] = t;<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            d[j] --;<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) <br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">topsort</span>())<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, res[i]);<br>    &#125;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​    （1）找到入度为0的点作根节点<br>​    （2）一定要将所有入度为0的点加入队列<br>​    （3）最后需要进行判断是否所有点都入队了，是则存在拓扑序，反之不存在。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数 质因数 约数 公约数 快速幂</title>
    <link href="/2023/04/03/%E6%95%B0%E8%AE%BA/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/04/03/%E6%95%B0%E8%AE%BA/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="质数-质因数-约数-公约数-快速幂"><a href="#质数-质因数-约数-公约数-快速幂" class="headerlink" title="质数 质因数 约数 公约数 快速幂"></a>质数 质因数 约数 公约数 快速幂<span id="more"></span></h2><h3 id="1、质数的判定————试除法"><a href="#1、质数的判定————试除法" class="headerlink" title="1、质数的判定————试除法"></a>1、质数的判定————试除法</h3><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(sqrt(n))</p></blockquote><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    优化： | 表示整除，如果d | n，显然n &#x2F; d | n 一定成立，因为d的约数一定是成对出现的，而这一对就是d 和 n &#x2F; d，<br>故我们在枚举的时候，只需要枚举较小的那个就能判定当前这对是不是该数的约数，如下：<br>​    d &lt;&#x3D; n &#x2F; d， d ^ 2 &lt;&#x3D; n， d &lt;&#x3D; 根号n，就把上面的O(n)的复杂度降到了O(根号n)。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>在判断的时候，一定要记得特判小于2的所有数，都不是质数。</p></blockquote><h3 id="2、分解质因数："><a href="#2、分解质因数：" class="headerlink" title="2、分解质因数："></a>2、分解质因数：</h3><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O（sqrt(N)）</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​从小到大枚举所有数，即从小到大尝试n的所有质因数，并求其次数。</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= i;.<br>            s ++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>    &#125;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）、关于枚举时，为什么一定不会枚举到合数？<br>​    答： 当我们枚举到i时，就说明n当中，已经不包含任何2 ~ i - 1的质因子了，<br>​    然后n能整除i，说明i当中也不包含任何2 ~ i - 1的质因子了，因此i一定是一个质数<br>​（2）、n中最多只包含一个大于sqrt(n)的质因子，故在枚举时，可以先把所有小于sqrt(n)的质因子枚举出来，<br>​最后将大于sqrt(n)的质因子特判输出即可。————————这样时间复杂度就从O(n)降到了O(sqrt(n));</p></blockquote><h3 id="3、线性筛法：筛质数"><a href="#3、线性筛法：筛质数" class="headerlink" title="3、线性筛法：筛质数"></a>3、线性筛法：筛质数</h3><h5 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(n)</p></blockquote><h5 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路:"></a>核心思路:</h5><blockquote><p>​    核心：每一个数i，只会被其最小质因子筛掉。<br>​        分析：在筛掉时候，是从小到大枚举所有质数，每次把当前质数和i的乘积筛掉，当 i % primes[j] &#x3D;&#x3D; 0成立时，<br>​        说明primes[j] 一定是i的最小质因子，因为primes[j]是从小到大枚举的，且所有的质数都放在了primes里。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++)<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><blockquote><p>​    1、因为prime中素数是递增的，所以如果i%prime[j]!&#x3D;0代表i的最小质因数还没有找到，<br>​    即i的最小质因数大于prime[j]。也就是说prime[j]就是iprime[j]的最小质因数，于是iprime[j]被它的最小质因数筛掉了。</p><p>​    2、如果当i%prime[j]&#x3D;&#x3D;0时，代表i的最小质因数是prime[j]，<br>​    那么iprimej+k这个合数的最小质因数就不是prime[j+k]而是prime[j]了。<br>​    所以iprime[j+k]应该被prime[j]筛掉，而不是后续的prime[j+k]。于是在此时break。</p><p>​    3、对于一个合数x，假设primes[j]是x的最小质因子，当i枚举到x &#x2F; primes[j]时，i就会被筛掉，且一定是被其最小质因子筛掉的。</p></blockquote><h3 id="4、试除法求约数"><a href="#4、试除法求约数" class="headerlink" title="4、试除法求约数"></a>4、试除法求约数</h3><h5 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(sqrt(n))</p></blockquote><h5 id="核心思路：-2"><a href="#核心思路：-2" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​试除法求约数：<br>（1）i从1开始，遍历到n &#x2F; int<br>（2）每找到一个约数：<br>​    （2.1）就将它约数放入数组中，<br>​    （2.2）判断一个n &#x2F; i &#x3D;&#x3D; i，如果不相等，就把他放入数组中<br>（3）找完之后sort一下，即可获得从小到大的一个数的约数数组<br>​优化同质数，一个数的约数也是成对出现的，故在枚举时，直接枚举较小的约数即可，即i &lt;&#x3D; sqrt(n)</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>                <span class="hljs-keyword">if</span> (i != n / i) res.<span class="hljs-built_in">push_back</span>(n / i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、约数个数："><a href="#5、约数个数：" class="headerlink" title="5、约数个数："></a>5、约数个数：</h3><h5 id="核心思路：-3"><a href="#核心思路：-3" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    N &#x3D; p1 ^ a1 * p2 ^ a2 * … * pk ^ ak<br>​    则约数个数为cnt &#x3D; (a1 + 1)(a2 + 2)…(ak + 1)，证明：<br>​                                    N &#x3D; p1 ^ a1 * p2 ^ a2 * … * pk ^ ak<br>​    因为N的任意一个约数d，都可以写作d &#x3D; p1 ^ b1 * p2 ^ b2 * … * pk ^ bk, 0 &lt;&#x3D; bi &lt;&#x3D; ai，<br>​    pi每一项的指数b如果不同，则构成的约数就不同，故对于每一个pi都有(ai + 1)种情况，故约数个数就有(ai + 1)个。<br>​    而对于N来说，N的每一个约数，都对应了b1 ~ bk的不同取法，则选法种数即为约数个数，<br>​    故约数个数则为cnt &#x3D; (a1 + 1)(a2 + 1)…(ak + 1)</p><p>​    int范围内，约数个数最多的数只有1500~1600个。</p></blockquote><h5 id="代码模板：-4"><a href="#代码模板：-4" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br>    <span class="hljs-keyword">while</span> (n --)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++;<br>    &#125;<br>    res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> prime : primes) res = res * (prime.second + <span class="hljs-number">1</span> ) % mod;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​约数个数 &#x3D; 分解质因数后，（所有指数 + 1）相乘</p></blockquote><h3 id="6、约数之和"><a href="#6、约数之和" class="headerlink" title="6、约数之和"></a>6、约数之和</h3><h5 id="核心思路：-4"><a href="#核心思路：-4" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    N &#x3D; p1 ^ a1 * p2 ^ a2 * … * pk ^ ak<br>​    则约数之和为sum &#x3D; (p1 ^ 0 + p1 ^ 1 + … + p1 ^ a1) * … *(pk ^ 0 + pk ^ 1 + … + pk ^ ak)，证明：<br>​    用乘法分配律将上式展开，就是一堆乘积（） + 一堆乘积（） + （）…<br>​    而（）则是从上式括号中每一个括号中任取一项组成的，任意一堆乘积（）都是一个约数，<br>​    故这个公式就是将所有约数加在一起了。</p></blockquote><h5 id="代码模板：-5"><a href="#代码模板：-5" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><br>    <span class="hljs-keyword">while</span> (n --)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++;<br>    &#125;<br><br>    res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> prime : primes)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = prime.first, b = prime.second;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (b --) t = (t * a + <span class="hljs-number">1</span>) % mod;<br>        res = res * t % mod;<br><br>    &#125;<br>    cout &lt;&lt; res;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​约数之和 &#x3D; 因式分解后（所有幂的0~其指数次方之和）的乘积</p></blockquote><h3 id="7、最大公约数："><a href="#7、最大公约数：" class="headerlink" title="7、最大公约数："></a>7、最大公约数：</h3><h5 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路:"></a>核心思路:</h5><blockquote><p>​    d | a, d | b，则d | (a + b) &#x3D; d | ax + by，<br>​    (a, b)的最大公约数 &#x3D; (b, a % b) 的最大公约数。</p><p>​    证明：a mod b &#x3D; a - (a&#x2F;b) * b &#x3D; a - c * b<br>​    (a, b) &#x3D; (b, a - c * b)，d | a, d | b，所以d | (a - c * b)成立<br>​    d | b, d | a - c * b,则d | a - c * b + c * b，即d | a，所以右边的公约数 &#x3D; 左边的公约数，左边的公约数等于右边的公约数<br>​    故，(a, b) &#x3D; (b, a mod b)成立</p></blockquote><h5 id="代码模板：-6"><a href="#代码模板：-6" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、快速幂："><a href="#8、快速幂：" class="headerlink" title="8、快速幂："></a>8、快速幂：</h3><h5 id="核心思路：-5"><a href="#核心思路：-5" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>反复平方法。<br>    预处理出来一些值：a ^ (2 ^ 0) mod p, a ^ (2 ^ 1) mod p,,,a ^ (2 ^ logk) modp的值,共logk个，<br>    用这些值去组合出a ^ k<br>    a ^ k &#x3D; a ^ (2 ^ x1) * a ^ (2 ^ x2) … * a ^ (2 ^ xt)<br>      &#x3D; a ^ (2 ^ x1 + 2 ^ x2 + …2 ^ xt)，即把k拆分成2^x1,2^x2,,,2^xt这logk个数的和。<br>（1）拆k的方式：把k用二进制表示，把二进制数下是1的位，加上其所属幂位即可，<br>    例k的二进制表示为： 110110，k &#x3D; 2^1 + w^2 + 2^4 + 2^5，<br>（2）如何预处理出我们所需要的值：<br>    第一个数a^(2^0) &#x3D; a^1 &#x3D; a,后面每个数都是前面一个数的平方。</p></blockquote><h5 id="代码模板：-7"><a href="#代码模板：-7" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回的就是a^k % p</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL) res * a % p;  <span class="hljs-comment">//当前位是1，则前位更新到答案中</span><br>        k &gt;&gt;= <span class="hljs-number">1</span>;    <span class="hljs-comment">//算过的位删掉</span><br>        a = (LL) a * a % p;<span class="hljs-comment">//把a变成下一个</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​一定一定要注意每个运算的地方都要进行(long long)的转换，以及 取模%p</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础数学知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树问题</title>
    <link href="/2023/04/01/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <url>/2023/04/01/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="两种最小生成树的解决方法"><a href="#两种最小生成树的解决方法" class="headerlink" title="两种最小生成树的解决方法"></a>两种最小生成树的解决方法<span id="more"></span></h2><h3 id="1、Prim算法："><a href="#1、Prim算法：" class="headerlink" title="1、Prim算法："></a>1、Prim算法：</h3><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​稠密图O(n^2）</p><blockquote><p>​（1）朴素版： O(n^2) —– 邻接矩阵<br>​（2）堆优化版：被kruskal完爆（×）</p></blockquote><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    先从某一个点开始，逐渐把所有点与该点连接起来，每次连通的时候，我们是选择当前这个<br>​    点所在的连通块，与外面连的所有边里，选择一条最短的一条边加入连通块中。每次扩展一个<br>   ​ 点进来，扩展n - 1次即可。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        res += dist[t];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//表示这个点已经加入集合</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Kruskal算法："><a href="#2、Kruskal算法：" class="headerlink" title="2、Kruskal算法："></a>2、Kruskal算法：</h3><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​稀疏图 并查集 + 快排</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​基于并查集，先将所有边从小到大排序，每一次从小到大枚举所有边，当枚举到某一条边时，<br>   ​ 左边的一个点一定在某个连通块中，右边的点也一定在某一个连通块中，当前枚举的这条边<br>   ​ 可以分为几种情况：<br>  ​  （1）当前这条边连接的两个点已经连通了，那么就不用连接<br>  ​  （2）当前这条边连接的两个点不连通，那么久把这条边加到生成树中。<br>  ​  维护连通性可以用并查集。<br>​直接用结构体存下：a, b, w。</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><span class="hljs-comment">//定义结构体和重载小于号</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Edge &amp;W) <br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span><span class="hljs-comment">//kruskal模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m); <span class="hljs-comment">//将所有边的权值相加</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) p[i] = i; <span class="hljs-comment">//初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b)) <span class="hljs-comment">//判断两个点是否在同一个集合里，</span><br>        &#123;<br>            p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);   <span class="hljs-comment">//将两个点连上一条线</span><br>            res += w;   <span class="hljs-comment">//累加集合的权重</span><br>            cnt ++;     <span class="hljs-comment">//每加入一条边到集合里，就累加一次</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;    <span class="hljs-comment">//如果加入集合的次数，小于点的个数减一（n个点需要n-1条边连通），说明不连通</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路问题</title>
    <link href="/2023/03/31/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/31/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="五种最短路的解决方法"><a href="#五种最短路的解决方法" class="headerlink" title="五种最短路的解决方法"></a>五种最短路的解决方法<span id="more"></span></h2><h3 id="1、Dijkstra算法："><a href="#1、Dijkstra算法：" class="headerlink" title="1、Dijkstra算法："></a>1、Dijkstra算法：</h3><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​朴素版 O(n^2)，用于无负权边</p><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    每次找到集合中距离最短的边进行更新，并用这条确定的最短的边去扩展与他相连通的所有点，<br>​    并更新距离，用st[]数组标记已经找到了最短距离。<br>​稀疏图用邻接矩阵存，反之用邻接表存。</p></blockquote><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）邻接矩阵存边时，可以用g[a][b] &#x3D; min(g[a][b], c)，避免重边和自环，但也要先初始化memset(g,0x3f, sizeof g);</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//第一个的点到起点的距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)    <span class="hljs-comment">//迭代n次，有n个点需要找到最短距离，每次迭代找一个最短距离</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)   <span class="hljs-comment">//遍历所有点</span><br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<span class="hljs-comment">//找到一条没有确定最短距离，且距离起点最近的一个点</span><br>                t = j;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)   <span class="hljs-comment">//利用已经确定的最短距离，去更新他们邻点到起点的最短距离</span><br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、堆优化版Dijkstra算法："><a href="#2、堆优化版Dijkstra算法：" class="headerlink" title="2、堆优化版Dijkstra算法："></a>2、堆优化版Dijkstra算法：</h3><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(mlogn)，用于无负权边。</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​对朴素版 Dijkstra算法的核心进行优化，就是每次取出的是所有边中最短的边，<br>​我们可以利用小根堆去维护需要遍历的所有边，这样每次取出堆顶元素，即最短的边了。</p></blockquote><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）pair类型的优先队列是按照第一个关键词进行排序的，故第一位只能放距离。<br>​（2）邻接表初始化表头memset(h, -1, sizeof h);<br>​（3）初始化距离数组dist为 INF，便于寻找最短路径。</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    <span class="hljs-comment">//初始化起点到所有的点的距离为无穷大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化第一个点到起点的距离为0</span><br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    <span class="hljs-comment">//创建一个PII类型的优先队列，小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);  <span class="hljs-comment">//将起点1，距离起点距离0，放入堆中</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) <span class="hljs-comment">//只要堆中还有元素，就进行循环</span><br>    &#123;   <br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">//每次取出堆顶，由于是小根堆，堆顶就是最小元素</span><br>        heap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//将取出的堆顶删除，这里默认取出来之后，就是对该元素进行操作，表示已经求出了起点到堆顶元素的最小值</span><br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;     <span class="hljs-comment">//取出位置，和距离</span><br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//如果该点已经进行过操作，那么就跳过该元素，用于防止遍历已经操作过的元素了</span><br>        st[ver] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//进行到这一步，说明该点还没有找到最短距离，后续会进行查找，这里提前标记已经找到</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])    <span class="hljs-comment">//对邻接表进行遍历，这里遍历的是h[ver]是ver为表头的邻接表的元素</span><br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];   <span class="hljs-comment">//存下当前点的值</span><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) <span class="hljs-comment">//如果当前的点到起点的距离小于原有距离（初始值或之前本次遍历时获得的值）</span><br>            &#123;<br>                dist[j] = dist[ver] + w[i]; <span class="hljs-comment">//更新dist最短距离的值</span><br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);    <span class="hljs-comment">//将该点的距离和位置放入堆中</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Bellman-ford算法："><a href="#3、Bellman-ford算法：" class="headerlink" title="3、Bellman-ford算法："></a>3、Bellman-ford算法：</h3><h5 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​O(nm)，用于有数限制的最短路问题。<br>​与其他最短路算法不同是，Bellman-ford算法需要自己定义一个结构体，进行存边。</p><h5 id="核心思路：-2"><a href="#核心思路：-2" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​（1）初始化dist数组，并初始化起点的距离<br>​（2）迭代k次，表示只能经过k条边<br>​（3）迭代所有边，即迭代m次，每次迭代前备份一下上一次的dist数组(last)，用于后续更新dist距离，<br>​（4）第m次时迭代更新与起点距离m条边及以内的点的最短距离（松弛）</p></blockquote><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return 0，因为存在负权边。<br>​（2）每次都遍历会遍历所有边，有很多边是无效的，spfa算法针对这一点进行优化。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);        <span class="hljs-comment">//初始化所有的点到起点的距离都是无穷大</span><br><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化第一个点到起点的距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)    <span class="hljs-comment">//遍历k次， 表示经过k条边</span><br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(last, dist, <span class="hljs-keyword">sizeof</span> dist);    <span class="hljs-comment">//每次遍历备份一下上一次遍历结果的数组，因为可能在更新的时候，会改变dist，导致后续在更新时值不丢</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)   <span class="hljs-comment">//有m个边需要去遍历,每次求出一条件的路径</span><br>        &#123;<br>            <span class="hljs-keyword">auto</span> e = edges[j];  <span class="hljs-comment">//将每一行的数据值（c）和方向（a-&gt;b）取出</span><br>            dist[e.b] = <span class="hljs-built_in">min</span>(dist[e.b], last[e.a] + e.c);    <span class="hljs-comment">//每次取出直接到达该点的距离和原有距离的最小值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、Spfa算法："><a href="#4、Spfa算法：" class="headerlink" title="4、Spfa算法："></a>4、Spfa算法：</h3><h5 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(m)是对bellman_ford算法中松弛一步的优化。不能含有负权回路。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​（1）初始化dist数组<br>​（2）定义一个循环队列，将需要更新最短距离的点加入队列中，这样就不用每次去寻找需要更新的边了<br>​（3）遍历队列中的元素，只要该元素所在的连通块中，存在新的最短距离，就将其加入队列中，去更新后面的元素距离。</p></blockquote><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>（1）这里的st[]数组意义和Dijkstra算法不同，<br>        Dijkstra算法中st[]数组表示是否求出最短距离；<br>    Spfa算法中st[]数组表示某个点是否在队列中。<br>    （2）Spfa算法能求含负权边的原因，也是因为（1）中的特性，若存在负权边，就会去重新更新与该点连接的边的最短距离。<br>    （3）Spfa最坏情况是O(nm)<br>    （4）循环队列写法：</p><p>​hh &#x3D; 0, tt &#x3D; 0, q[tt ++] &#x3D; 1;<br>​while (hh !&#x3D; tt);<br>​int t &#x3D; q[hh++];<br>​if (tt &#x3D;&#x3D; N) tt &#x3D; 0;<br>​…<br>​q[tt ++] &#x3D; x;<br>​if (tt &#x3D;&#x3D; N) tt &#x3D; 0;</p><p>​(5)spfa算法最后判断的条件是dist[n] &#x3D;&#x3D; INF的原因是，bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但spfa算法不一样，他相当于采用BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    <span class="hljs-comment">//初始化最初距离为无穷</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化第一个点到起点的距离</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;   <span class="hljs-comment">//定义一个队列用于存放待更新的值</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//将起点放进去</span><br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//标记起点在队列中</span><br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())    <span class="hljs-comment">//只要队列中还存在需要更新的值，就继续进行循环</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">//取出队头元素</span><br>        q.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">//就队头元素删除</span><br><br>        st[t] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//标记该元素已经不在队列中了</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])  <span class="hljs-comment">//对邻接表进行遍历</span><br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];   <span class="hljs-comment">//将值存下来</span><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])       <span class="hljs-comment">//如果队头元素的距离+下一个点的权值小于原有距离（初始化的值或者在之前遍历中所赋有的值）</span><br>            &#123;<br>                dist[j] = dist[t] + w[i];       <span class="hljs-comment">//更新距离</span><br>                <span class="hljs-keyword">if</span> (!st[j])                     <span class="hljs-comment">//如果这个点不在队列中，</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);  <span class="hljs-comment">//就将其加入队列中，并进行标记</span><br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[n];<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、spfa算法判负环："><a href="#5、spfa算法判负环：" class="headerlink" title="5、spfa算法判负环："></a>5、spfa算法判负环：</h3><h5 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(m)</p></blockquote><h5 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h5><blockquote><p>若图中存在负环，那么spfa算法就会一直不断地更新最短距离，故只要我们发现更新次数 &gt;&#x3D; n次，<br>就说明有负环，因为n个点只需要n - 1条边连接，故只需要更新n - 1次。<br>    故我们只需要在每次更新最短距离时，更新cnt[j] &#x3D; cnt[t] + 1即可，最后若更新次数 &gt;&#x3D; n次，就结束循环，返回true。<br>    注意：<br>    （1）这里需要注意，可能负环与起点1，不连通，故需要将所有点都加入到队列中，然后开始spfa算法遍历即可。</p></blockquote><h5 id="代码模板：-4"><a href="#代码模板：-4" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];   <span class="hljs-comment">//更新起点到某一个点的最短距离</span><br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;    <span class="hljs-comment">//更新起点到某一个点的最短距离的更新次数</span><br><br>                <span class="hljs-keyword">if</span> (cnt[t] &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//如果更新次数大于n，说明至少走过了n + 1个点，说明存在循环，即负权回路</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、Floyd算法："><a href="#6、Floyd算法：" class="headerlink" title="6、Floyd算法："></a>6、Floyd算法：</h3><h5 id="时间复杂度：-5"><a href="#时间复杂度：-5" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(n^3)多源最短路问题。</p></blockquote><h5 id="核心思路：-3"><a href="#核心思路：-3" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>基于DP：<br>    （1）状态表示：f[k][i][j]<br>        所有从i出发，最终走到j，且中间只经过节点编号不超过k的所有路径。<br>    （2）属性：min<br>    （3）状态计算：<br>        以第i个点是否在路径中进行划分：<br>            所有不包含节点k的路径：d[k - 1][i][j]<br>            所有包含节点k的路径：d[k - 1][i][k] + d[k - 1][k][j]<br>    （4）由于每次用的都是上一层的d，故可以把k层优化掉<br>        即d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j])</p></blockquote><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>（1）初始化：自环设置成d[i][j] &#x3D; 0，其他情况设置成INF，便于求min<br>（2）用邻接矩阵存边，直接d[a][b] &#x3D; min(d[a][b], c);</p></blockquote><h5 id="代码模板：-5"><a href="#代码模板：-5" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">初始化：<br>（<span class="hljs-number">1</span>）i != j，d[i][j] = <span class="hljs-number">0x3f3f3f3f</span>，无穷，便于后续求最短路<br>（<span class="hljs-number">2</span>）i == j，d[i][j] = <span class="hljs-number">0</span>，自环<br>实现：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br><span class="hljs-comment">//i到j的最小距离距离=原有距离与上一个点的距离到起点的距离+上一点到当前点的距离的最小值</span><br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
