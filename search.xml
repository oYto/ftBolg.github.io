<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go实现Ping操作</title>
      <link href="/2023/10/31/Go/Go%E5%AE%9E%E7%8E%B0Ping%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/10/31/Go/Go%E5%AE%9E%E7%8E%B0Ping%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>​这次我们来看一下什么是 Ping 操作，以及它有什么用处，并且我们来动手实现一个简易版的 Ping 工具。<span id="more"></span></p><h4 id="Ping-是什么？"><a href="#Ping-是什么？" class="headerlink" title="Ping 是什么？"></a>Ping 是什么？</h4><p>​<code>ping</code> 是一个计算机网络工具，通常用于测试网络连接的可达性和测量往返时间。在大多数操作系统中，<code>ping</code> 命令是一个内置的命令行工具，可以通过命令行终端使用。例如，在 Windows 操作系统中，你可以在命令提示符中运行 <code>ping</code> 命令，而在类 Unix 操作系统（如 Linux 和 macOS）中，你可以在终端中使用 <code>ping</code> 命令。通常，命令的语法是 <code>ping 目标主机或 IP</code>，然后命令将输出与目标主机的通信状态和 RTT 相关的信息。</p><h4 id="Ping-有什么用处？"><a href="#Ping-有什么用处？" class="headerlink" title="Ping 有什么用处？"></a>Ping 有什么用处？</h4><p>​<code>Ping</code> 工具主要有以下几个主要用途：</p><ol><li><strong>测试主机的可达性</strong>：<code>ping</code> 命令用于检查另一个主机是否可以在网络上访问。它向目标主机发送一个小的数据包（通常是 ICMP Echo Request），如果目标主机正常工作，它将响应一个回复数据包（通常是 ICMP Echo Reply）。如果没有响应，那么目标主机可能无法访问或处于离线状态。</li><li><strong>测量往返时间（RTT）</strong>：<code>ping</code> 命令通常会显示每次请求和响应之间的时间差，这被称为往返时间（RTT）。这个值表示了数据从发送端到接收端的往返延迟，通常以毫秒为单位。测量 RTT 对于评估网络性能和延迟非常有用。</li><li><strong>网络故障排除</strong>：<code>ping</code> 是网络故障排除的有用工具之一。通过检查 <code>ping</code> 的输出，网络管理员可以确定网络连接是否正常，以及延迟是否在可接受范围内。如果 <code>ping</code> 失败，管理员可以进一步调查网络故障的原因。</li><li><strong>监测网络稳定性</strong>：<code>ping</code> 命令还可以用于监测网络的稳定性。通过连续地向目标主机发送 <code>ping</code> 请求，可以了解网络连接的质量和稳定性。如果出现不稳定性，管理员可以及时采取措施。</li></ol><h4 id="动手实现一个-Ping-工具"><a href="#动手实现一个-Ping-工具" class="headerlink" title="动手实现一个 Ping 工具"></a>动手实现一个 Ping 工具</h4><p>​首先，我们要了解一下 <code>Ping</code> 操作的工作原理：向网络上的另一个主机系统发送 <code>ICMP</code> 报文，如果指定系统得到了报文，它将把回复报文传回给发送者。</p><p>​先来看看 ICMP 报文长什么样：</p><p><img src="/images/ICMP%E6%8A%A5%E6%96%87.png" alt="ICMP报文"></p><p>​ICMP 报文由 ICMP 报文头 和 数据包组成，其报文头包含 Type、Code、Checksum、ID、SequenceNum 字段。因此，我们需要先在本地主机上定义 ICMP 请求报文结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ICMP <span class="hljs-keyword">struct</span> &#123;<br>Type        <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 类型</span><br>Code        <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 代码</span><br>CheckSum    <span class="hljs-type">uint16</span> <span class="hljs-comment">// 校验和</span><br>ID          <span class="hljs-type">uint16</span> <span class="hljs-comment">// ID</span><br>SequenceNum <span class="hljs-type">uint16</span> <span class="hljs-comment">// 序号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​上面只是 ICMP 的报文头，我们在后面还需要为这个报文构建请求数据。需要注意的是，定义的顺序不能乱，因为我们发送数据包是按字节发送的，所以获取对应的字段的时候，也是按照对应字段的位置去获取的，如果顺序乱了，获取到的数据就会出错。</p><p>​在构建数据之前，我们先设置好命令行参数，以获取对应参数和目标 IP，同时需要定义全局变量，将命令行参数绑定到对应的变量中，方便使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>helpFlag <span class="hljs-type">bool</span><br>timeout  <span class="hljs-type">int64</span> <span class="hljs-comment">// 耗时</span><br>size     <span class="hljs-type">int</span>   <span class="hljs-comment">// 大小</span><br>count    <span class="hljs-type">int</span>   <span class="hljs-comment">// 请求次数</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetCommandArgs</span><span class="hljs-params">()</span></span> &#123;<br>flag.Int64Var(&amp;timeout, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;请求超时时间&quot;</span>)<br>flag.IntVar(&amp;size, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;发送字节数&quot;</span>)<br>flag.IntVar(&amp;count, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;请求次数&quot;</span>)<br>flag.BoolVar(&amp;helpFlag, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;显示帮助信息&quot;</span>)<br>flag.Parse()<br>&#125;<br></code></pre></td></tr></table></figure><p>​在 <code>main</code> 函数中，启用命令行参数设置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>GetCommandArgs()<br>&#125;<br></code></pre></td></tr></table></figure><p>​在发送报文前，我们需要先建立连接，此时需要先获取目标 IP，这个由命令行参数中获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取目标 IP</span><br>desIP := os.Args[<span class="hljs-built_in">len</span>(os.Args)<span class="hljs-number">-1</span>]<br><span class="hljs-comment">// 构建连接</span><br>conn, err := net.DialTimeout(<span class="hljs-string">&quot;ip:icmp&quot;</span>, desIP, time.Duration(timeout)*time.Millisecond)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Println(err.Error())<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-comment">// 远程地址</span><br>remoteaddr := conn.RemoteAddr()<br></code></pre></td></tr></table></figure><p>​连接建立后，我们需要根据参数中的发送次数 <code>count</code> 去发送对应次数的报文，因此需要用 <code>for</code> 去做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i ++ &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>​通过百度百科可以查到，我们要使用的是 Ping 请求，即回显请求，其对应的 Type 和 Code 如下：</p><p><img src="/images/ICMPPing%E8%AF%B7%E6%B1%82.png" alt="ICMPPing请求"></p><p>​同样，我们在全局变量中添加对应的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>typ      <span class="hljs-type">uint8</span> = <span class="hljs-number">8</span><br>    code     <span class="hljs-type">uint8</span> = <span class="hljs-number">0</span><br>)<br></code></pre></td></tr></table></figure><p>​做好前面的准备工作，我们就可以开始构建我们的 ICMP 请求报文了。我们这里以发送的第几次作为 ID 和序列号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">icmp := &amp;ICMP&#123;<br>        Type:        typ,<br>        Code:        code,<br>        CheckSum:    <span class="hljs-type">uint16</span>(<span class="hljs-number">0</span>),<br>        ID:          <span class="hljs-type">uint16</span>(i),<br>        SequenceNum: <span class="hljs-type">uint16</span>(i),<br>    &#125;<br></code></pre></td></tr></table></figure><p>​由于 ICMP 是使用二进制进行传输的，所以我们需要将信息用二进制表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buffer bytes.Buffer<br>binary.Write(&amp;buffer, binary.BigEndian, icmp)<br></code></pre></td></tr></table></figure><p>​然后根据发送数据的大小 <code>size</code> 构建数据并写在 ICMP 报文后面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br>buffer.Write(data)<br>data = buffer.Bytes()<br></code></pre></td></tr></table></figure><p>​现在，就只差一个校验和字段了，计算 ICMP（Internet Control Message Protocol）报文的校验和字段遵循以下步骤：</p><ol><li>将报文分为 16 位的字（两个字节）。</li><li>对所有字进行按位求和（二进制求和），包括数据部分和报文头。如果有剩余字节（奇数个字节），将其附加到最后一个字节。</li><li>将溢出的进位位（如果有）加回到结果中。</li><li>取结果的二进制反码（按位取反）</li></ol><p>​代码实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkSum</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint16</span> &#123;<br><span class="hljs-comment">// 第一步：两两拼接并求和</span><br>length := <span class="hljs-built_in">len</span>(data)<br>index := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> sum <span class="hljs-type">uint32</span><br><span class="hljs-keyword">for</span> length &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// 拼接且求和</span><br>sum += <span class="hljs-type">uint32</span>(data[index])&lt;&lt;<span class="hljs-number">8</span> + <span class="hljs-type">uint32</span>(data[index+<span class="hljs-number">1</span>])<br>length -= <span class="hljs-number">2</span><br>index += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-comment">// 奇数情况，还剩下一个，直接求和过去</span><br><span class="hljs-keyword">if</span> length == <span class="hljs-number">1</span> &#123;<br>sum += <span class="hljs-type">uint32</span>(data[index])<br>&#125;<br><br><span class="hljs-comment">// 第二部：高 16 位，低 16 位 相加，直至高 16 位为 0</span><br>hi := sum &gt;&gt; <span class="hljs-number">16</span><br><span class="hljs-keyword">for</span> hi != <span class="hljs-number">0</span> &#123;<br>sum = hi + <span class="hljs-type">uint32</span>(<span class="hljs-type">uint16</span>(sum))<br>hi = sum &gt;&gt; <span class="hljs-number">16</span><br>&#125;<br><span class="hljs-comment">// 返回 sum 值 取反</span><br><span class="hljs-keyword">return</span> <span class="hljs-type">uint16</span>(^sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>​接着再将算出来的校验和放到报文头对应的位置中去，这里需要计算一下位置。假设我们有以下 ICMP 报文：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|      Type       |      Code       |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|         Checksum (2 bytes)       |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|           Identifier (2 bytes)   |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|        Sequence Number (2 bytes) |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|           Data (variable length) |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><p>​校验和属于报文的第3、4个字节，即 data[2] 和 data[3]。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">data[<span class="hljs-number">2</span>] = <span class="hljs-type">byte</span>(checkSum &gt;&gt; <span class="hljs-number">8</span>)<br>data[<span class="hljs-number">3</span>] = <span class="hljs-type">byte</span>(checkSum)<br></code></pre></td></tr></table></figure><p>​最后再设置一下超时时间，就可以将数据 <code>data</code> 写入连接中了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 设置超时时间</span><br>conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Millisecond))<br><br><span class="hljs-comment">// 将 data 写入连接中，</span><br>n, err := conn.Write(data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Println(err)<br>    <span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​发送完成后，再构建缓冲接收响应包，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>n, err = conn.Read(buf)<br><span class="hljs-comment">//fmt.Println(data)</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Println(err)<br>    <span class="hljs-keyword">continue</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​然后我们就可以从响应包中获取我们需要的数据，比如 IP 地址、TTL等：</p><p><img src="/images/icmp%E5%9B%9E%E5%A4%8D%E6%8A%A5%E6%96%87.png" alt="icmp回复报文"></p><p>​根据抓到的 ICMP 响应包，可以知道 IP 头共 20 个字节，源 IP 和 目标 IP 在我们接收的数据包的倒数 8 个字节里，所以我们可以推算出我们访问的 IP 地址，就可以构建我们的打印信息了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;来自 %d.%d.%d.%d 的回复：字节=%d 时间=%d TTL=%d\n&quot;</span>, buf[<span class="hljs-number">12</span>], buf[<span class="hljs-number">13</span>], buf[<span class="hljs-number">14</span>], buf[<span class="hljs-number">15</span>], n<span class="hljs-number">-28</span>, t, buf[<span class="hljs-number">8</span>])<br></code></pre></td></tr></table></figure><p>​至此，我们 Ping 工具的核心功能就实现了，还有一些统计信息，就不做具体的讲解了，感兴趣的可以从代码中看具体的实现。</p><p>完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;encoding/binary&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// tcp 报文前20个是报文头，后面的才是 ICMP 的内容。</span><br><span class="hljs-comment">// ICMP：组建 ICMP 首部（8 字节） + 我们要传输的内容</span><br><span class="hljs-comment">// ICMP 首部：type、code、校验和、ID、序号，1 1 2 2 2</span><br><span class="hljs-comment">// 回显应答：type = 0，code = 0</span><br><span class="hljs-comment">// 回显请求：type = 8, code = 0</span><br><br><span class="hljs-keyword">var</span> (<br>helpFlag <span class="hljs-type">bool</span><br>timeout  <span class="hljs-type">int64</span> <span class="hljs-comment">// 耗时</span><br>size     <span class="hljs-type">int</span>   <span class="hljs-comment">// 大小</span><br>count    <span class="hljs-type">int</span>   <span class="hljs-comment">// 请求次数</span><br>typ      <span class="hljs-type">uint8</span> = <span class="hljs-number">8</span><br>code     <span class="hljs-type">uint8</span> = <span class="hljs-number">0</span><br>SendCnt  <span class="hljs-type">int</span>                   <span class="hljs-comment">// 发送次数</span><br>RecCnt   <span class="hljs-type">int</span>                   <span class="hljs-comment">// 接收次数</span><br>MaxTime  <span class="hljs-type">int64</span> = math.MinInt64 <span class="hljs-comment">// 最大耗时</span><br>MinTime  <span class="hljs-type">int64</span> = math.MaxInt64 <span class="hljs-comment">// 最短耗时</span><br>SumTime  <span class="hljs-type">int64</span>                 <span class="hljs-comment">// 总计耗时</span><br>)<br><br><span class="hljs-comment">// ICMP 序号不能乱</span><br><span class="hljs-keyword">type</span> ICMP <span class="hljs-keyword">struct</span> &#123;<br>Type        <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 类型</span><br>Code        <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 代码</span><br>CheckSum    <span class="hljs-type">uint16</span> <span class="hljs-comment">// 校验和</span><br>ID          <span class="hljs-type">uint16</span> <span class="hljs-comment">// ID</span><br>SequenceNum <span class="hljs-type">uint16</span> <span class="hljs-comment">// 序号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println()<br>log.SetFlags(log.Llongfile)<br>GetCommandArgs()<br><br><span class="hljs-comment">// 打印帮助信息</span><br><span class="hljs-keyword">if</span> helpFlag &#123;<br>displayHelp()<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// 获取目标 IP</span><br>desIP := os.Args[<span class="hljs-built_in">len</span>(os.Args)<span class="hljs-number">-1</span>]<br><span class="hljs-comment">//fmt.Println(desIP)</span><br><span class="hljs-comment">// 构建连接</span><br>conn, err := net.DialTimeout(<span class="hljs-string">&quot;ip:icmp&quot;</span>, desIP, time.Duration(timeout)*time.Millisecond)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-comment">// 远程地址</span><br>remoteaddr := conn.RemoteAddr()<br>fmt.Printf(<span class="hljs-string">&quot;正在 Ping %s [%s] 具有 %d 字节的数据:\n&quot;</span>, desIP, remoteaddr, size)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br><span class="hljs-comment">// 构建请求</span><br>icmp := &amp;ICMP&#123;<br>Type:        typ,<br>Code:        code,<br>CheckSum:    <span class="hljs-type">uint16</span>(<span class="hljs-number">0</span>),<br>ID:          <span class="hljs-type">uint16</span>(i),<br>SequenceNum: <span class="hljs-type">uint16</span>(i),<br>&#125;<br><br><span class="hljs-comment">// 将请求转为二进制流</span><br><span class="hljs-keyword">var</span> buffer bytes.Buffer<br>binary.Write(&amp;buffer, binary.BigEndian, icmp)<br><span class="hljs-comment">// 请求的数据</span><br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br><span class="hljs-comment">// 将请求数据写到 icmp 报文头后</span><br>buffer.Write(data)<br>data = buffer.Bytes()<br><span class="hljs-comment">// ICMP 请求签名（校验和）：相邻两位拼接到一起，拼接成两个字节的数</span><br>checkSum := checkSum(data)<br><span class="hljs-comment">// 签名赋值到 data 里</span><br>data[<span class="hljs-number">2</span>] = <span class="hljs-type">byte</span>(checkSum &gt;&gt; <span class="hljs-number">8</span>)<br>data[<span class="hljs-number">3</span>] = <span class="hljs-type">byte</span>(checkSum)<br>startTime := time.Now()<br><br><span class="hljs-comment">// 设置超时时间</span><br>conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Millisecond))<br><br><span class="hljs-comment">// 将 data 写入连接中，</span><br>n, err := conn.Write(data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 发送数 ++</span><br>SendCnt++<br><span class="hljs-comment">// 接收响应</span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>n, err = conn.Read(buf)<br><span class="hljs-comment">//fmt.Println(data)</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 接受数 ++</span><br>RecCnt++<br><span class="hljs-comment">//fmt.Println(n, err) // data：64，ip首部：20，icmp：8个 = 92 个</span><br><span class="hljs-comment">// 打印信息</span><br>t := time.Since(startTime).Milliseconds()<br>fmt.Printf(<span class="hljs-string">&quot;来自 %d.%d.%d.%d 的回复：字节=%d 时间=%d TTL=%d\n&quot;</span>, buf[<span class="hljs-number">12</span>], buf[<span class="hljs-number">13</span>], buf[<span class="hljs-number">14</span>], buf[<span class="hljs-number">15</span>], n<span class="hljs-number">-28</span>, t, buf[<span class="hljs-number">8</span>])<br>MaxTime = Max(MaxTime, t)<br>MinTime = Min(MinTime, t)<br>SumTime += t<br>time.Sleep(time.Second)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;\n%s 的 Ping 统计信息:\n&quot;</span>, remoteaddr)<br>fmt.Printf(<span class="hljs-string">&quot;    数据包: 已发送 = %d，已接收 = %d，丢失 = %d (%.f%% 丢失)，\n&quot;</span>, SendCnt, RecCnt, count*<span class="hljs-number">2</span>-SendCnt-RecCnt, <span class="hljs-type">float64</span>(count*<span class="hljs-number">2</span>-SendCnt-RecCnt)/<span class="hljs-type">float64</span>(count*<span class="hljs-number">2</span>)*<span class="hljs-number">100</span>)<br>fmt.Println(<span class="hljs-string">&quot;往返行程的估计时间(以毫秒为单位):&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;    最短 = %d，最长 = %d，平均 = %d\n&quot;</span>, MinTime, MaxTime, SumTime/<span class="hljs-type">int64</span>(count))<br>&#125;<br><br><span class="hljs-comment">// 求校验和</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkSum</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint16</span> &#123;<br><span class="hljs-comment">// 第一步：两两拼接并求和</span><br>length := <span class="hljs-built_in">len</span>(data)<br>index := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> sum <span class="hljs-type">uint32</span><br><span class="hljs-keyword">for</span> length &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// 拼接且求和</span><br>sum += <span class="hljs-type">uint32</span>(data[index])&lt;&lt;<span class="hljs-number">8</span> + <span class="hljs-type">uint32</span>(data[index+<span class="hljs-number">1</span>])<br>length -= <span class="hljs-number">2</span><br>index += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-comment">// 奇数情况，还剩下一个，直接求和过去</span><br><span class="hljs-keyword">if</span> length == <span class="hljs-number">1</span> &#123;<br>sum += <span class="hljs-type">uint32</span>(data[index])<br>&#125;<br><br><span class="hljs-comment">// 第二部：高 16 位，低 16 位 相加，直至高 16 位为 0</span><br>hi := sum &gt;&gt; <span class="hljs-number">16</span><br><span class="hljs-keyword">for</span> hi != <span class="hljs-number">0</span> &#123;<br>sum = hi + <span class="hljs-type">uint32</span>(<span class="hljs-type">uint16</span>(sum))<br>hi = sum &gt;&gt; <span class="hljs-number">16</span><br>&#125;<br><span class="hljs-comment">// 返回 sum 值 取反</span><br><span class="hljs-keyword">return</span> <span class="hljs-type">uint16</span>(^sum)<br>&#125;<br><br><span class="hljs-comment">// GetCommandArgs 命令行参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetCommandArgs</span><span class="hljs-params">()</span></span> &#123;<br>flag.Int64Var(&amp;timeout, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;请求超时时间&quot;</span>)<br>flag.IntVar(&amp;size, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;发送字节数&quot;</span>)<br>flag.IntVar(&amp;count, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;请求次数&quot;</span>)<br>flag.BoolVar(&amp;helpFlag, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;显示帮助信息&quot;</span>)<br>flag.Parse()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Max</span><span class="hljs-params">(a, b <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span><span class="hljs-params">(a, b <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">if</span> a &lt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">displayHelp</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">`选项：</span><br><span class="hljs-string">-n count       要发送的回显请求数。</span><br><span class="hljs-string">-l size        发送缓冲区大小。</span><br><span class="hljs-string">-w timeout     等待每次回复的超时时间(毫秒)。</span><br><span class="hljs-string">-h        帮助选项`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​本文讲解了常用工具 Ping，并且从 ICMP 报文角度手把手教大家实现了一个简易版的 Ping 工具，在这个过程中大家可以收获到很多东西，希望大家能够自己动手实现一下，结果一定不会让你失望。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息积压了如何处理？</title>
      <link href="/2023/10/30/MQ/%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E4%BA%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F/"/>
      <url>/2023/10/30/MQ/%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E4%BA%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>​在系统中使用消息队列的时候，消息积压这个问题也经常遇到，并且这个问题还不太好解决。<span id="more"></span></p><p>​消息积压的直接原因通常是，系统中的某个部分出现了性能问题，来不及处理上游发送的消息，才会导致消息积压。</p><p>​下面我们来分析下，在使用消息队列的时候，如何优化代码的性能，避免出现消息积压，以及遇到了消息积压问题，该如何进行处理，最大程度地避免消息积压对业务的影响。</p><h1 id="优化性能来避免消息积压"><a href="#优化性能来避免消息积压" class="headerlink" title="优化性能来避免消息积压"></a>优化性能来避免消息积压</h1><p>​对于绝大多数使用消息队列的业务来说，消息队列本身的处理能力要远大于业务能力的处理能力。主流的一些消息队列的单个节点，消息收发的能力可以达到每秒钟处理几万至几十万条消息的水平，还可以通过水平扩展 Broker 的实例数成倍地提升处理能力。</p><p>​而一般的业务系统需要处理的业务逻辑远比消息队列复杂，单个节点每秒钟可以处理几百到几千次请求，已经可以算是性能非常好的了。所以，对于消息队列的性能优化，我们更应该关注，<strong>在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。</strong></p><h4 id="发送端性能优化"><a href="#发送端性能优化" class="headerlink" title="发送端性能优化"></a>发送端性能优化</h4><p>​发送端业务代码的处理性能，实际上和消息队列的关系并不打，因为发送端都是先执行自己的业务逻辑，再发送消息。**如果系统发送消息的性能上不去，可以优先检查一下是不是发送消息之前的业务逻辑耗时太多导致的。 **</p><p>​对于发送消息的业务逻辑，只要注意设置好合适的并发和批量大小，就可以达到很好的发送性能。</p><p>​我们之前的文章中讲过 Producer 发送消息的过程，Producer 发消息给 Broker，Broker 收到消息后返回确认响应，这是一次完整的交互。假设这一次交互的平均时延是 1 ms，我们把这 1ms 的时间分解开，它包括了下面这些步骤的耗时：</p><ul><li>发送端准备数据、序列号消息、构造请求等逻辑的时间，即发送端在发送网络请求之前的耗时</li><li>发送消息和返回响应在网络传输中的耗时</li><li>Broker 处理消息的时延</li></ul><p>​如果是单线程发送，每次只发送 1 条消息，那么每秒只能发送 1000ms &#x2F; 1ms * 1 条 &#x2F;ms &#x3D; 1000 条 消息，这种情况下并不能发挥出消息队列的全部实力。</p><p>​这个时候，我们可以选择增加每次发送消息的批量大小或增加并发，都能成倍地增加性能，具体的选择，还是需要根据业务需求来进行选择。</p><p>​比如说，你的消息发送端是一个微服务，主要接受 RPC 请求处理在线业务。很自然的，微服务在处理每次请求的时候，就在当前线程直接发送消息就可以了，因为所有 RPC 框架都是多线程支持多并发的，自然也就实现了并行发送消息。并且在线业务比较在意的是请求响应时延，选择批量发送必然会影响 RPC 服务的时延。这种情况，比较明智的方式就是通过并发来提升发送性能。</p><p>​如果你的系统是一个离线分析系统，离线系统在性能上的需求是什么呢？它不关心时延，更注重整个系统的吞吐量。发送端的数据都是来自于数据库，这种情况就更适合批量发送，你可以批量从数据库读取数据，然后批量来发送消息，同样用少量的并发就可以获得非常高的吞吐量。</p><h4 id="消费端性能优化"><a href="#消费端性能优化" class="headerlink" title="消费端性能优化"></a>消费端性能优化</h4><p>​在使用消息队列的时候，大部分性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。如果这种性能倒挂的问题是暂时的，那问题不大，等消费端的性能恢复之后，超过发送端的性能，那积压的消息是可以被消费完的。</p><p>​要是消费端的性能一直低于生产端，时间长了整个系统就会出现问题：要么消息队列的存储被填满无法继续提供服务，要么消息丢失，对于整个系统来说都是严重故障。</p><p>​所以，这种设计系统的时候，<strong>一定要保证消费端的消费性能要高于生产端的发送性能，这样才能保证健康的继续运行。</strong></p><p>​消费端的性能优化还可以通过水平扩展来处理，即增加消费的并发数来提升总体的消费性能。特别需要注意的一点是，<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。</strong>如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。原因我们之前讲过，因为对于消费者来说，在每个分区上实际上只能支持单线程消费。</p><p>​有很多消费程序，是这样解决消费慢的问题的：</p><p><img src="/images/%E6%B6%88%E8%B4%B9%E6%85%A2%E9%97%AE%E9%A2%98.png" alt="消费慢问题"></p><p>​业务处理逻辑比较慢，很难优化，为了避免消息积压，在收到消息的 OnMessage 方法中，不处理任务业务逻辑，而是把这个消息放到内存队列里就返回了。然后启动多个业务线程，这些线程里是真正处理消息的业务逻辑，这些线程从内存队列里取消息处理，这样它就解决了单个 Consumer 不能并行消费的问题。</p><p>​这个方法看似很完美，但是如果收消息的节点宕机，在内存队列中还没有来得及处理这些消息就会丢失。关于 ”消息丢失“ 问题，可以查看 《如何确保消息不会丢失》这篇文章。</p><h4 id="消息积压了该如何处理？"><a href="#消息积压了该如何处理？" class="headerlink" title="消息积压了该如何处理？"></a>消息积压了该如何处理？</h4><p>​上述两种情况都是在系统设计上的情况，还有一种情况是在系统正常运转时，没有积压或者少量积压后很快就消费掉了，但是某一个时刻，突然开始消息积压并持续上涨。这种情况需要在短时间内找到消息积压的原因，并迅速解决问题，才不至于影响业务。</p><p>​能导致消息突然积压，最粗粒度的原因只有两种：<strong>要么是发送变快了，要么是消费变慢了。</strong></p><p>​大部分消息队列都内置了监控功能，只要通过监控数据，很容易确定是哪种原因。如果是单位时间发送的消息增加，比如赶上大促销或者抢购，短时间内不太可能优化消费端的代码来提升消费性能，唯一的办法就是通过扩容消费端的实例数来提升总体的消费能力。</p><p>​如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将系统降级，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。</p><p>​还有一种不太常见的情况，你通过监控发现，无论是<strong>发送消息的速度还是消费消息的速度和原来都没什么变化，</strong>这时候你需要检查一下你的消费端，是不是<strong>消费失败导致的一条消息反复消费这种情况比较多</strong>，这种情况也会拖慢整个系统的消费速度。</p><p>​如果监控到消费变慢了，你需要检查你的消费实例，分析一下是什么原因导致消费变慢。优先检查一下日志是否有大量的消费错误，如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在什么地方不动了，比如触发了死锁或者卡在等待某些资源上了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>​这篇文章，我们主要讨论了两个问题，一个是如何在设计系统时从消息队列的收发两端优化系统性能，提前预防消息堆积；另一个问题是，当系统发生消息积压后，该如何处理。</p><p>​优化收发消息性能，预防积压的方法有两种：增加批量或者增加并发，在发送端两种方法都可以使用，在消费端需要注意的是，增加并发需要同步扩容分区数量，否则是不起作用的。</p><p>​而对于系统发生消息积压的情况，需要先解决积压再分析原因，快速解决积压的方法就是通过水平扩容增加 Consumer 的实例数量，退一步的办法就是将系统降级，关闭一些不重要的业务，保证重要业务的正常运行。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/10/30/Go/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/10/30/Go/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><h4 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h4><p>​接口是计算机系统中多个组件共享的边界，不同的组件能够在边界上交换信息。接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要下层的具体模块，只需要依赖一个约定好的接口。</p><p><img src="/images/%E4%B8%8A%E4%B8%8B%E6%B8%B8%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E8%A7%A3%E8%80%A6.png" alt="上下游通过接口"></p><blockquote><p>举个例子：我们定义了一个 <code>Shape</code> 接口，它规定了一个 <code>Area()</code> 方法，然后我们创建了两个结构体 <code>Circle</code> 和 <code>Rectangle</code> 分别实现了这个接口的 <code>Area</code> 方法。我们可以实现一个<code>calculateArea</code> 函数计算它们的面积，参数就设置为 <code>Shape</code> 接口，我们就可以通过接口来调用它们的方法获取到面积，而不用关心是什么形状。</p><p>这就是接口的作用：<strong>它定义了一个规范，不同的对象可以根据这个规范来实现自己的功能，而不需要关心其他对象的具体实现，从而降低了代码的耦合度。</strong></p></blockquote><p>​这种面向接口的编程方式有着非常大的生命力，不论在框架还是操作系统中我们都能够找到接口的身影。</p><p>​除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。</p><p>​人能够同时处理的信息非常有限，定义良好的接口能够隔离底层的实现，让我们将重点放在当前的代码片段中。SQL 就是接口的一个例子，当我们使用 SQL 语句查询数据的时候，其实不需要关心底层数据库的实现，我们只在乎 SQL 返回的结果是否符合预期。</p><p><img src="/images/SQL%E5%92%8C%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="SQL和不同数据库"></p><p>​计算机科学中的接口是比较抽象的概念，但编程语言中接口的概念就比较具体。Go 语言中的接口是一种内置的类型，它定义了以一组方法的签名，下面介绍几个基本的概念以及常见问题。</p><h5 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h5><p>​很多面向对象语言都有接口这个概念，例如 Java 和 C#。Java 的接口不仅可以定义方法签名，还可以定义变量，这些定义的变量可以直接在实现接口的类中使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">public <span class="hljs-keyword">interface</span> MyInterface &#123;<br>    public String hello = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    public void sayHello();<br>&#125;<br></code></pre></td></tr></table></figure><p>​上述代码定义了一个必须实现的方法 <code>sayHello</code> 和一个会注入到实现类的变量 <code>hello</code>。在下面的代码中，<code>MyInterfaceImpl</code> 实现了 <code>MyInterface</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">public class MyInterfaceImpl implements MyInterface &#123;<br>    public void sayHello() &#123;<br>        System.out.<span class="hljs-built_in">println</span>(MyInterface.hello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​Java 中必须使用这种显示声明接口的方法，但 Go 语言中不需要这样的方式。</p><p>​Go 语言中定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RPCError <span class="hljs-keyword">struct</span> &#123;<br>Code <span class="hljs-type">int64</span><br>Message <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *RPCError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s, code=%d&quot;</span>, e.Message, e.Code)<br>&#125;<br></code></pre></td></tr></table></figure><p>​这段代码中根本没有出现 <code>error</code> 的影子，这就是 Go 语言中实现接口的方法，是隐式的，我们只需要实现  <code>Error() string</code> 方法就实现了 <code>error</code> 接口。这种方式与 Java 实现接口的方法是完全不同的：</p><ul><li>Java：实现接口需要显示地声明接口并实现所有方法</li><li>Go：实现接口的所有方法就隐式地实现了接口</li></ul><p>​我们使用上述 <code>RPCError</code> 结构体时并不关心它实现了哪些接口，Go 语言只会在传递参数、返回参数以及变量赋值时才会对某个类型是否实现接口进行检查。</p><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>​Go 语言中接口也是一种类型，它能够出现在变量的定义、函数的参数和返回值中并对它们做出约束。Go 语言中有两种不同的接口：一种是带有方法的接口，另一种总是不带任何方法的接口：</p><p><img src="/images/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8E%A5%E5%8F%A3.png" alt="Go语言中的两种接口"></p><p>​Go 语言使用 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 表示第一种接口，使用 <a href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 表示第二种不包含任何方法的接口 <code>interface&#123;&#125;</code>，两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中很常见，所以在实现时使用了特殊的类型。</p><p>​Go 语言中的 <code>interface</code> 与 C 语言中的 <code>void  *</code> 不同，它不是任意类型。如果我们将类型转换成了 <code>interface&#123;&#125;</code> 类型，变量在运行期间也会发生变化，获取变量类型时会得到 <code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := <span class="hljs-number">1</span><br>Print(v)<br><span class="hljs-built_in">println</span>(v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-built_in">println</span>(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>​上述函数只接受 <code>interface</code> 类型的参数，在调用 <code>Print</code> 函数的时候，会对参数 <code>v</code> 进行类型转换，将原来的 <code>Test</code> 类型转换成 <code>interface</code>{} 类型，于是打印出来的结果就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">(<span class="hljs-number">0x45e020</span>,<span class="hljs-number">0xc00002a748</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="接口和指针"><a href="#接口和指针" class="headerlink" title="接口和指针"></a>接口和指针</h5><p>​在 Go 语言中同时使用指针和接口时会发生一些让人困惑的问题，接口在定义一组方法时没有对实现的接收者做限制，所以我们会看到某个类型实现接口的两种方式：</p><p><img src="/images/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3.png" alt="结构体和指针实现接口"></p><p>​因为结构体类型和指针类型是不同的，就像我们不能向一个接受指针的函数传递结构体一样，在实现接口时这两种类型也不能划等号。虽然两种类型不同，但是上图中的两种实现不可以同时存在，Go 语言的编译器会在结构体类型和指针类型都实现一个方法时报错 “method redeclared”。</p><p>​对 <code>Cat</code> 结构体来说，它在实现接口时可以选择接受者的类型，即结构体或者结构体指针，在初始化时也可以初始化成结构体或者指针。下面的代码总结了如何使用结构体、结构体指针实现接口，以及如何使用结构体、结构体指针初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;&#125;<br><span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">interface</span> &#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c  Cat)</span></span> Quack &#123;&#125;  <span class="hljs-comment">// 使用结构体实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span></span> Quack &#123;&#125;  <span class="hljs-comment">// 使用结构体指针实现接口</span><br><br><span class="hljs-keyword">var</span> d Duck = Cat&#123;&#125;      <span class="hljs-comment">// 使用结构体初始化变量</span><br><span class="hljs-keyword">var</span> d Duck = &amp;Cat&#123;&#125;     <span class="hljs-comment">// 使用结构体指针初始化变量</span><br></code></pre></td></tr></table></figure><p>Go</p><p>实现接口的类型和初始化返回的类型两个维度共组成了四种情况，然而这四种情况不是都能通过编译器的检查：</p><table><thead><tr><th align="center"></th><th align="center">结构体实现接口</th><th align="center">结构体指针实现接口</th></tr></thead><tbody><tr><td align="center">结构体初始化变量</td><td align="center">通过</td><td align="center">不通过</td></tr><tr><td align="center">结构体指针初始化变量</td><td align="center">通过</td><td align="center">通过</td></tr></tbody></table><p>四种中只有使用指针实现接口，使用结构体初始化变量无法通过编译，其他的三种情况都可以正常执行。当实现接口的类型和初始化变量时返回的类型时相同时，代码通过编译是理所应当的：</p><ul><li>方法接受者和初始化类型都是结构体；</li><li>方法接受者和初始化类型都是结构体指针；</li></ul><p>​而剩下的两种方式为什么一种能够通过编译，另一种无法通过编译呢？先说能通过编译的情况：方法的接收者是结构体，而初始化的变量是结构体指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span></span> Quack() &#123;<br>fmt.Println(<span class="hljs-string">&quot;neow&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c Duck = &amp;Cat&#123;&#125;<br>c.Quack()<br>&#125;<br></code></pre></td></tr></table></figure><p>​因为指针 <code>&amp;Cat&#123;&#125;</code> 变量能够隐式地获取到指向的结构体，所以能在结构体上调用对应的方法。</p><p>​而如果方法的接收者是结构体指针，而初始化的变量是结构体，代码就无法通过编译了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">interface</span> &#123;<br>Quack()<br>&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span></span> Quack() &#123;<br>fmt.Println(<span class="hljs-string">&quot;meow&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c Duck = Cat&#123;&#125;<br>c.Quack()<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs"> 编译器会提醒：无法将 &#39;Cat&#123;&#125;&#39; (类型 Cat) 用作类型 Duck 类型未实现 &#39;Duck&#39;，因为 &#39;Quack&#39; 方法有指针接收器。</code></pre><p><img src="/images/%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8E%A5%E6%94%B6%E8%80%85%E7%B1%BB%E5%9E%8B.png" alt="实现接口的接收者类型"></p><p>​如图所示，不论上述代码中初始化的变量 <code>c</code> 是 <code>Cat&#123;&#125;</code> 还是 <code>&amp;Cat&#123;&#125;</code>，使用 <code>c.Quack()</code>方法时都会发生值拷贝：</p><ul><li>上图左侧，对于 <code>&amp;Cat</code> 来说，这意味着拷贝一个新的 <code>&amp;Cat&#123;&#125;</code> 指针，这个指针与原来的指针指向一个相同并且唯一的结构体，所以编译器可以隐式的对变量解引用来获取指针指向的结构体；</li><li>上图右侧，对于 <code>Cat&#123;&#125;</code>来说，这意味着 <code>Quack</code>方法会接受一个全新的 <code>Cat&#123;&#125;</code>，因为方法的参数是 <code>*Cat</code>，编译器不会无中生有创建一个新的指针；即使编译器可以创建新的指针，这个指针也无法指向最初调用该方法的结构体。</li></ul><p>​因此，当我们使用指针实现接口时，只有指针类型才会实现该接口；当我们使用结构体实现接口时，指针类型和结构体类型都会实现该接口。但这并不意味着我们应该统一使用结构体实现接口，这里只是做一个解释。</p><h5 id="nil-和-non-nil"><a href="#nil-和-non-nil" class="headerlink" title="nil 和 non-nil"></a>nil 和 non-nil</h5><p>​我们可以通过一个例子理解 <strong>Go  语言的接口类型不是任意类型</strong> 这句话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> TestStruct <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NilOrNot</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> v == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s *TestStruct<br>fmt.Println(s == <span class="hljs-literal">nil</span>)      <span class="hljs-comment">// #=&gt; true</span><br>fmt.Println(NilOrNot(s))   <span class="hljs-comment">// #=&gt; false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​简单总结一下上述代码：</p><ul><li>将上述变量与 <code>nil</code> 比较会返回 <code>true</code>；</li><li>将上述变量传入 <code>NilOrNot</code> 方法并与 <code>nil</code> 比较会返回 <code>false</code>；</li></ul><p>​出现上述现象的原因是 —— 调用 <code>NilOrNot</code> 函数时发生了 <strong>隐式类型转换</strong>，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在发生类型转换时， <code>*TestStruct</code> 类型转换成了 <code>interface&#123;&#125;</code> 类型，转换后的变量不仅包含转换前的变量值 <code>nil</code>，还包含变量的类型信息 <code>TestStruct</code>，所以转换后的变量与 <code>nil</code> 不相等。</p><h4 id="2、数据结构"><a href="#2、数据结构" class="headerlink" title="2、数据结构"></a>2、数据结构</h4><p>​从概述中，我们了解到Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：</p><ul><li>使用 <code>runtime.iface</code> 结构体表示包含方法的接口</li><li>使用<code>runtime.eface</code>结构体表示不包含方法的 <code>interface&#123;&#125;</code> 类型</li></ul><p>​<code>runtime.eface</code> 结构体在 Go 语言中的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;<br>_type *_type<br>data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>​由于 <code>interface&#123;&#125;</code> 不包含任何方法，所以它的结构体是比较简单的，只包含指向底层数据和结构的两个指针。因此不难看出，—— Go 语言的任意类型都可以转换成 <code>interface&#123;&#125;</code>。</p><p>​另一个用于表示接口的结构体是 <code>runtime.iface</code>，这个结构体中指向原始数据的指针 <code>data</code>，还有一个 <code>runtime.itab</code> 类型的 <code>tab</code> 字段。</p><p>​下面我们来分析一个 Go 语言接口中的这两个类型，即<code>runtime._type</code> 和 <code>runtime.itab</code>。</p><h5 id="类型结构体"><a href="#类型结构体" class="headerlink" title="类型结构体"></a>类型结构体</h5><p>​<code>runtime._type</code> 是 Go 语言类型的运行时表示。它包含很多类型的元信息，例如类型大小、哈希、对齐以及种类等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> _type <span class="hljs-keyword">struct</span> &#123;<br>size       <span class="hljs-type">uintptr</span>    <span class="hljs-comment">// 类型的大小（以字节为单位）</span><br>ptrdata    <span class="hljs-type">uintptr</span>    <span class="hljs-comment">// 指针数据的大小（以字节为单位），通常用于垃圾回收</span><br>hash       <span class="hljs-type">uint32</span>     <span class="hljs-comment">// 可能用于标识类型的散列值</span><br>tflag      tflag      <span class="hljs-comment">// 类型的标志（flag），描述类型的属性，例如是否可比较等</span><br>align      <span class="hljs-type">uint8</span>      <span class="hljs-comment">// 类型的对齐方式（以字节为单位）</span><br>fieldAlign <span class="hljs-type">uint8</span>      <span class="hljs-comment">// 结构体字段的对齐方式（以字节为单位）</span><br>kind       <span class="hljs-type">uint8</span>      <span class="hljs-comment">// 类型的种类，例如，不同值可以表示不同的类型，如字符串、整数等</span><br>equal      <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span> <span class="hljs-comment">// 用于比较两个该类型的值是否相等的函数</span><br>gcdata     *<span class="hljs-type">byte</span>      <span class="hljs-comment">// 可能与垃圾回收有关的数据</span><br>str        nameOff    <span class="hljs-comment">// 类型的名称，通常通过字符串表的索引来引用类型名称</span><br>ptrToThis  typeOff    <span class="hljs-comment">// 用于引用类型自身的偏移</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>size</code> 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li><li><code>hash</code> 字段能够帮助我们快速确定类型是否相等；</li><li><code>equal</code> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 <code>typeAlg</code> 结构体中迁移过来的<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:4">4</a>；</li></ul><p>​对该结构体中的字段，我们只需要有个大体的概念即可，不用详细理解所有字段的作用和意义。</p><h5 id="itab-结构体"><a href="#itab-结构体" class="headerlink" title="itab 结构体"></a>itab 结构体</h5><p><a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 结构体是接口类型的核心组成部分，每一个 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 都占 32 字节，我们可以将其看成接口类型和具体类型的组合，它们分别用 <code>inter</code> 和 <code>_type</code> 两个字段表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;<br>inter *interfacetype  <span class="hljs-comment">// 指向接口类型的指针</span><br>_type *_type          <span class="hljs-comment">// 指向具体类型的指针</span><br>hash  <span class="hljs-type">uint32</span>          <span class="hljs-comment">// 散列值，可能用于快速类型检查</span><br>_     [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>         <span class="hljs-comment">// 未使用的 4 字节填充</span><br>fun   [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span>      <span class="hljs-comment">// 包含一个指向类型方法的指针的数组</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>hash</code> 是对 <code>_typehash</code> 的拷贝，当我们想将 <code>interface</code> 类型转换成具体类型时，可以使用该字段快速判断目标类型和具体类型<code>runtime._type</code> 是否一致；</li><li><code>fun</code> 是一个动态大小的数组，用于动态派发的虚函数表，存储了一组函数指针。虽然该变量被声明成大小固定的数组，但是在使用时会通过原始指针获取其中的数据，所以 <code>fun</code> 数组中保存的元素数量是不确定的；</li></ul><p>​后面会对上述两个字段进行深入了解。</p><h4 id="3、类型转换"><a href="#3、类型转换" class="headerlink" title="3、类型转换"></a>3、类型转换</h4><p>​下面通过几个例子深入理解接口类型是如何初始化和传递的。</p><h5 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h5><p>​首先回到这一节开头提到的 <code>Duck</code> 接口的例子，我们使用 <code>//go:noinline</code> 指令<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/#fn:5">5</a>禁止 <code>Quack</code> 方法的内联编译：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">interface</span> &#123;<br>Quack()<br>&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">//go:noinline</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span></span> Quack() &#123;<br><span class="hljs-built_in">println</span>(c.Name + <span class="hljs-string">&quot; meow&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c Duck = &amp;Cat&#123;Name: <span class="hljs-string">&quot;draven&quot;</span>&#125;<br>c.Quack()<br>&#125;<br></code></pre></td></tr></table></figure><p>​我们使用编译器将上述代码编译成汇编语言、删掉一些对理解接口原理无用的指令并保留与赋值语句相关的代码，拆分成三部分：</p><ol><li>结构体 <code>Cat</code> 的初始化；</li><li>赋值触发的类型转换过程；</li><li>调用接口的方法 <code>Quack()</code>；</li></ol><p>我们先来分析结构体 <code>Cat</code> 的初始化过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">LEAQ<span class="hljs-keyword">type</span>.<span class="hljs-string">&quot;&quot;</span>.Cat(SB), AX                ;; AX = &amp;<span class="hljs-keyword">type</span>.<span class="hljs-string">&quot;&quot;</span>.Cat<br>MOVQAX, (SP)                           ;; SP = &amp;<span class="hljs-keyword">type</span>.<span class="hljs-string">&quot;&quot;</span>.Cat<br>CALLruntime.newobject(SB)              ;; SP + <span class="hljs-number">8</span> = &amp;Cat&#123;&#125;<br>MOVQ<span class="hljs-number">8</span>(SP), DI                          ;; DI = &amp;Cat&#123;&#125;<br>MOVQ$<span class="hljs-number">6</span>, <span class="hljs-number">8</span>(DI)                          ;; StringHeader(DI.Name).Len = <span class="hljs-number">6</span><br>LEAQ<span class="hljs-keyword">go</span>.<span class="hljs-type">string</span>.<span class="hljs-string">&quot;draven&quot;</span>(SB), AX         ;; AX = &amp;<span class="hljs-string">&quot;draven&quot;</span><br>MOVQAX, (DI)                           ;; StringHeader(DI.Name).Data = &amp;<span class="hljs-string">&quot;draven&quot;</span><br></code></pre></td></tr></table></figure><ol><li>获取 <code>Cat</code> 结构体类型指针并将其作为参数放到栈上；</li><li>通过 <code>CALL</code> 指定调用 <a href="https://draveness.me/golang/tree/runtime.newobject"><code>runtime.newobject</code></a> 函数，这个函数会以 <code>Cat</code> 结构体类型指针作为入参，分配一片新的内存空间并将指向这片内存空间的指针返回到 SP+8 上；</li><li>SP+8 现在存储了一个指向 <code>Cat</code> 结构体的指针，我们将栈上的指针拷贝到寄存器 <code>DI</code> 上方便操作；</li><li>由于 <code>Cat</code> 中只包含一个字符串类型的 <code>Name</code> 变量，所以在这里会分别将字符串地址 <code>&amp;&quot;draven&quot;</code> 和字符串长度 6 设置到结构体上，最后三行汇编指令等价于 <code>cat.Name = &quot;draven&quot;</code>；</li></ol><p>​字符串在运行时的表示是指针加上字符串长度，这里要看一下初始化之后的 <code>Cat</code> 结构体在内存中的表示是什么样的：</p><p><img src="/images/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88.png" alt="结构体指针"></p><p>因为 <code>Cat</code> 结构体的定义中只包含一个字符串，而字符串在 Go 语言中总共占 16 字节，所以每一个 <code>Cat</code> 结构体的大小都是 16 字节。初始化 <code>Cat</code> 结构体之后就进入了将 <code>*Cat</code> 转换成 <code>Duck</code> 类型的过程了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">LEAQ<span class="hljs-keyword">go</span>.itab.*<span class="hljs-string">&quot;&quot;</span>.Cat,<span class="hljs-string">&quot;&quot;</span>.Duck(SB), AX    ;; AX = *itab(<span class="hljs-keyword">go</span>.itab.*<span class="hljs-string">&quot;&quot;</span>.Cat,<span class="hljs-string">&quot;&quot;</span>.Duck)<br>MOVQDI, (SP)                           ;; SP = AX<br></code></pre></td></tr></table></figure><p>类型转换的过程比较简单，<code>Duck</code> 作为一个包含方法的接口，它在底层使用 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体表示。<a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体包含两个字段，其中一个是指向数据的指针，另一个是表示接口和结构体关系的 <code>tab</code> 字段，我们已经通过上一段代码 SP+8 初始化了 <code>Cat</code> 结构体指针，这段代码只是将编译期间生成的 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 结构体指针复制到 SP 上：</p><p><img src="/images/cat%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt="cat类型转换"></p><p>到这里，我们会发现 SP ~ SP+16 共同组成了 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体，而栈上的这个 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 也是 <code>Quack</code> 方法的第一个入参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">CALL    <span class="hljs-string">&quot;&quot;</span>.(*Cat).Quack(SB)                ;; SP.Quack()<br></code></pre></td></tr></table></figure><p>​上述代码会直接通过 <code>CALL</code> 指令完成方法的调用，细心的读者可能会发现一个问题 —— 为什么在代码中我们调用的是 <code>Duck.Quack</code> 但生成的汇编是 <code>*Cat.Quack</code> 呢？Go 语言的编译器会在编译期间将一些需要动态派发的方法调用改写成对目标方法的直接调用，以减少性能的额外开销。如果在这里禁用编译器优化，就会看到动态派发的过程，我们会在后面分析接口的动态派发以及性能上的额外开销。</p><h5 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h5><p>在这里我们继续修改上一节中的代码，使用结构体类型实现 <code>Duck</code> 接口并初始化结构体类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Duck <span class="hljs-keyword">interface</span> &#123;<br>Quack()<br>&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">//go:noinline</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span></span> Quack() &#123;<br><span class="hljs-built_in">println</span>(c.Name + <span class="hljs-string">&quot; meow&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c Duck = Cat&#123;Name: <span class="hljs-string">&quot;draven&quot;</span>&#125;<br>c.Quack()<br>&#125;<br></code></pre></td></tr></table></figure><p>编译上述代码会得到如下所示的汇编指令，需要注意的是为了代码更容易理解和分析，这里的汇编指令依然经过了删减，不过不影响具体的执行过程。与上一节一样，我们将汇编代码的执行过程分成以下几个部分：</p><ol><li>初始化 <code>Cat</code> 结构体；</li><li>完成从 <code>Cat</code> 到 <code>Duck</code> 接口的类型转换；</li><li>调用接口的 <code>Quack</code> 方法；</li></ol><p>我们先来看一下上述汇编代码中用于初始化 <code>Cat</code> 结构体的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">XORPS   X0, X0                          ;; X0 = <span class="hljs-number">0</span><br>MOVUPS  X0, <span class="hljs-string">&quot;&quot;</span>..autotmp_1+<span class="hljs-number">32</span>(SP)        ;; StringHeader(SP+<span class="hljs-number">32</span>).Data = <span class="hljs-number">0</span><br>LEAQ    <span class="hljs-keyword">go</span>.<span class="hljs-type">string</span>.<span class="hljs-string">&quot;draven&quot;</span>(SB), AX      ;; AX = &amp;<span class="hljs-string">&quot;draven&quot;</span><br>MOVQ    AX, <span class="hljs-string">&quot;&quot;</span>..autotmp_1+<span class="hljs-number">32</span>(SP)        ;; StringHeader(SP+<span class="hljs-number">32</span>).Data = AX<br>MOVQ    $<span class="hljs-number">6</span>, <span class="hljs-string">&quot;&quot;</span>..autotmp_1+<span class="hljs-number">40</span>(SP)        ;; StringHeader(SP+<span class="hljs-number">32</span>).Len = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>Go</p><p>这段汇编指令会在栈上初始化 <code>Cat</code> 结构体，而上一节的代码在堆上申请了 16 字节的内存空间，栈上只有一个指向 <code>Cat</code> 的指针。</p><p>初始化结构体后会进入类型转换的阶段，编译器会将 <code>go.itab.&quot;&quot;.Cat,&quot;&quot;.Duck</code> 的地址和指向 <code>Cat</code> 结构体的指针作为参数一并传入 <a href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">LEAQ<span class="hljs-keyword">go</span>.itab.<span class="hljs-string">&quot;&quot;</span>.Cat,<span class="hljs-string">&quot;&quot;</span>.Duck(SB), AX     ;; AX = &amp;(<span class="hljs-keyword">go</span>.itab.<span class="hljs-string">&quot;&quot;</span>.Cat,<span class="hljs-string">&quot;&quot;</span>.Duck)<br>MOVQAX, (SP)                           ;; SP = AX<br>LEAQ<span class="hljs-string">&quot;&quot;</span>..autotmp_1+<span class="hljs-number">32</span>(SP), AX           ;; AX = &amp;(SP+<span class="hljs-number">32</span>) = &amp;Cat&#123;Name: <span class="hljs-string">&quot;draven&quot;</span>&#125;<br>MOVQAX, <span class="hljs-number">8</span>(SP)                          ;; SP + <span class="hljs-number">8</span> = AX<br>CALLruntime.convT2I(SB)                ;; runtime.convT2I(SP, SP+<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>Go</p><p>这个函数会获取 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 中存储的类型，根据类型的大小申请一片内存空间并将 <code>elem</code> 指针中的内容拷贝到目标的内存中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convT2I</span><span class="hljs-params">(tab *itab, elem unsafe.Pointer)</span></span> (i iface) &#123;<br>t := tab._type<br>x := mallocgc(t.size, t, <span class="hljs-literal">true</span>)<br>typedmemmove(t, x, elem)<br>i.tab = tab<br>i.data = x<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go</p><p><a href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 会返回一个 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a>，其中包含 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 指针和 <code>Cat</code> 变量。当前函数返回之后，<code>main</code> 函数的栈上会包含以下数据：</p><p><img src="/images/%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0%E6%8C%87%E9%92%88.png" alt="结构体到指针"></p><p>SP 和 SP+8 中存储的 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 和 <code>Cat</code> 指针是 <a href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 函数的入参，这个函数的返回值位于 SP+16，是一个占 16 字节内存空间的 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体，SP+32 存储的是在栈上的 <code>Cat</code> 结构体，它会在 <a href="https://draveness.me/golang/tree/runtime.convT2I"><code>runtime.convT2I</code></a> 执行的过程中拷贝到堆上。</p><p>在最后，我们会通过以下的指令调用 <code>Cat</code> 实现的接口方法 <code>Quack()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">MOVQ<span class="hljs-number">16</span>(SP), AX ;; AX = &amp;(<span class="hljs-keyword">go</span>.itab.<span class="hljs-string">&quot;&quot;</span>.Cat,<span class="hljs-string">&quot;&quot;</span>.Duck)<br>MOVQ<span class="hljs-number">24</span>(SP), CX ;; CX = &amp;Cat&#123;Name: <span class="hljs-string">&quot;draven&quot;</span>&#125;<br>MOVQ<span class="hljs-number">24</span>(AX), AX ;; AX = AX.fun[<span class="hljs-number">0</span>] = Cat.Quack<br>MOVQCX, (SP)   ;; SP = CX<br>CALLAX         ;; CX.Quack()<br></code></pre></td></tr></table></figure><p>Go</p><p>这几个汇编指令还是非常好理解的，<code>MOVQ 24(AX), AX</code> 是最关键的指令，它从 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 结构体中取出 <code>Cat.Quack</code> 方法指针作为 <code>CALL</code> 指令调用时的参数。接口变量的第 24 字节是 <code>itab.fun</code> 数组开始的位置，由于 <code>Duck</code> 接口只包含一个方法，所以 <code>itab.fun[0]</code> 中存储的就是指向 <code>Quack</code> 方法的指针了。</p><h4 id="4、类型断言"><a href="#4、类型断言" class="headerlink" title="4、类型断言"></a>4、类型断言</h4><h4 id="5、动态派发"><a href="#5、动态派发" class="headerlink" title="5、动态派发"></a>5、动态派发</h4>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用</title>
      <link href="/2023/10/29/Go/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/2023/10/29/Go/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将从函数的调用惯例和参数传递方法两个方面分别介绍函数执行的过程。<span id="more"></span></p><h4 id="1、调用惯例"><a href="#1、调用惯例" class="headerlink" title="1、调用惯例"></a>1、调用惯例</h4><p>​对于不同的编程语言， 它们在调用函数的时候往往都使用相同的语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">somefunction(arg0, arg1)<br></code></pre></td></tr></table></figure><p>​虽然它们调用函数的语法相似，但它们的调用习惯可能大不相同。调用管理是调用方和被调用方对于参数和返回值传递的约定，下面会对 Go 语言和 C 语言的调用惯例进行讲解。</p><h5 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h5><p>​假设有以下 C 语言代码，包含一个主函数 <code>main</code> 和一个自定义函数 <code>my_function</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> arg1, <span class="hljs-type">int</span> arg2)</span> &#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i = my_function(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​编译成汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">main:<br>    pushq   %rbp            ; 保存主函数的栈帧<br>    movq    %rsp, %rbp      ; 设置主函数的栈帧<br>    subq    $<span class="hljs-number">16</span>, %rsp       ; 为局部变量分配 <span class="hljs-number">16</span> 字节的栈空间<br>    movl    $<span class="hljs-number">2</span>, %esi        ; 设置第二个参数 (esi = <span class="hljs-number">2</span>)<br>    movl    $<span class="hljs-number">1</span>, %edi        ; 设置第一个参数 (edi = <span class="hljs-number">1</span>)<br>    call    my_function     ; 调用 my_function<br>    movl    %eax, <span class="hljs-number">-4</span>(%rbp)  ; 将 my_function 的返回值保存在主函数的局部变量中<br>    ; 继续执行主函数的其它部分<br>my_function:<br>    pushq   %rbp            ; 保存 my_function 的栈帧<br>    movq    %rsp, %rbp      ; 设置 my_function 的栈帧<br>    movl    %edi, <span class="hljs-number">-4</span>(%rbp)  ; 将第一个参数从寄存器 edi 放入 my_function 的栈帧中<br>    movl    %esi, <span class="hljs-number">-8</span>(%rbp)  ; 将第二个参数从寄存器 esi 放入 my_function 的栈帧中<br>    movl    <span class="hljs-number">-8</span>(%rbp), %eax  ; 将第二个参数（esi）加载到寄存器 eax (eax = <span class="hljs-number">1</span>)<br>    movl    <span class="hljs-number">-4</span>(%rbp), %edx  ; 将第一个参数（edi）加载到寄存器 edx (edx = <span class="hljs-number">2</span>)<br>    addl    %edx, %eax      ; 计算 eax = eax + edx (eax = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">3</span>)<br>    popq    %rbp            ; 恢复 my_function 的栈帧<br>    ret                     ; 返回 my_function 的调用<br></code></pre></td></tr></table></figure><p>​我们按照调用前、调用时以及调用后的顺序分析上述调用过程：</p><ul><li>在 <code>my_function</code> 调用前，调用方 <code>main</code> 函数将 <code>my_function</code> 的两个参数分别存到 edi 和 esi 寄存器中；</li><li>在 <code>my_function</code> 调用时，它会将寄存器 edi 和 esi 中的数据存储到 eax 和 edx 两个寄存器中，随后通过汇编指令 <code>addl</code> 计算两个入参之和；</li><li>在 <code>my_function</code> 调用后，使用寄存器 eax 传递返回值，<code>main</code> 函数将 <code>my_function</code> 的返回值存储到栈上的 <code>i</code> 变量中；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> arg1, <span class="hljs-type">int</span> arg2, <span class="hljs-type">int</span> ... arg8)</span> &#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2 + ... + arg8;<br>&#125;<br></code></pre></td></tr></table></figure><p>​如上述代码所示，当 <code>my_function</code> 函数的入参增加至八个时，重新编译当前程序可以会得到不同的汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">main:<br>pushq%rbp<br>movq%rsp, %rbp<br>subq$<span class="hljs-number">16</span>, %rsp     <span class="hljs-comment">// 为参数传递申请 16 字节的栈空间</span><br>movl$<span class="hljs-number">8</span>, <span class="hljs-number">8</span>(%rsp)   <span class="hljs-comment">// 传递第 8 个参数</span><br>movl$<span class="hljs-number">7</span>, (%rsp)    <span class="hljs-comment">// 传递第 7 个参数</span><br>movl$<span class="hljs-number">6</span>, %r9d<br>movl$<span class="hljs-number">5</span>, %r8d<br>movl$<span class="hljs-number">4</span>, %ecx<br>movl$<span class="hljs-number">3</span>, %edx<br>movl$<span class="hljs-number">2</span>, %esi<br>movl$<span class="hljs-number">1</span>, %edi<br>callmy_function<br></code></pre></td></tr></table></figure><p>​<code>main</code> 函数调用 <code>my_function</code> 时，前六个参数会使用 edi、esi、edx、ecx、r8d 和 r9d 六个寄存器传递。寄存器的使用顺序也是调用惯例的一部分，函数的第一个参数一定会使用 edi 寄存去，第二个参数使用 esi 寄存器，以此推类。</p><p>​最后两个参数与前面完全不同，调用方 <code>main</code>函数通过栈传递这两个参数，下图展示了 <code>main</code> 函数在调用 <code>my_function</code> 前的栈信息：</p><p><img src="/images/main%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.png" alt="main函数栈帧"></p><p>​上图中 rbp 寄存器会存储函数调用栈的基址指针，即属于 <code>main</code> 函数的栈空间的起始位置，而另一个寄存器 rsp 存储的是 <code>main</code> 函数调用栈结束的位置，这两个寄存器共同表示了函数的栈空间。</p><p>​在调用 <code>my_function</code> 之前，<code>main</code> 函数通过 <code>subq $16, %rsp</code> 指令分配了 16 个字节的栈地址，随后将第六个以上的参数按照从右到左的顺序存入栈中，即第八个和第七个，余下的六个参数会通过寄存器传递，接下来运行的 <code>call my_function</code> 指令会调用 <code>my_function</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">my_function:<br>pushq%rbp<br>movq%rsp, %rbp<br>movl%edi, <span class="hljs-number">-4</span>(%rbp)    <span class="hljs-comment">// rbp-4 = edi = 1</span><br>movl%esi, <span class="hljs-number">-8</span>(%rbp)    <span class="hljs-comment">// rbp-8 = esi = 2</span><br>...<br>movl<span class="hljs-number">-8</span>(%rbp), %eax    <span class="hljs-comment">// eax = 2</span><br>movl<span class="hljs-number">-4</span>(%rbp), %edx    <span class="hljs-comment">// edx = 1</span><br>addl%eax, %edx        <span class="hljs-comment">// edx = eax + edx = 3</span><br>...<br>movl<span class="hljs-number">16</span>(%rbp), %eax    <span class="hljs-comment">// eax = 7</span><br>addl%eax, %edx        <span class="hljs-comment">// edx = eax + edx = 28</span><br>movl<span class="hljs-number">24</span>(%rbp), %eax    <span class="hljs-comment">// eax = 8</span><br>addl%edx, %eax        <span class="hljs-comment">// edx = eax + edx = 36</span><br>popq%rbp<br></code></pre></td></tr></table></figure><p>​<code>my_function</code> 会先将寄存器中的全部数据转移到栈上，然后利用 eax 寄存器计算所有入参的和并返回结果。</p><p>​总结一下的话就是：</p><ul><li>六个以及六个以下的参数，会按照顺序分别使用 edi、esi、edx、ecx、r8d、r9d 这六个寄存器传递；</li><li>六个以上的参数会使用栈传递，函数的参数会以从右到左的顺序依次存入栈中</li></ul><p>​而函数的返回值是通过 eax 寄存器进行传递的，由于只使用一个寄存器存储返回值，所以 C 语言的函数不能同时返回多个值。</p><h5 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h5><p>​同样，我们以一个简单的代码片段来分析 Go 语言函数的调用惯例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">return</span> a + b, a - b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>myFunction(<span class="hljs-number">66</span>, <span class="hljs-number">77</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​上述的 <code>myFunction</code> 函数接受两个整数并返回两个整数，<code>main</code> 函数在调用 <code>myFunction</code> 时将 66 和 77 两个参数传递到当前函数中，使用 <code>go tool compile -S -N -l main.go</code> 编译上述代码可以得到如下所示的汇编指令：</p><blockquote><p>如果编译时不使用 -N -l 参数，编译器会对汇编代码进行优化，编译结果会有较大差别。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&quot;&quot;</span>.main STEXT size=<span class="hljs-number">68</span> args=<span class="hljs-number">0x0</span> locals=<span class="hljs-number">0x28</span><br><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQ(TLS), CX       ; 将TLS（线程本地存储）中的指针加载到寄存器CX中<br><span class="hljs-number">0x0009</span> <span class="hljs-number">00009</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)CMPQSP, <span class="hljs-number">16</span>(CX)     ; 比较栈指针SP和<span class="hljs-number">16</span>(CX)中的值<br><span class="hljs-number">0x000d</span> <span class="hljs-number">00013</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)JLS<span class="hljs-number">61</span>              ; 如果SP小于等于<span class="hljs-number">16</span>(CX)，则跳转到偏移地址<span class="hljs-number">61</span><br><span class="hljs-number">0x000f</span> <span class="hljs-number">00015</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)SUBQ$<span class="hljs-number">40</span>, SP         ; 为局部变量分配<span class="hljs-number">40</span>字节的栈空间<br><span class="hljs-number">0x0013</span> <span class="hljs-number">00019</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQBP, <span class="hljs-number">32</span>(SP)      ; 将基址指针BP存储到<span class="hljs-number">32</span>(SP)中<br><span class="hljs-number">0x0018</span> <span class="hljs-number">00024</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)LEAQ<span class="hljs-number">32</span>(SP), BP      ; 设置BP为<span class="hljs-number">32</span>(SP)<br><span class="hljs-number">0x001d</span> <span class="hljs-number">00029</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>)MOVQ$<span class="hljs-number">66</span>, (SP)       ; 将值<span class="hljs-number">66</span>存储到栈上的位置(SP)<br><span class="hljs-number">0x0025</span> <span class="hljs-number">00037</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>)MOVQ$<span class="hljs-number">77</span>, <span class="hljs-number">8</span>(SP)      ; 将值<span class="hljs-number">77</span>存储到栈上的位置<span class="hljs-number">8</span>(SP)<br><span class="hljs-number">0x002e</span> <span class="hljs-number">00046</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>)CALL<span class="hljs-string">&quot;&quot;</span>.myFunction(SB) ; 调用函数myFunction<br><br><span class="hljs-number">0x0033</span> <span class="hljs-number">00051</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)MOVQ<span class="hljs-number">32</span>(SP), BP      ; 恢复基址指针BP<br><span class="hljs-number">0x0038</span> <span class="hljs-number">00056</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)ADDQ$<span class="hljs-number">40</span>, SP         ; 恢复栈指针SP<br><span class="hljs-number">0x003c</span> <span class="hljs-number">00060</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)RET                 ; 返回<br></code></pre></td></tr></table></figure><p>​根据 <code>main</code> 函数生成的汇编指令，我们可以分析出 <code>main</code> 函数调用 <code>myFunction</code> 之前的栈：</p><p><img src="/images/go%E8%AF%AD%E8%A8%80main%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.png" alt="go语言main函数栈帧"></p><p>​<code>main</code> 函数通过 <code>SUBQ $40, SP</code> 指令一共在栈上分配了 40 字节的内存空间</p><table><thead><tr><th>空间</th><th>大小</th><th>作用</th></tr></thead><tbody><tr><td>SP+32 ~ BP</td><td>8 字节</td><td><code>main</code> 函数的栈基址指针</td></tr><tr><td>SP+16 ~ SP+32</td><td>16 字节</td><td>函数 <code>myFunction</code> 的两个返回值</td></tr><tr><td>SP ~ SP+16</td><td>16 字节</td><td>函数 <code>myFunction</code> 的两个参数</td></tr></tbody></table><p>​<code>myFunction</code> 入参的压栈顺序和 C 语言一样，也是从右到左，即第一个参数 66 在栈顶的 SP ~ SP+8，第二个参数存储在 SP+8 ~ SP+16 的空间中。</p><p>​当我们准备好函数的入参之后，会调用汇编指令 <code>CALL &quot;&quot;.myFunction(SB)</code>，这个指令首先会将 <code>main</code> 的返回地址存入栈中，然后改变当前的栈指针 SP 并执行 <code>myFunction</code> 的汇编指令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&quot;&quot;</span>.myFunction STEXT nosplit size=<span class="hljs-number">49</span> args=<span class="hljs-number">0x20</span> locals=<span class="hljs-number">0x0</span><br><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">3</span>)MOVQ$<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>.~r2+<span class="hljs-number">24</span>(SP) <span class="hljs-comment">// 初始化第一个返回值</span><br><span class="hljs-number">0x0009</span> <span class="hljs-number">00009</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">3</span>)MOVQ$<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>.~r3+<span class="hljs-number">32</span>(SP) <span class="hljs-comment">// 初始化第二个返回值</span><br><span class="hljs-number">0x0012</span> <span class="hljs-number">00018</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>)MOVQ<span class="hljs-string">&quot;&quot;</span>.a+<span class="hljs-number">8</span>(SP), AX    <span class="hljs-comment">// AX = 66</span><br><span class="hljs-number">0x0017</span> <span class="hljs-number">00023</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>)ADDQ<span class="hljs-string">&quot;&quot;</span>.b+<span class="hljs-number">16</span>(SP), AX   <span class="hljs-comment">// AX = AX + 77 = 143</span><br><span class="hljs-number">0x001c</span> <span class="hljs-number">00028</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>)MOVQAX, <span class="hljs-string">&quot;&quot;</span>.~r2+<span class="hljs-number">24</span>(SP) <span class="hljs-comment">// (24)SP = AX = 143</span><br><span class="hljs-number">0x0021</span> <span class="hljs-number">00033</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>)MOVQ<span class="hljs-string">&quot;&quot;</span>.a+<span class="hljs-number">8</span>(SP), AX    <span class="hljs-comment">// AX = 66</span><br><span class="hljs-number">0x0026</span> <span class="hljs-number">00038</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>)SUBQ<span class="hljs-string">&quot;&quot;</span>.b+<span class="hljs-number">16</span>(SP), AX   <span class="hljs-comment">// AX = AX - 77 = -11</span><br><span class="hljs-number">0x002b</span> <span class="hljs-number">00043</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>)MOVQAX, <span class="hljs-string">&quot;&quot;</span>.~r3+<span class="hljs-number">32</span>(SP) <span class="hljs-comment">// (32)SP = AX = -11</span><br><span class="hljs-number">0x0030</span> <span class="hljs-number">00048</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>)RET<br></code></pre></td></tr></table></figure><p>​从上述的汇编代码中我们可以看出，当前函数在执行时首先会将 <code>main</code> 函数中预留的两个返回值地址置成 <code>int</code> 类型的默认值 0，然后根据栈的相对位置获取参数并进行加减操作并将值存回栈中，在 <code>myFunction</code> 函数返回之间，栈中的数据如下图所示：</p><p><img src="/images/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%89%8D%E7%9A%84%E6%A0%88.png" alt="函数返回前的栈"></p><p>在 <code>myFunction</code> 返回后，<code>main</code> 函数会通过以下的指令来恢复栈基址指针并销毁已经失去作用的 40 字节栈内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0x0033</span> <span class="hljs-number">00051</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)    MOVQ    <span class="hljs-number">32</span>(SP), BP<br><span class="hljs-number">0x0038</span> <span class="hljs-number">00056</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)    ADDQ    $<span class="hljs-number">40</span>, SP<br><span class="hljs-number">0x003c</span> <span class="hljs-number">00060</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)    RET<br></code></pre></td></tr></table></figure><p>​通过分析 Go 语言编译后的汇编指令，我们发现 <strong>Go 语言使用栈传递参数和接收返回值，所以它只需要在栈上多分配一些内存就可以返回多个值。</strong></p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>​Go 语言和 C 语言在设计函数的调用惯例时选择了不同实现方法。C 语言同时使用寄存器和栈传递参数，使用 eax 寄存器传递返回值；而 Go 语言使用栈传递参数和返回值。这两种设计的优缺点如下：</p><ul><li><p>C 语言的方式能够大幅度减少函数调用时的额外开销，但也增加了实现的复杂度</p><ul><li>CPU 访问栈的开销比访问寄存器高几十倍</li><li>需要单独处理函数参数过多的情况。</li></ul></li><li><p>Go 语言实现的方式能够降低实现的复杂度并支持多返回值，但是牺牲了函数调用的性能：</p><ul><li>不需要考虑超过寄存器数量的参数应该如何传递</li><li>不需要考虑不同架构上寄存器差异</li><li>函数入参和出参的内存空间需要在栈上进行分配</li></ul></li></ul><p>​Go 语言使用栈作为参数的返回值传递的方法是综合考虑后的设计，这样意味着编译器会更加简单、更容易维护</p><h4 id="2、参数传递"><a href="#2、参数传递" class="headerlink" title="2、参数传递"></a>2、参数传递</h4><p>​除了函数的调用惯例之外，我们还需要关心的另一个问题就是：Go 语言在参数传递时时传值还是传引用，不同的方式会影响我们的函数中修改入参时是否会影响我们的原数据。</p><ul><li>传值：函数调用时会对参数进行拷贝，被调用方和调用方两者持有不相关的两份数据；</li><li>传引用：函数调用时会传递参数的指针，被调用方和调用方两者持有相同数据，任意一方做出修改都会影响到另一方。</li></ul><p>​在 Go 语言中，参数传递的方式是传值，也就是说：不论是传递基本类型、结构体还是指针，都会对传递的参数进行拷贝。</p><h5 id="整型和数组"><a href="#整型和数组" class="headerlink" title="整型和数组"></a>整型和数组</h5><p>​如下示例，我们在 <code>myFunction</code> 内和 <code>main</code> 函数内分别打印参数的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(i <span class="hljs-type">int</span>, arr [2]<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&quot;</span>, i, &amp;i, arr, &amp;arr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">30</span><br>arr := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">66</span>, <span class="hljs-number">77</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;before calling - i=(%d, %p) arr=(%v, %p)\n&quot;</span>, i, &amp;i, arr, &amp;arr)<br>myFunction(i, arr)<br>fmt.Printf(<span class="hljs-string">&quot;after  calling - i=(%d, %p) arr=(%v, %p)\n&quot;</span>, i, &amp;i, arr, &amp;arr)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>before calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc00009a000</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc00009a010</span>)<br>in my_funciton - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc00009a008</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc00009a020</span>)<br>after  calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc00009a000</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc00009a010</span>)<br></code></pre></td></tr></table></figure><p>​会发现，<code>main</code> 函数和被调用者 <code>myFunction</code> 中参数的地址是完全不同的。</p><p>​不过从 <code>main</code> 函数的角度来看，在调用 <code>myFunction</code> 前后，整数 <code>i</code> 和数组 <code>arr</code> 两个参数的地址都没有变化。</p><p>​然后我们试着在 <code>myFunction</code> 函数中对参数进行修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(i <span class="hljs-type">int</span>, arr [2]<span class="hljs-type">int</span>)</span></span> &#123;<br>i = <span class="hljs-number">29</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">88</span><br>fmt.Printf(<span class="hljs-string">&quot;in my_funciton - i=(%d, %p) arr=(%v, %p)\n&quot;</span>, i, &amp;i, arr, &amp;arr)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>before calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc000072008</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc000072010</span>)<br>in my_funciton - i=(<span class="hljs-number">29</span>, <span class="hljs-number">0xc000072028</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">88</span>], <span class="hljs-number">0xc000072040</span>)<br>after  calling - i=(<span class="hljs-number">30</span>, <span class="hljs-number">0xc000072008</span>) arr=([<span class="hljs-number">66</span> <span class="hljs-number">77</span>], <span class="hljs-number">0xc000072010</span>)<br></code></pre></td></tr></table></figure><p>​发现 <code>myFunction</code> 中对参数的修改也就仅仅影响了当前函数，并没有影响调用方 <code>main</code> 函数中的值。所以：<strong>Go 语言中对于基本类型和数组都是值传递的</strong>，即调用函数时会对参数进行拷贝。所以我们在传参的时候，如果参数所占空间特别大，这张传值的方式会特别影响性能。</p><h5 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h5><p>​然后再可靠另外两种结构体和指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(a MyStruct, b *MyStruct)</span></span> &#123;<br>a.i = <span class="hljs-number">31</span><br>b.i = <span class="hljs-number">41</span><br>fmt.Printf(<span class="hljs-string">&quot;in my_function - a=(%d, %p) b=(%v, %p)\n&quot;</span>, a, &amp;a, b, &amp;b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := MyStruct&#123;i: <span class="hljs-number">30</span>&#125;<br>b := &amp;MyStruct&#123;i: <span class="hljs-number">40</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;before calling - a=(%d, %p) b=(%v, %p)\n&quot;</span>, a, &amp;a, b, &amp;b)<br>myFunction(a, b)<br>fmt.Printf(<span class="hljs-string">&quot;after calling  - a=(%d, %p) b=(%v, %p)\n&quot;</span>, a, &amp;a, b, &amp;b)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>before calling - a=(&#123;<span class="hljs-number">30</span>&#125;, <span class="hljs-number">0xc000018178</span>) b=(&amp;&#123;<span class="hljs-number">40</span>&#125;, <span class="hljs-number">0xc00000c028</span>)<br>in my_function - a=(&#123;<span class="hljs-number">31</span>&#125;, <span class="hljs-number">0xc000018198</span>) b=(&amp;&#123;<span class="hljs-number">41</span>&#125;, <span class="hljs-number">0xc00000c038</span>)<br>after calling  - a=(&#123;<span class="hljs-number">30</span>&#125;, <span class="hljs-number">0xc000018178</span>) b=(&amp;&#123;<span class="hljs-number">41</span>&#125;, <span class="hljs-number">0xc00000c028</span>)<br></code></pre></td></tr></table></figure><p>​从结果可以得出结果：</p><ul><li>传递结构体时：会拷贝结构体中的全部内容</li><li>传递结构体指针时：会拷贝结构体指针</li></ul><p>​修改结构体指针指向的内容，相当于改变了指针指向的结构体，所以在函数内部对结构体的修改是可以被 <code>main</code> 函数看到的。</p><p>​我们简单修改上述代码，分析一下 Go 语言结构体在内存中的布局：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>j <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(ms *MyStruct)</span></span> &#123;<br>ptr := unsafe.Pointer(ms)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>c := (*<span class="hljs-type">int</span>)(unsafe.Pointer((<span class="hljs-type">uintptr</span>(ptr) + <span class="hljs-type">uintptr</span>(<span class="hljs-number">8</span>*i))))<br>*c += i + <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;[%p] %d\n&quot;</span>, c, *c)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := &amp;MyStruct&#123;i: <span class="hljs-number">40</span>, j: <span class="hljs-number">50</span>&#125;<br>myFunction(a)<br>fmt.Printf(<span class="hljs-string">&quot;[%p] %v\n&quot;</span>, a, a)<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span><br>[<span class="hljs-number">0xc000018180</span>] <span class="hljs-number">41</span><br>[<span class="hljs-number">0xc000018188</span>] <span class="hljs-number">52</span><br>[<span class="hljs-number">0xc000018180</span>] &amp;&#123;<span class="hljs-number">41</span> <span class="hljs-number">52</span>&#125;<br></code></pre></td></tr></table></figure><p>​从打印的地址可以看出，结构体在内存中是一片连续的内存空间，指向结构体的指针也就指向结构体的首地址。我们可以通过 通用指针类型<code>unsafe.Pointer</code>  和 指针运算类型<code>uintptr</code> 将普通指针进行转化和计算，可以通过偏移指针来访问对应的结构体的元素。</p><p>​如果我们将上述代码简化成如下所示的代码片段并使用 <code>go tool compile</code> 进行编译会得到如下的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStruct <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>j <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(ms *MyStruct)</span></span> *MyStruct &#123;<br><span class="hljs-keyword">return</span> ms<br>&#125;<br><br>$ <span class="hljs-keyword">go</span> tool compile -S -N -l main.<span class="hljs-keyword">go</span><br><span class="hljs-string">&quot;&quot;</span>.myFunction STEXT nosplit size=<span class="hljs-number">20</span> args=<span class="hljs-number">0x10</span> locals=<span class="hljs-number">0x0</span><br><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>)MOVQ$<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>.~r1+<span class="hljs-number">16</span>(SP) <span class="hljs-comment">// 初始化返回值</span><br><span class="hljs-number">0x0009</span> <span class="hljs-number">00009</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)MOVQ<span class="hljs-string">&quot;&quot;</span>.ms+<span class="hljs-number">8</span>(SP), AX   <span class="hljs-comment">// 复制引用</span><br><span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)MOVQAX, <span class="hljs-string">&quot;&quot;</span>.~r1+<span class="hljs-number">16</span>(SP) <span class="hljs-comment">// 返回引用</span><br><span class="hljs-number">0x0013</span> <span class="hljs-number">00019</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>)RET<br></code></pre></td></tr></table></figure><p>​在这段汇编语言中，我们发现当参数是指针时，也会使用 <code>MOVQ &quot;&quot;.ms+8(SP), AX</code> 指令复制引用，然后将复制后的指针作为返回值传递回调用方。</p><p><img src="/images/Go%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0.png" alt="Go语言指针参数"></p><p>​所以指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间。<strong>所以 Go 语言中传指针也是传值</strong>。</p><h5 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h5><p>当我们验证了 Go 语言中大多数常见的数据结构之后，其实能够推测出 Go 语言在传递参数时使用了传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。</p><h4 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h4><p>​本文讲述了 Go 语言函数的调用惯例，是使用栈传递参数和返回值的，在调用函数之前会在栈上为返回值分配合适的内存空间，随后将入参从右到左按顺序压栈并拷贝参数，返回值会被存储到调用方预先留好的存储空间上。</p><p>​关于 Go 语言函数调用，可以总结以下几点：</p><ol><li>通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右；</li><li>函数返回值通过堆栈传递并由调用者预先分配内存空间；</li><li>调用函数时都是传值，接收方会对入参进行复制再计算；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何确保消息不会丢失</title>
      <link href="/2023/10/27/MQ/%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1/"/>
      <url>/2023/10/27/MQ/%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<p>​很多人刚开始接触消息队列的时候，最经常遇到的一个问题就是丢消息了。<span id="more"></span>对于大部分业务来说，丢消息意味着丢数据，是完全无法接受的。</p><p>​现在很多主流的消息队列都实现了完善的消息可靠性保证机制，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。</p><p>​所以，绝大部分丢消息的原因都是开发者不熟悉消息队列，没有正确地使用和配置造成的。下面我们一起来了解下消息队列是如何保证消息可靠传递的，只要熟知原理，就能很快知道如何配置消息队列，写出可靠的代码，避免消息丢失。</p><h1 id="检查消息队列的方法"><a href="#检查消息队列的方法" class="headerlink" title="检查消息队列的方法"></a>检查消息队列的方法</h1><p>​用消息队列最尴尬的情况不是丢消息，而是丢了消息还不知道。对于一个刚刚上线的系统，各方面肯定都不是很稳定，这个时候就特别许需要监控系统中是否有消息丢失的情况。</p><p>​如果是对于一些基础设施比较完善的公司，可以使用分布式链路追踪系统，很方便地追踪每一条消息。如果没有的话，下面提供一种简答的方法，来检查是否有消息丢失的情况。</p><p>​<strong>我们可以使用消息队列的有序性来验证是否有消息丢失</strong>。原理很简单，在 Producer 端，我们给每个发出的消息附加一个连续递增的序列号，在 Consumer 端来检查这个序列号的连续性。</p><p>​如果没有消息队列，Consumer 端收到消息的序列号必然是递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 + 1.如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号确定丢失的是哪条消息，方便进一步排查原因和补救。</p><p>​大多数消息队列的客户端都支持<strong>拦截器</strong>，可以利用这个拦截器机制，在 Producer 发送消息之前的拦截器中将序号注入到消息中，在 Consumer 收到消息的拦截器中检测序号的连续性。这样实现的好处是：消息检测的代码不会入侵到业务代码中，待系统稳定后，也方便将这部分代码检测的逻辑关闭或者删除。</p><p>​如果在一个分布式系统中实现了这个检测机制，有以下几个问题需要注意：</p><ol><li>像 Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的 ，只能保证队列或分区上的消息是有序的，所以我们在发送消息的时候要指定分区，并且每个分区单独检测消息序号的连续性。</li><li>如果系统中 Producer 是多实例的，由于多个 Producer 并不好协调彼此之间的发送顺序，所以每个 Producer 分别生成各自的消息序号，并且需要附加 Producer 标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。</li><li>Consumer 实例的数量最好是和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便在 Consumer 内检测消息序号的连续性。</li></ol><h1 id="确保信息可靠传递"><a href="#确保信息可靠传递" class="headerlink" title="确保信息可靠传递"></a>确保信息可靠传递</h1><p>​上面讲述了如何检测消息丢失，下面再来看看什么时候会发生消息丢失，该如何避免。</p><p>​消息从生产到消费完成整个过程，可以分为下面三个阶段：</p><p><img src="/images/%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E5%88%B0%E6%B6%88%E8%B4%B9.png" alt="消息生产到消费"></p><ul><li><strong>生产阶段</strong>：在这个阶段，消息在 Producer 创建出来，经过网络传输发送到 Broker 端。</li><li><strong>存储阶段</strong>：在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。</li><li><strong>消费阶段</strong>：在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。</li></ul><h4 id="1、生产阶段"><a href="#1、生产阶段" class="headerlink" title="1、生产阶段"></a>1、生产阶段</h4><p>​在生产阶段，消息队列通过最常用的请求确认机制来保证消息的可靠传递：代码中调用发送消息的方法时，消息队列的客户端会把消息发送到 Broker，Broker 收到消息后，会给客户端返回一个确认响应，表明消息已经收到。客户端收到响应后，一次正常的消息发送就完成了。</p><p>​只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到确认响应后，会自动重试，如果还是失败，就会以返回值或者异常的方式告知调用方。</p><p>​<strong>在编写发送消息代码时，通过正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失了。</strong>以 Kafka 为例，我们看一下如何可靠地发送消息：</p><p>​同步发送时，只要注意捕获异常即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">partition, offset, err := producer.SendMessage(message)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;消息发送失败:&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;消息发送成功，分区：%d, 偏移：%d\n&quot;</span>, partition, offset)<br>&#125;<br></code></pre></td></tr></table></figure><p>​异步发送时，需要去异步检查返回值，并进行处理：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">producer.Input() &lt;- message<br><br>select &#123;<br><span class="hljs-keyword">case</span> &lt;-producer.Successes():<br>    fmt.Println(<span class="hljs-string">&quot;消息发送成功&quot;</span>)<br><span class="hljs-keyword">case</span> err := &lt;-producer.Errors():<br>    fmt.Println(<span class="hljs-string">&quot;消息发送失败:&quot;</span>, err.Err)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、存储阶段"><a href="#2、存储阶段" class="headerlink" title="2、存储阶段"></a>2、存储阶段</h4><p>​在存储阶段，只要 Borker 不出现故障，比如进程死掉了或者服务器宕机了，就不会出现丢失消息的问题。但如果出现了的话， 还是可能会丢失消息的。</p><p>​<strong>如果对于消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢失消息</strong>。</p><p>​对于单个节点的 Broker，需要配置 Broker 参数，在收到消息后将消息写入磁盘，再给 Producer 返回确认响应。这样即使发生宕机，由于消息已经写入磁盘，恢复后还可以继续消费。例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配置为 SYNC_FLUSH 同步刷盘。</p><p>​如果 Borker 是由多个节点组成的集群，需要将 Borker 集群配置成：至少消息发送到 2 个以上的节点，再给客户端回复发送确认响应。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会造成消息的丢失。</p><h4 id="3、消费阶段"><a href="#3、消费阶段" class="headerlink" title="3、消费阶段"></a>3、消费阶段</h4><p>​消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递。客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，成功后，才会给 Broker 发送消费确认响应。如果 Broker 没有收到消息的消费确认响应，下次拉消息的时候还是会返回同一条消息，以此来确保消息不会在网络传输过程中丢失，也不会因为客户端执行消费逻辑中出错导致丢失。</p><p>​在编写代码的过程中，<strong>需要注意，不要在收到消息后立马返回消息确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</strong></p><p>​同样，我们使用 golang 语言消费 RabbitMQ 消息为例，看看如何实现一段可靠的消费代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">forever := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> d := <span class="hljs-keyword">range</span> msgs &#123;<br>        body := d.Body<br>        fmt.Printf(<span class="hljs-string">&quot; [x] 收到消息 %s\n&quot;</span>, body)<br><br>        <span class="hljs-comment">// 在这里处理收到的消息</span><br>        <span class="hljs-comment">// 你可以在这里调用 database.save(body) 来保存消息</span><br><br>        fmt.Println(<span class="hljs-string">&quot; [x] 消费完成&quot;</span>)<br><br>        <span class="hljs-comment">// 完成消费业务逻辑后发送消费确认响应</span><br>        d.Ack(<span class="hljs-literal">false</span>)<br>    &#125;<br>&#125;()<br><br>log.Printf(<span class="hljs-string">&quot;等待消息。要退出，请按 CTRL+C&quot;</span>)<br>&lt;-forever<br></code></pre></td></tr></table></figure><p>​正确的顺序时，先把消息保存到数据库中，然后再发送消费确认。这样如果保存消息失败了，就不会执行消费代码，下次拉取的还是这条消息，直到消费成功。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>​这一篇文章，先讲述了在系统中，如果检查消息队列消息丢失的情况，然后分析了一条消息从发送到消费成功的整个过程，以及消息队列是如何确保消息的可靠性，不会丢失的。这个过程可以分为分三个阶段，每个阶段都需要正确的编写代码并且设置正确的配置项，才能配合消息队列的可靠性机制，确保消息不会丢失。</p><ul><li>在生产阶段，你需要捕获消息发送的错误，并重发消息。</li><li>在存储阶段，你可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，来确保消息不会因为某个 Broker 宕机或者磁盘损坏而丢失。</li><li>在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。</li></ul><p>​知道这几个阶段的原理后，如果再出现丢消息的情况，可以通过在代码中加一些日志的方式，很快定位到是哪个阶段出了问题，然后再进一步分析，快速找到问题的原因。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用事务消息实现分布式事务？</title>
      <link href="/2023/10/26/MQ/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF/"/>
      <url>/2023/10/26/MQ/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>​本文来聊一聊消息队列过程中消息重复怎么办？<span id="more"></span></p><p>​在消息传递过程中，如果出现消息传递失败，发送方就会进行重试，重试过程中就有可能产生重复的消息。对于使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。</p><p>​比如一个消费订单的系统，统计下单金额的微服务，如果没有正确处理重复消息，就会出现重复统计，导致结果错误。</p><p>​处理重复消息可以从两个方面进行考虑：</p><ol><li>消息队列本身保证消息不重复</li><li>业务实现幂等</li></ol><h1 id="消息重复的情况是必然存在的"><a href="#消息重复的情况是必然存在的" class="headerlink" title="消息重复的情况是必然存在的"></a>消息重复的情况是必然存在的</h1><p>​在 MQTT 协议中，针对传递消息能够提供的服务质量标准，提供了三种不同服务质量的定义，这三种服务质量从低到高依次是：</p><ul><li><strong>At most once：</strong> 至多一次。在消息传递时，最多被送达一次，这意味着无法保证消息可靠性，允许丢数据。适用于对消息可靠性要求不高的监控场景，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。</li><li><strong>At least once：</strong>至少一次。消息在传递时，至少会被送达一次，即不允许丢消息，但允许有少量重复消息出现。例如，金融交易处理系统通常采用至少一次传递，因为在这种场景中，任何一笔交易都不能丢失，但允许某些交易重复。虽然会有一些额外的重复处理工作，但系统必须保证每笔交易都会被处理。</li><li><strong>Exactly once：</strong>恰好一次。消息在传递时，只会被送达一次。这个是最高等级。比如电信行业的通信系统可能采用恰好一次传递标准，以确保不仅数据不会丢失，而且不会发送重复的短信或通话记录。</li></ul><p>​上述的服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。我们常用的消息队列提供的服务都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka。所以消息队列是很难保证消息不重复的。</p><p>​因此我们想要保证消息不重复，就需要我们的代码中能接受 “ 消息可能会重复” 这一现状，然后通过一些方法来消除重复消息对业务的影响。</p><blockquote><p>​有人会说，“Kafka 的文档中说它是支持 Exactly once 的。”，但其实 Kafka 所支持的 “Exactly once” 和我们刚刚提到的服务质量标准 “Exactly once” 是不一样的，它是 Kafka 提供的另一个特性。</p></blockquote><h1 id="用幂等性解决消息重复问题"><a href="#用幂等性解决消息重复问题" class="headerlink" title="用幂等性解决消息重复问题"></a>用幂等性解决消息重复问题</h1><p>​通常解决重复消息的办法是：在消费端，让消费消息的操作具备幂等性。</p><blockquote><p>幂等性：幂等原本是数学上的一个概念，后来被拓展到计算机领域，被用来描述一个操作、方法或者服务。一个幂等操作的特点是：<strong>其任意执行多次所产生的影响均与执行一次的影响相同。</strong></p></blockquote><p>​一个幂等的方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。</p><p>​举个例子，在不考虑并发的情况下，“将账户 X 的余额设置为 100 元”，执行一次和多次的最终结果都是 “账户 X 的余额设置为 100 元”。只要提供的参数 100 元不变，这个操作就是一个幂等的操作。</p><p>​再举一个例子，“将账户 X 的余额加 100 元”，这个操作它就不是幂等的，每执行一次，账户余额就会增加 100 元，执行多次和执行一次对系统的影响（也就是账户的余额）是不一样的。</p><p>​因此我们只要保证消费消息的逻辑是幂等的，就不用担心重复消息的执行会对系统造成任何改变。</p><p>​于是我们可以总结出一个 “公式” ：</p><p>​从对系统的影响结果来说：<strong>At least once + 幂等消费 &#x3D; Exactly once。</strong></p><p>​由于并不是所有的业务都能设计成天然幂等的，因此需要一些方法和技巧来实现幂等，下面就来介绍几种常用的设计幂等操作的方法：</p><h4 id="1、利用数据库的唯一约束实现幂等"><a href="#1、利用数据库的唯一约束实现幂等" class="headerlink" title="1、利用数据库的唯一约束实现幂等"></a>1、利用数据库的唯一约束实现幂等</h4><p>​例如上面的那个不具备幂等特性的转账的例子：将账户 X 的余额加  100 元。我们可以通过修改业务逻辑，让它具备幂等性。</p><p>​我们可以通过限定，每个账单每个用户只能执行一次变更操作。在分布式系统中，这个限制实现的方法非常多，最简单的是我们在数据库中建一张转账流水表，这个表有三个字段：转账单 ID、账户 ID 和变更金额，然后给账单 ID 和账户 ID 这两个字段创建一个联合的唯一约束，这样对于相同的转账单 ID 和账户 ID，表里只能存在一条记录。</p><p>​这样我们消费信息的逻辑就变成了：” 在流水表中增加一条转账记录，然后根据转账记录，异步更新用户余额即可 。“ 在流水表增加一条记录这个操作，由于存在唯一约束，故对于同一个账单同一个账户 只能插入一条记录，后续重复插入都会失败，这样就实现了幂等的操作。<strong>我们只要写一个 SQL，正确实现它就可以了。</strong></p><h4 id="2、为更新的数据设置前置条件"><a href="#2、为更新的数据设置前置条件" class="headerlink" title="2、为更新的数据设置前置条件"></a>2、为更新的数据设置前置条件</h4><p>​另一种实现幂等的思路就是，给数据变更设置一个前置条件，如果满足条件就更新数据，否则就拒绝更新，在更新数据的时候，同时变更前置条件中需要判断的数据。后续执行重复操作的时候，由于第一次更新的时候已经修改了前置条件中的判断依据，不满足前置条件，则不会重复执行更新数据操作。</p><p>​还是上面说的那个例子中，”将账户 X 的余额增加 100 元“ 这个操作不具备幂等性，我们可以给这个操作加上一个前置条件，变为：”如果账户余额为 500 元，就将余额加 100 元“，这下该操作就具备幂等性了。同样对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否满足前置条件，只有满足，才能执行变更操作。</p><p>​另一种更为通用的方法是，给数据增加一个版本号属性，每次更新数据前，判断当前版本号和消息中的版本号是否一致，如果不一致就拒绝更新数据，更新数据的时候同时将版本号 + 1，这样也可以实现幂等。</p><h4 id="3、记录并检查操作"><a href="#3、记录并检查操作" class="headerlink" title="3、记录并检查操作"></a>3、记录并检查操作</h4><p>​上面两种方法其实并不是万能的，如果恰好也不适用于你的场景，还有一种通用性最强，适用范围最广的实现幂等方法：<strong>记录并检查操作</strong>，也称 ”Token 机制或 GUID（全局唯一 ID）机制“，实现的思路很简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。</p><p>​具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一 ID，消费时先检查这个 ID 是否被消费过，如果没有被消费过，才更新数据，然后将该 ID 的消费状态设置为已消费。</p><p>​原理和实现看似都很简单，但在分布式系统中是非常难实现的。首先，需要给每个消息都指定一个全局唯一 ID，这件事本身就不简单，方法有很多，但都不太好同时满足简单、高可用和高性能，或多或少都会有些牺牲。</p><p>​更麻烦的是，在 ”检查消费状态，然后更新数据并设置消费状态“ 中，三个操作必须为一组且具备原子性，才能真正实现幂等。对于这个问题，当然我们可以用事务来实现，也可以用锁来实现，但是在分布式系统中，无论是分布式事务还是分布式锁都是比较难解决问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>​这篇文章，我们了解到消息队列在使用中可能会出现消息重复的问题，并介绍了几种通过实现幂等的操作来避免消息重复给系统带来的影响，可以利用数据库的唯一约束防止重复更新数据，也可以为数据更新设置一次性的前置条件，来防止重复消息，如果这两种方法都不适用，还可以用 ”记录并检查操作“ 的方式来保证幂等，这种方法适用范围最广，但是实现难度和复杂度也比较高，一般不推荐使用。</p><p>​这些实现幂等的方法，不仅可以用于解决重复消息的问题，也同样适用于，在其他场景中来解决重复请求或者重复调用的问题。比如，我们可以将 HTTP 服务设计成幂等的，解决前端或者 APP 重复提交表单数据的问题；也可以将一个微服务设计成幂等的，解决 RPC 框架自动重试导致的重复调用问题。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用事务消息实现分布式事务？</title>
      <link href="/2023/10/26/MQ/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F/"/>
      <url>/2023/10/26/MQ/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>消息队列中的事务是什么呢？<span id="more"></span></p><p>说到事务，肯定会优先想到数据库中的事务。在数据库中需要事务，是为了保证数据的一致性、完整性、持久性和隔离性。它可以将数据库中的一组操作合并为一个不可分割的工作单元，要么全部执行成功，要么全部执行失败。那消息队列为什么也需要事务呢？</p><p>在很多场景下，我们发消息的目的是为了通知另一个系统或者模块去更新数据，<strong>消息队列中的 “事务”，主要解决的是消息生产者和消息消费组的数据一致性问题。</strong></p><p>拿电商举例，用户在电商 APP 上购物，先把商品加到购物车里，然后几件商品一起下单，最后支付，完成购物流程。</p><p>这个过程中，订单系统创建订单后，发消息给购物车系统，将已下单的商品从购物车中删除。其中，从购物车将已下单的商品删除这个步骤并不是主要流程中的步骤，故可以使用消息队列来异步清理购物车，这样的设计显得更加合理。</p><p><img src="/images/%E6%B8%85%E7%90%86%E8%B4%AD%E7%89%A9%E8%BD%A6.png" alt="清理购物车"></p><p>对于订单系统来说，它创建订单的过程实际上执行了 2 个步骤的操作：</p><ol><li>在订单库中插入一条订单数据，创建订单；</li><li>发消息给消息队列，内容就是刚刚创建的订单。</li></ol><p>购物车系统订阅相关的主题，接收订单发送的消息，然后清理购物车，在购物车中删除订单中的商品。</p><p>在分布式系统中，上述的所有操作都有可能会失败，如果不做任何处理，就有可能导致订单数据与购物车数据不一致的问题，比如：</p><ol><li>创建了订单，没有删除购物车</li><li>订单没有创建，购物车里面的商品就被删除了</li></ol><p>对于上面第一个问题来说，失败的处理比较简单，只要成功执行清理购物车后再提交消费确认即可，如果执行失败，由于没有提交消费确认，消息队列中不会删除该消息，消息队列会自动重试</p><p>问题的关键是第二个问题，创建订单和发送消息两个步骤要么都成功，要么都失败，不允许一个成功另一个失败的情况出现。</p><p>这就是事务需要解决的问题。</p><h1 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h1><p>​通常我们理解的事务是：对若干数据进行更新操作，为了保证这些数据的完整性和一致性，我们希望这些更新操作<strong>要么都成功，要么都失败；</strong>至于更新的数据，不只局限于数据库中的数据，可以是磁盘上的一个文件，也可以是远端的一个服务，或者以其他形式存储的数据。</p><p>​一个严格意义的事务实现，应该具有四个特性：原子性、一致性、隔离性、持久性。这四个特性简称 ACID 特性。</p><p><strong>原子性</strong>，是指一个事务操作不可分割，要么成功，要么失败，不能有一半成功一半失败的情况。</p><p><strong>一致性</strong>，是指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据。</p><p><strong>隔离性</strong>，是指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰，这个有点儿像我们打网游中的副本，我们在副本中打的怪和掉的装备，与其他副本没有任何关联也不会互相影响。</p><p><strong>持久性</strong>，是指一个事务一旦完成提交，后续的其他操作和故障都不会对事务的结果产生任何影响。</p><p>很多单体关系型数据库都实现了完整的 ACID，但是对于分布式系统来说，严格的实现 ACID 这四个特性几乎是不可能的，或者说实现的代价太大，大到我们无法接收。</p><p>分布式事务就是指在分布式系统中实现的事务。在分布式系统中，在保证可用性和不严重牺牲性能的情况下，要保证数据的一致性就非常困难了，所以出现了很多残缺版的一致性，比如顺序一致性、最终一致性等。</p><p>显然想要实现完整版的分布式系统事务更是不可能完成的任务。所以目前大家所说的分布式事务，更多情况下，是在分布式系统中事务的不完整实现。在不同的应用场景中，有不同的实现，目的都是通过一些妥协来解决实际问题。</p><p>在实际应用中，比较常见的分布式事务实现有 2PC（Two-phase Commit，也叫二阶段提交）、TCC(Try-Confirm-Cancel) 和事务消息。每一种实现都有其特定的使用场景，也有各自的问题，都不是完美的解决方案。</p><p>事务消息适合的场景主要是那些需要异步更新数据，并且对于数据实时性要求并不高的场景。比如上面提到的订单-购物车案例，在创建订单后，如果出现短暂的几秒，购物车里的商品没有被及时清空，也不是完全不可接受的，只要保证最终购物车的数据和订单数据保持一致即可。</p><h1 id="消息队列是如何实现分布式事务的？"><a href="#消息队列是如何实现分布式事务的？" class="headerlink" title="消息队列是如何实现分布式事务的？"></a>消息队列是如何实现分布式事务的？</h1><p>要使用事务消息，肯定需要消息队列提供相应的功能才能实现，Kafka 和 RocketMQ 都提供了事务相关功能。</p><p>还是订单-购物车的例子，我们一起看下如何使用消息队列来实现分布式事务。</p><p><img src="/images/%E8%AE%A2%E5%8D%95-%E8%B4%AD%E7%89%A9%E8%BD%A6.png" alt="订单-购物车"></p><p>首先，订单系统在消息队列中开启事务。然后订单系统向消息队列服务器发送一个 ”半消息“，这个半消息是一个完整的消息内容，与普通消息的唯一区别就是，在事务提交之前，这个消息对于消费者是不可见的。</p><p>半消息发送成功之后，订单系统开始执行本地事务，在订单库中创建一条订单记录，并提交订单库的数据库事务。然后根据本地事务执行结果决定提交或者回滚事务消息。</p><ul><li>如果订单创建成功，那就提交事务，购物车系统就可以消费到这条消息，继续后续的处理。</li><li>如果订单创建失败，购物车系统就不会收到这条消息。</li></ul><p>这样就基本实现了，”要么都成功，要么都失败“ 的一致性要求了。</p><blockquote><p>半消息（也称为预提交消息）是通过一种两阶段提交的方式来确定事务是提交还是回滚的。</p><p>发送半消息的时，会包含一个标识，通常为事务 ID 或唯一标识，这个将于本地事务相关联。</p><p>如果本地事务执行成功，订单系统决定提交事务消息。它将在消息队列上的半消息标记为“可被消费”，这使得消费者可以看到和处理这条消息。</p><p>消费者可以使用事务标识来查找与该消息相关的本地事务状态，根据本地事务状态来决定是否要处理该消息。</p></blockquote><p>上述过程中，还有一个问题是没有解决的：如果在第四步提交事务消息时失败了怎么办？</p><p>Kafka 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在代码中反复重试提交，直到成功或者删除之前创建的订单作为补偿。RocketMQ 则给出了另一种解决方案。</p><h1 id="RocketMQ-中的分布式事务实现"><a href="#RocketMQ-中的分布式事务实现" class="headerlink" title="RocketMQ 中的分布式事务实现"></a>RocketMQ 中的分布式事务实现</h1><p>在 RocketMQ 中的事务实现中，增加了<strong>事务反查的机制</strong>来解决事务消息提交失败的问题。如果 Prodcuer 也就是订单系统，在提交事务或者回滚事务时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求。</p><p>Borker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。</p><p>为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。</p><p>在我们这个例子中，反查本地事务的逻辑很简单，只需要根据消息中的订单 ID，去订单库中查询是否存在即可，存在则返回成功，反之返回失败。RocketMQ 会自动根据事务反查的结果提交或回滚事务消息。</p><p>这个反查本地事务的实现，并不依赖消息的发送方，也就是订单服务的某个实例节点上的任务数据。这种情况下，即使是发送事务消息的那个订单服务节点宕机了，RocketMQ 依然可以通过查询其他服务节点来执行反查，确保事务的完成性。</p><p>综合上面讲的通用事务消息的实现和 RocketMQ 的事务反查机制，使用 RocketMQ 事务消息功能实现分布式事务的流程如下图：</p><p><img src="/images/%E4%BA%8B%E5%8A%A1%E5%8F%8D%E6%9F%A5.png" alt="事务反查"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过订单-购物车的案例，学习了事务的 ACID 四大特性，以及如何使用消息队列来实现分布式事务。</p><p>然后我们给出了现有的几种分布式事务的解决方案，包括事务消息，但这几种方案都不是银弹，每一种方案都有局限性和特定的使用场景。</p><p>最后我们学习了 RocketMQ 的事务反查机制，这张机制通过定期反查事务状态，来补充提交事务消息可能出现的失败问题。在 Kafka 中并没有实现类似的反查机制，需要用户自己去解决这个问题。</p><p>但是，这不代表 RocketMQ 的事务功能比 Kafka 更好，只能说在我们这个例子的场景下，更适合使用 RocketMQ。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息模型：主题和队列的区别？</title>
      <link href="/2023/10/26/MQ/%E4%B8%BB%E9%A2%98%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2023/10/26/MQ/%E4%B8%BB%E9%A2%98%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>​这篇文章，我们来讲解一下消息队列中像队列、主题、分区等基础概念。<span id="more"></span>只有搞清楚他们，才能进行后续的学习。</p><p>​每种消息队列都有自己的一套消息模型，像队列、主题、分区这些名词概念，在不同的产品中都会涉及，但含义又不太一样。之所以没有一套适用的标准，是因为标准的进化跟不上消息队列的演变速度，故这些东西没有标准。</p><p>​要想搞清楚队列、主题、分区是什么东西，需要从消息队列的演变说起。</p><h1 id="主题和队列有什么区别？"><a href="#主题和队列有什么区别？" class="headerlink" title="主题和队列有什么区别？"></a>主题和队列有什么区别？</h1><p>​在互联网的架构师圈中流传着这样一句话：”好的架构不是设计出来的，而是演进出来的“。</p><p>​最初的消息队列，就是一个严格意义上的队列。在维基百科中，队列的定义是这样的：</p><blockquote><p>队列是<a href="https://zh.wikipedia.org/wiki/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA%E6%BC%94%E7%AE%97%E6%B3%95">先进先出</a>（FIFO, First-In-First-Out）的<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a>。在具体应用中通常用<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">链表</a>或者<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组</a>来实现。队列只允许在后端（称为<em>rear</em>）进行插入操作，在前端（称为<em>front</em>）进行删除操作。</p></blockquote><p>​其中比较有几个关键的点，第一个是先进先出，在消息入队出队过程中，需要保证这些消息严格有序，按照什么顺序进队，就要按照什么顺序出队。队列中的”读“就是出队，”写“就是入队。</p><p>​<strong>早期的消息队列就是按照队列的数据结构来进行设计的</strong>。生产者发送消息就是入队操作，消费者接收消息就是出队操作，服务端存放消息的容器就称为 ”队列“。</p><p><img src="/images/%E9%98%9F%E5%88%97.png" alt="队列"></p><p>​如果有多个生产者往同一个队列里发送消息，这个队列中可以消费的消息，就是这些生产者发送的消息的合集，顺序就是这些生产者发送消息的顺序。如果多个消费者从同一个队列里接收消息，这些消费者属于竞争关系，每个消费者只能收到队列中的一部分消息，即每一条消息只能被一个消费者消费。</p><p>​如果需要实现将一份数据发送给多个消费者，例如，对于一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。这个时候，单个队列就无法满足了，一个可行的办法是，为每个消费者创建一个单独的队列，让生产者给每个消费者都发送一份数据。显然这个方法是很笨的，同样的一份消息数据被复制到多个队列中是很浪费资源的。更重要的是，这样就违背了消息队列 ”解耦“ 这个设计初衷，因为生产者需要提前知道有哪些消费者。</p><p>​为解决这个问题，就演化出了另一种模型：<strong>“ 发布 - 订阅模型（Publish-Subscribe Pattern”。</strong></p><p><img src="/images/PST.png" alt="发布-订阅"></p><p>​在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。</p><p>​在消息队列的历史上很长一段时间里，队列模型 和 发布-订阅模型 是并存的，有些消息队列同时支持这两种模型，让业务方自己根据场景进行选择。</p><p>​对比一下两种模型：</p><ul><li>生产者—-发布者</li><li>消费者—-订阅者</li><li>队列 —– 主题</li></ul><p>​<strong>它们最大的区别就是：一份数据能不能被多次消费。</strong></p><p>​在这种发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。也就是说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</p><p>​现代的消息队列产品使用的消息模型大多是这种发布 - 订阅模型，当然也有例外。</p><h1 id="RabbitMQ-的消息模型"><a href="#RabbitMQ-的消息模型" class="headerlink" title="RabbitMQ 的消息模型"></a>RabbitMQ 的消息模型</h1><p>​RabbitMQ 就是少数依然坚持适用队列模型的产品之一。那它是怎么解决多个消费者的问题的呢？这里实际上是将 RabbitMQ 的一个特色模块利用起来了，它位于生产者和队列之间，生产者不关心将消息发送到哪个队列，而是发送给 Exchange，由 Exchange 上配置的路由规则来决定将消息发送到哪些队列中。</p><p><img src="/images/RabbitMQ.png" alt="RabbitMQ"></p><p>​同一个消息如果需要多个消费者消费，则可以通过配置 Exchange 将消息发送到多个队列，每个队列中都存一份完整的消息数据，可以为一个消费者提供服务。这样就实现了 发布-订阅模型 中，”一个消息被多个消费者消费“ 的功能。具体的配置，可以查看 <a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html">官网</a></p><h1 id="RocketMQ-的消息模型"><a href="#RocketMQ-的消息模型" class="headerlink" title="RocketMQ 的消息模型"></a>RocketMQ 的消息模型</h1><p>​RocketMQ 使用的消息模型是标准的 <strong>发布 - 订阅模型</strong>，在其术语中，生产者、消费者和主题与上面讲的完全一致。</p><p>​但 RocketMQ 中也有队列这个概念，并且十分重要。它的具体作用在后面会说起，我们先来看看消息队列的消费机制。</p><p>​几乎所有的消息队列产品都是使用 ”请求 -  确认“ 机制，确保消息不会在传递过程中由于网络问题或服务器故障丢失。具体的做法与 TCP 连接过程中确认应答类似。在生产端，生产者先将消息发送给服务端，也就是 Broker，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。</p><p>​如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。</p><p>​这样的机制保证了消息传递过程中的可靠性。但是引入这个机制，就存在一个问题：为了确保消息的有序性，在一条消息被成功消费前，下一条消息不能被消费，否则就会出现消息空洞，违背了有序性这个原则。</p><blockquote><p>“消息空洞”指的是消息队列中存在一些未被消费的消息序号或标识，这些消息应该按照特定顺序被处理，但由于某些原因，其中的一些消息尚未被消费。这种情况可能会违反消息传递的有序性，因为一些消息被提前消费，而其他消息被延迟或遗漏。</p></blockquote><p>​也就是说，每个主题任意时刻只能有一个消费者消费，那就无法同过水平扩展消费者的数量来提升消费端总体的性能。因此，RocketMQ 在主题下引入了队列的概念。</p><p>​<strong>每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。</strong>需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。</p><p>​RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间的消费进度没有关联，即一个消息被 Consumer Group 1 消费过，也会再给 Consumer Group 2 消费。</p><p>​在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息是不会马上进行删除的，这就需要 RocketMQ 为每个消费组在队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，这个位置之后的消息都没有被消费过，每消费一条消息，该位置就加一。</p><p>​可以对照这张图加深理解。</p><p><img src="/images/RocketMQ.png" alt="RocketMQ"></p><h1 id="Kafka-的消息模型"><a href="#Kafka-的消息模型" class="headerlink" title="Kafka 的消息模型"></a>Kafka 的消息模型</h1><p>​Kafka 的消息模型和 RocketMQ 完全一样，唯一的区别就是，在 Kafka 中，队列这个概念的名词不一样，Kafka 中对应的名称是 ”分区（（Partition）“，含义和功能是没有任何区别的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>​本文讲述了队列和主题的区别，这两个概念背后对应着两种不同的消息队列模型：队列模型 和 发布-订阅模型。</p><p>​常用的消息队列中，RabbitMQ 采用队列模型，但它可以通过 Exchange 模块实现 发布-订阅 的功能。RocketMQ 和 Kafka 采用的是 发布-订阅模型，并且二者的消息模型是基本一致的。</p><p>​最后需要清楚的是，本文介绍的消息模型和相关概念只是业务层面的模型，不同的消息队列的底层实现肯定有很大的区别，只是从业务上来看，它们的类似的。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择消息队列？</title>
      <link href="/2023/10/25/MQ/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F/"/>
      <url>/2023/10/25/MQ/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>作为一个程序员，我们必须要认识到，软件工程中是不存在”银弹“的。<span id="more"></span></p><p>在消息队列的选型问题上，也是同样的道理。并不存在哪个消息队列就是最好的，能够解决所有的问题。常用的消息队列有好几个，每一种都有自己的优势和劣势，需要业务方根据自己的系统的情况，选择最适合的产品。</p><h1 id="选择消息队列的基本标准"><a href="#选择消息队列的基本标准" class="headerlink" title="选择消息队列的基本标准"></a>选择消息队列的基本标准</h1><h4 id="1、开源"><a href="#1、开源" class="headerlink" title="1、开源"></a>1、开源</h4><p>​首先，必须是开源的产品，因为一旦在开发过程中遇到一个系统 Bug，你至少<strong>有机会</strong>通过修改源代码来修复这个 Bug，而不是只能无期限地等待产品的开发者发布新版本解决该问题。</p><h4 id="2、流行"><a href="#2、流行" class="headerlink" title="2、流行"></a>2、流行</h4><p>​其次，这个产品必须是近年来比较流行并且有一定社区活跃度的产品。流行意味着使用的人很多，只要你的场景不是很冷门，几乎你遇到的 Bug 都有前辈已经踩过坑了，都能找到类似的解决方案。</p><p>​同时流行的产品与周边生态系统会有一个比较好的集成和兼容，大部分场景下不需要为自己的业务额外地去开发其他中间件。</p><h4 id="3、可靠"><a href="#3、可靠" class="headerlink" title="3、可靠"></a>3、可靠</h4><p>​需要保证消息传递的可靠，确保消息不会丢失。</p><h4 id="4、支持-Cluster"><a href="#4、支持-Cluster" class="headerlink" title="4、支持 Cluster"></a>4、支持 Cluster</h4><p>​支持集群，确保不会因为某个节点宕机导致服务不可用的情况，同时也需要保证消息不会丢失</p><h4 id="5、性能"><a href="#5、性能" class="headerlink" title="5、性能"></a>5、性能</h4><p>​具备足够好的性能，能满足大多数场景的性能要求。</p><h1 id="可供选择的消息队列产品"><a href="#可供选择的消息队列产品" class="headerlink" title="可供选择的消息队列产品"></a>可供选择的消息队列产品</h1><h4 id="1、RabbitMQ"><a href="#1、RabbitMQ" class="headerlink" title="1、RabbitMQ"></a>1、RabbitMQ</h4><p>​老牌消息队列 RabbitMQ，俗称兔子 MQ。它是用一种比较小众的语言：Erlang 编写的，最早为电信行业系统之间的可靠通信设计的，支持 AMQP 协议。</p><p>​它的特点是：<strong>轻量级、迅捷</strong>，宣传口号是：”开箱即用的消息队列“，是一个相当轻量级的消息队列，非常容易部署和使用。因此 RabbitMQ 成为了 ”最流行的消息中间件之一“。</p><p>​RabbitMQ 一个比较有特色的功能是支持非常灵活的路由配置，和其他消息队列不同的是，它在生产者和队列之间增加了一个类似交换机的 Exchange 模块。这个模块根据配置的路由规则将生产者发出的消息分发到不同的队列中。路由的规则也非常灵活，甚至可以自己来实现路由规则。</p><blockquote><p>这里通过一个示例，详细解释一下 Exchange 模块的作用：</p><p><strong>假设你有一个电商网站，你希望根据用户的购买地理位置将订单消息路由到不同的队列，以便分别处理。</strong></p><ol><li><strong>创建 Exchange：</strong> 首先，你会创建一个 Exchange，可以命名为 “OrderExchange”。这是消息的中转站，它会接收生产者发送的订单消息，并负责将这些消息路由到一个或多个队列中。</li><li><strong>创建队列：</strong> 然后，你会创建多个队列，每个队列代表一个不同的地理位置，比如 “USOrders”、”EUOrders” 和 “AsiaOrders”。</li><li><strong>定义绑定规则：</strong> 接下来，你会定义绑定规则。这些规则告诉 Exchange 如何将消息路由到队列。例如，你可以定义规则，将订单消息中的地理位置信息与队列的名称进行匹配。如果订单来自美国，它将被路由到 “USOrders” 队列，如果来自欧洲，它将被路由到 “EUOrders” 队列。</li><li><strong>生产者发送消息：</strong> 当用户在网站上下订单时，订单服务会将订单消息发送到 “OrderExchange”。这个消息会带有订单信息，包括地理位置。</li><li><strong>Exchange 路由消息：</strong> “OrderExchange” 根据你定义的规则，将消息路由到相应的队列。如果订单来自美国，它将被发送到 “USOrders” 队列。</li><li><strong>队列消费消息：</strong> 各个队列中的消费者（可能是不同的处理订单的系统）订阅相应队列并处理订单消息。”USOrders” 队列中的消费者处理来自美国的订单，”EUOrders” 队列中的消费者处理来自欧洲的订单，依此类推。</li></ol></blockquote><p>​RabbitMQ 的客户端所支持的编程语言是消息队列中最多的，如果你的系统是使用某种冷门语言开发，那你可以尝试找到对应的 RabbitMQ 客户端，不出意外的话，应该是能找到的。</p><p>​接下来说说 RabbitMQ 的几个问题：</p><ol><li><strong>消息堆积</strong>：RabbitMQ 的设计理念是管道，它对消息堆积的支持有限，大量消息堆积可能导致性能下降。因此，它不是最佳选择用于需要大规模消息堆积的应用。</li><li><strong>性能较差：</strong>相对于其他消息队列系统，RabbitMQ 的性能较差。它通常能够处理每秒数万到十几万条消息，性能依赖于硬件配置，虽然大多数的应用场景也够用了，但如果对消息队列的性能要求非常高的话，就不要选择 RabbitMQ。</li><li><strong>二次开发难：</strong>RabbitMQ 使用的 Erlang 语言不仅非常小众，而且这个语言的学习曲线非常陡峭。如果想基于 RabbitMQ 做一些扩展和二次开发，则需要慎重考虑可持续维护的问题。</li></ol><h4 id="2、RocketMQ"><a href="#2、RocketMQ" class="headerlink" title="2、RocketMQ"></a>2、RocketMQ</h4><p>​RocketMQ 是阿里巴巴开源的消息队列产品，后捐赠于 Apache 软件基金会，成为其顶级项目。它经历多次 ”双十一“ 的考研，<strong>性能、稳定性和可靠性</strong>都是值得信赖的，是一款优秀的国产消息队列。</p><p>​RocketMQ 有非常活跃的中文社区，大多数问题都能够找到中文的答案，这或许也是越来越多国内大厂使用的原因。另外，它使用 Java 语言开发，贡献者大多数都是中国人，源代码也相对比较容易读懂，很方便进行扩展或二次开发。</p><p>​RocketMQ 的好处是，它对于在线业务的相应做了很多的优化，大多数情况下可以做到毫秒级的响应，<strong>如果你的应用场景很在意响应时延，那应该选择使用 RocketMQ。</strong></p><p>​RocketMQ 的性能比 RabbitMQ 要高一个数量级，每秒钟大概能处理几十万条消息。</p><p>​RocketMQ 的一个劣势是，<strong>国际知名度比较低</strong>，与<strong>周边生态系统的集成和兼容程度要略逊一筹。</strong></p><h4 id="3、Kafka"><a href="#3、Kafka" class="headerlink" title="3、Kafka"></a>3、Kafka</h4><p>​Kafka 最早是由 Linkedln 开发，目前也是 Apache 的顶级项目，它<strong>最初的设计目的是用于处理海量的日志</strong>。</p><p>​在早期的版本中，为了获得极致的性能，在设计方面做了很多牺牲，比如不保证消息的可靠性，可能会丢失消息，也不支持集群，功能上也比较简陋。这些牺牲对于处理海量日志这个特定的场景是可以接收的，但此时的 Kafka 不能被称为一个合格的消息队列。在随后几年 Kafka 逐步补齐了短板，当下的 Kafka 已经发展为一个非常成熟的消息队列产品，无论数据可靠性、稳定性和功能特性等方面都可以满足绝大多数场景了。</p><p>​<strong>Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。</strong></p><p>​Kafka 使用 Scala 和 Java 开发，设计上大量使用了批量和异步的思想，这使得 Kafka 能做到超高的性能，尤其是异步收发的性能，是三者中最好的。但与 RocketMQ 并没有量级上的差异，大约每秒可以处理几十万条消息。</p><p>​然而，Kafka采用的异步批量消息处理设计会引发一个问题，即它的<strong>同步消息传递响应时延较高</strong>。这是因为在客户端发送一条消息后，Kafka不会立即传递消息，而是会等待一段时间以便累积一批消息后再一起处理。这种”批量处理”设计在Kafka的Broker中多次出现。在业务场景中，如果每秒的消息数量相对较低，Kafka的响应时延可能会变得较高。因此，Kafka通常不太适用于需要低延迟的在线业务场景。</p><h1 id="第二梯队的消息队列"><a href="#第二梯队的消息队列" class="headerlink" title="第二梯队的消息队列"></a>第二梯队的消息队列</h1><p>​除了上述比较常用的消息队列，还有一些不太常用的产品，之所以不太流行肯定是有原因的，所以不推荐使用。下面简单介绍一下：</p><h4 id="1、ActiveMQ"><a href="#1、ActiveMQ" class="headerlink" title="1、ActiveMQ"></a>1、ActiveMQ</h4><p>​ActiveMQ 的最老牌的开源消息队列，是十年前唯一可供选择的开源消息队列，目前已进入老年期，社区不活跃。无论是功能还是性能方面，与现代的消息队列都存在明显的差异，存在的意义仅限于兼容一些老系统。</p><h4 id="2、ZeroMQ"><a href="#2、ZeroMQ" class="headerlink" title="2、ZeroMQ"></a>2、ZeroMQ</h4><p>​严格来说 ZeroMQ 并不能称之为一个消息队列，而是一个基于消息队列的多线程网络库，如果你的需求是将消息队列的功能集成到你的系统进程中，可以考虑使用 ZeroMQ。</p><h4 id="3、Pulsar"><a href="#3、Pulsar" class="headerlink" title="3、Pulsar"></a>3、Pulsar</h4><p>​Pulsar是一个相对较新的开源消息队列系统，最初由Yahoo开发，目前仍处于不断成长和发展的阶段。与其他传统消息队列系统最显著的不同之处在于其采用了存储和计算分离的设计思想。不少人比较喜欢这种设计，它有可能会引领未来消息队列的一个发展方向。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​根据上述多种消息队列的讲解，对于消息队列的选择肯定已经心中有数了，下面给出几点意见：</p><ul><li>如果你的系统中消息队列不是主要部分，且对消息队列的功能和性能没有很高的要求，只需要用一个<strong>开箱即用易于维护</strong>的产品，则开源使用 <strong>RabbitMQ</strong></li><li>如果你的系统使用消息队列的场景是处理在线业务，比如交易系统中用消息队列传递订单，那么 <strong>RocketMQ</strong> 的<strong>低延迟和稳定性</strong>是比较推荐的</li><li>如果需要处理海量的消息，像收集日志、监控信息或是你的应用场景使用了大数据、流计算相关的开源产品，那 Kafka 是最适合你的消息队列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么需要消息队列</title>
      <link href="/2023/10/25/MQ/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/10/25/MQ/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>​这篇文章主要围绕两个话题来叙述：消息队列是什么？主要解决什么问题。<span id="more"></span></p><h1 id="消息队列是什么？"><a href="#消息队列是什么？" class="headerlink" title="消息队列是什么？"></a>消息队列是什么？</h1><p>​消息队列是最古老的中间件之一，从系统之间有通信需求开始，就自然产生了消息队列。但是给消息队列下一个准确的定义却不太容易。我们知道，消息队列的主要功能就是收发消息，但是它的作用不仅仅只是解决应用之间的通信问题这么简单。</p><p>生活中也存在很多例子可以用来解释消息队列的概念。一个常见的例子是快餐餐厅的点餐系统。让我们来看看这个例子：</p><p>在一个繁忙的快餐餐厅，通常有多个工作人员负责不同的任务，包括点餐、烹饪食物、包装和交付食物给客户。最开始的时候，点餐员会将顾客的订单直接传达给厨师，然后等待食物烹饪完成，然后再将其交付给客户。这种方式存在一些问题：</p><ol><li><p><strong>等待时间</strong>：点餐员可能需要等待一段时间，直到厨师准备好食物。这导致了服务速度较慢。</p></li><li><p><strong>同步问题</strong>：如果厨师繁忙，点餐员必须等待，不能处理新的订单。</p></li><li><p><strong>故障容忍性</strong>：如果点餐员或厨师出现问题，整个点餐过程可能会中断。</p></li></ol><p>为了解决这些问题，餐厅引入了消息队列系统，还是上面的例子。现在的订单处理过程如下：</p><ol><li><p>顾客在点餐柜台上点餐并支付，点餐员将订单信息输入到点餐系统，但订单不再直接传递给厨师。</p></li><li><p>订单信息被放入订单队列中，等待处理。厨师从队列中获取订单并开始烹饪。</p></li><li><p>同时，点餐员可以接受更多订单，将它们加入队列。这意味着点餐员不必等待烹饪完成，而是可以快速处理更多订单。</p></li><li><p>一旦订单完成烹饪，它被放回队列，等待交付。送餐员从队列中获取订单并将其交付给客户。</p></li></ol><p>消息队列系统的作用类似于上述的例子，具有类似的优势：</p><ul><li><p><strong>解耦合</strong>：点餐员和厨师不再需要直接通信，他们通过队列进行互动，各自独立工作。</p></li><li><p><strong>流量调节</strong>：点餐员可以接受更多订单，而不会影响食物的烹饪和交付速度。订单等待在队列中，直到厨师和送餐员准备好接受它们。</p></li><li><p><strong>可伸缩性</strong>：餐厅可以雇佣更多的点餐员、厨师和送餐员来应对繁忙时段，而不必更改整个点餐系统。</p></li><li><p><strong>容错性</strong>：即使点餐员、厨师或送餐员出现问题，队列中的订单仍然安全，等待下一个可用的处理程序。</p></li></ul><h1 id="哪些问题适合使用消息队列来解决？"><a href="#哪些问题适合使用消息队列来解决？" class="headerlink" title="哪些问题适合使用消息队列来解决？"></a>哪些问题适合使用消息队列来解决？</h1><h4 id="1、异步处理"><a href="#1、异步处理" class="headerlink" title="1、异步处理"></a>1、异步处理</h4><p>在一个典型的秒杀系统中，需要解决如何有效处理大量请求的问题。通常，这个过程可以分为五个主要步骤：风险控制、库存锁定、生成订单、短信通知和更新统计数据。其中，风险控制和库存锁定是决定秒杀成功的关键步骤，而其他步骤则可以在稍后异步处理。</p><p>原本的处理流程是，应用将请求发送到网关，然后依次调用这五个步骤，最后将结果返回给应用。但在实际场景中，只有风险控制和库存锁定两个步骤决定了秒杀的结果，其他步骤并不需要即时完成。</p><p>因此，<strong>一种优化方法是，当服务器完成风险控制和库存锁定后，即可立即响应用户请求，同时将请求的相关数据放入消息队列中，以便后续的步骤异步处理。</strong></p><p><strong>在这个场景中，采用消息队列进行异步处理带来了多个好处：</strong></p><ol><li><p><strong>更快的响应速度</strong>：用户能够迅速得到秒杀结果，无需等待后续步骤的完成。</p></li><li><p><strong>并发处理</strong>：通过异步执行，系统能够在秒杀期间更高效地利用服务器资源，处理更多的秒杀请求。</p></li><li><p><strong>降低系统压力</strong>：在秒杀结束后，系统可以有序地处理生成订单、短信通知和更新统计数据等步骤，减少了系统的高峰负载。</p></li></ol><h4 id="2、流量控制"><a href="#2、流量控制" class="headerlink" title="2、流量控制"></a>2、流量控制</h4><p>继续讨论秒杀系统的设计，我们已经引入了消息队列来实现异步处理，但我们还需要解决一个关键问题：如何防止过多的请求压垮系统？</p><p>一个健壮的程序应该具备自我保护的能力，即在面对大规模请求时，它能够在自身承受范围内处理尽可能多的请求，同时拒绝无法处理的请求，以确保系统正常运行。然而，很多现实中的程序并不总是如此”健壮”，而直接拒绝请求会影响用户体验。</p><p>因此，我们需要设计一个强大的架构来保护后端服务。我们的设计思路是通过消息队列来隔离网关和后端服务，以实现流量控制和后端服务的保护。</p><p>引入消息队列后，整个秒杀流程如下：</p><ol><li>网关接收到请求后，将请求放入请求消息队列。</li><li>后端服务从请求消息队列中获取APP请求，执行后续的秒杀处理流程，然后返回结果。</li></ol><p>当秒杀活动开始时，<strong>如果在短时间内涌入大量秒杀请求</strong>，这些请求不会直接冲击到后端秒杀服务。相反，<strong>它们会在消息队列中排队等待处理，后端服务会按照其最大处理能力从消息队列中获取请求并进行处理。</strong></p><p>对于超时的请求，可以直接丢弃，APP可以将没有响应的请求视为秒杀失败。此外，运维人员可以随时增加后端秒杀服务的实例数量以进行水平扩容，而无需对系统的其他部分进行任何更改。</p><p>这种<strong>设计的优点</strong>在于它可以根据下游处理能力自动调节流量，实现了“削峰填谷”的效果。然而，这种方法也有一些代价：</p><ol><li>增加了系统调用链的环节，从而导致<strong>总体响应时间延长</strong>。</li><li>需要将同步调用改为异步消息传递，增加了系统的复杂性。</li></ol><h4 id="3、服务解耦"><a href="#3、服务解耦" class="headerlink" title="3、服务解耦"></a>3、服务解耦</h4><p>消息队列的另一个重要作用是实现系统之间的解耦。让我们再以电商领域为例，来说明解耦的重要性和作用。</p><p>在电商系统中，订单数据是核心信息，每当创建一个新订单时，涉及到多个下游系统的操作：</p><ol><li>支付系统需要触发支付过程。</li><li>风险控制系统需要审核订单的合法性。</li><li>客服系统需要通知用户，通常通过短信发送信息。</li><li>经营分析系统需要更新统计数据。</li></ol><p>随着业务的扩大，这些下游系统会不断增加和变化，而且每个系统通常只需要订单数据的某个子集。维护订单服务的开发团队不得不不断投入大量精力来适应这些下游系统的不断增长和变化。每次下游系统的接口发生变更，都要求订单模块进行修改和重新上线。对于电商这类核心服务来说，这种紧密的耦合几乎是不可接受的。</p><p>为了解决这一问题，许多电商选择引入消息队列。<strong>通过引入消息队列，订单服务只需要在订单发生变化时向一个名为”Order”的主题发布一条消息，而所有下游系统都会订阅这个主题</strong>。这使得每个下游系统都可以及时获取到完整的订单数据，而不论下游系统的增加、减少或者具体需求如何变化。</p><p>这种设计<strong>带来的好处</strong>是，无论下游系统的变动如何，订单服务无需做出任何修改，从而实现了订单服务与下游服务之间的解耦。这种解耦设计<strong>使系统更加灵活和可维护</strong>，减少了对核心服务的依赖和干预，提高了系统的稳定性和可扩展性。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面举例了消息队列最常被使用的三种场景：异步处理、流量限制、服务解耦，消息队列的使用范围肯定不仅仅局限于这些，但这里就不作多的列举了。</p><p>简单的说，我们在单体应用里面需要用队列解决的问题，在分布式系统中大多数都可以用消息队列来解决。</p><p>同时我们也应该明白，引入消息队列可能造成的一些问题和局限性：</p><ul><li>引入消息队列带来的延迟问题</li><li>增加了系统的复杂度</li><li>可能产生数据不一致的问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/10/25/Go/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/10/25/Go/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>​这篇文章带大家一起了解一下 数组、切片、哈希表、字符串四种数据结构。<span id="more"></span></p><h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>​数组作为一种基本的数据结构，通过我们会从两个维度去描述它，也就是数组中存储的元素类型和数组最大能存储的元素个数，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br>[<span class="hljs-number">200</span>]<span class="hljs-keyword">interface</span><br></code></pre></td></tr></table></figure><p>​Go 语言数组在初始化之后，大小就无法改变，只有存储元素类型相同且大小相同的数组类型才是同一类型的数组。</p><p>​编译期间的数组类型是由 <a href="https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray"><code>cmd/compile/internal/types.NewArray</code></a>  函数生成的，包含了两个字段：元素类型 elem 和 数组大小 bound，这两个字段共同构成了数组类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewArray</span><span class="hljs-params">(elem *Type, bound <span class="hljs-type">int64</span>)</span></span> *Type &#123;<br><span class="hljs-comment">// 检查数组的大小是否小于0</span><br><span class="hljs-keyword">if</span> bound &lt; <span class="hljs-number">0</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;NewArray: invalid bound %v&quot;</span>, bound)<br>&#125;<br><span class="hljs-comment">// 创建一个新的数组类型对象</span><br>t := newType(TARRAY)<br><span class="hljs-comment">// 设置数组类型的额外信息，包括元素类型和大小</span><br>t.extra = &amp;Array&#123;Elem: elem, Bound: bound&#125;<br><span class="hljs-comment">// 根据元素类型的NotInHeap属性设置数组类型的NotInHeap属性</span><br>t.SetNotInHeap(elem.NotInHeap())<br><span class="hljs-comment">// 返回新创建的数组类型</span><br><span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、初始化"><a href="#2、初始化" class="headerlink" title="2、初始化"></a>2、初始化</h4><p>​Go 语言的数组有两种不同的创建方式，一种是显示地指定数组大小，一种是使用 <code>[...]T</code> 声明数组，Go 语言会在编译期间通过源代码推到数组的大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">arr1 := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>arr2 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>​这两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式会在编译期间转换成前一种，也就是编译器对数组大小的推导。下面介绍编译器推到的过程。</p><h5 id="上限推导"><a href="#上限推导" class="headerlink" title="上限推导"></a>上限推导</h5><p>​两种不同的声明方式，会导致编译器做出完全不同的处理。</p><ol><li><p>使用第一种方式 <code>[10] T</code>，那么变量的类型在编译进行到<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/">类型检查</a>阶段就会被提取出来，随后使用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/types.NewArray"><code>cmd/compile/internal/types.NewArray</code></a>创建包含数组大小的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/types.Array"><code>cmd/compile/internal/types.Array</code></a> 结构体。</p></li><li><p>当我们使用 <code>[...]T</code> 的方式声明数组时，编译器会在的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheckcomplit"><code>cmd/compile/internal/gc.typecheckcomplit</code></a> 函数中对该数组的大小进行推导：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typecheckcomplit</span><span class="hljs-params">(n *Node)</span></span> (res *Node) &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 如果数组的类型是切片和字面量 &quot;...&quot; 则处理</span><br><span class="hljs-keyword">if</span> n.Right.Op == OTARRAY &amp;&amp; n.Right.Left != <span class="hljs-literal">nil</span> &amp;&amp; n.Right.Left.Op == ODDD &#123;<br><span class="hljs-comment">// 对数组中元素的类型进行类型检查</span><br>n.Right.Right = typecheck(n.Right.Right, ctxType)<br><span class="hljs-comment">// 如果元素类型为空，则清除节点类型并返回节点</span><br><span class="hljs-keyword">if</span> n.Right.Right.Type == <span class="hljs-literal">nil</span> &#123;<br>n.Type = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-comment">// 获取元素类型</span><br>elemType := n.Right.Right.Type<br><span class="hljs-comment">// 通过 typecheckarraylit 计算数组中元素的数量</span><br>length := typecheckarraylit(elemType, <span class="hljs-number">-1</span>, n.List.Slice(), <span class="hljs-string">&quot;array literal&quot;</span>)<br><span class="hljs-comment">// 将节点的操作修改为 OARRAYLIT</span><br>n.Op = OARRAYLIT<br><span class="hljs-comment">// 根据元素类型和计算出的长度创建新的数组类型</span><br>n.Type = types.NewArray(elemType, length)<br><span class="hljs-comment">// 清除右子节点</span><br>n.Right = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 返回修改后的节点</span><br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面这个函数中，会通过遍历元素的方式来计算数组中元素的数量。</p><p>所以我们可以看出 <code>[...]T&#123;1, 2, 3&#125;</code> 和 <code>[3]T&#123;1, 2, 3&#125;</code> 在运行时是完全等价的</p></li></ol><h5 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h5><p>​对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.anylit"><code>cmd/compile/internal/gc.anylit</code></a> 函数中做两种不同的优化：</p><ol><li>当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ol><p>​当数组的元素<strong>小于或者等于四个</strong>时，<a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.fixedlit"><code>cmd/compile/internal/gc.fixedlit</code></a> 会负责在函数编译之前将 <code>[3]&#123;1, 2, 3&#125;</code> 转换成更加原始的语句， <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.fixedlit"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数接收的 <code>kind</code> 是 <code>initKindLocalCode</code> 时，上述代码会将原有的初始化语句 <code>[3]int&#123;1, 2, 3&#125;</code> 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>​但是如果当前数组的元素大于四个，<a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.anylit"><code>cmd/compile/internal/gc.anylit</code></a> 会先获取一个唯一的 <code>staticname</code>，然后调用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.fixedlit"><code>cmd/compile/internal/gc.fixedlit</code></a> 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>statictmp_0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>statictmp_0[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>statictmp_0[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br>statictmp_0[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span><br>statictmp_0[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span><br>arr = statictmp_0<br></code></pre></td></tr></table></figure><p>​总结一下就是：在不考虑逃逸分析的情况下，如果数组中的元素个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化；否则，变量就会在静态存储区初始化，然后拷贝到栈上。转换后的代码才会继续进入中间代码生成和机器猫生成两个阶段，最后生成可执行的二进制文件。</p><h4 id="3、访问和赋值"><a href="#3、访问和赋值" class="headerlink" title="3、访问和赋值"></a>3、访问和赋值</h4><p>​无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据，无论丢失了哪个信息，我们都无法知道这片连续的内存空间到底存储了什么数据。</p><p>​数组访问越界是非常严重的错误，Go 语言中可以在编译期间的静态类型检查判断数组越界，<a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1"><code>cmd/compile/internal/gc.typecheck1</code></a> 会验证访问数组的索引：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typecheck1</span><span class="hljs-params">(n *Node, top <span class="hljs-type">int</span>)</span></span> (res *Node) &#123;<br><span class="hljs-keyword">switch</span> n.Op &#123;<br><span class="hljs-keyword">case</span> OINDEX:<br>ok |= ctxExpr<br>l := n.Left  <br>r := n.Right <br><span class="hljs-comment">// 根据左操作数的类型进行不同处理</span><br><span class="hljs-keyword">switch</span> n.Left.Type.Etype &#123;<br><span class="hljs-comment">// 对于字符串、数组和切片类型</span><br><span class="hljs-keyword">case</span> TSTRING, TARRAY, TSLICE:<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 如果索引类型不是整数，报错并中断处理</span><br><span class="hljs-keyword">if</span> n.Right.Type != <span class="hljs-literal">nil</span> &amp;&amp; !n.Right.Type.IsInteger() &#123;<br>yyerror(<span class="hljs-string">&quot;non-integer array index %v&quot;</span>, n.Right)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// 如果索引没有限制且是整数常量</span><br><span class="hljs-keyword">if</span> !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) &#123;<br><span class="hljs-comment">// 获取整数值</span><br>x := n.Right.Int64()<br><span class="hljs-comment">// 如果索引小于0，报错（索引必须为非负数）</span><br><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>yyerror(<span class="hljs-string">&quot;invalid array index %v (index must be non-negative)&quot;</span>, n.Right)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n.Left.Type.IsArray() &amp;&amp; x &gt;= n.Left.Type.NumElem() &#123;<br><span class="hljs-comment">// 如果是数组类型且索引越界，报错</span><br>yyerror(<span class="hljs-string">&quot;invalid array index %v (out of bounds for %d-element array)&quot;</span>, n.Right, n.Left.Type.NumElem())<br><span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>访问数组的索引是非整数时，报错 “non-integer array index %v”；</li><li>访问数组的索引是负数时，报错 “invalid array index %v (index must be non-negative)”；</li><li>访问数组的索引越界时，报错 “invalid array index %v (out of bounds for %d-element array)”；</li></ol><p>​数组和字符串的一些简单越界错误都会在编译期间发现，如：直接使用证书或者常量访问数组；但是如果使用变量去访问数组或者字符串时，编译器无法提前发现错误，就需要 Go 语言运行时阻止不合法的访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">arr[<span class="hljs-number">4</span>]: invalid array index <span class="hljs-number">4</span> (out of bounds <span class="hljs-keyword">for</span> <span class="hljs-number">3</span>-element array)<br>arr[i]: <span class="hljs-built_in">panic</span>: runtime <span class="hljs-type">error</span>: index out of <span class="hljs-keyword">range</span> [<span class="hljs-number">4</span>] with length <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>​Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <a href="https://draveness.me/golang/tree/runtime.panicIndex"><code>runtime.panicIndex</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.goPanicIndex"><code>runtime.goPanicIndex</code></a> 触发程序的运行时错误并导致崩溃退出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">TEXT runtime·panicIndex(SB),NOSPLIT,$<span class="hljs-number">0</span><span class="hljs-number">-8</span><br><span class="hljs-comment">// runtime·panicIndex是运行时处理数组越界访问的函数。</span><br>MOVLAX, x+<span class="hljs-number">0</span>(FP)      <span class="hljs-comment">// 将寄存器AX中的x参数存储到栈帧的偏移0(FP)位置。</span><br>MOVLCX, y+<span class="hljs-number">4</span>(FP)      <span class="hljs-comment">// 将寄存器CX中的y参数存储到栈帧的偏移4(FP)位置。</span><br>JMPruntime·goPanicIndex(SB)  <span class="hljs-comment">// 跳转到runtime·goPanicIndex函数进行错误处理。</span><br><br><span class="hljs-comment">// goPanicIndex是用于处理数组越界访问的运行时函数。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goPanicIndex</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">// 获取调用goPanicIndex函数的调用者的程序计数器（PC）。</span><br>panicCheck1(getcallerpc(), <span class="hljs-string">&quot;index out of range&quot;</span>)<br><span class="hljs-comment">// 创建boundsError结构体，其中包含有关数组越界错误的信息。</span><br><span class="hljs-comment">// - x: 数组索引</span><br><span class="hljs-comment">// - signed: 是否为有符号整数索引</span><br><span class="hljs-comment">// - y: 数组的长度</span><br><span class="hljs-comment">// - code: 错误代码（在这里是boundsIndex）</span><br><span class="hljs-built_in">panic</span>(boundsError&#123;x: <span class="hljs-type">int64</span>(x), signed: <span class="hljs-literal">true</span>, y: y, code: boundsIndex&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h4><ol><li><strong>数组概述</strong>：数组是一种基本的数据结构，它由两个维度描述：存储的元素类型和数组的最大容量（大小）。例如，<code>[10]int</code> 表示一个包含10个整数的数组，而 <code>[200]interface&#123;&#125;</code> 表示一个包含200个任意类型的元素的数组。</li><li><strong>数组大小不可改变</strong>：在Go语言中，一旦数组被初始化，其大小（容量）无法更改。只有当数组的元素类型和大小完全相同时，它们才被认为是相同类型的数组。</li><li><strong>数组类型生成</strong>：在编译期间，数组的类型由 <code>cmd/compile/internal/types.NewArray</code> 函数生成，它包含两个关键字段：元素类型 <code>elem</code> 和数组大小 <code>bound</code>。</li><li><strong>初始化数组</strong>：Go语言支持两种不同的数组初始化方式。一种是显式指定数组大小，另一种是使用 <code>[...]T</code> 声明数组，编译器将在编译时推断数组大小。这两种方式在运行时具有相同的效果。</li><li><strong>数组大小推导</strong>：数组大小推导是通过编译器进行的。当使用 <code>[10]T</code> 的方式声明数组时，大小在编译期间被提取为类型信息。对于 <code>[...]T</code> 声明，编译器使用 <code>cmd/compile/internal/gc.typecheckcomplit</code> 函数在编译期间计算数组大小。</li><li><strong>数组初始化转换</strong>：编译器进行数组初始化转换，根据元素数量的不同，将数组初始化放在栈上或静态存储区。这可以优化性能，避免过多的栈内存操作。</li><li><strong>数组访问和越界检查</strong>：Go编译器在编译期间执行数组访问的静态类型检查，检查索引是否合法。它检查索引是否为整数、非负数以及是否越界。数组访问越界是一个严重的错误，可以在编译期间或运行时被检测到。</li><li><strong>数组越界运行时处理</strong>：在运行时，Go会使用 <code>runtime.panicIndex</code> 和 <code>runtime.goPanicIndex</code> 处理数组越界访问错误。这会导致程序崩溃，并提供有关越界的信息，如越界索引和数组大小。</li></ol><h1 id="二、切片"><a href="#二、切片" class="headerlink" title="二、切片"></a>二、切片</h1><h4 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h4><p>​数组在 Go 语言中没有那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。</p><p>​声明方式与数组相似，但只需要指定切片的元素类型即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[]<span class="hljs-type">int</span><br>[]<span class="hljs-keyword">interface</span><br></code></pre></td></tr></table></figure><p>​切片的类型在编译期间会由 <a href="https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice"><code>cmd/compile/internal/types.NewSlice</code></a> 函数生成，只包含切片中的元素类型，即 int 或者 interface等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSlice</span><span class="hljs-params">(elem *Type)</span></span> *Type &#123;<br><span class="hljs-keyword">if</span> t := elem.Cache.slice; t != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> t.Elem() != elem &#123;<br>Fatalf(<span class="hljs-string">&quot;elem mismatch&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> t<br>&#125;<br><br>t := New(TSLICE)<br>t.Extra = Slice&#123;Elem: elem&#125;<br>elem.Cache.slice = t<br><span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>​该方法会返回一个只包含切片内元素类型的结构，即切片内元素的类型是在编译期间确定的，存储在 <code>Extra</code> 字段中，供程序运行时动态获取。</p><h4 id="2、数据结构"><a href="#2、数据结构" class="headerlink" title="2、数据结构"></a>2、数据结构</h4><p>​切片的底层数据结构是用 <a href="https://draveness.me/golang/tree/reflect.SliceHeader"><code>reflect.SliceHeader</code></a> 结构体表示的，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 指向数组的指针</span><br>Len  <span class="hljs-type">int</span> <span class="hljs-comment">// 当前切片的长度</span><br>Cap  <span class="hljs-type">int</span> <span class="hljs-comment">// 当前切片的容量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​Data 是一片连续的内存空间，用于存储切片中的全部元素，<strong>我们可以将切片理解成一片连续的内存空间加上长度和容量的标识。</strong></p><p><img src="/images/slice.png" alt="slice"></p><p>​从图中我们可以看到，切片较数组来说，相当于是引入了一个抽象层，对数组中部分连续的片段进行了引用，我们在运行期间可以修改它的长度和范围。当切片底层数组的长度不足时，就会触发扩容，切片指向的数组会发生变化，此后再对切片进行修改，原始底层数组就不会发生改变了。</p><h4 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h4><p>​Go 中切片的初始化方式由三种：</p><ol><li><p>通过下标的方式获取数组或切片的一部分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">arr[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>] or slice[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li><li><p>使用字面量初始化新的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用关键字 <code>make</code> 创建切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li></ol><h5 id="使用下标"><a href="#使用下标" class="headerlink" title="使用下标"></a>使用下标</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> opslicemake<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newSlice</span><span class="hljs-params">()</span></span> []<span class="hljs-type">int</span> &#123;<br>arr := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>slice := arr[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>​使用下标创建切片，编译器会通过 <code>SliceMake</code> 操作，接收四个参数 <strong>元素类型、数组指针、切片大小和容量</strong> 来创建新的切片，这里的容量是继承自原数组的容量。需要注意的是，使用下标初始化并不会拷贝原数组或者原切片的数据，它只会创建一个指向原数组的切片结构体，包含一个指向原数组的指针，所以修改新切片的数据，也会修改原切片。</p><h5 id="使用字面量"><a href="#使用字面量" class="headerlink" title="使用字面量"></a>使用字面量</h5><p>​当我们使用字面量 <code>[]int&#123;1, 2, 3&#125;</code> 创建切片的时候，<a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.slicelit"><code>cmd/compile/internal/gc.slicelit</code></a> 函数会在编译期间将它展开成如下所示的代码片段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> vstat [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>vstat[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>vstat[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>vstat[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> vauto *[<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = <span class="hljs-built_in">new</span>([<span class="hljs-number">3</span>]<span class="hljs-type">int</span>)<br>*vauto = vstat<br>slice := vauto[:]<br></code></pre></td></tr></table></figure><ol><li>根据切片中的元素数量对底层数组的大小进行判断并创建一个数组</li><li>将这些字面量存储到初始化的数组中</li><li>创建一个同样指向 <code>[3]int</code>  类型的数组指针</li><li>将静态存储区的数组 <code>vstat</code> 赋值给 <code>vauto</code> 指针所在的地址</li><li>通过 <code>[:]</code> 操作获取一个底层使用<code>vauto</code>的切片</li></ol><p>​从第 5 步可以看出，使用字面量创建切片的方式本质上也是使用下标进行创建。</p><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>​使用 <code>make</code> 关键字 创建切片时，很多工作需要运行时的参与；调用方必须向 <code>make</code> 函数传入切片的大小以及可选的容量，然后类型检查期间会通过 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1"><code>cmd/compile/internal/gc.typecheck1</code></a>  函数校验参数是否正确：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typecheck1</span><span class="hljs-params">(n *Node, top <span class="hljs-type">int</span>)</span></span> (res *Node) &#123;<br><span class="hljs-keyword">switch</span> n.Op &#123;<br>...<br><span class="hljs-keyword">case</span> OMAKE:<br>args := n.List.Slice()<br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">switch</span> t.Etype &#123;<br><span class="hljs-keyword">case</span> TSLICE:<br>                <span class="hljs-comment">// 长度必须包含</span><br><span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(args) &#123;<br>yyerror(<span class="hljs-string">&quot;make(%v)缺少长度参数&quot;</span>, t) <span class="hljs-comment">// 报告编译错误，并返回原始节点 n</span><br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-comment">// 提取长度参数。</span><br>l := args[i]<br>i++<br><span class="hljs-keyword">var</span> r *Node<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(args) &#123;<br><span class="hljs-comment">// 如果存在，提取容量参数。</span><br>r = args[i]<br>&#125;<br>...<br><span class="hljs-comment">// 检查在 make([]T, len, cap) 中长度是否大于容量。</span><br><span class="hljs-keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="hljs-literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="hljs-number">0</span> &#123;<br>yyerror(<span class="hljs-string">&quot;在make(%v)中，长度大于容量&quot;</span>, t)<span class="hljs-comment">// 报告编译错误，并返回原始节点 n</span><br><span class="hljs-keyword">return</span> n<br>&#125;<br>n.Left = l<br>n.Right = r<br>n.Op = OMAKESLICE<br>&#125;<br>...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​该函数会检查 <code>len</code> 是否传入，且传入的容量 <code>cap</code> 一定要大于等于 长度 <code>len</code>。</p><p>​在参数校验后，当前函数还会将该节点的操作修改为切片操作，即<code>OMAKESLICE</code>，中间代码生成的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数会依据下面两个条件转换 <code>OMAKESLICE</code> 类型的节点：</p><ol><li>切片的大小和容量是否足够小</li><li>切片是否发生了逃逸，最终在堆上初始化</li></ol><p>​当切片发生逃逸或者非常大时，运行时需要 <a href="https://draveness.me/golang/tree/runtime.makeslice"><code>runtime.makeslice</code></a> 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，<code>make([]int, 3, 4)</code> 会被直接转换成如下所示的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br>n := arr[:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>​可以看到，也是通过下标 <code>[:3]</code> 得到数组对应的切片，这两部分都会在编译阶段完成。</p><p>​然后再看运行时创建切片的函数  <a href="https://draveness.me/golang/tree/runtime.makeslice"><code>runtime.makeslice</code></a>，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> unsafe.Pointer &#123;<br>    <span class="hljs-comment">// 计算所需内存和溢出检查</span><br>    mem, overflow := math.MulUintptr(et.size, <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>))<br>    <span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span> &gt; <span class="hljs-built_in">cap</span> &#123;<br>        mem, overflow := math.MulUintptr(et.size, <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">len</span>))<br>        <span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc || <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 切片长度异常，触发异常</span><br>            panicmakeslicelen()<br>        &#125;<br>        <span class="hljs-comment">// 切片容量异常，触发异常</span><br>        panicmakeslicecap()<br>    &#125;<br>    <span class="hljs-comment">// 分配内存并返回指针</span><br>    <span class="hljs-keyword">return</span> mallocgc(mem, et, <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​上述函数主要会为切片计算出所占用的内存空间，并在校验完成后，于堆上分配一片连续的内存：计算方式<code>内存空间 = 切片中元素大小 × 切片容量</code>，使用  <a href="https://draveness.me/golang/tree/runtime.mallocgc"><code>runtime.mallocgc</code></a> 函数根据对象大小进行内存分配，过程中</p><p>​分配内存前，会进行如下几方面的校验：</p><ol><li>内存空间的大小是否发生了溢出；</li><li>申请的内存大于最大可分配的内存；</li><li>传入的长度小于 0 或者长度大于容量；</li></ol><h4 id="4、访问元素"><a href="#4、访问元素" class="headerlink" title="4、访问元素"></a>4、访问元素</h4><p>​编译器将 <code>len(slice)</code> 和 <code>cap(slice)</code> 视为特殊操作，分别用 <code>OLEN</code> 和 <code>OCAP</code> 标识，并在 SSA 生成阶段将它们转换为 <code>OpSliceLen</code> 和 <code>OpSliceCap</code> 操作，以获取切片的长度和容量。此优化有助于在编译期间减少运行时的开销。</p><p>​通过 “decompose builtin” 优化，编译器在某些情况下会直接替换 <code>len(slice)</code> 和 <code>cap(slice)</code> 为切片的实际长度和容量，从而进一步提高程序性能。</p><p>​编译器对切片元素的访问也有进行优化，将 <code>OINDEX</code> 操作转换为直接访问切片地址的操作，以减少运行时成本。</p><p>​其实，大部分切片操作都在编译期间完成，包括切片遍历的优化，将包含 <code>range</code> 关键字的切片遍历转换为更简单的循环结构，以提高代码效率。这些优化和转换确保切片操作在运行时具有更高的性能，同时帮助编译器生成更有效的代码。</p><h4 id="5、追加和扩容"><a href="#5、追加和扩容" class="headerlink" title="5、追加和扩容"></a>5、追加和扩容</h4><p>​使用 <code>append</code> 关键字向切片追加元素也是常见操作，中间代码生成阶段的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.append"><code>cmd/compile/internal/gc.state.append</code></a> 方法会根据返回值是否会覆盖原变量，选择进入两种流程，如果 <code>append</code> 返回的新切片不需要赋值回原有的变量，就会进入如下的处理流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// append(slice, 1, 2, 3)</span><br><span class="hljs-comment">//  解析切片结构体，获取数组指针、长度、容量</span><br>ptr, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> := slice<br><span class="hljs-comment">// 追加后切片长度</span><br>newlen := <span class="hljs-built_in">len</span> + <span class="hljs-number">3</span><br><span class="hljs-comment">// 追加后长度大于容量，需要扩容</span><br><span class="hljs-keyword">if</span> newlen &gt; <span class="hljs-built_in">cap</span> &#123;<br>    ptr, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> = growslice(slice, newlen)<br>    newlen = <span class="hljs-built_in">len</span> + <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-comment">// 将新的元素依次加入切片中</span><br>*(ptr+<span class="hljs-built_in">len</span>) = <span class="hljs-number">1</span><br>*(ptr+<span class="hljs-built_in">len</span>+<span class="hljs-number">1</span>) = <span class="hljs-number">2</span><br>*(ptr+<span class="hljs-built_in">len</span>+<span class="hljs-number">2</span>) = <span class="hljs-number">3</span><br><span class="hljs-keyword">return</span> makeslice(ptr, newlen, <span class="hljs-built_in">cap</span>)<br></code></pre></td></tr></table></figure><p>​我们会先解构切片结构体获取它的数组指针、大小和容量，如果在追加元素后切片的大小大于容量，那么就会调用 <a href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 对切片进行扩容并将新的元素依次加入切片。</p><p>​如果会覆盖原切片，这时 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.append"><code>cmd/compile/internal/gc.state.append</code></a> 方法会使用另一种方式展开关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// slice = append(slice, 1, 2, 3)</span><br><span class="hljs-comment">//  解析切片结构体，获取数组指针、长度、容量</span><br>a := &amp;slice<br>ptr, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> := slice<br>newlen := <span class="hljs-built_in">len</span> + <span class="hljs-number">3</span><br><span class="hljs-comment">// 检查是否需要扩容</span><br><span class="hljs-keyword">if</span> <span class="hljs-type">uint</span>(newlen) &gt; <span class="hljs-type">uint</span>(<span class="hljs-built_in">cap</span>) &#123;<br>   <span class="hljs-comment">// 扩容</span><br>   newptr, <span class="hljs-built_in">len</span>, newcap = growslice(slice, newlen)<br>   vardef(a) <span class="hljs-comment">// 定义 a 为指向切片的指针</span><br>   *a.<span class="hljs-built_in">cap</span> = newcap <span class="hljs-comment">// 更新切片容量</span><br>   *a.ptr = newptr <span class="hljs-comment">// 更新切片指针</span><br>&#125;<br><span class="hljs-comment">// 更新长度</span><br>newlen = <span class="hljs-built_in">len</span> + <span class="hljs-number">3</span><br>*a.<span class="hljs-built_in">len</span> = newlen<br><span class="hljs-comment">// 追加新元素</span><br>*(ptr+<span class="hljs-built_in">len</span>) = <span class="hljs-number">1</span><br>*(ptr+<span class="hljs-built_in">len</span>+<span class="hljs-number">1</span>) = <span class="hljs-number">2</span><br>*(ptr+<span class="hljs-built_in">len</span>+<span class="hljs-number">2</span>) = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>​是否覆盖原变量的逻辑其实差不多，最大的区别在于得到的新切片<strong>是否会赋值回原变量</strong>。如果我们选择覆盖原有的变量，就不需要担心切片发生拷贝影响性能，因为 Go 语言编译器已经对这种常见的情况做出了优化。</p><p>​上面是对于切片容量足够时，向切片中追加元素的分析，接下来我们再来分析一下当切片容量不足时，如何处理。</p><p>​当切片的容量不足时，我们会调用 <a href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 函数为切片扩容，扩容是为切片<strong>分配新的内存空间并拷贝原切片中元素的过程</strong>，先来看看新切片的容量是如何确定的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> slice &#123;<br>newcap := old.<span class="hljs-built_in">cap</span><br>doublecap := newcap + newcap<br>    <span class="hljs-comment">// 期望容量大于当前容量的两倍就会使用期望容量</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 当前切片的长度小于 1024 就会将容量翻倍</span><br><span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;<br>newcap = doublecap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>newcap += newcap / <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​新切片容量的确定，运行时会根据切片当前的容量以及当前切片的长度选择不同的策略进行扩容：</p><ol><li>如果期望容量大于当前容量的两倍就会使用期望容量</li><li>如果当前切片的长度小于 1024 就会将容量翻倍</li><li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新的容量大于期望容量；</li></ol><p>​上面只会初步确定切片的大致容量，实际上还需要根据切片中的元素大小进行内存对齐，以此来提高访问效率。当数组中元素所占的字节大小为 1、 8 或者 2 的倍数时，运行时会使用如下的代码进行内存对齐：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> overflow <span class="hljs-type">bool</span>    <span class="hljs-comment">// 检测内存是否溢出</span><br><span class="hljs-keyword">var</span> lenmem, newlenmem, capmem <span class="hljs-type">uintptr</span>  <span class="hljs-comment">// 用于存储长度和容量的内存地址</span><br><br><span class="hljs-comment">// 根据元素类型的大小进行不同的计算</span><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> et.size == <span class="hljs-number">1</span>: <span class="hljs-comment">// 如果元素大小为1字节</span><br>    lenmem = <span class="hljs-type">uintptr</span>(old.<span class="hljs-built_in">len</span>)          <span class="hljs-comment">// 旧切片的长度</span><br>    newlenmem = <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>)            <span class="hljs-comment">// 新的切片长度</span><br>    capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap)) <span class="hljs-comment">// 新的切片容量，需要对齐</span><br>    overflow = <span class="hljs-type">uintptr</span>(newcap) &gt; maxAlloc <span class="hljs-comment">// 检查是否发生内存溢出</span><br>    newcap = <span class="hljs-type">int</span>(capmem)                <span class="hljs-comment">// 更新新的切片容量</span><br><span class="hljs-keyword">case</span> et.size == sys.PtrSize:  <span class="hljs-comment">// 如果元素大小等于指针大小</span><br>    lenmem = <span class="hljs-type">uintptr</span>(old.<span class="hljs-built_in">len</span>) * sys.PtrSize  <span class="hljs-comment">// 旧切片的长度</span><br>    newlenmem = <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>) * sys.PtrSize    <span class="hljs-comment">// 新的切片长度</span><br>    capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap) * sys.PtrSize)  <span class="hljs-comment">// 新的切片容量，需要对齐</span><br>    overflow = <span class="hljs-type">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize  <span class="hljs-comment">// 检查是否发生内存溢出</span><br>    newcap = <span class="hljs-type">int</span>(capmem / sys.PtrSize)           <span class="hljs-comment">// 更新新的切片容量</span><br><span class="hljs-keyword">case</span> isPowerOfTwo(et.size):  <span class="hljs-comment">// 如果元素大小是2的幂次方</span><br>    <span class="hljs-comment">// 进行其他计算...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 处理其他情况...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​内存对齐就是使用 <a href="https://draveness.me/golang/tree/runtime.roundupsize"><code>runtime.roundupsize</code></a> 函数，它会将带申请的内存向上取整，取整时使用 <a href="https://draveness.me/golang/tree/runtime.class_to_size"><code>runtime.class_to_size</code></a> 数组，使用该数组中的整数可以提高内存的分配效率并减少碎片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> class_to_size = [_NumSizeClasses]<span class="hljs-type">uint16</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">48</span>, <span class="hljs-number">64</span>, <span class="hljs-number">80</span>, ...,&#125;<br></code></pre></td></tr></table></figure><p>​在默认情况下，我们会将目标容量和元素大小相乘得到占用的内存。如果计算新容量时发生了内存溢出或者请求内存超过上限，就会直接崩溃退出程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> overflow <span class="hljs-type">bool</span>    <span class="hljs-comment">// 检测内存是否溢出</span><br><span class="hljs-keyword">var</span> newlenmem, capmem <span class="hljs-type">uintptr</span>  <span class="hljs-comment">// 用于存储长度和容量的内存地址switch &#123;</span><br>    <span class="hljs-comment">// 处理其他情况...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 计算新的内存大小，包括长度和容量</span><br>    lenmem = <span class="hljs-type">uintptr</span>(old.<span class="hljs-built_in">len</span>) * et.size<br>    newlenmem = <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">cap</span>) * et.size<br>    <span class="hljs-comment">// 使用 math 包中的函数计算新的容量并对其进行对齐</span><br>    capmem, _ = math.MulUintptr(et.size, <span class="hljs-type">uintptr</span>(newcap))<br>    capmem = roundupsize(capmem)<br>    newcap = <span class="hljs-type">int</span>(capmem / et.size)<br>&#125;<br><span class="hljs-comment">// 初始化 p 变量用于分配内存</span><br><span class="hljs-keyword">var</span> p unsafe.Pointer<br><span class="hljs-comment">// 检查元素类型是否包含指针，以决定是否需要清除内存</span><br><span class="hljs-keyword">if</span> et.kind&amp;kindNoPointers != <span class="hljs-number">0</span> &#123;<br>    p = mallocgc(capmem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)<br>    memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    p = mallocgc(capmem, et, <span class="hljs-literal">true</span>)<br>    <br>    <span class="hljs-comment">// 启用写屏障（write barrier）用于 GC</span><br>    <span class="hljs-keyword">if</span> writeBarrier.enabled &#123;<br>        bulkBarrierPreWriteSrcOnly(<span class="hljs-type">uintptr</span>(p), <span class="hljs-type">uintptr</span>(old.array), lenmem)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 复制旧切片的数据到新分配的内存中</span><br>memmove(p, old.array, lenmem)<br><span class="hljs-comment">// 返回新的切片，包括新的底层数内存地址、长度和容量</span><br><span class="hljs-keyword">return</span> slice&#123;p, old.<span class="hljs-built_in">len</span>, newcap&#125;<br></code></pre></td></tr></table></figure><p>​如果切片中元素不是指针类型，那么会调用 <a href="https://draveness.me/golang/tree/runtime.memclrNoHeapPointers"><code>runtime.memclrNoHeapPointers</code></a> 将超出切片当前长度的位置清空并在最后使用 <a href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 将原数组内存中的内容拷贝到新申请的内存中，然后再将超出的部分重新追加到新内存中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr []<span class="hljs-type">int64</span><br>arr = <span class="hljs-built_in">append</span>(arr, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>​当我们执行上述代码时，会触发 <a href="https://draveness.me/golang/tree/runtime.growslice"><code>runtime.growslice</code></a> 函数扩容 <code>arr</code> 切片并传入期望的新容量 5，这时期望分配的内存大小为 40 字节；不过因为切片中的元素大小等于 <code>sys.PtrSize</code>，所以运行时会调用 <a href="https://draveness.me/golang/tree/runtime.roundupsize"><code>runtime.roundupsize</code></a> 向上取整内存的大小到 48 字节，所以新切片的容量为 48 &#x2F; 8 &#x3D; 6。</p><h4 id="6、拷贝切片"><a href="#6、拷贝切片" class="headerlink" title="6、拷贝切片"></a>6、拷贝切片</h4><p>​当我们使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.copyany"><code>cmd/compile/internal/gc.copyany</code></a> 也会分两种情况进行处理拷贝操作，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">n := <span class="hljs-built_in">len</span>(a)<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-built_in">len</span>(b) &#123;<br>    n = <span class="hljs-built_in">len</span>(b)<br>&#125;<br><span class="hljs-keyword">if</span> a.ptr != b.ptr &#123;<br>    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) <br>&#125;<br></code></pre></td></tr></table></figure><p>​ <a href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 会负责拷贝内存。如果拷贝是发生在运行时，例如：<code>go copy(a, b)</code>，编译器会使用 <a href="https://draveness.me/golang/tree/runtime.slicecopy"><code>runtime.slicecopy</code></a> 替换运行期间调用的 <code>copy</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicecopy</span><span class="hljs-params">(to, fm slice, width <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 如果源切片或目标切片的长度为 0，不进行复制，返回 0</span><br><span class="hljs-keyword">if</span> fm.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> || to.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>n := fm.<span class="hljs-built_in">len</span><br><span class="hljs-comment">// 如果目标切片的长度小于源切片的长度，只复制目标切片长度的数据</span><br><span class="hljs-keyword">if</span> to.<span class="hljs-built_in">len</span> &lt; n &#123;<br>n = to.<span class="hljs-built_in">len</span><br><br><span class="hljs-comment">// 如果元素宽度为 0，不执行复制操作，返回长度 n</span><br><span class="hljs-keyword">if</span> width == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-comment">// 计算需要复制的总字节数</span><br>size := <span class="hljs-type">uintptr</span>(n) * width<br><span class="hljs-comment">// 如果复制的字节数为 1，直接复制单个字节数据</span><br><span class="hljs-keyword">if</span> size == <span class="hljs-number">1</span> &#123;<br>*(*<span class="hljs-type">byte</span>)(to.array) = *(*<span class="hljs-type">byte</span>)(fm.array)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 否则，使用 memmove 函数复制数据</span><br>memmove(to.array, fm.array, size)<br>&#125;<br><span class="hljs-comment">// 返回成功复制的元素个数</span><br><span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>​无论是编译期间拷贝还是运行时拷贝，两种拷贝方式都会通过 <a href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 将整块内存的内容拷贝到目标的内存区域中：</p><p><img src="/images/copy.png" alt="copy"></p><p>​相比于依次拷贝元素，<a href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 能够提供更好的性能。</p><h4 id="7、小结"><a href="#7、小结" class="headerlink" title="7、小结"></a>7、小结</h4><p>​下面是对上面内容的一个小结：</p><ol><li><p><strong>概述：</strong> 介绍了 Go 语言中切片的特性，切片是一种动态数组，可以自动扩容，与数组相似但长度可变。切片的类型在编译时确定，但长度和容量可以在运行时变化。</p></li><li><p><strong>数据结构：</strong> 描述了切片的底层数据结构，即 <code>reflect.SliceHeader</code>，包含指向数组的指针、长度和容量信息。</p></li><li><p><strong>初始化：</strong> 介绍了三种初始化切片的方式：通过下标、使用字面量、使用 <code>make</code> 关键字。解释了编译器在背后的工作，包括基于切片元素的大小来选择不同的策略。</p></li><li><p><strong>访问元素：</strong> 提到编译器优化 <code>len(slice)</code> 和 <code>cap(slice)</code>，以及如何将 <code>OINDEX</code> 操作优化为直接访问切片地址。</p></li><li><p><strong>追加和扩容：</strong> 解释了使用 <code>append</code> 进行元素追加的过程，包括扩容策略，内存对齐，以及内存的分配和拷贝。</p></li><li><p><strong>拷贝切片：</strong> 详细说明了编译期和运行时两种不同情况下的切片拷贝操作，使用 <code>copy(a, b)</code> 的编译时优化以及运行时的拷贝函数 <code>slicecopy</code>，还解释了底层内存的拷贝过程。</p></li></ol><p>这些内容详细介绍了 Go 语言中切片的内部工作机制，包括初始化、访问、扩容和拷贝等方面的细节，有助于理解切片的性能和使用。</p><h1 id="三、哈希表"><a href="#三、哈希表" class="headerlink" title="三、哈希表"></a>三、哈希表</h1><h4 id="1、设计原理"><a href="#1、设计原理" class="headerlink" title="1、设计原理"></a>1、设计原理</h4><p>​哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 O(1) 的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>​实现哈希表的关键在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求<strong>哈希函数的输出范围为大于输入范围</strong>，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p><p><img src="/images/%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.png" alt="完美的哈希函数"></p><p>​比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题。如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 O(1)�(1)；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 O(n)�(�)，由此看来，使用好的哈希函数是至关重要的。</p><p><img src="/images/%E4%B8%8D%E5%9D%87%E5%8C%80%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.png" alt="不均匀哈希函数"></p><h5 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h5><p>​在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多也会产生冲突。然而多数的哈希函数都是不够完美的，所以仍然存在发生哈希碰撞的可能，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p><h6 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h6><p>​<a href="https://en.wikipedia.org/wiki/Open_addressing">开放寻址法</a><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#fn:2">2</a>是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是<strong>依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中</strong>。如果我们使用开放寻址法来实现哈希表，那么哈希表底层的数据结构就是数组，不过因为数组的长度有限，向哈希表写入这个键值对会从如下的索引开始遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">index := hash(<span class="hljs-string">&quot;author&quot;</span>) % array.<span class="hljs-built_in">len</span><br></code></pre></td></tr></table></figure><p>​当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置：</p><p><img src="/images/%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE.png" alt="开放寻址法写入数据"></p><p>​如上图，哈希表中的两个键值对 key1 和 key2 发生冲突时，key3 会被写入 key2 后面的空闲位置。当我们再去读取 key3 对应的值的时候，就会先获取键的哈希并取模，这个时候会先找到 key1，发现与 key3 不相等，就会继续往后找，直到内存为空或者找到目标元素为止。</p><p>​开放寻址法中对性能影响最大的是<strong>装载因子</strong>，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 O(n)�(�) 的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。</p><h6 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h6><p>​拉链法是哈希表最常见的实现方法，大多数的编程语言都用拉链法来实现哈希表，它的实现比开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p><p>​实现拉链法一般会使用数组加上链表，不过有一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成扩展的二维数组：</p><p><img src="/images/%E6%8B%89%E9%93%BE%E6%B3%95%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE.png" alt="拉链法写入数据"></p><p>​如上图，当我们需要将键值对（key6，value6）写入哈希表时，键值对中的键 key6 都会经过一个哈希函数，哈希函数会帮助我们选择一个桶，方式就是直接对哈希的结果取模：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">index := hash(<span class="hljs-string">&quot;key6&quot;</span>) % array.<span class="hljs-built_in">len</span><br></code></pre></td></tr></table></figure><p>​选择了 2 号桶后，就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p><ol><li>找到键相同的键值对 — 更新键对应的值</li><li>没有找到键相同的键值对 – 在链表末尾追加新的键值对</li></ol><p>如果要在哈希表中获取某个键对应的值，会经历如下的过程：</p><p><img src="/images/1%E6%8B%89%E9%93%BE%E6%B3%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE.png" alt="1拉链法读取数据"></p><p>​上图是寻找 key11 的例子，当哈希表发现命中 4 号桶后，它会依次遍历桶中的键值对，遍历完整个链表也没有找到期望的键，说明哈希表中不存在该键对应的值。</p><p>​一个性能比较好的哈希表中，每个桶中的元素应该有 0 ~ 3 个，很少会超过这个范围。计算哈希、定位桶、遍历桶这三个过程是哈希表读写操作的主要开销，拉链法中也有转载因子的概念：<code> 装载因子 = 元素数量 ÷ 桶数量</code> </p><p>​同样的，拉链法的装载因子越大，哈希表的读写性能越差。一般情况下，拉链法的哈希表装载因子都不会超过 1 ，当哈希表装载因子较大时，会触发哈希表的扩容，通过创建更多的桶来重新划分键值对的分布，保证性能不会出现严重的下降。</p><h4 id="2、数据结构-1"><a href="#2、数据结构-1" class="headerlink" title="2、数据结构"></a>2、数据结构</h4><p>​Go 运行时同时使用了多个数据结构组合表示哈希表，其中 <a href="https://draveness.me/golang/tree/runtime.hmap"><code>runtime.hmap</code></a> 是最核心的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>count     <span class="hljs-type">int</span><br>flags     <span class="hljs-type">uint8</span><br>B         <span class="hljs-type">uint8</span><br>noverflow <span class="hljs-type">uint16</span><br>hash0     <span class="hljs-type">uint32</span><br><br>buckets    unsafe.Pointer<br>oldbuckets unsafe.Pointer<br>nevacuate  <span class="hljs-type">uintptr</span><br><br>extra *mapextra<br>&#125;<br><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>overflow    *[]*bmap<br>oldoverflow *[]*bmap<br>nextOverflow *bmap<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>count</code> 表示当前哈希表中的元素数量</li><li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，该字段存储的是桶的对数，即 <code>len(buckets) = 2 ^ B</code></li><li><code>hash0</code> 是哈希种子，在创建哈希函数时作为参数传入，它能为哈希函数的结果引入随机性</li><li><code>oldverflow</code> 是哈希表在扩容时用来保存之前的 <code>buckets</code> 的字段，它的大小是当前<code> buckets</code> 的一半</li></ol><p><img src="/images/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="哈希表的数据结构"></p><p>​如图所示，哈希表 <code>runtime.hamp</code> 的桶是<code>runtime.bmap</code>。每一个 <code>runtime.bmp</code> 都能存储 8 个键值对，当哈希表中存储的数据过多，单个桶已经装满时，会使用 <code>extra.nextOverflow</code> 中的桶存储溢出的数据。</p><p>​上述的两种桶被称为 正常桶 和溢出桶。黄色的 <code>runtime.bmap</code> 是正常桶，绿色的 <code>runtime.bmap</code> 是溢出桶。</p><p>​桶的结构体 <code>runtime.bmap</code> 在 Go 语言源码中的定义只包含一个简单的 <code>tophash</code> 字段，<code>tophash</code> 存储了键的哈希值高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>tophash [bucketCnt]uint8s<br>&#125;<br></code></pre></td></tr></table></figure><p>​在运行期间，<code>runtime.bmap</code> 还包含其他字段，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-type">uintptr</span><br>    overflow <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p><h4 id="3、初始化-1"><a href="#3、初始化-1" class="headerlink" title="3、初始化"></a>3、初始化</h4><p>​Go 语言初始化哈希表的两种方法 ——字面量和运行时。</p><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>​Go 语言中一般使用 <code>ke : value</code> 的语法来表示键值对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br><span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-number">4</span>,<br><span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-number">6</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>​在初始化哈希时，需要声明键值对的类型，这种使用字面量初始化的方式会通过 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.maplit"><code>cmd/compile/internal/gc.maplit</code></a> 初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maplit</span><span class="hljs-params">(n *Node, m *Node, init *Nodes)</span></span> &#123;<br>a := nod(OMAKE, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>a.Esc = n.Esc<br>a.List.Set2(typenod(n.Type), nodintconst(<span class="hljs-type">int64</span>(n.List.Len())))<br>litas(m, a, init)<br><br>entries := n.List.Slice()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) &gt; <span class="hljs-number">25</span> &#123;<br>...<br><span class="hljs-keyword">return</span><br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>​当哈希表中的元素数量少于或者等于 25 个时，编译器会将字面量初始化的结构体转换成以下的代码，将所有的键值对一次加入到哈希表中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<br>hash[<span class="hljs-string">&quot;1&quot;</span>] = <span class="hljs-number">2</span><br>hash[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-number">4</span><br>hash[<span class="hljs-string">&quot;5&quot;</span>] = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>​旦哈希表中元素的数量超过了 25 个，编译器会创建两个数组分别存储键和值，这些键值对会通过如下所示的 for 循环加入哈希：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>vstatk := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, ... ， <span class="hljs-string">&quot;26&quot;</span>&#125;<br>vstatv := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ... , <span class="hljs-number">26</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(vstak); i++ &#123;<br>    hash[vstatk[i]] = vstatv[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里展开的两个切片 <code>vstatk</code> 和 <code>vstatv</code> 还会被编辑器继续展开。无论使用哪种方法，使用字面量初始化的过程都会使用 Go 语言中的关键字 <code>make</code> 来创建新的哈希并通过最原始的 <code>[]</code> 语法向哈希追加元素。</p><h5 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h5><p>​当创建的哈希被分配到栈上并且其容量小于 <code>BUCKETSIZE = 8</code> 时，Go 语言在编译阶段会使用如下方式快速初始化哈希，这也是编译器对小容量的哈希做的优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> h *hmap<br><span class="hljs-keyword">var</span> hv hmap<br><span class="hljs-keyword">var</span> bv bmap<br>h := &amp;hv<br>b := &amp;bv<br>h.buckets = b<br>h.hash0 = fashtrand0()<br></code></pre></td></tr></table></figure><p>除了上述特定的优化之外，无论 <code>make</code> 是从哪里来的，只要我们使用 <code>make</code> 创建哈希，Go 语言编译器都会在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/">类型检查</a>期间将它们转换成 <a href="https://draveness.me/golang/tree/runtime.makemap"><code>runtime.makemap</code></a>，使用字面量初始化哈希也只是语言提供的辅助工具，最后调用的都是 <a href="https://draveness.me/golang/tree/runtime.makemap"><code>runtime.makemap</code></a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(t *maptype, hint <span class="hljs-type">int</span>, h *hmap)</span></span> *hmap &#123;<br>mem, overflow := math.MulUintptr(<span class="hljs-type">uintptr</span>(hint), t.bucket.size)<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc &#123;<br>hint = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>h = <span class="hljs-built_in">new</span>(hmap)<br>&#125;<br>h.hash0 = fastrand()<br><br>B := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> overLoadFactor(hint, B) &#123;<br>B++<br>&#125;<br>h.B = B<br><br><span class="hljs-keyword">if</span> h.B != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> nextOverflow *bmap<br>h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br>h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>h.extra.nextOverflow = nextOverflow<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数会按照下面的步骤执行：</p><ol><li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li><li>调用 <a href="https://draveness.me/golang/tree/runtime.fastrand"><code>runtime.fastrand</code></a> 获取一个随机的哈希种子；</li><li>根据传入的 <code>hint</code> 计算出需要的最小需要的桶的数量；</li><li>使用 <a href="https://draveness.me/golang/tree/runtime.makeBucketArray"><code>runtime.makeBucketArray</code></a> 创建用于保存桶的数组；</li></ol><p><a href="https://draveness.me/golang/tree/runtime.makeBucketArray"><code>runtime.makeBucketArray</code></a> 会根据传入的 <code>B</code> 计算出的需要创建的桶数量并在内存中分配一片连续的空间用于存储数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBucketArray</span><span class="hljs-params">(t *maptype, b <span class="hljs-type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;<br>base := bucketShift(b)<br>nbuckets := base<br><span class="hljs-keyword">if</span> b &gt;= <span class="hljs-number">4</span> &#123;<br>nbuckets += bucketShift(b - <span class="hljs-number">4</span>)<br>sz := t.bucket.size * nbuckets<br>up := roundupsize(sz)<br><span class="hljs-keyword">if</span> up != sz &#123;<br>nbuckets = up / t.bucket.size<br>&#125;<br>&#125;<br><br>buckets = newarray(t.bucket, <span class="hljs-type">int</span>(nbuckets))<br><span class="hljs-keyword">if</span> base != nbuckets &#123;<br>nextOverflow = (*bmap)(add(buckets, base*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>last := (*bmap)(add(buckets, (nbuckets<span class="hljs-number">-1</span>)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>last.setoverflow(t, (*bmap)(buckets))<br>&#125;<br><span class="hljs-keyword">return</span> buckets, nextOverflow<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当桶的数量小于 2424 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li><li>当桶的数量多于 2424 时，会额外创建 2B−42�−4 个溢出桶；</li></ul><p>根据上述代码，我们能确定在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，只是被 <a href="https://draveness.me/golang/tree/runtime.hmap"><code>runtime.hmap</code></a> 中的不同字段引用，当溢出桶数量较多时会通过 <a href="https://draveness.me/golang/tree/runtime.newobject"><code>runtime.newobject</code></a> 创建新的溢出桶。</p><h4 id="4、读写操作"><a href="#4、读写操作" class="headerlink" title="4、读写操作"></a>4、读写操作</h4><p>​哈希表的访问一般都是通过下标或者遍历进行的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">_ = hash[key]<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> hash &#123;<br>    <span class="hljs-comment">// k, v</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​这两种方式虽然都能读取哈希表的数据，但是使用的函数和底层原理完全不同。前者需要知道哈希的键并且一次只能获取单个键对应的值，而后者可以遍历哈希中的全部键值对，访问数据时也不需要预先知道哈希的键。在这里我们会介绍前一种访问方式。</p><p>​数据结构的写一般指的都是增加、删除和修改，增加和修改字段都使用索引和赋值语句，而删除字典中的数据需要使用关键字 <code>delete</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">hash[key] = value<br>hash[key] = newValue<br><span class="hljs-built_in">delete</span>(hash, key)<br></code></pre></td></tr></table></figure><h5 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h5><p>​在编译的<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/">类型检查</a>期间，<code>hash[key]</code> 以及类似的操作都会被转换成哈希的 <code>OINDEXMAP</code> 操作，<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-ir-ssa/">中间代码生成</a>阶段会在 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr"><code>cmd/compile/internal/gc.walkexpr</code></a> 函数中将这些 <code>OINDEXMAP</code> 操作转换成如下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">v     := hash[key] <span class="hljs-comment">// =&gt; v     := *mapaccess1(maptype, hash, &amp;key)</span><br>v, ok := hash[key] <span class="hljs-comment">// =&gt; v, ok := mapaccess2(maptype, hash, &amp;key)</span><br></code></pre></td></tr></table></figure><p>​赋值语句左侧接受参数的个数会决定使用的运行时方法：</p><ul><li>当接受一个参数时，会使用 <a href="https://draveness.me/golang/tree/runtime.mapaccess1"><code>runtime.mapaccess1</code></a>，该函数仅会返回一个指向目标值的指针；</li><li>当接受两个参数时，会使用 <a href="https://draveness.me/golang/tree/runtime.mapaccess2"><code>runtime.mapaccess2</code></a>，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 <code>bool</code> 值：</li></ul><p>​<a href="https://draveness.me/golang/tree/runtime.mapaccess1"><code>runtime.mapaccess1</code></a> 会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 <a href="https://draveness.me/golang/tree/runtime.bucketMask"><code>runtime.bucketMask</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.add"><code>runtime.add</code></a> 拿到该键值对所在的桶序号和哈希高位的 8 位数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br>alg := t.key.alg<br>hash := alg.hash(key, <span class="hljs-type">uintptr</span>(h.hash0))<br>m := bucketMask(h.B)<br>b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>top := tophash(hash)<br>bucketloop:<br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> alg.equal(key, k) &#123;<br>v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.valuesize))<br><span class="hljs-keyword">return</span> v<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>​在 <code>bucketloop</code> 循环中，哈希会依次遍历正常桶和溢出桶中的数据，它会先比较哈希的高 8 位和桶中存储的 <code>tophash</code>，后比较传入的和桶中的值以加速数据的读写。用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等 <code>tophash</code> 的概率影响性能。</p><p><img src="/images/%E8%AE%BF%E9%97%AE%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt="访问哈希表中的数据"></p><p>​如上图所示，每一个桶都是一整片的内存空间，当发现桶中的 <code>tophash</code> 与传入键的 <code>tophash</code> 匹配之后，我们会通过指针和偏移量获取哈希中存储的键 <code>keys[0]</code> 并与 <code>key</code> 比较，如果两者相同就会获取目标值的指针 <code>values[0]</code> 并返回。</p><p>​另一个同样用于访问哈希表中数据的 <a href="https://draveness.me/golang/tree/runtime.mapaccess2"><code>runtime.mapaccess2</code></a> 只是在 <a href="https://draveness.me/golang/tree/runtime.mapaccess1"><code>runtime.mapaccess1</code></a> 的基础上多返回了一个标识键值对是否存在的 <code>bool</code> 值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess2</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="hljs-type">bool</span>) &#123;<br>...<br>bucketloop:<br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> alg.equal(key, k) &#123;<br>v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.valuesize))<br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>]), <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​使用 <code>v, ok := hash[k]</code> 的形式访问哈希表中元素时，我们能够通过这个布尔值更准确地知道当 <code>v == nil</code> 时，<code>v</code> 到底是哈希中存储的元素还是表示该键对应的元素不存在，所以在访问哈希时，更推荐使用这种方式判断元素是否存在。</p><h5 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h5><p>​当形如 <code>hash[k]</code> 的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成 <a href="https://draveness.me/golang/tree/runtime.mapassign"><code>runtime.mapassign</code></a> 函数的调用，该函数与 <a href="https://draveness.me/golang/tree/runtime.mapaccess1"><code>runtime.mapaccess1</code></a> 比较相似，我们将其分成几个部分依次分析，首先是函数会根据传入的键拿到对应的哈希和桶：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br>alg := t.key.alg<br>hash := alg.hash(key, <span class="hljs-type">uintptr</span>(h.hash0))<br><br>h.flags ^= hashWriting<br><br>again:<br>bucket := hash &amp; bucketMask(h.B)<br>b := (*bmap)(unsafe.Pointer(<span class="hljs-type">uintptr</span>(h.buckets) + bucket*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>top := tophash(hash)<br></code></pre></td></tr></table></figure><p>​然后通过遍历比较桶中存储的 <code>tophash</code> 和键的哈希，如果找到了相同结果就会返回目标位置的地址。其中 <code>inserti</code> 表示目标元素的在桶中的索引，<code>insertk</code> 和 <code>val</code> 分别表示键值对的地址，获得目标地址之后会通过算术计算寻址获得键值对 <code>k</code> 和 <code>val</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> inserti *<span class="hljs-type">uint8</span><br><span class="hljs-keyword">var</span> insertk unsafe.Pointer<br><span class="hljs-keyword">var</span> val unsafe.Pointer<br>bucketloop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="hljs-literal">nil</span> &#123;<br>inserti = &amp;b.tophash[i]<br>insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br>val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.valuesize))<br>&#125;<br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> !alg.equal(key, k) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.valuesize))<br><span class="hljs-keyword">goto</span> done<br>&#125;<br>ovf := b.overflow(t)<br><span class="hljs-keyword">if</span> ovf == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>b = ovf<br>&#125;<br></code></pre></td></tr></table></figure><p>​上述的 for 循环会依次遍历正常桶和溢出桶中存储的数据，整个过程会分别判断 <code>tophash</code> 是否相等、<code>key</code> 是否相等，遍历结束后会从循环中跳出。</p><p><img src="/images/%E5%93%88%E5%B8%8C%E8%A1%A8%E9%81%8D%E5%8E%86%E6%BA%A2%E5%87%BA%E6%A1%B6.png" alt="哈希表遍历溢出桶"></p><p>如果当前桶已经满了，哈希会调用 <a href="https://draveness.me/golang/tree/runtime.hmap.newoverflow"><code>runtime.hmap.newoverflow</code></a> 创建新桶或者使用 <a href="https://draveness.me/golang/tree/runtime.hmap"><code>runtime.hmap</code></a> 预先在 <code>noverflow</code> 中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的 <code>noverflow</code> 计数器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> inserti == <span class="hljs-literal">nil</span> &#123;<br>newb := h.newoverflow(t, b)<br>inserti = &amp;newb.tophash[<span class="hljs-number">0</span>]<br>insertk = add(unsafe.Pointer(newb), dataOffset)<br>val = add(insertk, bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize))<br>&#125;<br><br>typedmemmove(t.key, insertk, key)<br>*inserti = top<br>h.count++<br><br>done:<br><span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前键值对在哈希中不存在，哈希会为新键值对规划存储的内存地址，通过 <a href="https://draveness.me/golang/tree/runtime.typedmemmove"><code>runtime.typedmemmove</code></a> 将键移动到对应的内存空间中并返回键对应值的地址 <code>val</code>。如果当前键值对在哈希中存在，那么就会直接返回目标区域的内存地址，哈希并不会在 <a href="https://draveness.me/golang/tree/runtime.mapassign"><code>runtime.mapassign</code></a> 这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址，</p><h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>​在写入的过程中，其实还会涉及到一个过程：扩容操作。随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要更多的桶和更大的内存保证哈希的读写性能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br>...<br><span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>hashGrow(t, h)<br><span class="hljs-keyword">goto</span> again<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>​该函数会在以下两种情况触发哈希的扩容：</p><ol><li>装载因子已经超过 6.5</li><li>哈希使用了太多溢出桶</li></ol><p>​根据触发的条件不同，扩容的方式也不同：如果扩容的原因是溢出桶太多，那么这次扩容就是等量扩容 <code>sameSizeGrow</code>，这是一种特殊的扩容，当我们持续向哈希表中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断累积溢出桶造成缓慢的内存泄漏。<code>sameSizeGrow</code> 通过复用已有的哈希扩容机制解决该问题，一旦出现了过多的溢出桶，它会创建新的桶保存数据，垃圾回收会清理旧的溢出桶并释放内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hashGrow</span><span class="hljs-params">(t *maptype, h *hmap)</span></span> &#123;<br>bigger := <span class="hljs-type">uint8</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> !overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) &#123;<br>bigger = <span class="hljs-number">0</span><br>h.flags |= sameSizeGrow<br>&#125;<br>oldbuckets := h.buckets<br>newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="hljs-literal">nil</span>)<br><br>h.B += bigger<br>h.flags = flags<br>h.oldbuckets = oldbuckets<br>h.buckets = newbuckets<br>h.nevacuate = <span class="hljs-number">0</span><br>h.noverflow = <span class="hljs-number">0</span><br><br>h.extra.oldoverflow = h.extra.overflow<br>h.extra.overflow = <span class="hljs-literal">nil</span><br>h.extra.nextOverflow = nextOverflow<br>&#125;<br></code></pre></td></tr></table></figure><p>哈希在扩容的过程中会通过 <a href="https://draveness.me/golang/tree/runtime.makeBucketArray"><code>runtime.makeBucketArray</code></a> 创建一组新桶和预创建的溢出桶，随后将原有的桶数组设置到 <code>oldbuckets</code> 上并将新的空桶设置到 <code>buckets</code> 上，溢出桶也使用了相同的逻辑更新，下图展示了触发扩容后的哈希：</p><p><img src="/images/%E5%93%88%E5%B8%8C%E8%A1%A8%E8%A7%A6%E5%8F%91%E6%89%A9%E5%AE%B9.png" alt="哈希表触发扩容"></p><p>我们在 <a href="https://draveness.me/golang/tree/runtime.hashGrow"><code>runtime.hashGrow</code></a> 中还看不出来等量扩容和翻倍扩容的太多区别，等量扩容创建的新桶数量只是和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转移。哈希表的数据迁移的过程在是 <a href="https://draveness.me/golang/tree/runtime.evacuate"><code>runtime.evacuate</code></a> 中完成的，它会对传入桶中的元素进行再分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">evacuate</span><span class="hljs-params">(t *maptype, h *hmap, oldbucket <span class="hljs-type">uintptr</span>)</span></span> &#123;<br>b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>newbit := h.noldbuckets()<br><span class="hljs-keyword">if</span> !evacuated(b) &#123;<br><span class="hljs-keyword">var</span> xy [<span class="hljs-number">2</span>]evacDst<br>x := &amp;xy[<span class="hljs-number">0</span>]<br>x.b = (*bmap)(add(h.buckets, oldbucket*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>x.k = add(unsafe.Pointer(x.b), dataOffset)<br>x.v = add(x.k, bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize))<br><br>y := &amp;xy[<span class="hljs-number">1</span>]<br>y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>y.k = add(unsafe.Pointer(y.b), dataOffset)<br>y.v = add(y.k, bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize))<br></code></pre></td></tr></table></figure><p>​而当哈希表的容量翻倍时，每个旧桶的元素会都分流到新创建的两个桶中，这里仔细分析一下分流元素的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>k := add(unsafe.Pointer(b), dataOffset)<br>v := add(k, bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="hljs-number">1</span>, add(k, <span class="hljs-type">uintptr</span>(t.keysize)), add(v, <span class="hljs-type">uintptr</span>(t.valuesize)) &#123;<br>top := b.tophash[i]<br>k2 := k<br><span class="hljs-keyword">var</span> useY <span class="hljs-type">uint8</span><br>hash := t.key.alg.hash(k2, <span class="hljs-type">uintptr</span>(h.hash0))<br><span class="hljs-keyword">if</span> hash&amp;newbit != <span class="hljs-number">0</span> &#123;<br>useY = <span class="hljs-number">1</span><br>&#125;<br>b.tophash[i] = evacuatedX + useY<br>dst := &amp;xy[useY]<br><br><span class="hljs-keyword">if</span> dst.i == bucketCnt &#123;<br>dst.b = h.newoverflow(t, dst.b)<br>dst.i = <span class="hljs-number">0</span><br>dst.k = add(unsafe.Pointer(dst.b), dataOffset)<br>dst.v = add(dst.k, bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize))<br>&#125;<br>dst.b.tophash[dst.i&amp;(bucketCnt<span class="hljs-number">-1</span>)] = top<br>typedmemmove(t.key, dst.k, k)<br>typedmemmove(t.elem, dst.v, v)<br>dst.i++<br>dst.k = add(dst.k, <span class="hljs-type">uintptr</span>(t.keysize))<br>dst.v = add(dst.v, <span class="hljs-type">uintptr</span>(t.valuesize))<br>&#125;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>​只使用哈希函数是不能定位到具体某一个桶的，哈希函数只会返回很长的哈希，例如：<code>b72bfae3f3285244c4732ce457cca823bc189e0b</code>，我们还需一些方法将哈希映射到具体的桶上。我们一般都会使用取模或者位操作来获取桶的编号，假如当前哈希中包含 4 个桶，那么它的桶掩码就是 0b11(3)，使用位操作就会得到 3， 我们就会在 3 号桶中存储该数据.</p><p>​<a href="https://draveness.me/golang/tree/runtime.evacuate"><code>runtime.evacuate</code></a> 最后会调用 <a href="https://draveness.me/golang/tree/runtime.advanceEvacuationMark"><code>runtime.advanceEvacuationMark</code></a> 增加哈希的 <code>nevacuate</code> 计数器并在所有的旧桶都被分流后清空哈希的 <code>oldbuckets</code> 和 <code>oldoverflow</code>.</p><p>​除了写入操作之外，删除操作也会在哈希表扩容期间触发 <a href="https://draveness.me/golang/tree/runtime.growWork"><code>runtime.growWork</code></a>，触发的方式和代码与这里的逻辑几乎完全相同，都是计算当前值所在的桶，然后拷贝桶中的元素。</p><p>​简单总结一下哈希表扩容的设计和原理，哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，扩容过程不是原子的，而是通过 <a href="https://draveness.me/golang/tree/runtime.growWork"><code>runtime.growWork</code></a> 增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流。除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 <code>sameSizeGrow</code> 这一机制，在出现较多溢出桶时会整理哈希的内存减少空间的占用。</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>​想要删除哈希中的元素，就需要使用<code>delete</code> 关键字，这个关键字的唯一作用就是将某一个键对应的元素从哈希表中删除，无论是该键对应的值是否存在，这个内建的函数都不会返回任何的结果。</p><p>​哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p><h4 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h4><p>​Go 语言使用拉链法解决哈希碰撞问题，实现哈希表，对哈希表的访问、写入和删除等操作都在编译期间转换成运行时的函数或方法。每个哈希桶存储键对应哈希的前 8 位，这些前 8 位哈希值成为能够快速遍历桶中元素的缓存。</p><p>​每个哈希桶最多存储 8 个键值对。一旦某个桶内的键值对数量超过 8 个，新的键值对将存储在哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希表的装载因子也逐渐升高。当装载因子超过一定范围时，会触发哈希表的扩容操作。扩容将哈希表的桶数量翻倍，这个元素重新分配的过程是在调用写操作时逐步完成的，不会导致性能的急剧波动。这种机制有助于维护哈希表的高效性和均衡性。</p><h1 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h1><p>​字符串是由字符组成的数组，C 语言中的字符串使用字符数组 <code>char[]</code> 表示。数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串，Go 语言中的字符串只是一个只读的字节数组，如下图所示：</p><p><img src="/images/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84.png" alt="内存中的数组"></p><p>​只读只意味着字符串会分配到只读的内存空间，但是 Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间，我们仍然可以通过在 <code>string</code> 和 <code>[]byte</code> 类型之间反复转换实现修改这一目的：</p><ol><li>先将这段内存拷贝到堆或者栈上；</li><li>将变量的类型转换成 <code>[]byte</code> 后并修改字节数据；</li><li>将修改后的字节数组转换回 <code>string</code>；</li></ol><h4 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h4><p>​字符串在 Go 语言中的实现很简单，每一个字符串在运行时都会使用 <code>reflect.StringHeader</code> 表示，其中包含指向字符数组的指针和数组的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​会发现与切片的结构体非常相似，至少了一个表示容量的 <code>Cap</code> 字段，因此字符串经常被说是一个只读的切片类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、解析过程"><a href="#2、解析过程" class="headerlink" title="2、解析过程"></a>2、解析过程</h4><p>​解析器会在词法分析阶段解析字符串，将原有无意义的字符流转换成 Token 序列。在 Go 语言中有两种声明字符串的方式，即双引号和反引号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">str1 := <span class="hljs-string">&quot;this is a string&quot;</span><br>str2 := <span class="hljs-string">`this is s another</span><br><span class="hljs-string">string `</span><br></code></pre></td></tr></table></figure><p>​对于双引号声明字符串没有啥好说的，它只能用于单行字符串的初始化，其内部如果需要使用双引号，要用 <code>\</code> 转义；而反引号可以摆脱单行的限制。当使用反引号时，双引号不再表示字符串的开始和结尾，因此在字符串内部可以直接使用 <code>&quot;</code>。反引号在需要手写 JSON 或者其他复杂数据格式的场景下非常方便：：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">json := <span class="hljs-string">`&#123;&quot;author&quot;: &quot;draven&quot;, &quot;tags&quot;: [&quot;golang&quot;]&#125;`</span><br></code></pre></td></tr></table></figure><p>​两种不同的声明方式，也就意味着编辑器需要不同的解析方式。对于双引号格式的字符串，编译器使用扫描器 <a href="https://draveness.me/golang/tree/cmd/compile/internal/syntax.scanner"><code>cmd/compile/internal/syntax.scanner</code></a> 会将输入的字符串转换成 Token 流，<a href="https://draveness.me/golang/tree/cmd/compile/internal/syntax.scanner.stdString"><code>cmd/compile/internal/syntax.scanner.stdString</code></a> 方法是它用来解析使用双引号的标准字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *scanner)</span></span> stdString() &#123;<br>s.startLit()  <span class="hljs-comment">// 初始化字符串字面量扫描</span><br><br><span class="hljs-keyword">for</span> &#123;<br>r := s.getr()  <span class="hljs-comment">// 从输入中获取一个字符</span><br><span class="hljs-keyword">if</span> r == <span class="hljs-string">&#x27;&quot;&#x27;</span> &#123;<br><span class="hljs-keyword">break</span>  <span class="hljs-comment">// 如果字符是双引号，表示字符串结束，退出循环</span><br>&#125;<br><span class="hljs-keyword">if</span> r == <span class="hljs-string">&#x27;\\&#x27;</span> &#123;<br>s.escape(<span class="hljs-string">&#x27;&quot;&#x27;</span>)  <span class="hljs-comment">// 处理转义字符</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> r == <span class="hljs-string">&#x27;\n&#x27;</span> &#123;<br>s.ungetr()  <span class="hljs-comment">// 回退字符</span><br>s.<span class="hljs-type">error</span>(<span class="hljs-string">&quot;newline in string&quot;</span>)  <span class="hljs-comment">// 产生错误消息，因为字符串中不应包含换行符</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> &#123;<br>s.errh(s.line, s.col, <span class="hljs-string">&quot;string not terminated&quot;</span>)  <span class="hljs-comment">// 产生错误消息，字符串没有正常终止</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>s.nlsemi = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 标记字符串中允许包含换行符</span><br>s.lit = <span class="hljs-type">string</span>(s.stopLit())  <span class="hljs-comment">// 存储已扫描的字符串字面量的内容</span><br>s.kind = StringLit  <span class="hljs-comment">// 标记标记的种类为字符串字面量</span><br>s.tok = _Literal  <span class="hljs-comment">// 标记标记的类型为字面量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​从这个方法的实现我们能分析出 Go 语言处理标准字符串的逻辑：</p><ol><li>标准字符串使用双引号表示开头和结尾；</li><li>标准字符串需要使用反斜杠 <code>\</code> 来逃逸双引号；</li><li>标准字符串不能出现如下所示的隐式换行 <code>\n</code>；</li></ol><p>​使用反引号声明的解析就很简单了，<a href="https://draveness.me/golang/tree/cmd/compile/internal/syntax.scanner.rawString"><code>cmd/compile/internal/syntax.scanner.rawString</code></a> 会将非反引号的所有字符都划分到当前字符串的范围中，所以我们可以使用它支持复杂的多行字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *scanner)</span></span> rawString() &#123;<br>s.startLit()  <span class="hljs-comment">// 初始化原始字符串字面量扫描</span><br><br><span class="hljs-keyword">for</span> &#123;<br>r := s.getr()  <span class="hljs-comment">// 从输入中获取一个字符</span><br><span class="hljs-keyword">if</span> r == <span class="hljs-string">&#x27;`&#x27;</span> &#123;<br><span class="hljs-keyword">break</span>  <span class="hljs-comment">// 如果字符是反引号，表示原始字符串结束，退出循环</span><br>&#125;<br><span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> &#123;<br>s.errh(s.line, s.col, <span class="hljs-string">&quot;string not terminated&quot;</span>)  <span class="hljs-comment">// 产生错误消息，原始字符串没有正常终止</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br>s.nlsemi = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 标记原始字符串中允许包含换行符</span><br>s.lit = <span class="hljs-type">string</span>(s.stopLit())  <span class="hljs-comment">// 存储已扫描的原始字符串字面量的内容</span><br>s.kind = StringLit  <span class="hljs-comment">// 标记标记的种类为原始字符串字面量</span><br>s.tok = _Literal  <span class="hljs-comment">// 标记标记的类型为字面量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​无论是标准字符串还是原始字符串都会被标记成 <code>StringLit</code> 并传递到语法分析阶段。在语法分析阶段，与字符串相关的表达式都会由 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.noder.basicLit"><code>cmd/compile/internal/gc.noder.basicLit</code></a> 方法处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *noder)</span></span> basicLit(lit *syntax.BasicLit) Val &#123;<br><span class="hljs-keyword">switch</span> s := lit.Value; lit.Kind &#123;<br><span class="hljs-keyword">case</span> syntax.StringLit:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;`&#x27;</span> &#123;<br>s = strings.Replace(s, <span class="hljs-string">&quot;\r&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">-1</span>)  <span class="hljs-comment">// 如果是原始字符串字面量，去除其中的回车符</span><br>&#125;<br>u, _ := strconv.Unquote(s)  <span class="hljs-comment">// 解析字符串字面量并移除转义字符</span><br><span class="hljs-keyword">return</span> Val&#123;U: u&#125;  <span class="hljs-comment">// 返回解析后的字符串字面量作为 Val 结构</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是 <code>import</code> 语句中包的路径、结构体中的字段标签还是表达式中的字符串都会使用这个方法将原生字符串中最后的换行符删除并对字符串 Token 进行 Unquote，也就是去掉字符串两边的引号等无关干扰，还原其本来的面目。</p><p><a href="https://draveness.me/golang/tree/strconv.Unquote"><code>strconv.Unquote</code></a> 处理了很多边界条件导致实现非常复杂，其中不仅包括引号，还包括 UTF-8 等编码的处理逻辑，这里也就不展开介绍了。</p><h4 id="3、拼接"><a href="#3、拼接" class="headerlink" title="3、拼接"></a>3、拼接</h4><p>​项目中我们拼接字符串会使用 <code>+</code>，编译器会将该符号对应的 <code>OADD</code> 节点转换成 <code>OADDSTR</code> 类型的节点，随后在 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr"><code>cmd/compile/internal/gc.walkexpr</code></a> 中调用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.addstr"><code>cmd/compile/internal/gc.addstr</code></a> 函数生成用于拼接字符串的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkexpr</span><span class="hljs-params">(n *Node, init *Nodes)</span></span> *Node &#123;<br><span class="hljs-keyword">switch</span> n.Op &#123;<br><span class="hljs-comment">// 其他操作的处理...</span><br><span class="hljs-keyword">case</span> OADDSTR:<br>n = addstr(n, init)  <span class="hljs-comment">// 如果操作为字符串拼接，调用 addstr 函数处理</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.addstr"><code>cmd/compile/internal/gc.addstr</code></a> 能帮助我们在编译期间选择合适的函数对字符串进行拼接，该函数会根据带拼接的字符串数量选择不同的逻辑：</p><ul><li><p>如果小于或者等于 5 个，那么会调用 <code>concatstring&#123;2,3,4,5&#125;</code> 等一系列函数；</p></li><li><p>如果超过 5 个，那么会选择 <a href="https://draveness.me/golang/tree/runtime.concatstrings"><code>runtime.concatstrings</code></a> 传入一个数组切片；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addstr</span><span class="hljs-params">(n *Node, init *Nodes)</span></span> *Node &#123;<br>c := n.List.Len()  <span class="hljs-comment">// 获取字符串拼接表达式中操作数的数量</span><br><br>buf := nodnil()  <span class="hljs-comment">// 创建一个 nil 的节点，用于存储字符串拼接结果</span><br>args := []*Node&#123;buf&#125;  <span class="hljs-comment">// 创建一个节点切片，初始包含 buf 节点</span><br><span class="hljs-keyword">for</span> _, n2 := <span class="hljs-keyword">range</span> n.List.Slice() &#123;<br>args = <span class="hljs-built_in">append</span>(args, conv(n2, types.Types[TSTRING]))  <span class="hljs-comment">// 将表达式节点 n2 转换为字符串类型，然后添加到 args 中</span><br>&#125;<br><br><span class="hljs-keyword">var</span> fn <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> c &lt;= <span class="hljs-number">5</span> &#123;<br>fn = fmt.Sprintf(<span class="hljs-string">&quot;concatstring%d&quot;</span>, c)  <span class="hljs-comment">// 根据操作数数量选择合适的字符串拼接函数名</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fn = <span class="hljs-string">&quot;concatstrings&quot;</span><br><br>t := types.NewSlice(types.Types[TSTRING])<br>slice := nod(OCOMPLIT, <span class="hljs-literal">nil</span>, typenod(t))  <span class="hljs-comment">// 创建一个字符串切片的复合字面量</span><br>slice.List.Set(args[<span class="hljs-number">1</span>:])  <span class="hljs-comment">// 设置切片的元素列表为 args 中的参数</span><br>args = []*Node&#123;buf, slice&#125;<br>&#125;<br><br>cat := syslook(fn)  <span class="hljs-comment">// 查找字符串拼接函数</span><br>r := nod(OCALL, cat, <span class="hljs-literal">nil</span>)  <span class="hljs-comment">// 创建一个函数调用节点</span><br>r.List.Set(args)<br><span class="hljs-comment">// 其他处理逻辑...</span><br><span class="hljs-keyword">return</span> r  <span class="hljs-comment">// 返回处理后的字符串拼接表达式节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​其实无论使用 <code>concatstring&#123;2,3,4,5&#125;</code> 中的哪一个，最终都会调用 <a href="https://draveness.me/golang/tree/runtime.concatstrings"><code>runtime.concatstrings</code></a>，它会先对遍历传入的切片参数，再过滤空字符串并计算拼接后字符串的长度。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstrings</span><span class="hljs-params">(buf *tmpBuf, a []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>idx := <span class="hljs-number">0</span><br>l := <span class="hljs-number">0</span><br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> a &#123;<br>n := <span class="hljs-built_in">len</span>(x)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>l += n<br>count++<br>idx = i<br>&#125;<br><span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-comment">// 如果没有非空字符串可拼接，返回空字符串</span><br>&#125;<br><span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span> &amp;&amp; (buf != <span class="hljs-literal">nil</span> || !stringDataOnStack(a[idx])) &#123;<br><span class="hljs-keyword">return</span> a[idx]  <span class="hljs-comment">// 如果只有一个非空字符串且无需缓冲区拼接，直接返回该字符串</span><br>&#125;<br>s, b := rawstringtmp(buf, l)  <span class="hljs-comment">// 分配用于拼接的字符串内存</span><br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-built_in">copy</span>(b, x)  <span class="hljs-comment">// 将每个字符串拷贝到拼接结果中</span><br>b = b[<span class="hljs-built_in">len</span>(x):]  <span class="hljs-comment">// 更新拼接位置</span><br>&#125;<br><span class="hljs-keyword">return</span> s  <span class="hljs-comment">// 返回拼接后的字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​如果非空字符串的数量为 1 并且当前的字符串不在栈上，就可以直接返回该字符串，不需要做出额外操作。</p><p><img src="/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8B%B7%E8%B4%9D.png" alt="字符串拼接和拷贝"></p><p>​但是在正常情况下，运行时会调用 <code>copy</code> 将输入的多个字符串拷贝到目标字符串所在的内存空间。新的字符串是一片新的内存空间，与原来的字符串也没有任何关联，一旦需要拼接的字符串非常大，拷贝带来的性能损失是无法忽略的。</p><h4 id="4、类型转换"><a href="#4、类型转换" class="headerlink" title="4、类型转换"></a>4、类型转换</h4><p>​当我们使用 Go 语言解析和序列化 JSON 等数据格式时，经常需要将数据在 <code>string</code> 和 <code>[]byte</code> 之间来回转换，类型转换的开销其实是蛮大的，经常成为程序性能热点。</p><p>​从字节数组到字符串的转换需要使用 <a href="https://draveness.me/golang/tree/runtime.slicebytetostring"><code>runtime.slicebytetostring</code></a> 函数，例如：<code>string(bytes)</code>，该函数在函数体中会先处理两种比较常见的情况，也就是长度为 0 或者 1 的字节数组，这两种情况处理起来都非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicebytetostring</span><span class="hljs-params">(buf *tmpBuf, b []<span class="hljs-type">byte</span>)</span></span> (str <span class="hljs-type">string</span>) &#123;<br>l := <span class="hljs-built_in">len</span>(b)<br><span class="hljs-keyword">if</span> l == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-comment">// 如果输入字节数组为空，返回空字符串</span><br>&#125;<br><span class="hljs-keyword">if</span> l == <span class="hljs-number">1</span> &#123;<br>stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="hljs-number">0</span>]])<br>stringStructOf(&amp;str).<span class="hljs-built_in">len</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span>  <span class="hljs-comment">// 如果字节数组长度为1，直接使用静态字节数组构建字符串</span><br>&#125;<br><span class="hljs-keyword">var</span> p unsafe.Pointer<br><span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(b) &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>p = unsafe.Pointer(buf)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p = mallocgc(<span class="hljs-type">uintptr</span>(<span class="hljs-built_in">len</span>(b)), <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>)  <span class="hljs-comment">// 分配足够的内存用于存储字节数组数据</span><br>&#125;<br>stringStructOf(&amp;str).str = p<br>stringStructOf(&amp;str).<span class="hljs-built_in">len</span> = <span class="hljs-built_in">len</span>(b)<br>memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="hljs-type">uintptr</span>(<span class="hljs-built_in">len</span>(b))  <span class="hljs-comment">// 将字节数组内容拷贝到新分配的内存中</span><br><span class="hljs-keyword">return</span>  <span class="hljs-comment">// 返回构建的字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​处理过后会根据传入的缓冲区大小决定是否需要为新字符串分配一片内存空间，<a href="https://draveness.me/golang/tree/runtime.stringStructOf"><code>runtime.stringStructOf</code></a> 会将传入的字符串指针转换成 <a href="https://draveness.me/golang/tree/runtime.stringStruct"><code>runtime.stringStruct</code></a> 结构体指针，然后设置结构体持有的字符串指针 <code>str</code> 和长度 <code>len</code>，最后通过 <a href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 将原 <code>[]byte</code> 中的字节全部复制到新的内存空间中。</p><p>​当我们想要将字符串转换成 <code>[]byte</code> 类型时，需要使用 <a href="https://draveness.me/golang/tree/runtime.stringtoslicebyte"><code>runtime.stringtoslicebyte</code></a> 函数，该函数的实现非常容易理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringtoslicebyte</span><span class="hljs-params">(buf *tmpBuf, s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br><span class="hljs-keyword">var</span> b []<span class="hljs-type">byte</span><br><span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>*buf = tmpBuf&#123;&#125;<br>b = buf[:<span class="hljs-built_in">len</span>(s)]  <span class="hljs-comment">// 如果提供了足够的缓冲区并且缓冲区足够大，使用缓冲区</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>b = rawbyteslice(<span class="hljs-built_in">len</span>(s))  <span class="hljs-comment">// 否则分配一个新的字节数组切片</span><br>&#125;<br><span class="hljs-built_in">copy</span>(b, s)  <span class="hljs-comment">// 将字符串内容拷贝到字节数组切片中</span><br><span class="hljs-keyword">return</span> b  <span class="hljs-comment">// 返回字节数组切片</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述函数会根据是否传入缓冲区做出不同的处理：</p><ul><li>当传入缓冲区时，它会使用传入的缓冲区存储 <code>[]byte</code>；</li><li>当没有传入缓冲区时，运行时会调用 <a href="https://draveness.me/golang/tree/runtime.rawbyteslice"><code>runtime.rawbyteslice</code></a> 创建新的字节切片并将字符串中的内容拷贝过去；</li></ul><p><img src="/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="字符串和字符数组的转换"></p><p>​字符串和 <code>[]byte</code> 中的内容虽然一样，但是字符串的内容是只读的，我们不能通过下标或者其他形式改变其中的数据，而 <code>[]byte</code> 中的内容是可以读写的。不过无论从哪种类型转换到另一种都需要拷贝数据，而内存拷贝的性能损耗会随着字符串和 <code>[]byte</code> 长度的增长而增长。</p><h4 id="5、小结-1"><a href="#5、小结-1" class="headerlink" title="5、小结"></a>5、小结</h4><p>​字符串是 Go 语言中相对来说比较简单的一种数据结构，我们在这一节中详细分析了字符串与 <code>[]byte</code> 类型的关系，从词法分析阶段理解字符串是如何被解析的，作为只读的数据类型，我们无法改变其本身的结构，但是在做拼接和类型转换等操作时一定要注意性能的损耗，遇到需要极致性能的场景一定要尽量减少类型转换的次数。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀系统总结</title>
      <link href="/2023/10/18/%E5%B7%A5%E5%85%B7/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/10/18/%E5%B7%A5%E5%85%B7/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="秒杀："><a href="#秒杀：" class="headerlink" title="秒杀："></a>秒杀：<span id="more"></span></h1><p>​做一个秒杀系统，我们需要与业务方进行沟通交流，了解清楚，才能设计出一个比较符合业务的系统，一般的流程会在后面进行一个阐述。</p><h4 id="1、需求对齐"><a href="#1、需求对齐" class="headerlink" title="1、需求对齐"></a>1、需求对齐</h4><ul><li>做什么：了解什么时间，秒杀什么，数量是多少，有没有限制<ul><li>比如 2023年10月18日，在淘宝秒杀100台华为手机，原价15000，现价13000，一人限购一台</li></ul></li><li>业务流程<ul><li>进入商品详情页</li><li>还在倒计时</li><li>倒计时结束，检查是否秒杀结束。秒杀都付完款结束，就没必要继续进行</li><li>检查是否名额还有剩余，没有的话， 就不能再点购买；这时候可能还会有机会，可能有人没付款或者系统原因有少卖的 名额退还，关于少卖，我们后面说原因。</li><li>点购买</li><li>库存抢夺，这里有许多细节，后面讨论</li><li>抢到了，就创建订单</li><li>在时间内支付，过时失效</li><li>购买成功。</li></ul></li></ul><h4 id="2、请求量对齐"><a href="#2、请求量对齐" class="headerlink" title="2、请求量对齐"></a>2、请求量对齐</h4><p>​不同的请求量的方案是完全不一样的，需要确定两个地方：</p><ol><li><p>整体的流量有多大：预估业务到达时的压力</p></li><li><p>后端服务要支持多大的请求量：后端正常服务多少请求量，超过的就限流掉。</p><p>下面是对不同请求量的分析与方案：</p></li></ol><ul><li>5k：直接使用 MySQL 抗，上线前需要实际测试。</li><li>1w：可以考虑使用两台 MySQL。</li><li>10w：不能采用 20 台 MySQL，需要考虑成本。可以用一台 Reids 来搞库存，顶 10 台 MySQL，加上本身 Redis 只吃内存，不吃 CPU。</li><li>＞ 10w：Redis 集群，把库存分散到 Redis 不同分片，不同的用户走不同的分片，流量分散，分开抢名额。</li></ul><h4 id="3、精准度对齐"><a href="#3、精准度对齐" class="headerlink" title="3、精准度对齐"></a>3、精准度对齐</h4><ul><li>能否多卖：<ul><li>什么时候会发生：在高并发下用 Redis 管理库存时，如果 Redis 重启则可能丢失已经执行的命令，库存变多；如果 Redis 是主从模式，假设发生切换，也可能丢失一部分命令，库存变多；如果查询库存和扣减库存不是原子性，在高并发下可能超卖</li><li>如何解决：<ul><li>不允许发生：使用一致性更强的 MySQL 来保护，Redis 挂了再恢复可能丢失的数据，主从切换也可能会丢数据。</li><li>允许小概率超卖：库存走 Redis 即可，毕竟发生崩溃刚好丢数据也是小概率事件，Redis 抢到就是成功，根据抢到的结果，创建支付单即可，业务也会变得简单，Redis 名额 和 MySQL 库存的一致性就不存在了。</li></ul></li></ul></li><li>能否少卖：<ul><li>什么时候会发生：库存扣减了，但订单没生成；订单生成了，用户没付款，回退可能失败。</li><li>如何解决：<ul><li>不允许：需要一个补偿机制</li><li>允许发生：那就不需要补偿机制</li></ul></li></ul></li></ul><h4 id="4、难点分析"><a href="#4、难点分析" class="headerlink" title="4、难点分析"></a>4、难点分析</h4><ul><li>高并发：海量请求砸下来，可能导致服务直接挂掉，活动 G 了<ul><li>流量削减<ul><li>预约：预知大概的流量，与实际流量相差大概一个量级</li><li>验证码：拉平请求，通过验证码，将大家操作的时间由原本的一秒，拉到 1~10s 之间，相当于将请求平摊了。</li><li>限流：超过的流量就拒绝掉，这个是必须做的，因为不知道会由多大的流量到来，通过限流来兜底。</li><li>削峰：异步化削峰。<ul><li>就是在对请求做完参数检查、频率限制之后，把后续的一整个流程进行异步化处理。可能会导致用户体验差：圈圈转很久，最后提示：商品已抢完。</li><li>其他方案：通常就是通过 Redia 来预扣库存，为了避免混淆，我们把 Redis 中的：成为名额、抢到名额，在绝对部分情况下都能发券成功时，再让用户等待一会是可以接收的。</li><li>业务逻辑：<ul><li>校验请求</li><li>确认并扣减名额</li><li>记录扣减名额信息</li><li>将扣减名额成功的信息直接发给库存服务或者先丢入异步队列。</li></ul></li></ul></li><li>风控：购买资格，是否达到购买的条件；风控系统，防止恶意刷单、脚本抢购、多个账户同时抢等。<ul><li>打击黄牛：针对某个用户接口次数过于频繁，可以只针对该用户做限制</li><li>针对 IP 做限制：但容易误杀，因为可能有同一个网络的用户，都是一个出口 IP。所以针对 IP 限流的阈值页不能太低，更多的还是兜底。</li><li>验证码：将 90% 的时间都用在验证码输入上，降低使用脚本点击的影响</li></ul></li><li>限购</li></ul></li></ul></li><li>高精准<ul><li>库存减扣<ul><li>预扣库存：MySQL 扛不住，Redis 不够可靠，按 10w 以上流量来考虑，通过的方案就是 Redis  预扣库存操作，也就是 Redis 中存放的，可以看作名额，真正的库存不在这里。</li><li>MySQL 扣减：MySQL 中存放真正的库存，这里需要通过 MySQL 保证库存可靠的</li><li>减扣记录：MySQL 扣减成功后，就会创建订单，前端会跳到支付页，支付之后，等待支付成功。</li></ul></li><li>库存补偿<ul><li>定时任务：订单超时未支付，额度加载回 MySQL，直接加载 Redis，失败了还有名额加载逻辑兜底。</li></ul></li></ul></li></ul><h1 id="更新中。。。"><a href="#更新中。。。" class="headerlink" title="更新中。。。"></a>更新中。。。</h1>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL三范式</title>
      <link href="/2023/10/14/MySQL/MySQL%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
      <url>/2023/10/14/MySQL/MySQL%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介<span id="more"></span></h4><p>​三大范式是 MySQL 数据库设计表结构所遵循的规范和指导方法，目的是为了减少冗余，建立结构合理的数据库，从而提高数据存储和使用的性能。</p><p>​三大范式之间是有依赖关系的，比如第二范式是在第一范式的基础上建设的，第三范式是在第二范式的基础上建设的。</p><p>​简单来说，就是原子性、唯一性、无传递性。</p><h4 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 - 1NF"></a>第一范式 - 1NF</h4><p>​遵循原子性。即，<strong>表中字段的数据，不可再分</strong>。例如下述表结构：</p><table><thead><tr><th>员工编号</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>001</td><td>运营部小明</td><td>19</td></tr><tr><td>002</td><td>技术部小美</td><td>28</td></tr><tr><td>003</td><td>销售部小张</td><td>20</td></tr></tbody></table><p>​上述表结构中，姓名字段是可以进行再拆分的，因此它不符合第一范式。符合第一范式的表结构如下：</p><table><thead><tr><th>员工编号</th><th>部门</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>001</td><td>运营部</td><td>小明</td><td>19</td></tr><tr><td>002</td><td>技术部</td><td>小美</td><td>28</td></tr><tr><td>003</td><td>销售部</td><td>小张</td><td>20</td></tr></tbody></table><p>​但也并不是所有情况，都需要符合第一范式，例如：</p><table><thead><tr><th>员工编码</th><th>姓名</th><th>省</th><th>市</th><th>区</th></tr></thead><tbody><tr><td>001</td><td>小张</td><td>江西省</td><td>南昌市</td><td>东湖区</td></tr><tr><td>002</td><td>小黄</td><td>广东省</td><td>佛山市</td><td>禅城区</td></tr><tr><td>003</td><td>小高</td><td>湖北省</td><td>武汉市</td><td>新洲区</td></tr></tbody></table><p>​所以，范式只是一个参考，更多的是需要根据实际情况设计表结构。</p><h4 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 - 2NF"></a>第二范式 - 2NF</h4><p>​在满足第一范式的情况下，<strong>遵循唯一性</strong>，消除部分依赖。即 <strong>表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。</strong></p><p>​通俗一点讲就是，<strong>一个表只能描述一件事情，且由该表的主键确定</strong>。</p><p>​例如，主键为学号，则可以确定姓名、年龄等学生信息。</p><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>001</td><td>小美</td><td>18</td></tr><tr><td>002</td><td>小张</td><td>19</td></tr><tr><td>003</td><td>小明</td><td>20</td></tr></tbody></table><p>​主键为课程名称，就可以确定该课程学分、成绩等信息。</p><table><thead><tr><th>课程名称</th><th>成绩</th><th>学分</th></tr></thead><tbody><tr><td>语文</td><td>90</td><td>3</td></tr><tr><td>数学</td><td>90</td><td>2</td></tr><tr><td>英语</td><td>90</td><td>3</td></tr></tbody></table><p>​不遵循第二范式，可能会造成下述后果：</p><ol><li>数据冗余：将不同类型的信息存储在同一张表中可能导致数据冗余。例如，在学生表中，如果每个学生都有多个课程，将学生和课程信息合并存储可能导致数据复制。如果有两名学生，每人选修三门课程，表中会包含6条记录，其中的学生信息将重复。</li><li>更新数据不方便：当需要更新特定信息时，如果数据存储在同一张表中，更新可能变得不太方便。举例来说，如果需要更改某门课程的学分，必须在整个表中搜索相关记录并更新，这可能是一个繁琐的过程。但如果将数据拆分到不同的表中，只需在包含相关信息的表中进行更新，更加便捷。</li><li>插入数据不方便或可能导致异常情况：在某些情况下，插入数据可能变得复杂或引发异常。举例如下：<ul><li>假设主键是学号或课程名称，当需要插入新的课程信息时，必须精心规划哪些学生将选择该课程。这可能需要指定为哪些学生插入对应的课程信息。此外，如果还没有相关成绩信息，可能需要将成绩字段置为空，以后再进行更新。</li><li>假设主键是学号和课程名称的联合主键，插入课程信息时，如果没有学生选择该课程，可能会导致学号主键字段缺失，从而无法插入相关信息。</li></ul></li></ol><h4 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 - 3NF"></a>第三范式 - 3NF</h4><p>​在满足第二范式的情况下， 消除传递依赖。即，<strong>在任一主键都可以确定所有非主键字段的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。</strong></p><p>​举个例子，如下</p><table><thead><tr><th>学号</th><th>姓名</th><th>班级</th><th>班主任</th></tr></thead><tbody><tr><td>001</td><td>小美</td><td>一年级（3）班</td><td>陈老师</td></tr></tbody></table><p>​这个表中，学号是主键，它可以唯一确定姓名、班级、班主任，符合第二范式，但是在非主键字段中，我们可以可以通过班级推导出该班级的班主任，所以他不符合第三范式。</p><p>​上述的表要满足第三范式，可以像下面这样设计：</p><p>1.学生表</p><table><thead><tr><th>学号</th><th>姓名</th><th>班级</th></tr></thead><tbody><tr><td>001</td><td>小美</td><td>一年级（3）班</td></tr></tbody></table><p>2.班级表</p><table><thead><tr><th>班级</th><th>班主任</th></tr></thead><tbody><tr><td>一年级（3）</td><td>陈老师</td></tr></tbody></table><pre><code class="hljs"> 通过把班主任和班级的映射关系做成另一张表，就可以消除表中的传递依赖。</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>第一范式（1 NF）：字段不可再拆分</li><li>第二范式（2 NF）：表中任意一个主键或者任意一组联合主键，可以唯一确定除该主键外的所有非主键值。</li><li>第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 范式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/10/14/%E5%B7%A5%E5%85%B7/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/14/%E5%B7%A5%E5%85%B7/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍<span id="more"></span></h1><p>​在面试中被问到排序算法，发现不能很好的描述出来，于是写一篇文章总结一下。常见的排序算法有 <strong>冒泡排序</strong>、<strong>插入排序</strong>、<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>等。下面一一介绍。</p><h4 id="1、冒泡排序-O-n-2"><a href="#1、冒泡排序-O-n-2" class="headerlink" title="1、冒泡排序 O(n^2)"></a>1、冒泡排序 O(n^2)</h4><h5 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h5><p>​共 n 个元素需要排序，通过比较相邻的两个元素，并将较大的元素放到后面，以此每一轮比较将乱序的元素中的最大的元素放到最后一个有序区间中。<strong>每一次遍历都能确定一个数在有序数组中的位置，且数组最后的一个区间中的数是有序的</strong>，直到所有数的位置都确定了，排序完成。</p><h5 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> arr[j] &gt; arr[j+<span class="hljs-number">1</span>] &#123;<br>                <span class="hljs-comment">// 交换 arr[j] 和 arr[j+1]</span><br>                arr[j], arr[j+<span class="hljs-number">1</span>] = arr[j+<span class="hljs-number">1</span>], arr[j]<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="2、插入排序-O-n-2"><a href="#2、插入排序-O-n-2" class="headerlink" title="2、插入排序 O(n^2)"></a>2、插入排序 O(n^2)</h4><h5 id="算法思想：-1"><a href="#算法思想：-1" class="headerlink" title="算法思想："></a>算法思想：</h5><p>​遍历一遍整个数组，每次遍历将当前元素放到数组首部的有序序列中的合适位置，每次保证数组首部增加一个数，遍历 n - 1 次后，就可以保证整个数组的有序性。【合适的位置：往前找第一个小于当前数的位置，将其放在该数的后面，就说明当前数前面小于当前数，当前数后面大于当前数】</p><h5 id="核心代码：-1"><a href="#核心代码：-1" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i ++ &#123;<br>        key := q[i] <span class="hljs-comment">// go 中切片使用的注意点</span><br>        j := i - <span class="hljs-number">1</span> <span class="hljs-comment">// 往前找第一个小于当前数的位置，将其放在该数的后面，就说明当前数前面小于当前数，当前数后面大于当前数</span><br>        <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; q[j] &gt; key &#123;<br>            q[j + <span class="hljs-number">1</span>] = q[j]<br>            j -- <br>        &#125;<br>        q[j + <span class="hljs-number">1</span>] = key<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3、快速排序-O-nlogn"><a href="#3、快速排序-O-nlogn" class="headerlink" title="3、快速排序 O(nlogn)"></a>3、快速排序 O(nlogn)</h4><h5 id="算法思想：-2"><a href="#算法思想：-2" class="headerlink" title="算法思想："></a>算法思想：</h5><p>​分而治之的一个思想，每次将整个数组分为两部分，然后保证左边是小于某个值的，右边是大于某个值的，这样在对两个部分采用同样的思想去划分，最后划分到区间中只有一个数了，就可以保证整个数组是有序的了。</p><h5 id="核心代码：-2"><a href="#核心代码：-2" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(q []<span class="hljs-type">int</span>, l, r <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> l &gt;= r &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br><br>    mid := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>    x := q[mid]<br>    i, j := l - <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        <span class="hljs-keyword">for</span> i ++; q[i] &lt; x; i ++&#123;&#125;<br>        <span class="hljs-keyword">for</span> j --; q[j] &gt; x; j --&#123;&#125;<br>        <span class="hljs-keyword">if</span> i &lt; j &#123;<br>            q[i], q[j] = q[j], q[i]<br>        &#125;<br>    &#125;<br>    quickSort(q, l, j)<br>    quickSort(q, j + <span class="hljs-number">1</span>, r)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、归并排序-O-nlogn"><a href="#4、归并排序-O-nlogn" class="headerlink" title="4、归并排序 O(nlogn)"></a>4、归并排序 O(nlogn)</h4><h5 id="算法思想：-3"><a href="#算法思想：-3" class="headerlink" title="算法思想："></a>算法思想：</h5><p>​利用递归将整个区间分为足够小的区间，保证小区间中的数是有序的，然后再逐渐回溯，使大区间也变得有序。最终达到整个区间有序的一个状态。</p><h5 id="核心代码：-3"><a href="#核心代码：-3" class="headerlink" title="核心代码："></a>核心代码：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go">unc mergeSort(a []<span class="hljs-type">int</span>, l, r <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">if</span> l &gt;= r &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    mid := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>    mergeSort(a, l, mid)<br>    mergeSort(a, mid+<span class="hljs-number">1</span>, r)<br>    i, j, k := l, mid+<span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt;= mid &amp;&amp; j &lt;= r &#123;<br>        <span class="hljs-keyword">if</span> a[i] &lt;= a[j] &#123;<br>            t[k] = a[i]<br>            k++<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            t[k] = a[j]<br>            k++<br>            j++<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i &lt;= mid &#123;<br>        t[k] = a[i]<br>        k++<br>        i++<br>    &#125;<br>    <span class="hljs-keyword">for</span> j &lt;= r &#123;<br>        t[k] = a[j]<br>        k++<br>        j++<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, j := l, <span class="hljs-number">0</span>; i &lt;= r; i++ &#123;<br>        a[i] = t[j]<br>        j++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、堆排序"><a href="#5、堆排序" class="headerlink" title="5、堆排序"></a>5、堆排序</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>​堆：即一棵完全二叉树，且每一个点小于等于其左右儿子节点【小根堆】。</p><p>​建堆：从总数的 n&#x2F;2 开始往上建，因为必须保证其有左右儿子节点。建堆的过程，就是把父节点、左右儿子节点中较小的元素放到父节点的位置，<strong>逐步将大的节点往下移的操作。</strong></p><h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> n, m, cnt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> h []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">down</span> <span class="hljs-params">(u <span class="hljs-type">int</span>)</span></span> &#123;<br>    t := u<br>    <span class="hljs-keyword">if</span> u * <span class="hljs-number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t] &#123;<br>        t = u * <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t] &#123;<br>        t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> t != u &#123;<br>        h[t], h[u] = h[u], h[t]<br>        down(t)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Scan(&amp;n, &amp;m)<br>    h = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i ++ &#123;<br>        fmt.Scan(&amp;h[i])<br>    &#125;<br>    cnt = n<br>    <br>    <span class="hljs-keyword">for</span> i := n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i -- &#123;<br>        down(i)<br>    &#125;<br>    <span class="hljs-keyword">for</span> n &gt; <span class="hljs-number">0</span> &#123;<br>        n --<br>        fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, h[<span class="hljs-number">1</span>])<br>        h[<span class="hljs-number">1</span>] = h[cnt]<br>        cnt --<br>        down(<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其余算法慢慢补充。。。。"><a href="#其余算法慢慢补充。。。。" class="headerlink" title="其余算法慢慢补充。。。。"></a>其余算法慢慢补充。。。。</h1>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体嵌套3</title>
      <link href="/2023/10/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%973/"/>
      <url>/2023/10/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%973/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)<br>p.ShowB()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;<br>People<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := Teacher&#123;&#125;<br>t.ShowB()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案与解析"><a href="#答案与解析" class="headerlink" title="答案与解析"></a>答案与解析</h4><p>​参考答案及解析：teacher showB。</p><p>​知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。</p><p>​此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络攻击</title>
      <link href="/2023/10/06/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
      <url>/2023/10/06/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击<span id="more"></span></h1><h4 id="1、DNS-劫持"><a href="#1、DNS-劫持" class="headerlink" title="1、DNS 劫持"></a>1、DNS 劫持</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>​当我们访问网站的时候，实际上会先进行域名解析得到网站服务器的 IP 地址，然后才进行后续的访问。DNS 劫持利用了这个过程追踪的漏洞，攻击者在 DNS 服务器上篡改 DNS 解析结果，将域名解析到攻击者控制的恶意服务器上，这时候我们访问的域名就被重定向到恶意网站上。</p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>​手动更换公共 DNS 服务器，绕过被劫持的 DNS 服务器。</p><h4 id="2、DNS-污染"><a href="#2、DNS-污染" class="headerlink" title="2、DNS 污染"></a>2、DNS 污染</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>​DNS 污染就是用户得到一个虚假的结果，攻击者监听 DNS 查询，一旦发现查询的域名与自己是匹配的，就把自己伪装成目标域名服务器，然后返回虚假的结果给用户，这样用户域名解析的结果就是错误的，无法和正确的目标服务器 IP 进行通信。</p><h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><ol><li>绕过被污染的非权威 DNS 服务器，直接访问干净的公共服务器。</li><li>在本机直接绑定 hosts，绕过 DNS 解析过程。</li></ol><h4 id="3、简述-DDOS-攻击原理，如何防范它？"><a href="#3、简述-DDOS-攻击原理，如何防范它？" class="headerlink" title="3、简述 DDOS 攻击原理，如何防范它？"></a>3、简述 DDOS 攻击原理，如何防范它？</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>​DDOS（Distributed Denial of Service） 攻击就是大量的僵尸计算机发送大量的请求，让服务器的带宽、CPU 和内存耗尽，让服务器超载后，无法再对外提供正常的服务。</p><p>​DDOS 攻击大体分为网络层攻击和传输层攻击，攻击应用层的方式比如有 DNS 洪水攻击，攻击传输层的方式比如有 SYN 洪水攻击、UDP 洪水攻击。</p><h5 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h5><ol><li>限制单个 IP 地址的请求频率，并且对异常流量的 IP 地址，拉黑名单、配置防火墙规则，阻止恶意流量请求。</li><li>增加用户验证机制，使用验证码、人脸识别等方式，增加用户验证的难度，减少恶意请求的影响。</li><li>花钱买可靠的 DDOS 防护提供商，他们具备强大的网络基础设施和专业的防护技术，能够识别和过滤掉恶意流量，保证正常服务的运行。</li></ol><h4 id="4、XSS-攻击？"><a href="#4、XSS-攻击？" class="headerlink" title="4、XSS 攻击？"></a>4、XSS 攻击？</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p>​XSS（Cross-Site Scripting） 攻击，即跨站点脚本攻击，攻击方式是攻击者在一些可以评论或者发帖的网站，发布一些恶意脚本代码，然后被服务端保存了，后面访问的网站的时候，浏览器会执行该恶意脚本，这样攻击者就可以窃取用户的敏感信息了。</p><h5 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h5><ol><li>输入验证和过滤：过滤一些特殊的字符，比如 javaScript 脚本中的 &lt;&gt; 进行转移 &lt;&gt; 再进行存储，这样就能有效的进行 xss 攻击的防护。</li><li>使用 HTTP-only Cookie：将敏感信息存储在 HTTP-only Cookite 中，限制 JavaScript 的访问权限，防止恶意脚本窃取用户的 Cookite 信息。</li></ol><h4 id="5、CSRF-攻击"><a href="#5、CSRF-攻击" class="headerlink" title="5、CSRF 攻击"></a>5、CSRF 攻击</h4><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><p>CSRF（Cross-Site Request Forgery）叫跨站点伪造攻击，攻击形式是，用户先登录银行A 网站，这时候就获得了A 网站的 Cookie，然后不小心访问了一个恶意B 网站，B 网站会让用户向银行A 网站发起一个转账请求，由于用户端有了银行 A网站的 Cookie，这时候有可能就会转账成功，造成并非本人意愿的操作结果。</p><h5 id="解决办法-4"><a href="#解决办法-4" class="headerlink" title="解决办法"></a>解决办法</h5><ol><li>同源检测：在服务器端对请求进行同源检测，只接受来自同一域名下的请求。这可以通过检查请求头中的 Referer 字段或者 Origin 字段来实现。</li><li>使用验证码：对于敏感操作，要求用户输入验证码进行验证，以防止自动化脚本发起的恶意请求。</li><li>使用 CSRF 令牌： 在用户执行敏感操作时，要求用户提交一个 CSRF 令牌。该令牌是一个随机生成的字符串存储在用户的会话中，并且在每个请求中都要验证该令牌的有效性。攻击者无法伪造正确的CSRF 令牌，从而防止 CSRF 攻击。</li></ol><h4 id="6、SQL-注入攻击"><a href="#6、SQL-注入攻击" class="headerlink" title="6、SQL 注入攻击"></a>6、SQL 注入攻击</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><p>​SQL 注入攻击在攻击者在 HTTP 请求中注入恶意 SQL 语句，让服务端构造执行 SQL 语句时，恶意的 SQL 被一起构造了，然后在数据库中，这样就可能对数据库造成全量数据拉取、删除、更小等敏感的操作。</p><h5 id="解决办法-5"><a href="#解决办法-5" class="headerlink" title="解决办法"></a>解决办法</h5><ol><li>参数化查询或预编译语句：使用参数化查询或预编译语句来构造和执行 SQL 查询。这样可以将用户输入的数据作为参数传递给查询，而不是将其直接拼接到 SQL 语句中，参数化查询可以防止恶意代码的注入。</li><li>输入验证和过滤：对用户输入的数据进行验证和过滤，确保只接受合法的输入，可以使用白名单过滤、正则表达式验证或编码转义等技术来防止恶意代码的注入。</li><li>最小权限原则：在数据库中为应用程序使用最小权限的数据库账户，这样即使发生 SQL 注入攻击，攻击者也只能在该账户的权限范围内进行操作，减少损失。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见状态码</title>
      <link href="/2023/10/06/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2023/10/06/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码<span id="more"></span></h1><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81.png"></p><h4 id="1、200"><a href="#1、200" class="headerlink" title="1、200"></a>1、200</h4><p>200：服务器已经接收了请求，但处理还没有完成。</p><p>204：服务器已经成功处理了请求，但相应中没有任何返回内容。比如 DELETE 请求。</p><p>206：客户端发送了一个带有 Range 头的 GET 请求，并且服务器成功返回了请求的部分内容。比如下载大文件的一部分或者断电续传。</p><h4 id="2、300"><a href="#2、300" class="headerlink" title="2、300"></a>2、300</h4><p>301：永久重定向</p><p>302：临时重定向</p><p>304：表示服务器资源没有被修改。用于访问有缓存的数据，返回 304 表示缓存未失效。</p><h4 id="3、400"><a href="#3、400" class="headerlink" title="3、400"></a>3、400</h4><p>400：客户端发送的请求有错误或者无效，服务器无法理解或处理该请求。通常是由于客户端发送的请求中包含了无效的参数、格式错误的数据、缺失必要的参数等。</p><p>403：客户端请求被服务器拒绝，通常是由于客户端没有足够的权限来访问请求的资源。</p><p>404：表示服务器无法找到请求的资源。通常是由于客户端请求的资源不存在，或者请求的 URL 地址错误。</p><h4 id="4、500"><a href="#4、500" class="headerlink" title="4、500"></a>4、500</h4><p>500：服务器内部发生了错误，但服务器无法提供详细的错误信息。表示服务器遇到了意外情况或者未知错误。</p><p>501：服务器不支持客户端请求的功能或方法。</p><p>502：表示服务器作为网关或代理，从上游服务器接收到一个无效的响应。通常意味着上游服务器出现故障或无法正常工作。</p><p>503：服务器暂时无法提供服务。服务器过载、维护中、临时不可用或其他临时性原因造成的。</p><p>504：服务器作为网关或代理，在等待上游服务器的响应时，超时了。比如出现 sql 慢查询、接口发生死循环、死锁等问题。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言编程之旅》</title>
      <link href="/2023/10/06/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85%E3%80%8B/"/>
      <url>/2023/10/06/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>《Go 语言编程之旅》</p><p><a href="https://golang2.eddycjy.com/"> Go 语言编程之旅</a></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口类型值为nil</title>
      <link href="/2023/10/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%80%BC%E4%B8%BAnil/"/>
      <url>/2023/10/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%80%BC%E4%B8%BAnil/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;nil&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;not nil&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. nil</li><li>B. not nil</li><li>C. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>答案及解析：A。</p><p>当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/2023/10/05/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2023/10/05/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁 "></a>分布式锁 <span id="more"></span></h1><h4 id="1、什么是分布式锁？"><a href="#1、什么是分布式锁？" class="headerlink" title="1、什么是分布式锁？"></a>1、什么是分布式锁？</h4><p>​在分布式场景下的锁，比如在多台不同机器上的进程，去竞争同一项资源，就是分布式锁。</p><h4 id="2、分布式锁有哪些特性？"><a href="#2、分布式锁有哪些特性？" class="headerlink" title="2、分布式锁有哪些特性？"></a>2、分布式锁有哪些特性？</h4><ul><li><strong>互斥性</strong>：只能让一个竞争者持有锁</li><li><strong>安全性</strong>：避免锁因为异常永远不被释放，当一个竞争者在持有锁期间，由于意外崩溃而导致未能主动解锁，其持有的锁也能够被兜底释放，并保证后续其它竞争者也能加锁</li><li><strong>对称性</strong>：同一个锁，加锁和解锁必须是一个竞争者，不能把其他竞争者持有的锁给释放了</li><li><strong>可靠性</strong>：需要有一定程度的异常处理能力、容灾能力。</li></ul><h4 id="3、分布式锁的实现方式"><a href="#3、分布式锁的实现方式" class="headerlink" title="3、分布式锁的实现方式"></a>3、分布式锁的实现方式</h4><h5 id="最简化版本"><a href="#最简化版本" class="headerlink" title="最简化版本"></a>最简化版本</h5><p>​直接用 Redis 的 setnx 命令，语法：<code>setnx key value</code>，如果 key 不存在，则会将 key 设置为 value，并返回 1；如果 key 存在，不会有任务影响，返回 0。</p><p>​通过 setnx 加锁，其他服务无法加锁，进而阻塞；用完之后，通过 delete 解锁，其他服务再去竞争锁。</p><h5 id="支持过期时间"><a href="#支持过期时间" class="headerlink" title="支持过期时间"></a>支持过期时间</h5><p>​最简化版本有一个问题：如果获取锁的服务挂掉了，那么锁就一直得不到释放，就会导致其他服务无法获取到锁，影响到其他服务，所以这里需要一个过期时间来进行兜底。</p><p>​Redis 中有 expire 命令，用来设置一个 key 的过期时间。但是 setnx 和 expire 不具备原子性，如果 setnx 获取锁之后，服务挂掉，还没来得及设置过期时间，照样石沉大海。</p><p>​于是使用 set 和 expire 的原子操作：<code>set key value nx ex seconds</code> nx 标识 setnx 特性，ex 标识过期时间，最后一个参数就是过期时间的值。</p><p>​加上过期时间，基本上这个锁就能用了。但存在一个问题：会存在服务 A 释放掉 服务 B 的锁的可能。</p><h5 id="加上-owner"><a href="#加上-owner" class="headerlink" title="加上 owner"></a><strong>加上 owner</strong></h5><p>​在特殊的场景：服务 A 获取到了锁，由于业务流程比较长或者网络延迟、GC卡顿等原因，导致锁过期，而业务还会继续进行，这时候，业务 B 已经拿到了锁，准备去执行。这个时候服务 A 恢复过来并做完了任务，就会释放锁，而 B 还在继续，就会导致服务 A 释放掉了 服务 B 的锁。</p><p>​在真实的分布式场景中，可能存在几十个竞争者，上述情况发生的概率就会很高，导致同一份资源频繁被不同竞争者同时访问，分布式锁也就失去了意义。</p><p>​发生这个问题的关键在于：竞争者可以释放掉其他竞争者的锁。所以我们可以给出进一步的解决方案：分布式锁需要满足谁申请谁释放原则，不能释放别人的锁，也就是说，分布式锁，是要有归属的。</p><h5 id="引入-lua"><a href="#引入-lua" class="headerlink" title="引入 lua"></a><strong>引入 lua</strong></h5><p>​加入 owner 后的版本，也还有一点点小问题。完整的流程是：竞争者获取到锁执行任务，执行完毕后检查锁是不是自己的，最后释放。</p><p>​这些操作都不是原子化的，可能锁获取的时候还是自己的，删除的时候已经是别人的了。</p><p>​这里就需要引入 Lua。</p><p>​Redis + Lua，可以说是专门为解决原子问题而生的。 </p><p>​到了这里，分布式锁的前三个特性已经满足：对称性、安全性、互斥性。可以是一个可以用的分布式锁了，能满足大多数场景。</p><h4 id="4、可靠性如何保证"><a href="#4、可靠性如何保证" class="headerlink" title="4、可靠性如何保证"></a>4、可靠性如何保证</h4><p>​还剩下可靠性没有解决。</p><p>​针对一些异常情景，包括 Redis 挂掉、业务执行时间过长、网络波动等情况。</p><p>​<strong>容灾考虑</strong></p><p>​前面我们谈及的内容，基本是基于单机考虑的，如果Redis挂掉了，那锁就不能获取了。这个问题该如何解决呢?<br>​一般来说，有两种方法:主从容灾和多级部署。</p><h5 id="主从容灾"><a href="#主从容灾" class="headerlink" title="主从容灾"></a>主从容灾</h5><p>​最简单的方式，就是为 Redis 配置从节点，当主节点挂掉了，从节点顶包。</p><p>​主从切换的话，需要人工参与，会提高人力成本。不过 Redis 已经有成熟的解决方案，也就是哨兵模式，可以灵活自动切换，不再需要人工介入。</p><p>​虽然一定程度解决了单点的容灾问题，但并不是尽善尽美的由于同步有时延，slave通过增加从节点的方式，可能会损失掉部分数据，分布式锁可能失效，这就会发生短暂的多机获取到执行权限</p><p>​有没有更可靠的办法呢?</p><p><strong>多机部署</strong></p><p>​如果对一致性高一些，可以尝试多机部署。比如 Redis 的 RedLock，大概思路就是多个机器，通常是奇数，达到一半以上同意才能算加锁成功，这样可靠性会向 ETCD 靠近。</p><blockquote><p>ETCD：<strong>etcd</strong>：在前面的回答中已经介绍过，etcd是一个分布式键值存储系统，用于配置管理、服务发现和分布式协调。它是一个独立的开源项目，由CNCF维护，具有强一致性和高可用性，用于构建分布式系统的基础设施。</p></blockquote><p>​现在假设有5个Redis主节点，基本保证它们不会同时宕掉，获取锁和释放锁的过程中客户端会执行以下操作:</p><ol><li>向5个Redis申请加锁;</li><li>只要超过一半，也就是3个Redis返回成功，那么就是获取到了锁。如果超过一半失败，需要向每个Redis发送解锁命令;</li><li>由于向5个Redis发送请求，会有一定时耗，所以锁剩余持有时间，需要减去请求时间。这个可以作为判断依据，如果剩余时间已经为0，那么也是获取锁失败;</li><li>使用完成之后，向5个Redis发送解锁请求。</li></ol><p>​这种模式的好处在于，如果挂了2台Redis，整个集群还是可用的，给了运维更多时间来修复。</p><p>​另外，多说一句，单点Redis的所有手段，这种多机模式都可以使用，比如为每个节点配置哨兵模式，由于加锁是一半以上同意就成功，那么如果单个节点进行了主从切换，单个节点数据的丢失，就不会让锁失效了。这样增强了可靠性。</p><h1 id="没有完全可靠的分布式锁"><a href="#没有完全可靠的分布式锁" class="headerlink" title="没有完全可靠的分布式锁"></a>没有完全可靠的分布式锁</h1><p>由于分布式系统中的三大困境，简称 NPC。</p><ol><li>N：Network Delay （网络延迟）网络延迟导致锁过期。</li><li>P：Process Pause（进程暂停）比如发生 GC，导致锁超时。</li><li>C：Clock Drift（时钟漂移）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组是可比较类型</title>
      <link href="/2023/10/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E6%98%AF%E5%8F%AF%E6%AF%94%E8%BE%83%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/10/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E6%98%AF%E5%8F%AF%E6%AF%94%E8%BE%83%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>b := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">if</span> a == b &#123;<br>fmt.Println(<span class="hljs-string">&quot;equal&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;not equal&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. compilation error</li><li>B. equal</li><li>C. not equal</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：A。</p><p>​Go 中的数组是值类型，可比较，另外一方面，<strong>数组的长度也是数组类型的组成部分</strong>，所以 a 和 b 是不同的类型，是不能比较的，所以编译错误。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口嵌入结构体</title>
      <link href="/2023/10/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/10/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码能否通过编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> worker <span class="hljs-keyword">interface</span> &#123;<br>work()<br>&#125;<br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>worker<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br>fmt.Println(w)<br>&#125;<br></code></pre></td></tr></table></figure><p>A: 能；B: 不能；C: 不知道</p><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这里答错的原因在于 worker 是一个接口，如果是一个普通的类型，相信大家会答对。一个结构体竟然可以嵌入一个接口？！</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>我们都知晓 Go 没有继承，但可以通过内嵌类型模拟部分继承的功能。大家要记住，接口也是类型，自然也将它作为嵌入类型。如果题目的 person 接口体改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>worker worker<br>&#125;<br></code></pre></td></tr></table></figure><p>相信会有更多人答对，这和嵌入类型唯一的区别在于是否显示指定了字段名，其他并无区别。</p><p>将接口作为嵌入类型可能让人感觉有些奇怪：那这个类型不是默认就实现了这个接口？！确实是这样的，所以才有了题目中这一句能编译通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br></code></pre></td></tr></table></figure><p>只不过，因为实例化 person 时，没有给 worker 指定值，因此 person 中的 worker 是 nil，调用它的话会报错，但编译是没问题的。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>有人可能要问，嵌入接口有实际用途吗？我找一个标准库中的例子。</p><p>在 sort 包中，有一个接口：Interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Len is the number of elements in the collection.</span><br>Len() <span class="hljs-type">int</span><br><span class="hljs-comment">// Less reports whether the element with</span><br><span class="hljs-comment">// index i should sort before the element with index j.</span><br>Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br><span class="hljs-comment">// Swap swaps the elements with indexes i and j.</span><br>Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是用于排序的。还有另外一个结构体：<a href="https://docs.studygolang.com/src/sort/sort.go?s=7078:7105#L239">reverse</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// This embedded Interface permits Reverse to use the methods of</span><br><span class="hljs-comment">// another Interface implementation.</span><br>Interface<br>&#125;<br></code></pre></td></tr></table></figure><p>它就内嵌了一个 Interface，用于排序的反转。</p><p>而内嵌接口的关键在于如何给这个内嵌的接口赋值。sort 包有一个函数：Reverse</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span></span> Interface &#123;<br><span class="hljs-keyword">return</span> &amp;reverse&#123;data&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中实例化 reverse 时，直接通过传递的 Interface 实例赋值给 reverse 的内嵌接口，然后 reverse 类型可以有选择的重新实现内嵌的 Interface 的方法。比如 Less 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> r.Interface.Less(j, i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>回到上面的题目，如果我们通过实例化的 w 调用 work 方法会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br>w.work()<span class="hljs-comment">// panic</span><br></code></pre></td></tr></table></figure><p>和上面 reverse 类似，你需要给 person 中的 worker 实例化，也就是需要一个实现了 worker 接口的类型实例。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span></span> work() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;I am &quot;</span>, s.name, <span class="hljs-string">&quot;, I am learning&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这样实例化 person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;worker: student&#123;<span class="hljs-string">&quot;polarisxu&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从map中取值</title>
      <link href="/2023/09/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%BB%8Emap%E4%B8%AD%E5%8F%96%E5%80%BC/"/>
      <url>/2023/09/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%BB%8Emap%E4%B8%AD%E5%8F%96%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[person]<span class="hljs-type">int</span><br>    p := person&#123;<span class="hljs-string">&quot;mike&quot;</span>&#125;<br>    fmt.Println(m[p])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.0</li><li>B.1</li><li>C.Compilation error</li></ul><h4 id="答案与解析"><a href="#答案与解析" class="headerlink" title="答案与解析"></a>答案与解析</h4><p>​A。</p><ol><li>未初始化的 map 为 nil map<ol><li>往值为 nil 的 map 添加值，会触发 panic</li><li>读取值为 nil 的 map，不会报错</li><li>删除值为 nil 的 map，不会报错</li></ol></li><li>已经初始化，没有任何元素的 map 为 空map，对 空map 增删改查不会报错</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的执行速度很快</title>
      <link href="/2023/09/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BE%88%E5%BF%AB/"/>
      <url>/2023/09/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BE%88%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">var</span> wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">println</span>(i)<br><span class="hljs-keyword">defer</span> wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>输出结果不唯一，代码存在风险, 所有 go 语句未必都能执行到。</p><p>这是使用 WaitGroup 经常犯下的错误！多次运行就会发现输出都会不同甚至又出现报错的问题。 这是因为 go 执行太快了，导致 wg.Add(1) 还没有执行 main 函数就执行完毕了。wg.Add 的位置放错了。</p><p>改为下面代码即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">var</span> wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt; N; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-built_in">println</span>(i)<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>        &#125;(i)<br>    &#125;<br><br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel创建后不能立刻关闭</title>
      <link href="/2023/09/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/channel%E5%88%9B%E5%BB%BA%E5%90%8E%E4%B8%8D%E8%83%BD%E7%AB%8B%E5%88%BB%E5%85%B3%E9%97%AD/"/>
      <url>/2023/09/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/channel%E5%88%9B%E5%BB%BA%E5%90%8E%E4%B8%8D%E8%83%BD%E7%AB%8B%E5%88%BB%E5%85%B3%E9%97%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>a, ok := &lt;-ch<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;close&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;a: &quot;</span>, a)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">close</span>(ch)<br>fmt.Println(<span class="hljs-string">&quot;ok&quot;</span>)<br>time.Sleep(time.Second * <span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">panic</span>: send on closed channel <br></code></pre></td></tr></table></figure><p>记住 channel 的一些关键特性：</p><ul><li>给一个 nil channel 发送数据，造成永远阻塞</li><li>从一个 nil channel 接收数据，造成永远阻塞</li><li>给一个已经关闭的 channel 发送数据，引起 panic</li><li>从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</li><li>无缓冲的channel是同步的，而有缓冲的channel是非同步的</li></ul><p>15字口诀：“空读写阻塞，写关闭异常，读关闭空零”，往已经关闭的 channel 写入数据会 panic。</p><p>本题中，因为 main 在开辟完两个 goroutine 之后，立刻<strong>关闭了 ch</strong>， 结果就是 panic：</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地项目推送到github</title>
      <link href="/2023/09/23/%E5%B7%A5%E5%85%B7/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0github/"/>
      <url>/2023/09/23/%E5%B7%A5%E5%85%B7/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<h1 id="本地项目上传至-GitHub"><a href="#本地项目上传至-GitHub" class="headerlink" title="本地项目上传至 GitHub"></a>本地项目上传至 GitHub<span id="more"></span></h1><h4 id="1、进入项目根目录，初始化本地仓库"><a href="#1、进入项目根目录，初始化本地仓库" class="headerlink" title="1、进入项目根目录，初始化本地仓库"></a>1、进入项目根目录，初始化本地仓库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br></code></pre></td></tr></table></figure><h4 id="2、创建密钥：创建-ssh-文件夹，并进入-ssh-文件夹"><a href="#2、创建密钥：创建-ssh-文件夹，并进入-ssh-文件夹" class="headerlink" title="2、创建密钥：创建 .ssh 文件夹，并进入 .ssh 文件夹"></a>2、创建密钥：创建 .ssh 文件夹，并进入 .ssh 文件夹</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mkdir <span class="hljs-string">.ssh</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">.ssh/</span><br></code></pre></td></tr></table></figure><h4 id="3、生成密钥，这里需要用到-GitHub-上绑定的邮箱"><a href="#3、生成密钥，这里需要用到-GitHub-上绑定的邮箱" class="headerlink" title="3、生成密钥，这里需要用到 GitHub 上绑定的邮箱"></a>3、生成密钥，这里需要用到 GitHub 上绑定的邮箱</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">ssh-keygen -t rsa -C <span class="hljs-string">&quot;XXXXXXX@XXX.com&quot;</span><br><br><span class="hljs-regexp">//</span> 第一个命令输入保存的文件名 id_rsa，后续命令直接回车即可<br>Enter file <span class="hljs-keyword">in</span> which to save the key (<span class="hljs-regexp">/c/</span>Users<span class="hljs-regexp">/ft/</span>.ssh/id_rsa): id_rsa<br></code></pre></td></tr></table></figure><h4 id="4、将公钥-id-rsa-pub-内容保存到-GitHub-上"><a href="#4、将公钥-id-rsa-pub-内容保存到-GitHub-上" class="headerlink" title="4、将公钥 id_rsa.pub 内容保存到 GitHub 上"></a>4、将公钥 id_rsa.pub 内容保存到 GitHub 上</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">cat id_rsa.<span class="hljs-built_in">push</span> <br><span class="hljs-comment">// 复制文件内容</span><br></code></pre></td></tr></table></figure><p><img src="/images/key.png"></p><p>然后点击 New SSh key，将 公钥复制到相应位置即可</p><h4 id="5、在-Github-上创建好项目，注意创建时勾选-Add-a-README-file，然后连接-Github-仓库"><a href="#5、在-Github-上创建好项目，注意创建时勾选-Add-a-README-file，然后连接-Github-仓库" class="headerlink" title="5、在 Github 上创建好项目，注意创建时勾选 Add a README file，然后连接 Github 仓库"></a>5、在 Github 上创建好项目，注意创建时勾选 <code>Add a README file</code>，然后连接 Github 仓库</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/XX/</span>XX.git<br></code></pre></td></tr></table></figure><p><img src="/images/Gous.png" alt="Gous.png"></p><h4 id="6、回到项目根目录，将内容提交直缓存区"><a href="#6、回到项目根目录，将内容提交直缓存区" class="headerlink" title="6、回到项目根目录，将内容提交直缓存区"></a>6、回到项目根目录，将内容提交直缓存区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git add .<br>// 可以用 git status 查看新提交了哪些文件<br></code></pre></td></tr></table></figure><h4 id="7、将缓存区文件提交到本地仓库"><a href="#7、将缓存区文件提交到本地仓库" class="headerlink" title="7、将缓存区文件提交到本地仓库"></a>7、将缓存区文件提交到本地仓库</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;本次提交的注释&quot;</span><br></code></pre></td></tr></table></figure><h4 id="8、将仓库中的文件推送到-GitHub-仓库"><a href="#8、将仓库中的文件推送到-GitHub-仓库" class="headerlink" title="8、将仓库中的文件推送到 GitHub 仓库"></a>8、将仓库中的文件推送到 GitHub 仓库</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>然后就可以到 GitHub 上查看到代码了。</p><h1 id="master-to-main"><a href="#master-to-main" class="headerlink" title="master to main"></a>master to main</h1><h4 id="1、重命名当前分支"><a href="#1、重命名当前分支" class="headerlink" title="1、重命名当前分支"></a>1、重命名当前分支</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git branch -m <span class="hljs-keyword">master</span> <span class="hljs-title">main</span><br></code></pre></td></tr></table></figure><h4 id="2、将远程存储库的-URL-更改为-SSH-格式。"><a href="#2、将远程存储库的-URL-更改为-SSH-格式。" class="headerlink" title="2、将远程存储库的 URL 更改为 SSH 格式。"></a>2、将远程存储库的 URL 更改为 SSH 格式。</h4><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">git</span>@<span class="hljs-string">github</span>.<span class="hljs-string">com:XX/</span><span class="hljs-string">XX</span>.<span class="hljs-string">git</span><br></code></pre></td></tr></table></figure><h4 id="3、删除远程分支"><a href="#3、删除远程分支" class="headerlink" title="3、删除远程分支"></a>3、删除远程分支</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> master<br></code></pre></td></tr></table></figure><h4 id="4、将本地仓库推送至远程仓库"><a href="#4、将本地仓库推送至远程仓库" class="headerlink" title="4、将本地仓库推送至远程仓库"></a>4、将本地仓库推送至远程仓库</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure><p>如果遇到错误，参考 <a href="https://blog.csdn.net/qyfx123456/article/details/129531549">master分支与main分支的问题_git main分支_Kudō Shin-ichi的博客-CSDN博客</a></p><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><p>git常用命令</p><ol><li>git config –global user.name xxx：设置全局用户名，信息记录在~&#x2F;.gitconfig文件中</li><li>git config –global user.email <a href="mailto:&#120;&#120;&#120;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#x6f;&#109;">&#120;&#120;&#120;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#x6f;&#109;</a>：设置全局邮箱地址，信息记录在~&#x2F;.gitconfig文件中</li><li>git init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li><li>git add XX：将XX文件添加到暂存区</li><li>**git add .**：将所有待加入暂存区的文件加入暂存区</li><li><strong>git rm –cached XX</strong>：将文件从仓库索引目录中删掉</li><li>**git commit -m “给自己看的备注信息”**：将暂存区的内容提交到当前分支</li><li><strong>git status</strong>：查看仓库状态</li><li>git diff XX：查看XX文件相对于暂存区修改了哪些内容</li><li>git log：查看当前分支的所有版本</li><li><strong>git reflog</strong>：查看HEAD指针的移动历史（包括被回滚的版本）</li><li>git reset –hard HEAD^ 或 git reset –hard HEAD~：将代码库回滚到上一个版本</li><li>git reset –hard HEAD^^：往上回滚两次，以此类推</li><li>git reset –hard HEAD~100：往上回滚100个版本</li><li>git reset –hard 版本号：回滚到某一特定版本</li><li>git checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销</li><li>git remote add origin <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#105;&#x74;&#46;&#x61;&#99;&#119;&#x69;&#x6e;&#x67;&#46;&#99;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#103;&#105;&#x74;&#46;&#x61;&#99;&#119;&#x69;&#x6e;&#x67;&#46;&#99;&#x6f;&#109;</a>:xxx&#x2F;XXX.git：将本地仓库关联到远程仓库</li><li><strong>git push -u</strong> (第一次需要-u以后不需要)：将当前分支推送到远程仓库</li><li>git push origin branch_name：将本地的某个分支推送到远程仓库</li><li>git clone <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#46;&#x61;&#x63;&#119;&#x69;&#110;&#x67;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#46;&#x61;&#x63;&#119;&#x69;&#110;&#x67;&#x2e;&#99;&#111;&#109;</a>:xxx&#x2F;XXX.git：将远程仓库XXX下载到当前目录下</li><li>git checkout -b branch_name：创建并切换到branch_name这个分支</li><li>git branch：查看所有分支和当前所处分支</li><li>git checkout branch_name：切换到branch_name这个分支</li><li>git merge branch_name：将分支branch_name合并到当前分支上</li><li>git branch -d branch_name：删除本地仓库的branch_name分支</li><li>git branch branch_name：创建新分支</li><li>git push –set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支</li><li>git push -d origin branch_name：删除远程仓库的branch_name分支</li><li>git pull：将远程仓库的当前分支与本地仓库的当前分支合并</li><li>git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并</li><li>git branch –set-upstream-to&#x3D;origin&#x2F;branch_name1 branch_name2：将远程的branch_name1分支与本地的branch_name2分支对应</li><li>git checkout -t origin&#x2F;branch_name 将远程的branch_name分支拉取到本地</li><li>git stash：将工作区和暂存区中尚未提交的修改存入栈中</li><li>git stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li><li>git stash drop：删除栈顶存储的修改</li><li>git stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li><li>git stash list：查看栈中所有元素</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量不允许溢出</title>
      <link href="/2023/09/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E4%B8%8D%E5%85%81%E8%AE%B8%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/09/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E4%B8%8D%E5%85%81%E8%AE%B8%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>题一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br><br>    <span class="hljs-built_in">println</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>题二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br><br>    <span class="hljs-built_in">println</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>它们分别输出什么？</p><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>​其实这是一道计算机基础题。</p><h5 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h5><p>​因为 <code>var b int8 = -128 / a</code> 不是常量表达式，因此 untyped 常量 -128 隐式转换为 int8 类型（即和 a 的类型一致），所以 <code>-128 / a</code> 的结果是 int8 类型，值是 128，超出了 int8 的范围。因为结果不是常量，允许溢出，128 的二进制表示是 10000000，正好是 -128 的补码。所以，第一题的结果是 -128。</p><h5 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h5><p>​对于 <code>var b int8 = -128 / a</code>，因为 a 是 int8 类型常量，所以 <code>-128 / a</code> 是常量表达式，在编译器计算，结果必然也是常量。因为 a 的类型是 int8，因此 -128 也会隐式转为 int8 类型，128 这个结果超过了 int8 的范围，但常量不允许溢出，因此编译报错。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口的底层细节</title>
      <link href="/2023/09/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82/"/>
      <url>/2023/09/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码打印出来什么内容，说出为什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Show()<br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Show() &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span> People &#123;<br><span class="hljs-keyword">var</span> stu *Student<br><span class="hljs-keyword">return</span> stu<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> live() == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;AAAAAAA&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;BBBBBBB&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p><strong>结果</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BBBBBBB</span><br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>我们需要了解<code>interface</code>的内部结构，才能理解这个题目的含义。（源码基于 Go1.17）</p><p>interface 在使用的过程中，共有两种表现形式</p><p>一种为**空接口(empty interface)**，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> MyInterface <span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>另一种为<strong>非空接口(non-empty interface)</strong>, 定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInterface <span class="hljs-keyword">interface</span> &#123;<br>function()<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种 interface 类型在底层分别用两种<code>struct</code>表示，空接口为<code>eface</code>, 非空接口为<code>iface</code>。</p><p><img src="https://static.studygolang.com/220205/8b9ad730048aceb7d7b7e3cf4631ad64.jpeg" alt="020501.jpeg"></p><hr><h4 id="空接口-eface"><a href="#空接口-eface" class="headerlink" title="空接口 eface"></a>空接口 eface</h4><p>空接口 eface 结构，由两个属性构成，一个是类型信息 _type，一个是数据信息。其数据结构声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;      <span class="hljs-comment">// 空接口</span><br>    _type *_type         <span class="hljs-comment">// 类型信息</span><br>    data  unsafe.Pointer <span class="hljs-comment">// 指向数据的指针(go 语言中特殊的指针类型 unsafe.Pointer 类似于 c 语言中的void*)</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>_type 属性</strong>：是 Go 语言中所有类型的公共描述，Go 语言几乎所有的数据结构都可以抽象成 <code>_type</code>，是所有类型的公共描述，**_type 负责决定 data 应该如何解释和操作，** <code>_type</code> 的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> _type <span class="hljs-keyword">struct</span> &#123;<br>size       <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 类型大小</span><br>ptrdata    <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 前缀持有所有指针的内存大小</span><br>hash       <span class="hljs-type">uint32</span>  <span class="hljs-comment">// 数据 hash 值</span><br>tflag      tflag<br>align      <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 对齐</span><br>fieldalign <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 嵌入结构体时的对齐</span><br>kind       <span class="hljs-type">uint8</span>   <span class="hljs-comment">// kind 有些枚举值 kind 等于 0 是无效的</span><br><span class="hljs-comment">// function for comparing objects of this type</span><br><span class="hljs-comment">// (ptr to object A, ptr to object B) -&gt; ==?</span><br>equal     <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span><br>gcdata    *<span class="hljs-type">byte</span><br>str       nameOff<br>ptrToThis typeOff<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>data 属性</strong>： 表示指向具体的实例数据的指针，它是一个<code>unsafe.Pointer</code>类型，相当于一个 C 的万能指针<code>void*</code>。</p><p><img src="https://static.studygolang.com/200405/a5dc4728aa922c8bf1bc25e5252cdf49.jpeg" alt="020504.jpeg"></p><hr><h4 id="非空接口-iface"><a href="#非空接口-iface" class="headerlink" title="非空接口 iface"></a>非空接口 iface</h4><p>iface 表示 non-empty interface 的数据结构，非空接口初始化的过程就是初始化一个 iface 类型的结构，其中<code>data</code>的作用与 <code>eface</code> 的相同，这里不再多加描述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>  tab  *itab<br>  data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>iface 结构中最重要的是 itab 结构（结构如下），每一个 <code>itab</code> 都占 32 字节的空间。itab 可以理解为<code>pair&lt;interface type, concrete type&gt;</code> 。itab 里面包含了 interface 的一些关键信息，比如 method 的具体实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;<br>  inter  *interfacetype   <span class="hljs-comment">// 接口自身的元信息</span><br>  _type  *_type           <span class="hljs-comment">// 具体类型的元信息</span><br>  hash   <span class="hljs-type">int32</span>            <span class="hljs-comment">// _type 里也有一个同样的 hash，此处多放一个是为了方便运行接口断言</span><br>  _      [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br>  fun    [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span>       <span class="hljs-comment">// 函数指针，指向具体类型所实现的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中值得注意的字段，个人理解如下：</p><ol><li><code>interface type</code>包含了一些关于 interface 本身的信息，比如<code>package path</code>，包含的<code>method</code>。这里的interfacetype 是定义 interface 的一种抽象表示。</li><li><code>_type</code>表示具体化的类型，与 eface 的 <code>_type</code> 类型相同。</li><li><code>hash</code>字段其实是对<code>_type.hash</code>的拷贝，它会在 interface 的实例化时，用于快速判断目标类型和接口中的类型是否一致。另，Go 的 interface 的 Duck-typing 机制也是依赖这个字段来实现。</li><li><code>fun</code>字段其实是一个动态大小的数组，虽然声明时是固定大小为 1，但在使用时会直接通过 fun 指针获取其中的数据，并且不会检查数组的边界，所以该数组中保存的元素数量是不确定的。</li></ol><hr><p>所以，People 拥有一个 Show 方法，属于非空接口，People 的内部定义是一个<code>iface</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>    Show()  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://static.studygolang.com/200405/3687c0abd9da66c7ed58bbc2258cf00e.jpeg" alt="020502.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span> People &#123;<br>    <span class="hljs-keyword">var</span> stu *Student<br>    <span class="hljs-keyword">return</span> stu      <br>&#125;<br></code></pre></td></tr></table></figure><p>stu 是一个指向 nil 的空指针，但是最后<code>return stu</code> 会触发匿名变量 <code>People = stu</code> 值拷贝动作，所以最后<code>live()</code>放回给上层的是一个<code>People insterface&#123;&#125;</code>类型，也就是一个<code>iface struct&#123;&#125;</code>类型。 stu 为 nil，只是<code>iface</code>中的 data 为 nil 而已。 但是<code>iface struct&#123;&#125;</code>本身并不为 nil.</p><p><img src="https://static.studygolang.com/200405/af13c13498a74d3a9c90cf8cc208e4a0.jpeg" alt="020503.jpeg"></p><p>所以如下判断的结果为<code>BBBBBBB</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <br>    <span class="hljs-keyword">if</span> live() == <span class="hljs-literal">nil</span> &#123;  <br>        fmt.Println(<span class="hljs-string">&quot;AAAAAAA&quot;</span>)      <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;BBBBBBB&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态的特点</title>
      <link href="/2023/09/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B92/"/>
      <url>/2023/09/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B92/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码能通过编译吗？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Speak(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Speak(think <span class="hljs-type">string</span>) (talk <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> think == <span class="hljs-string">&quot;love&quot;</span> &#123;<br>talk = <span class="hljs-string">&quot;You are a good boy&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>talk = <span class="hljs-string">&quot;hi&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> peo People = Student&#123;&#125;<br>think := <span class="hljs-string">&quot;love&quot;</span><br>fmt.Println(peo.Speak(think))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><h2 id="继承与多态的特点"><a href="#继承与多态的特点" class="headerlink" title="继承与多态的特点"></a>继承与多态的特点</h2><p>在 golang 中对多态的特点体现从语法上并不是很明显。</p><p>我们知道发生多态的几个要素：</p><p>1、有interface接口，并且有接口定义的方法。</p><p>2、有子类去重写interface的接口。</p><p>3、有父类指针指向子类的具体对象</p><p>那么，满足上述 3 个条件，就可以产生多态效果，就是，父类指针可以调用子类的具体方法。</p><p>所以上述代码报错的地方在 <code>var peo People = Student&#123;&#125;</code> 这条语句， <code>Student&#123;&#125;</code> 已经重写了父类 <code>People&#123;&#125;</code> 中的 <code>Speak(string) string</code> 方法，那么只需要用父类指针指向子类对象即可。（Go 中不叫父类，这里是为了好理解）</p><p>所以应该改成 <code>var peo People = &amp;Student&#123;&#125;</code> 即可编译通过。（People 为 interface 类型，就是指针类型）</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nil的可赋值类型</title>
      <link href="/2023/09/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E5%8F%AF%E8%B5%8B%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/09/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E5%8F%AF%E8%B5%8B%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面赋值正确的是：</p><ul><li>A. var x &#x3D; nil</li><li>B. var x interface{} &#x3D; nil</li><li>C. var x string &#x3D; nil</li><li>D. var x error &#x3D; nil</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>答案及解析：BD。这道题考的知识点是 nil。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看它的源码就知道，所以 D 是对的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ago">type error interface &#123;<br>Error() string<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iota的使用细节</title>
      <link href="/2023/09/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/"/>
      <url>/2023/09/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否编译通过？如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>x = <span class="hljs-literal">iota</span><br>_<br>y<br>z = <span class="hljs-string">&quot;zz&quot;</span><br>k <br>p = <span class="hljs-literal">iota</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>fmt.Println(x,y,z,k,p)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案：编译通过，输出：0 2 zz zz 5</p><p>知识点：</p><ol><li><p>iota 只能在常量的表达式中使用</p></li><li><p>每次 const 出现时，都会让 iota 初始化为 0【自增长】</p></li><li><p>使用 iota 自定义枚举类型</p></li><li><p>可以用 ‘_’ 线跳过值</p></li><li><p>可用于定义数量级</p></li><li><p>iota 在下一行增长</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// 1， 2</span><br>    Cherimoya, Durian <span class="hljs-comment">// 2， 3</span><br>    Elderberry, Fig <span class="hljs-comment">// 3， 4</span><br>)<br></code></pre></td></tr></table></figure></li><li><p>中间允许插队，但增值依旧不变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    i = <span class="hljs-literal">iota</span><span class="hljs-comment">// 0</span><br>    j = <span class="hljs-number">3.14</span> <span class="hljs-comment">// 3.14</span><br>    k = <span class="hljs-literal">iota</span><span class="hljs-comment">// 2</span><br>    l<span class="hljs-comment">// 3</span><br>)<br></code></pre></td></tr></table></figure></li></ol><p>参考 <a href="https://www.cnblogs.com/zsy/p/5370052.html">https://www.cnblogs.com/zsy/p/5370052.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map是值引用为只读</title>
      <link href="/2023/09/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E6%98%AF%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%BA%E5%8F%AA%E8%AF%BB/"/>
      <url>/2023/09/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E6%98%AF%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%BA%E5%8F%AA%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码能否编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = student<br>list[<span class="hljs-string">&quot;student&quot;</span>].Name = <span class="hljs-string">&quot;LDB&quot;</span><br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p><strong>结果</strong></p><p>编译失败，<code>cannot assign to struct field list[&quot;student&quot;].Name in map</code></p><p><strong>分析</strong></p><p><code>map[string]Student</code> 的 value 是一个 Student 结构值，所以当<code>list[&quot;student&quot;] = student</code>,是一个值拷贝过程。而<code>list[&quot;student&quot;]</code>则是一个值引用。那么值引用的特点是<code>只读</code>。所以对<code>list[&quot;student&quot;].Name = &quot;LDB&quot;</code>的修改是不允许的。</p><p><strong>方法一：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = student<br><span class="hljs-comment">//list[&quot;student&quot;].Name = &quot;LDB&quot;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方法1:</span><br><span class="hljs-comment">    */</span><br>    tmpStudent := list[<span class="hljs-string">&quot;student&quot;</span>]<br>    tmpStudent.Name = <span class="hljs-string">&quot;LDB&quot;</span><br>    list[<span class="hljs-string">&quot;student&quot;</span>] = tmpStudent<br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment">方法1:</span><br><span class="hljs-comment">*/</span><br>tmpStudent := list[<span class="hljs-string">&quot;student&quot;</span>]<br>tmpStudent.Name = <span class="hljs-string">&quot;LDB&quot;</span><br>list[<span class="hljs-string">&quot;student&quot;</span>] = tmpStudent<br></code></pre></td></tr></table></figure><p>是先做一次值拷贝，做出一个<code>tmpStudent副本</code>,然后修改该副本，然后再次发生一次值拷贝复制回去，<code>list[&quot;student&quot;] = tmpStudent</code>,但是这种会在整体过程中发生 2 次结构体值拷贝，性能很差。</p><p><strong>方法二</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = &amp;student<br>list[<span class="hljs-string">&quot;student&quot;</span>].Name = <span class="hljs-string">&quot;LDB&quot;</span><br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将 map 的类型的 value 由 Student 值，改成 Student 指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student<br></code></pre></td></tr></table></figure><p>这样，我们实际上每次修改的都是指针所指向的 Student 空间，指针本身是常指针，不能修改，<code>只读</code>属性，但是指向的 Student 是可以随便修改的，而且这里并不需要值拷贝。只是一个指针的赋值。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量没有地址而言</title>
      <link href="/2023/09/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E6%B2%A1%E6%9C%89%E5%9C%B0%E5%9D%80%E8%80%8C%E8%A8%80/"/>
      <url>/2023/09/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E6%B2%A1%E6%9C%89%E5%9C%B0%E5%9D%80%E8%80%8C%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> cl = <span class="hljs-number">100</span><br><br><span class="hljs-keyword">var</span> bl = <span class="hljs-number">123</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    <span class="hljs-built_in">println</span>(&amp;bl,bl)<br>    <span class="hljs-built_in">println</span>(&amp;cl,cl)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>考点：<strong>常量</strong></p><p>常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cannot take the address of cl<br></code></pre></td></tr></table></figure><p>内存四区概念：</p><h4 id="A-数据类型本质："><a href="#A-数据类型本质：" class="headerlink" title="A.数据类型本质："></a>A.数据类型本质：</h4><p>固定内存大小的别名</p><h4 id="B-数据类型的作用："><a href="#B-数据类型的作用：" class="headerlink" title="B. 数据类型的作用："></a>B. 数据类型的作用：</h4><p>编译器预算对象(变量)分配的内存空间大小。</p><p><img src="https://static.studygolang.com/220123/c9fcb2200f908c3a2ceb887b66e2c0d7.png" alt="img"></p><h4 id="C-内存四区"><a href="#C-内存四区" class="headerlink" title="C. 内存四区"></a>C. 内存四区</h4><p><img src="https://static.studygolang.com/220123/fbee26e0b998b9967c97cefb112e2293.png" alt="img"></p><p>流程说明</p><p>1、操作系统把物理硬盘代码load到内存</p><p>2、操作系统把c代码分成四个区</p><p>3、操作系统找到main函数入口执行</p><h5 id="栈区-Stack-："><a href="#栈区-Stack-：" class="headerlink" title="栈区(Stack)："></a>栈区(Stack)：</h5><p>空间较小，要求数据读写性能高，数据存放时间较短暂。由编译器自动分配和释放，存放函数的参数值、函数的调用流程方法地址、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区)</p><h5 id="堆区-heap"><a href="#堆区-heap" class="headerlink" title="堆区(heap):"></a>堆区(heap):</h5><p>空间充裕，数据存放时间较久。一般由开发者分配及释放(但是Golang中会根据变量的逃逸现象来选择是否分配到栈上或堆上)，启动Golang的GC由GC清除机制自动回收。</p><h5 id="全局区-静态全局变量区"><a href="#全局区-静态全局变量区" class="headerlink" title="全局区-静态全局变量区:"></a>全局区-静态全局变量区:</h5><p>全局变量的开辟是在程序在<code>main</code>之前就已经放在内存中。而且对外完全可见。即作用域在全部代码中，任何同包代码均可随时使用，在变量会搞混淆，而且在局部函数中如果同名称变量使用<code>:=</code>赋值会出现编译错误。</p><p>全局变量最终在进程退出时，由操作系统回收。</p><blockquote><p>我么在开发的时候，尽量减少使用全局变量的设计</p></blockquote><h6 id="全局区-常量区："><a href="#全局区-常量区：" class="headerlink" title="全局区-常量区："></a>全局区-常量区：</h6><p>常量区也归属于全局区，常量为存放数值字面值单位，即不可修改。或者说的有的常量是直接挂钩字面值的。</p><p>比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> cl = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>cl是字面量10的对等符号。</p><p>所以在golang中，常量是无法取出地址的，因为字面量符号并没有地址而言。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体比较</title>
      <link href="/2023/09/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83%E7%BB%86%E8%8A%82/"/>
      <url>/2023/09/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码是否可以编译通过？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>sn1 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br>sn2 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br><span class="hljs-keyword">if</span> sn1 == sn2 &#123;<br>fmt.Println(<span class="hljs-string">&quot;sn1 == sn2&quot;</span>)<br>&#125;<br><br>sm1 := <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>m   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, m: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;<br><br>sm2 := <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>m   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, m: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;<br><br><span class="hljs-keyword">if</span> sm1 == sm2 &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 == sm2&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​编译不通过。</p><p>​关于 Go 语言中的 struct 比较问题，这个需要分情况来讨论：</p><ul><li><p>对于不同类型的 struct 无法进行比较</p></li><li><p>同一个 struct 的两个实例可比较也不可比较，</p><ul><li><p>如果该 strcut 的所有字段都是可比较类型，则可以比较</p></li><li><p>如果包含不可比较字段，如 slice、map、func 时，不可比较，但可以通过如下方式进行比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">可以使用reflect.DeepEqual进行比较<br><br><span class="hljs-keyword">if</span> reflect.DeepEqual(sm1, sm2) &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 == sm2&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 != sm2&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言规范知识点</title>
      <link href="/2023/09/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/09/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>Go101 作者发布了一道有意思的题目，这道题主要考察细节点，Go101 这本书也是以抠细节著称。看看这道题，以下程序输出什么？（单选）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> s = <span class="hljs-string">&quot;Go101.org&quot;</span><br><br><span class="hljs-comment">// len(s) == 9</span><br><span class="hljs-comment">// 1 &lt;&lt; 9 == 512</span><br><span class="hljs-comment">// 512 / 128 == 4</span><br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>A、0 0；B、0 4；C：4 0；D：4 4</p><p>这里涉及到两个知识点，在 Go 语言规范中都有明确的说明，但确实很细节。你答对了吗？原因知晓吗？</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>答案是 4 0（即选 C）。</p><p>​知识点：</p><ul><li>len 函数的参数是字符串字面量和简单的 array 表达式时，len 函数返回值是常量</li><li>如果常量 位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ）</li><li>对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code> 是一个常量位移表达式，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</li><li>对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，因为 <code>1 &lt;&lt; len(s[:])</code> 不是一个常量位移表达式，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型）。</li><li><code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code> 中，根据规范定义，1 会隐式转换为 byte 类型，因此 <code>1 &lt;&lt; len(s[:])</code> 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</li></ul><p>​<strong>1 会隐式转换为 byte 类型，因此 1 &lt;&lt; len(s[:]) 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</strong></p><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所以会重新思考。</p><p>好几个群都问，为什么结果会是 4 0，希望我解释下。因此有了此文。</p><p>这个小题涉及到几个知识点。</p><h2 id="len-函数的结果"><a href="#len-函数的结果" class="headerlink" title="len 函数的结果"></a>len 函数的结果</h2><p>要注意，len 是一个内置函数。在官方标准库文档<a href="https://docs.studygolang.com/pkg/builtin/#len">关于 len 函数</a> 有这么一句：</p><blockquote><p>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification’s “Length and capacity” section for details.</p></blockquote><p>明确支持，当参数是字符串字面量和简单 array 表达式，len 函数返回值是常量，这很重要。</p><p>上题中，如果 <code>const s = &quot;Go101.org”</code> 改为 <code>var s = &quot;Go101.org&quot;</code> 结果又会是什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;Go101.org&quot;</span><br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是 0 0。</p><p>但改为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> s = [<span class="hljs-number">9</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>&#125;<br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果又是 4 0。</p><p>接着看文档那句话的后半句，查看 Go 语言规范中<a href="https://hao.studygolang.com/golang_spec.html#id221">关于长度和容量的说明</a> 。</p><blockquote><p>内置函数 len 和 cap 获取各种类型的实参并返回一个 int 类型结果。实现会保证结果总是一个 int 值。</p><p>如果 s 是一个字符串常量，那么 len(s) 是一个常量 。如果 s 类型是一个数组或到数组的指针且表达式 s 不包含 信道接收 或（非常量的） 函数调用的话， 那么表达式 len(s) 和 cap(s) 是常量；这种情况下， s 是不求值的。否则的话， len 和 cap 的调用结果不是常量且 s 会被求值。</p></blockquote><p>可见题目中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure><p>第一句的 len(s) 是常量（因为 s 是字符串常量）；而第二句的 len(s[:]) 不是常量。这是这两条语句的唯一区别：两个 len 的返回结果数值并无差异，都是 9，但一个是常量一个不是。</p><h2 id="关于位移操作"><a href="#关于位移操作" class="headerlink" title="关于位移操作"></a>关于位移操作</h2><p>根据上面的分析，现在问题的关键在于位移运算这里。Go 语言规范中有<a href="https://docs.studygolang.com/ref/spec#Operators">这么一句</a> ：</p><blockquote><p>The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.</p></blockquote><p>大意是：在位移表达式的右侧的操作数必须为整数类型，或者可以被 uint 类型的值所表示的无类型的常量。如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。</p><p>这里的关键在于常量位移表达式。根据上文的分析，<code>1 &lt;&lt; len(s)</code> 是常量位移表达式，而 <code>1 &lt;&lt; len(s[:])</code> 不是。</p><p>规范上关于常量表达式中，还有<a href="https://docs.studygolang.com/ref/spec#Constant_expressions">这么一句</a> ：</p><blockquote><p>If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.</p></blockquote><p>大意是：如果常量 位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ）</p><p>因此对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code> 是一个常量位移表达式，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</p><p>而对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，因为 <code>1 &lt;&lt; len(s[:])</code> 不是一个常量位移表达式，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型）。</p><p>为什么是 byte 类型，大家可能还是有点晕。这要回到关于常量的说明上。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是在编译的时候进行计算的。在 Go 语言中，常量分两种：无类型和有类型。Go 规范上说，字面值常量， true , false , iota 以及一些仅包含无类型的恒定操作数的 常量表达式 是无类型的。</p><p>那有类型常量是怎么来的呢？一般有两种：显示声明或隐式得到。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">23</span><br><span class="hljs-keyword">const</span> b <span class="hljs-type">float32</span> = <span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>无类型常量都有一个默认类型（无类型常量的默认类型分别是 bool , rune , int , float64 , complex128 或 string）。当在上下文中需要请求该常量为一个带类型的值时，这个 默认类型 便指向该常量隐式转换后的类型。</p><p>所以 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code> 中，根据规范定义，1 会隐式转换为 byte 类型，因此 <code>1 &lt;&lt; len(s[:])</code> 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一道很具迷惑性的题目引出这么多小知识点。可能有人要喷：讨论这些有什么用？这也太细节了。我想说的是，Go 语言规范，细节点很多，能多掌握一些没坏处，说不定将来实际工作就遇到了类似的问题呢？！以上的知识点，很细节，但我认为也是挺有价值的。</p><p>当然了，你怎么说都行，你都是对的，你开心就好！</p><p>答案来自：<a href="https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/">https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定义接口会有额外的堆内存分配吗</title>
      <link href="/2023/09/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E4%BC%9A%E6%9C%89%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%90%97/"/>
      <url>/2023/09/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E4%BC%9A%E6%9C%89%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>Go 1.15 中 var i interface{} &#x3D; a 会有额外堆内存分配吗？</p><p>具体代码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a  <span class="hljs-type">int</span> = <span class="hljs-number">3</span><br><span class="hljs-comment">// 以下有额外内存分配吗？</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = a<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>在 Go 中，接口被实现为一对指针（请参阅 Russ Cox 的 Go 数据结构：<a href="https://research.swtch.com/interfaces">接口</a>）：指向有关类型信息的指针和指向值的指针。可以简单的表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>    tab  *itab<br>    data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 tab 是指向类型信息的指针；data 是指向值的指针。因此，一般来说接口意味着必须在堆中动态分配该值。</p><p>然而，**<a href="https://docs.studygolang.com/doc/go1.15">Go 1.15 发行说明</a>**在 runtime 部分中提到了一个有趣的改进：</p><blockquote><p>Converting a small integer value into an interface value no longer causes allocation.</p></blockquote><p>意思是说，将小整数转换为接口值不再需要进行内存分配。小整数是指 0 到 255 之间的数。</p><p>我们实际简单测试一下。</p><p>创建一个包 smallint，在包中创建文件 smallint.go，加上如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> smallint<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Convert</span><span class="hljs-params">(val <span class="hljs-type">int</span>)</span></span> []<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        slice[i] = val<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更好的看到效果，函数中进行了 100 次 int 到 interface 的转换。写个基准测试 smallint_test.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> smallint_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;testing&quot;</span><br>    <span class="hljs-string">&quot;test/smallint&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkConvert</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>        result := smallint.Convert(<span class="hljs-number">12</span>)<br>        _ = result<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分别使用 Go1.14 和 Go1.15 版本进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go version<br>go version go1.14.7 darwin/amd64<br>$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8      569830       1966 ns/op     2592 B/op      101 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 1.647s<br>$ go version<br>go version go1.15 darwin/amd64<br>$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8     1859451        655 ns/op     1792 B/op        1 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 2.178s<br></code></pre></td></tr></table></figure><p>接着讲 smallint_test.go 中调用 Convert 的参数由 12 改为 256，再次使用 Go1.15 运行，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8      551546       2049 ns/op     2592 B/op      101 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 1.502s<br></code></pre></td></tr></table></figure><p>证明了上面提到的优化点。</p><p>那么，你想过它大概怎么实现的吗？因为上文提到，Go 中接口的实现，使用一个指针字段指向接口值。现在竟然不再额外进行内存分配，说明做了什么特殊的事情。</p><p>其实答案非常简单。如果你对 Python、Java 等语言熟悉，应该知道大概如何实现的。Go 中如何做的，可以在 <strong><a href="https://go-review.googlesource.com/c/go/+/216401">Go CL 216401</a></strong> 中（合并到**<a href="https://github.com/golang/go/commit/9828c43288a53d3df75b1f73edad0d037a91dff8">此提交</a>**中了，GitHub 上更易于阅读）找到。具体来说就是 Go 中定义了一个特殊的静态数组，该数组由 256 个整数组成（0 到 255）。当必须分配内存以将整数存储在堆上，并将其转换为接口的一部分时，它首先检查是否它可以只返回指向数组中适当元素的指针。这种经常使用的值的静态分配，是一种很常见的优化手段。例如，Python 对小整数执行类似的操作，Java 也有常量池，进行类似的优化处理。</p><p>实际上，Go 以前有一个优化，如果你将 0 转换为接口值，它将返回一个指向特殊静态零值的指针。这次新的 0-255 优化替代了该值。</p><p>对具体实现细节感兴趣的，可以阅读下上文提到的提交。</p><p>答案解析来自：<a href="https://mp.weixin.qq.com/s/1r0nt8nA3foDRRrbRp4omg">https://mp.weixin.qq.com/s/1r0nt8nA3foDRRrbRp4omg</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言操作数的规范</title>
      <link href="/2023/09/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E8%A7%84%E8%8C%83/"/>
      <url>/2023/09/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a, b <span class="hljs-type">float64</span> = <span class="hljs-number">1.0</span>, <span class="hljs-number">4.0</span><br>fmt.Println(a | b)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：5；B：+Inf；C：panic；D：不能编译</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>正确答案：D</p><p><code>|</code> 操作是按位或操作符，它的操作数只能是整数，而上面这道题的操作数是 float64，因此编译不通过。</p><p>这是 Go 规范的内容 <a href="https://docs.studygolang.com/ref/spec#Arithmetic_operators%EF%BC%9A">https://docs.studygolang.com/ref/spec#Arithmetic_operators：</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">+    <span class="hljs-built_in">sum</span>                    integers, floats, complex values, strings<br>-    difference             integers, floats, complex values<br>*    product                integers, floats, complex values<br>/    quotient               integers, floats, complex values<br>%    remainder              integers<br><br>&amp;    bitwise AND            integers<br>|    bitwise OR             integers<br>^    bitwise XOR            integers<br>&amp;^   bit clear (AND NOT)    integers<br><br>&lt;&lt;   <span class="hljs-string">left shift             integer &lt;&lt; integer &gt;= 0</span><br><span class="hljs-string">&gt;&gt;   right shift            integer &gt;&gt; integer &gt;= 0</span><br></code></pre></td></tr></table></figure><p>可以通过 play 在线编译看看：<a href="https://play.studygolang.com/p/lLMbGE_ajrg">https://play.studygolang.com/p/lLMbGE_ajrg</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>append第二个参数不能直接使用slice</title>
      <link href="/2023/08/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8slice/"/>
      <url>/2023/08/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8slice/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否通过编译，如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对new定义的切片进行append操作</title>
      <link href="/2023/08/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9new%E5%AE%9A%E4%B9%89%E7%9A%84%E5%88%87%E7%89%87%E8%BF%9B%E8%A1%8Cappend%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/08/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9new%E5%AE%9A%E4%B9%89%E7%9A%84%E5%88%87%E7%89%87%E8%BF%9B%E8%A1%8Cappend%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>list = <span class="hljs-built_in">append</span>(list, <span class="hljs-number">1</span>)<br>fmt.Println(list)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。因为 new 进行分配内存后返回的是一个指针类型，不能对指针指向 append 操作。可以使用 make 初始化之后再用。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new和make的区别</title>
      <link href="/2023/08/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB-/"/>
      <url>/2023/08/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB-/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><h4 id="new-和-make-的区别？"><a href="#new-和-make-的区别？" class="headerlink" title="new 和 make 的区别？"></a>new 和 make 的区别？</h4><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><ul><li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据。</li><li>new 分配返回的是指针，即类型 *Type。make 返回的数据类型本身，即 Type。</li><li>new 分配的空间被清零。make 分配空间后，会进行初始化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片配合append使用</title>
      <link href="/2023/08/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E9%85%8D%E5%90%88append%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/08/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E9%85%8D%E5%90%88append%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面两段代码输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    fmt.Println(s)<br>&#125;<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">代码<span class="hljs-number"> 1 </span>输出：[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>2 3]<br>代码<span class="hljs-number"> 2 </span>输出：[1<span class="hljs-number"> 2 </span>3 4]<br></code></pre></td></tr></table></figure><p>参考解析：这道题考的是使用 append 向 slice 添加元素，第一段代码常见的错误是 [1 2 3]，需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map遍历为什么是无序的</title>
      <link href="/2023/08/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84/"/>
      <url>/2023/08/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>map 的 key 为什么是无序的？</p><p>在遍历 map 的时候，我们会发现，输出的 key 是无序的。为什么？</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p><p>当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key&#x2F;value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。</p><p>当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key&#x2F;value 对了。</p><p>多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。</p><p>答案解析来自：<a href="https://golang.design/go-questions/map/unordered/">https://golang.design/go-questions/map/unordered/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range遍历</title>
      <link href="/2023/08/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E9%81%8D%E5%8E%86/"/>
      <url>/2023/08/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么，说明原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> key,val := <span class="hljs-keyword">range</span> slice &#123;<br>m[key] = &amp;val<br>&#125;<br><br><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k,<span class="hljs-string">&quot;-&gt;&quot;</span>,*v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>-&gt; <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span>-&gt; <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span>-&gt; <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span>-&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>解析：这是新手常会犯的错误写法，for range 循环的时候会<strong>创建每个元素的副本，而不是元素的引用</strong>，所以 m[key] &#x3D; &amp;val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3.</p><p>正确的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> key,val := <span class="hljs-keyword">range</span> slice &#123;<br>value := val<br>m[key] = &amp;value<br>&#125;<br><br><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k,<span class="hljs-string">&quot;===&gt;&quot;</span>,*v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展题目</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Test <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Test)</span></span> Point()&#123;<br>fmt.Println(this.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>ts := []Test&#123;<br>&#123;<span class="hljs-string">&quot;a&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;b&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;c&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _,t := <span class="hljs-keyword">range</span> ts &#123;<br><span class="hljs-comment">//fmt.Println(reflect.TypeOf(t))</span><br><span class="hljs-keyword">defer</span> t.Point()<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/idwtwt/article/details/87378419">https://blog.csdn.net/idwtwt/article/details/87378419</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型断言、方法集</title>
      <link href="/2023/08/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E3%80%81%E6%96%B9%E6%B3%95%E9%9B%86/"/>
      <url>/2023/08/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E3%80%81%E6%96%B9%E6%B3%95%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>如果 Add() 函数的调用代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a Integer = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b Integer = <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = &amp;a<br>sum := i.(*Integer).Add(b)<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>则Add函数定义正确的是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">A.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span></span> Add(b Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br>B.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span></span> Add(b *Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> a + *b<br>&#125;<br><br>C.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span></span> Add(b Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> *a + b<br>&#125;<br><br>D.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> *a + *b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​AC。</p><p>当涉及到方法调用时，Go 语言对于接收者的类型转换会有两种情况：</p><ol><li>非指针类型的接收者调用方法：<ul><li>如果方法的接收者类型是指针类型 <code>*T</code>，而你使用非指针类型的变量 <code>v</code> 调用该方法，则编译器会自动将 <code>v</code> 转换为 <code>*T</code> 类型的指针，并调用相应的方法。</li><li>示例：<code>user.GetName()</code>，其中 <code>GetName()</code> 的接收者类型是 <code>*Student</code>，但你可以使用 <code>Student</code> 类型的变量 <code>user</code> 进行调用。</li></ul></li><li>指针类型的接收者调用方法：<ul><li>如果方法的接收者类型是非指针类型 <code>T</code>，而你使用指针类型的变量 <code>p</code> 调用该方法，则编译器会自动将 <code>p</code> 解引用为 <code>*T</code> 类型，并调用相应的方法。</li><li>示例：<code>user.GetId()</code>，其中 <code>GetId()</code> 的接收者类型是 <code>Student</code>，但你可以使用 <code>*Student</code> 类型的指针变量 <code>user</code> 进行调用。</li></ul></li></ol><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>switch语句</title>
      <link href="/2023/08/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/switch%E8%AF%AD%E5%8F%A5-2/"/>
      <url>/2023/08/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/switch%E8%AF%AD%E5%8F%A5-2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>关于switch语句，下面说法正确的有?</p><ul><li>A. 条件表达式必须为常量或者整数；</li><li>B. 单个case中，可以出现多个结果选项；</li><li>C. 需要用break来明确退出一个case；</li><li>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：BD。</p><p>A. 条件表达式可以是任何可以被求值的表达式，不仅限于常量或整数。例如，条件表达式可以是字符串、枚举类型、布尔值或其他数据类型。</p><p>C. Go 语言中不需要用 break 来退出，会在执行一条 case 语句后默认直接退出（只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；）</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="/2023/08/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/08/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>关于类型转化，下面选项正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">A.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = i<br><br>B.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = (MyInt)i<br><br>C.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = MyInt(i)<br><br>D.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = i.(MyInt)<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​在 Go 中进行类型转换时，如果基础类型相同，可以使用显式类型转换。选项 C 中的代码是正确的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = MyInt(i)<br></code></pre></td></tr></table></figure><p>这里将 <code>int</code> 类型的变量 <code>i</code> 转换为自定义类型 <code>MyInt</code>，因为它们的底层类型相同，所以是允许的。</p><p>选项 A 中的代码是错误的，因为直接将 <code>int</code> 类型赋值给 <code>MyInt</code> 类型是不允许的。</p><p>选项 B 中的代码是错误的，因为在 Go 中，显式类型转换的语法不需要括号。</p><p>选项 D 中的代码是错误的，因为使用点号语法 <code>i.(MyInt)</code> 是类型断言的语法，是将接口类型断言成某一类型，而不是类型转换的语法。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多重赋值</title>
      <link href="/2023/08/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC%E7%9A%84%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/08/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC%E7%9A%84%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p> 题目：<span id="more"></span></p><p>下面代码输出正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">1</span><br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br>i, s[i<span class="hljs-number">-1</span>] = <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Z&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;s: %v \n&quot;</span>, s)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. s: [Z,B,C]</li><li>B. s: [A,Z,C]</li></ul><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：A。</p><p>知识点：多重赋值。</p><p>多重赋值分为两个步骤，有先后顺序：</p><ul><li>计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；</li><li>赋值；</li></ul><p>所以本例，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 <code>i, s[0] = 2, &quot;Z&quot;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for循环的基础知识</title>
      <link href="/2023/08/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/08/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>关于循环语句，下面说法正确的有（）</p><ul><li>A. 循环语句既支持 for 关键字，也支持 while 和 do-while；</li><li>B. 关键字 for 的基本使用方法与 C&#x2F;C++ 中没有任何差异；</li><li>C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；</li><li>D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：CD。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程和线程</title>
      <link href="/2023/08/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/08/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>关于协程，下面说法正确是（）</p><ul><li>A. 协程和线程都可以实现程序的并发执行；</li><li>B. 线程比协程更轻量级；</li><li>C. 协程不存在死锁问题；</li><li>D. 通过 channel 来进行协程间的通信；</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：AD。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range遍历map是无序的</title>
      <link href="/2023/08/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E9%81%8D%E5%8E%86map%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84/"/>
      <url>/2023/08/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E9%81%8D%E5%8E%86map%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码里的 counter 的输出值？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">21</span>,<br><span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">22</span>,<br><span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">23</span>,<br>&#125;<br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;A&quot;</span>)<br>&#125;<br>counter++<br>fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 2</li><li>B. 3</li><li>C. 2 或 3</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：C。</p><p>for range map 是无序的，如果第一次循环到 A，则输出 3；否则输出 2。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range-6</title>
      <link href="/2023/08/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range-6/"/>
      <url>/2023/08/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range-6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出结果正确吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123;<br>bar <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []Foo&#123;<br>&#123;<span class="hljs-string">&quot;A&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;B&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;C&quot;</span>&#125;,<br>&#125;<br>s2 := <span class="hljs-built_in">make</span>([]*Foo, <span class="hljs-built_in">len</span>(s1))<br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> s1 &#123;<br>s2[i] = &amp;value<br>&#125;<br>fmt.Println(s1[<span class="hljs-number">0</span>], s1[<span class="hljs-number">1</span>], s1[<span class="hljs-number">2</span>])<br>fmt.Println(s2[<span class="hljs-number">0</span>], s2[<span class="hljs-number">1</span>], s2[<span class="hljs-number">2</span>])<br>&#125;<br>输出：<br>&#123;A&#125; &#123;B&#125; &#123;C&#125;<br>&amp;&#123;A&#125; &amp;&#123;B&#125; &amp;&#123;C&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：s2 的输出结果错误。</p><p>s2 的输出是 <code>&amp;&#123;C&#125; &amp;&#123;C&#125; &amp;&#123;C&#125;</code>，在前面题目我们提到过，for range 使用短变量声明(:&#x3D;)的形式迭代变量时，变量 i、value 在每次循环体中都会被重用，而不是重新声明。所以 s2 每次填充的都是临时变量 value 的地址，而在最后一次循环中，value 被赋值为{c}。因此，s2 输出的时候显示出了三个 &amp;{c}。</p><p>可行的解决办法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s1 &#123;<br>s2[i] = &amp;s1[i]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range...</title>
      <link href="/2023/08/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range(5)/"/>
      <url>/2023/08/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range(5)/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">r =  [1 12 13 4 5]<br>a =  [1 12 13 4 5]<br></code></pre></td></tr></table></figure><p>这道题是昨天第二题的一个解决办法，这的 a 是一个切片，那切片是怎么实现的呢？切片在 go 的内部结构有一个指向底层数组的指针，当 range 表达式发生复制时，副本的指针依旧指向原底层数组，所以对切片的修改都会反应到底层数组上，所以通过 v 可以获得修改后的数组元素。</p><p>引自：<a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make初始化切片</title>
      <link href="/2023/08/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%87%E7%89%87/"/>
      <url>/2023/08/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(s ...<span class="hljs-type">int</span>)</span></span> &#123;<br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)<br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>slice[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>change(slice...)<br>fmt.Println(slice)<br>change(slice[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]...)<br>fmt.Println(slice)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1 2 0 0 0]<br>[1 2 3 0 0]<br></code></pre></td></tr></table></figure><p>知识点：可变函数、append()操作。</p><p>Go 提供的语法糖<code>...</code>，可以将 slice 传进可变函数，不会创建新的切片。第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变； 第二次调用change() 函数时，使用了操作符<code>[i,j]</code>获得一个新的切片，假定为 slice1，<br>它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range中数组是值引用</title>
      <link href="/2023/08/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E4%B8%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2023/08/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E4%B8%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">r =  [1 2 3 4 5]<br>a =  [1 12 13 4 5]<br></code></pre></td></tr></table></figure><p>range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a。就这个例子来说，假设 b 是 a 的副本，则 range 循环代码是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> b &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。</p><p>如果想要 r 和 a 一样输出，修复办法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> &amp;a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">r =  [1 12 13 4 5]<br>a =  [1 12 13 4 5]<br></code></pre></td></tr></table></figure><p>修复代码中，使用 *[5]int 作为 range 表达式，其副本依旧是一个指向原数组 a 的指针，因此后续所有循环中均是 &amp;a 指向的原数组亲自参与的，因此 v 能从 &amp;a 指向的原数组中取出 a 修改后的值。</p><p>reference: <a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer注册未初始化函数</title>
      <link href="/2023/08/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/"/>
      <url>/2023/08/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += n<br><span class="hljs-built_in">recover</span>()<br>&#125;()<br><br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">defer</span> f()<br>f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f(<span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案及解析"><a href="#答案及解析" class="headerlink" title="答案及解析"></a>答案及解析</h4><p>​输出 7 。</p><p>​知识点：在 defer 注册函数的时候，即使注册了未初始化的函数，也不会报错，会继续执行后面的语句。</p><p>​当函数返回时，执行 defer 函数的时候，如果执行到了 未初始化的函数，就会发生 panic，并继续执行完其他 defer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;...&quot;</span>)<br><span class="hljs-comment">//recover() //恢复 panic</span><br>&#125;()<br><span class="hljs-keyword">defer</span> f() <span class="hljs-comment">// 注册一个未初始化的函数</span><br><br>fmt.Println(<span class="hljs-string">&quot;注册成功&quot;</span>)<br>f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Deferred function&quot;</span>)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;初始化成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在本题中，将参数 3 传入函数 f ，此时 n &#x3D; 3，注册两个 defer 函数，然后返回 n + 1，此时 r &#x3D; n  + 1 &#x3D; 4。</p><p>先执行  f() 函数，由于注册的时候该函数未进行初始化，故执行时发生 panic ，然后执行剩余的一个 defer 函数，此时 r &#x3D; n + r &#x3D; 7，然后 recover() 恢复了  panic ，使得函数能够执行最后一步，将 r 返回给 主函数 main，即 7。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同样的for-range，不同的知识</title>
      <link href="/2023/08/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%90%8C%E6%A0%B7%E7%9A%84for-range%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/08/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%90%8C%E6%A0%B7%E7%9A%84for-range%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> m = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i, v)<br>&#125;()<br>&#125;<br><br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">2 3<br>2 3<br>2 3<br></code></pre></td></tr></table></figure><p>​这里的for range 跟之前讲过的一样，变量 i、v 在每次循环体中都会被重用，而不是重新声明。</p><p> 各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个 goroutine 启动时的 i, v值。可以理解为闭包引用，使用的是上下文环境的值。两种可行的 fix 方法:</p><p>a.使用函数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,v <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(i, v)<br>&#125;(i,v)<br>&#125;<br></code></pre></td></tr></table></figure><p>b.使用临时变量保留当前值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> m &#123;<br>i := i           <span class="hljs-comment">// 这里的 := 会重新声明变量，而不是重用</span><br>v := v<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(i, v)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>​如果你简单得认为是上述那样，就错了。其实这样还有一个细节，就是这里每次输出都是一样的，是因为 切片内元素太少，导致 最开始创建的 goroutine 还没有开始执行，for range 就执行结束了。如果切片内的元素多一点，输出的结果就不一样了。</p><p>​所以这个题的本质，还是与之前的一样：for range 语句中定义的变量会被复用，而不是重新定义。</p><p>reference: <a href="https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/">https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range</title>
      <link href="/2023/08/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range2/"/>
      <url>/2023/08/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否正常结束？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> v &#123;<br>v = <span class="hljs-built_in">append</span>(v, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​for-range 遍历切片，在底层实现的时候，会先将该切片进行浅拷贝，拷贝到 temp（假设），然后遍历的时候遍历这个 temp，故后续加入切片的元素不会被遍历到，因此不会出现死循环，能正常结束。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短变量声明的小细节</title>
      <link href="/2023/08/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
      <url>/2023/08/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (*<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">5</span><br><span class="hljs-keyword">return</span> &amp;i, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//use p</span><br>fmt.Println(*p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p, err := foo()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>bar()<br>fmt.Println(*p)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 5 5</li><li>B. runtime error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。知识点：变量作用域。问题出在操作符<code>:=</code>，对于使用<code>:=</code>定义的变量，如果新变量与同名已定义的变量不在同一个作用域中，那么 Go 会新定义这个变量。</p><p>​对于本例来说，main() 函数里的 p 是新定义的变量，会遮住全局变量 p，导致执行到<code>bar()</code>时程序，全局变量 p 依然还是 nil，程序随即 Crash。</p><p>正确的做法是将 main() 函数修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>p, err = foo()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>bar()<br>fmt.Println(*p)<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题目引自 Tony Bai 老师的一篇文章，原文讲的很详细，推荐。</p><p><a href="https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/">https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和切片的比较</title>
      <link href="/2023/08/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2023/08/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面的代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println([...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125; == [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;)<br>fmt.Println([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125; == []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：有两处错误</p><ul><li>go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 <code>[...]int&#123;1&#125;</code> 和 <code>[2]int&#123;1&#125;</code> 是两种不同的类型，不能比较；</li><li>切片是不能比较的；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select死锁问题</title>
      <link href="/2023/08/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/select%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/select%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码的输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>foo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>bar := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> foo &lt;- &lt;-bar:<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;default&quot;</span>)<br>&#125;<br>&#125;()<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A：default</li><li>B：panic</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​B。因为 select 在执行之前，会将所有 case 语句中通道的右边部分先进行计算确定值，才会开始选择某个 case 语句。</p><p>这是我根据火丁笔记发的一篇文章：<a href="https://blog.huoding.com/2021/08/29/947">《一个 select 死锁问题》</a> 进行的修改，以便更好理解。</p><p>按常规理解，go func 中的 select 应该执行 default 分支，程序正常运行。但结果却不是，而是死锁。可以通过该链接测试：<a href="https://play.studygolang.com/p/kF4pOjYXbXf%E3%80%82">https://play.studygolang.com/p/kF4pOjYXbXf。</a></p><p>原因文章也解释了，Go 语言规范中有这么一句：</p><blockquote><p>For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the “select” statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.</p></blockquote><p>不知道大家看懂没有？于是，最后来了一个例子验证你是否理解了：为什么每次都是输出一半数据，然后死锁？（同样，这里可以运行查看结果：<a href="https://play.studygolang.com/p/zoJtTzI7K5T%EF%BC%89">https://play.studygolang.com/p/zoJtTzI7K5T）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">talk</span><span class="hljs-params">(msg <span class="hljs-type">string</span>, sleep <span class="hljs-type">int</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%s %d&quot;</span>, msg, i)<br>time.Sleep(time.Duration(sleep) * time.Millisecond)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fanIn</span><span class="hljs-params">(input1, input2 &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input1:<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input2:<br>&#125;<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := fanIn(talk(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">10</span>), talk(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1000</span>))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, &lt;-ch)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有没有这种感觉：</p><p><img src="https://polarisxu.studygolang.com/posts/go/action/imgs/select-channel-deadlock.png" alt="算法入门"></p><p>这是 StackOverflow 上的一个问题：<a href="https://stackoverflow.com/questions/51167940/chained-channel-operations-in-a-single-select-case%E3%80%82">https://stackoverflow.com/questions/51167940/chained-channel-operations-in-a-single-select-case。</a></p><p>关键点和文章开头例子一样，在于 select case 中两个 channel 串起来，即 fanIn 函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input1:<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input2:<br>&#125;<br></code></pre></td></tr></table></figure><p>如果改为这样就一切正常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> t := &lt;-input1:<br>  ch &lt;- t<br><span class="hljs-keyword">case</span> t := &lt;-input2:<br>  ch &lt;- t<br>&#125;<br></code></pre></td></tr></table></figure><p>结合这个更复杂的例子分析 Go 语言规范中的那句话。</p><p>对于 select 语句，在进入该语句时，会按源码的顺序对每一个 case 子句进行求值：这个求值只针对发送或接收操作的额外表达式。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ch 是一个 chan int；</span><br><span class="hljs-comment">// getVal() 返回 int</span><br><span class="hljs-comment">// input 是 chan int</span><br><span class="hljs-comment">// getch() 返回 chan int</span><br><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> ch &lt;- getVal():<br>  <span class="hljs-keyword">case</span> ch &lt;- &lt;-input:<br>  <span class="hljs-keyword">case</span> getch() &lt;- <span class="hljs-number">1</span>:<br>  <span class="hljs-keyword">case</span> &lt;- getch():<br>&#125;<br></code></pre></td></tr></table></figure><p>在没有选择某个具体 case 执行前，例子中的 <code>getVal()</code>、<code>&lt;-input</code> 和 <code>getch()</code> 会执行。这里有一个验证的例子：<a href="https://play.studygolang.com/p/DkpCq3aQ1TE%E3%80%82">https://play.studygolang.com/p/DkpCq3aQ1TE。</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- getVal(<span class="hljs-number">1</span>):<br>fmt.Println(<span class="hljs-string">&quot;in first case&quot;</span>)<br><span class="hljs-keyword">case</span> ch &lt;- getVal(<span class="hljs-number">2</span>):<br>fmt.Println(<span class="hljs-string">&quot;in second case&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;default&quot;</span>)<br>&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;The val:&quot;</span>, &lt;-ch)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getVal</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;getVal, i=&quot;</span>, i)<br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure><p>无论 select 最终选择了哪个 case，<code>getVal()</code> 都会按照源码顺序执行：<code>getVal(1)</code> 和 <code>getVal(2)</code>，也就是它们必然先输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">getVal, i= 1<br>getVal, i= 2<br></code></pre></td></tr></table></figure><p>你可以仔细琢磨一下。</p><p>现在回到 StackOverflow 上的那个问题。</p><p>每次进入以下 select 语句时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input1:<br><span class="hljs-keyword">case</span> ch &lt;- &lt;-input2:<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&lt;-input1</code> 和 <code>&lt;-input2</code> 都会执行，相应的值是：A x 和 B x（其中 x 是 0-5）。但每次 select 只会选择其中一个 case 执行，所以 <code>&lt;-input1</code> 和 <code>&lt;-input2</code> 的结果，必然有一个被丢弃了，也就是不会被写入 ch 中。因此，一共只会输出 5 次，另外 5 次结果丢掉了。（你会发现，输出的 5 次结果中，x 比如是 0 1 2 3 4）</p><p>而 main 中循环 10 次，只获得 5 次结果，所以输出 5 次后，报死锁。</p><hr><p>虽然这是一个小细节，但实际开发中还是有可能出现的。比如文章提到的例子写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ch 是一个 chan int；</span><br><span class="hljs-comment">// getVal() 返回 int</span><br><span class="hljs-comment">// input 是 chan int</span><br><span class="hljs-comment">// getch() 返回 chan int</span><br><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> ch &lt;- getVal():<br>  <span class="hljs-keyword">case</span> ch &lt;- &lt;-input:<br>  <span class="hljs-keyword">case</span> getch() &lt;- <span class="hljs-number">1</span>:<br>  <span class="hljs-keyword">case</span> &lt;- getch():<br>&#125;<br></code></pre></td></tr></table></figure><p>因此在使用 select 时，一定要注意这种可能的问题。</p><p>不要以为这个问题不会遇到，其实很常见。最多的就是 time.After 导致内存泄露问题，网上有很多文章解释原因，如何避免，其实最根本原因就是因为 select 这个机制导致的。</p><p>比如如下代码，有内存泄露（传递给 time.After 的时间参数越大，泄露会越厉害），你能解释原因吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> &#123;<br>            i++<br>            ch &lt;- i<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> x := &lt;- ch:<br>            <span class="hljs-built_in">println</span>(x)<br>        <span class="hljs-keyword">case</span> &lt;- time.After(<span class="hljs-number">30</span> * time.Second):<br>            <span class="hljs-built_in">println</span>(time.Now().Unix())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/chained-channel-operations-in-a-single-select-case/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/chained-channel-operations-in-a-single-select-case/。</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map的value本身的地址是不可寻的</title>
      <link href="/2023/08/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84value%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%AF%BB%E7%9A%84/"/>
      <url>/2023/08/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84value%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%AF%BB%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Math <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Math&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: Math&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m[<span class="hljs-string">&quot;foo&quot;</span>].x = <span class="hljs-number">4</span><br>fmt.Println(m[<span class="hljs-string">&quot;foo&quot;</span>].x)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 4</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B，编译报错 <code>cannot assign to struct field m[&quot;foo&quot;].x in map</code>。错误原因：对于类似 <code>X = Y</code>的赋值操作，必须知道 <code>X</code> 的地址，才能够将 <code>Y</code> 的值赋给 <code>X</code>，但 <strong>go 中的 map 的 value 本身是不可寻址的。</strong></p><p>有两个解决办法：</p><p>a.使用临时变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Math <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Math&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: Math&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tmp := m[<span class="hljs-string">&quot;foo&quot;</span>]<br>tmp.x = <span class="hljs-number">4</span><br>m[<span class="hljs-string">&quot;foo&quot;</span>] = tmp<br>fmt.Println(m[<span class="hljs-string">&quot;foo&quot;</span>].x)<br>&#125;<br></code></pre></td></tr></table></figure><p>b.修改数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Math <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Math&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: &amp;Math&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m[<span class="hljs-string">&quot;foo&quot;</span>].x = <span class="hljs-number">4</span><br>fmt.Println(m[<span class="hljs-string">&quot;foo&quot;</span>].x)<br>fmt.Printf(<span class="hljs-string">&quot;%#v&quot;</span>, m[<span class="hljs-string">&quot;foo&quot;</span>])   <span class="hljs-comment">// %#v 格式化输出详细信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>references:</p><ol><li><a href="https://blog.csdn.net/qq_36431213/article/details/82805043">https://blog.csdn.net/qq_36431213/article/details/82805043</a></li><li><a href="https://www.cnblogs.com/DillGao/p/7930674.html">https://www.cnblogs.com/DillGao/p/7930674.html</a></li><li><a href="https://haobook.readthedocs.io/zh_CN/latest/periodical/201611/zhangan.html">https://haobook.readthedocs.io/zh_CN/latest/periodical/201611/zhangan.html</a></li><li><a href="https://suraj.pro/post/golang_workaround/">https://suraj.pro/post/golang_workaround/</a></li><li><a href="https://blog.ijun.org/2017/07/cannot-assign-to-struct-field-in-map.html">https://blog.ijun.org/2017/07/cannot-assign-to-struct-field-in-map.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型自动使用其string方法</title>
      <link href="/2023/07/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%85%B6string%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%85%B6string%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Direction <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>North Direction = <span class="hljs-literal">iota</span><br>East<br>South<br>West<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Direction)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;North&quot;</span>, <span class="hljs-string">&quot;East&quot;</span>, <span class="hljs-string">&quot;South&quot;</span>, <span class="hljs-string">&quot;West&quot;</span>&#125;[d]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(South)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：South。知识点：iota 的用法、类型的 <code>String()</code> 方法。</p><p>根据 iota 的用法推断出 South 的值是 2；另外，<strong>如果类型定义了 <code>String()</code> 方法，当使用 <code>fmt.Printf()</code>、<code>fmt.Print()</code> 和 <code>fmt.Println()</code> 会自动使用 String() 方法，实现字符串的打印。</strong></p><p>Reference:</p><ol><li><a href="https://wiki.jikexueyuan.com/project/the-way-to-go/10.7.html">https://wiki.jikexueyuan.com/project/the-way-to-go/10.7.html</a></li><li><a href="https://www.sunansheng.com/archives/24.html">https://www.sunansheng.com/archives/24.html</a></li><li><a href="https://yourbasic.org/golang/iota/">https://yourbasic.org/golang/iota/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iota的用法</title>
      <link href="/2023/07/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2023/07/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b = <span class="hljs-literal">iota</span><br>)<br><span class="hljs-keyword">const</span> (<br>name = <span class="hljs-string">&quot;name&quot;</span><br>c    = <span class="hljs-literal">iota</span><br>d    = <span class="hljs-literal">iota</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(a)<br>fmt.Println(b)<br>fmt.Println(c)<br>fmt.Println(d)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：0 1 1 2。</p><p>知识点：iota 的用法。</p><p>iota 是 golang 语言的常量计数器，只能在常量的表达式中使用。</p><p>iota 在 <strong>const 关键字出现时将被重置为0</strong>，const中每新增一行常量声明将使 iota 计数一次。</p><p>Reference: <a href="https://studygolang.com/articles/2192">https://studygolang.com/articles/2192</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针类型和值类型的方法</title>
      <link href="/2023/07/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Speak(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Speak(think <span class="hljs-type">string</span>) (talk <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> think == <span class="hljs-string">&quot;speak&quot;</span> &#123;<br>talk = <span class="hljs-string">&quot;speak&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>talk = <span class="hljs-string">&quot;hi&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> peo People = Student&#123;&#125;<br>think := <span class="hljs-string">&quot;speak&quot;</span><br>fmt.Println(peo.Speak(think))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. speak</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>编译错误 <code>Student does not implement People (Speak method has pointer receiver)</code>，值类型 <code>Student</code> 没有实现接口的 <code>Speak()</code> 方法，而是指针类型 <code>*Student</code> 实现改方法。</p><p>详细请参考这篇文章 <a href="https://seekload.net/2019/06/06/go-study-method.html">https://seekload.net/2019/06/06/go-study-method.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础类型创建的方法</title>
      <link href="/2023/07/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> PrintInt ()  &#123;<br>fmt.Println(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>i.PrintInt()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p><strong>基于类型创建的方法必须定义在同一个包内</strong>，上面的代码基于 int 类型创建了 PrintInt() 方法，由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。解决的办法可以定义一种新的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Myint <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Myint)</span></span> PrintInt ()  &#123;<br>fmt.Println(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i Myint = <span class="hljs-number">1</span><br>i.PrintInt()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>len中的门道</title>
      <link href="/2023/07/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/len%E4%B8%AD%E7%9A%84%E9%97%A8%E9%81%93/"/>
      <url>/2023/07/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/len%E4%B8%AD%E7%9A%84%E9%97%A8%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>在 Go语言爱好者周刊第 104 期有一道题目，以下代码输出什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> x *<span class="hljs-keyword">struct</span> &#123;<br>    s [][<span class="hljs-number">32</span>]<span class="hljs-type">byte</span><br>  &#125;<br>  <br>  <span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(x.s[<span class="hljs-number">99</span>]))<br>&#125;<br></code></pre></td></tr></table></figure><p>A：运行时 panic；B：32；C：编译错误；D：0</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>正确率只有 16%。</p><p>正确答案：B。</p><h2 id="01-解析题目"><a href="#01-解析题目" class="headerlink" title="01 解析题目"></a>01 解析题目</h2><p>先剖析下这段代码，x 变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x *<span class="hljs-keyword">struct</span> &#123;<br>  s [][<span class="hljs-number">32</span>]<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里不是定义一个结构体类型，而是定义一个结构体类型指针变量，即 x 是一个指针，指针类型是一个匿名结构体。很显然，x 的值是 nil，因为没有初始化，可以打印证实这一点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x *<span class="hljs-keyword">struct</span> &#123;<br>s [][<span class="hljs-number">32</span>]<span class="hljs-type">byte</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;x.Type = %T; x.Value= %v\n&quot;</span>, x, x)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">x.Type = *struct &#123; s [][32]uint8 &#125;; x.Value= &lt;nil&gt;<br></code></pre></td></tr></table></figure><p>这也是为什么 48% 的人选择 A （panic） 的原因，毕竟 x 是 nil，panic 很自然的。比如这样就会 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">println</span>(x.s)<br><span class="hljs-comment">// panic: runtime error: invalid memory address or nil pointer dereference</span><br></code></pre></td></tr></table></figure><p>相应的，fmt.Println(x.s[99]) 也会 panic。但为什么 <code>len(x.s[99])</code> 就不 panic 了呢？所以得从 len 入手一探究竟。</p><h2 id="02-len-详解"><a href="#02-len-详解" class="headerlink" title="02 len 详解"></a>02 len 详解</h2><p>len 函数是一个内置类型，什么意思？就是由编译器实现的。它的参数可以接收多种类型，有泛型的味道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">len</span><span class="hljs-params">(v Type)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>关于它的说明，标准库文档有说明：</p><blockquote><p>内建函数 len 返回 v 的长度，这取决于具体类型：</p><ul><li>数组：v 中元素的数量</li><li>数组指针：*v 中元素的数量（v 为 nil 时 panic）</li><li>切片、map：v 中元素的数量；若 v 为nil，len(v) 即为零</li><li>字符串：v 中字节的数量</li><li>通道：通道缓存中队列（未读取）元素的数量；若 v 为 nil，len(v) 即为零</li></ul></blockquote><p>光这个解释，还不够全面，len 函数还有其他一些特殊的点。这要看 Go 语言规范。</p><p>在规范中，有一节是<a href="https://hao.studygolang.com/golang_spec.html#id221">关于 len 和 cap 的</a>。有如下几个要点：</p><ul><li>返回结果总是 int；</li><li>返回结果有可能是常量；</li><li>有时对函数参数不求值，即编译期确定返回值；</li></ul><p>2、3 点解释下。（规范中有说明）</p><p>如果 len 或 cap 的函数参数 v 是字符串常量，则返回值是一个常量。</p><p><strong>如果 v 的类型是数组或指向数组的指针，且表达式 v 没有包含 channel 接收或（非常量）函数调用，则返回值也是一个常量。这种情况下，不会对 v 进行求值（即编译期就能确定）。否则返回值不是常量，且会对 v 进行求值（即得运行时确定）。</strong></p><p><strong>这一点是这道题的关键。</strong></p><p>首先，x.s[99] 的类型是 <code>[32]byte</code>，它是一个数组，且表达式 <code>x.s[99]</code> 没有包含 channel 接收也不是函数调用，因此不会对 x.s[99] 进行求值，不求值自然不会 panic（想不明白？可以想成没有解引用操作）。也就是说，编译器能够在编译阶段分析出 x.s[99] 的类型是 [32]byte，且不需要对 x.s[99] 求值，因此直接返回数组的长度，即 32。</p><h2 id="03-其他类似情况"><a href="#03-其他类似情况" class="headerlink" title="03 其他类似情况"></a>03 其他类似情况</h2><p>类似这样不求值的情况还有没有？还真有。比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> testdata *<span class="hljs-keyword">struct</span> &#123;<br>  a *[<span class="hljs-number">7</span>]<span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> testdata.a &#123;<br>  fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样不会 panic，原理和上面的类似，<a href="https://hao.studygolang.com/golang_spec.html#id355">在 Go 语言规范有说明</a>。</p><p>“range” 子句中右侧的表达式被称为 range 表达式 ，它可以是数组、数组的指针、切片、字符串、map或是允许接收操作 的 channel。range 表达式会在开始此循环前被求值一次，但有一个例外：当存在最多一个迭代变量且 <code>len(x)</code> 是常量时，range 表达式是不被求值的。</p><p>所以上面代码中 testdata.a 不会被求值，因为 len(testdata.a) 是常量。</p><p>但如果改为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> testdata *<span class="hljs-keyword">struct</span> &#123;<br>  a *[<span class="hljs-number">7</span>]<span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-keyword">range</span> testdata.a &#123;<br>  fmt.Println(i, j)<br>&#125;<br></code></pre></td></tr></table></figure><p>就会 panic。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>通过这么一道「诡异」的面试题，希望你能够对 len 有更深的理解，也希望你能够重视 Go 语言规范，多留意一些细节，同时学会如何寻找问题的答案。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-104/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-104/。</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer注册函数</title>
      <link href="/2023/07/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>​</p><h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>​下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">defer</span> calc(<span class="hljs-string">&quot;1&quot;</span>, a, calc(<span class="hljs-string">&quot;10&quot;</span>, a, b))<br>a = <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> calc(<span class="hljs-string">&quot;2&quot;</span>, a, calc(<span class="hljs-string">&quot;20&quot;</span>, a, b))<br>b = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(index <span class="hljs-type">string</span>, a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ret := a + b<br>fmt.Println(index, a, b, ret)<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>程序执行到 main() 函数三行代码的时候，会先执行 calc() 函数的 b 参数，即：<code>calc(&quot;10&quot;,a,b)</code>，输出：10 1 2 3，得到值 3，因为<br>defer 定义的函数是延迟函数，故 calc(“1”,1,3) 会被延迟执行；</p><p>程序执行到第五行的时候，同样先执行 calc(“20”,a,b) 输出：20 0 2 2 得到值 2，同样将 calc(“2”,0,2) 延迟执行；</p><p>程序执行到末尾的时候，按照栈先进后出的方式依次执行：calc(“2”,0,2)，calc(“1”,1,3)，则就依次输出：2 0 2 2，1 1 3 4。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map的输出</title>
      <link href="/2023/07/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84%E8%BE%93%E5%87%BA/"/>
      <url>/2023/07/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E7%9A%84%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">0</span>:<span class="hljs-string">&quot;zero&quot;</span>,<span class="hljs-number">1</span>:<span class="hljs-string">&quot;one&quot;</span>&#125;<br><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k,v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0</span> zero<br><span class="hljs-number">1</span> one<br><span class="hljs-comment">// 或者</span><br><span class="hljs-number">1</span> one<br><span class="hljs-number">0</span> zero<br></code></pre></td></tr></table></figure><p>map 的输出是无序的。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量和作用域</title>
      <link href="/2023/07/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2023/07/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%98%E9%87%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面选项正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> a := <span class="hljs-number">1</span>; <span class="hljs-literal">false</span> &#123;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b := <span class="hljs-number">2</span>; <span class="hljs-literal">false</span> &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1 2</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：A。</p><p>推荐一篇文章，讲的很详细 <a href="https://studygolang.com/articles/35587">https://studygolang.com/articles/35587</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片对底层数组的影响</title>
      <link href="/2023/07/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E5%AF%B9%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2023/07/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E5%AF%B9%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := s1[<span class="hljs-number">1</span>:]<br>s2[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span><br>fmt.Println(s1)<br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1 2 4]</span><br><span class="hljs-string">[1 2 4]</span><br></code></pre></td></tr></table></figure><p>我们已经知道，golang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组，这会导致 s2[1] &#x3D; 4 语句影响 s1。</p><p>而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1。</p><p>但是为什么对 s2 赋值后影响的却是 s1 的第三个元素呢？这是因为切片 s2 是从数组的第二个元素开始，s2 索引为 1 的元素对应的是 s1 索引为 2 的元素。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer函数需要先注册</title>
      <link href="/2023/07/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E5%85%88%E6%B3%A8%E5%86%8C/"/>
      <url>/2023/07/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E5%85%88%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br>&#125;()<br><span class="hljs-keyword">if</span> a == <span class="hljs-literal">true</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;3&quot;</span>)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><p>defer 关键字后面的函数或者方法想要执行必须先注册，return 之后的 defer 是不能注册的， 也就不能执行后面的函数或方法。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string的使用</title>
      <link href="/2023/07/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面的代码有几处语法问题，各是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">string</span> = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br>        x = <span class="hljs-string">&quot;default&quot;</span><br>    &#125;<br>    fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：2 处有语法问题。</p><p>golang 的字符串类型是不能赋值 nil 的，也不能跟 nil 比较。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer(4)</title>
      <link href="/2023/07/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-5/"/>
      <url>/2023/07/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-5/</url>
      
        <content type="html"><![CDATA[<p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>person := &amp;Person&#123;<span class="hljs-number">28</span>&#125;<br><br><span class="hljs-comment">// 1.</span><br><span class="hljs-keyword">defer</span> fmt.Println(person.age)<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>fmt.Println(p.age)<br>&#125;(person)<br><br><span class="hljs-comment">// 3.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(person.age)<br>&#125;()<br><br>person = &amp;Person&#123;<span class="hljs-number">29</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>29 28 28。</p><p>这道题之前题目的基础上做了一点点小改动，前一题最后一行代码 <code>person.age = 29</code> 是修改引用对象的成员 age，这题最后一行代码 <code>person = &amp;Person&#123;29&#125;</code> 是修改引用对象本身，来看看有什么区别。</p><p>1.person.age 这一行代码跟之前含义是一样的，此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；</p><p>2.defer 缓存的是结构体 Person{28} 的地址，这个地址指向的结构体没有被改变，最后 defer 语句后面的函数执行的时候取出仍是 28；</p><p>3.闭包引用，person 的值已经被改变，指向结构体 <code>Person&#123;29&#125;</code>，所以输出 29.</p><p>由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 28 28。</p><p>以上解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的defer</title>
      <link href="/2023/07/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%AE%80%E5%8D%95%E7%9A%84defer/"/>
      <url>/2023/07/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%AE%80%E5%8D%95%E7%9A%84defer/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码正确的输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;F&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f()<br>fmt.Println(<span class="hljs-string">&quot;M&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. F M D</li><li>B. D F M</li><li>C. F D M</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>C。</p><p> 被调用函数里的 defer 语句在返回之前就会被执行，所以输出顺序是 F D M。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer(4)</title>
      <link href="/2023/07/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-4/"/>
      <url>/2023/07/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-4/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码段输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>person := &amp;Person&#123;<span class="hljs-number">28</span>&#125;<br><br><span class="hljs-comment">// 1. </span><br><span class="hljs-keyword">defer</span> fmt.Println(person.age)<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>fmt.Println(p.age)<br>&#125;(person)  <br><br><span class="hljs-comment">// 3.</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(person.age)<br>&#125;()<br><br>person.age = <span class="hljs-number">29</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：29 29 28。变量 person 是一个指针变量 。</p><p>1.person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；</p><p>2.defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；</p><p>3.很简单，闭包引用，输出 29；</p><p>又由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 29 28。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解闭包</title>
      <link href="/2023/07/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
      <url>/2023/07/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">app</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>t := <span class="hljs-string">&quot;Hi&quot;</span><br>c := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>t = t + <span class="hljs-string">&quot; &quot;</span> + b<br><span class="hljs-keyword">return</span> t<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := app()<br>b := app()<br>a(<span class="hljs-string">&quot;go&quot;</span>)<br>fmt.Println(b(<span class="hljs-string">&quot;All&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>A：Hi All；B：Hi go All；C：Hi；D：go All</p><p>这道题目答对的人蛮多的：60%。不管你是答对还是答错，如果最后再加一行代码：fmt.Println(a(“All”))，它输出什么？想看看你是不是蒙对了。（提示：你可以输出 t 的地址，看看是什么情况。）</p><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Hi All<br>Hi <span class="hljs-keyword">go</span> All<br></code></pre></td></tr></table></figure><pre><code class="hljs"> 闭包通过一个结构体来实现，它存储一个函数和一个关联的上下文环境。</code></pre><p>​因此每一个闭包都有自己的上下文环境，所以a与b两个闭包的内容是互不干涉的。</p><p>​第一次调用<code>a(&quot;go&quot;)</code>时，将 “go”添加到 a 闭包的 t 变量中，此时 a 闭包的 t 变量为 “Hi go”。</p><p>​接着调用 <code>b(&quot;All&quot;)</code>，将 “All” 添加到 b 闭包的 t 变量中，此时 b 闭包的 t 变量为 “Hi All”。</p><p>​最后我们再次调用 <code>a(&quot;All&quot;)</code>，将 “All” 添加到 a 闭包的 t 变量中，此时 a 闭包的 t 变量为 “Hi go All” 。</p><p>​所以最后的答案为 <code>fmt.Println(b(&quot;All&quot;))</code>输出 <code>&quot;Hi All&quot;</code>，<code>fmt.Println(a(&quot;All&quot;))</code>输出<code>Hi go All</code>。</p><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><h2 id="01-什么是闭包"><a href="#01-什么是闭包" class="headerlink" title="01 什么是闭包"></a>01 什么是闭包</h2><p>维基百科对<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">闭包的定义</a>：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如 C++）。</p></blockquote><p>关于（函数）闭包，有几个关键点：</p><ul><li>函数是一等公民；</li><li>闭包所处环境，可以引用环境里的值；</li></ul><p>问到什么是闭包时，网上一般这么回答的：</p><blockquote><p>在支持函数是一等公民的语言中，一个函数的返回值是另一个函数，被返回的函数可以访问父函数内的变量，当这个被返回的函数在外部执行时，就产生了闭包。</p></blockquote><p>所以，上面题目中，函数 app 的返回值是另一个函数，因此产生了闭包。</p><h2 id="02-Go-中的闭包"><a href="#02-Go-中的闭包" class="headerlink" title="02 Go 中的闭包"></a>02 Go 中的闭包</h2><p>Go 中的函数是一等公民，之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/H3iuhkvQWonZbi7AzmokSA">函数是一等公民，这到底在说什么？</a></p><p>日常开发中，闭包是很常见的。举几个例子。</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>在 net&#x2F;http 包中的函数 ProxyURL，实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ProxyURL returns a proxy function (for use in a Transport)</span><br><span class="hljs-comment">// that always returns the same URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ProxyURL</span><span class="hljs-params">(fixedURL *url.URL)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Request)</span></span> (*url.URL, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Request)</span></span> (*url.URL, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> fixedURL, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的返回值是另一个函数，签名是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Request)</span></span> (*url.URL, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>在返回的函数中，引用了父函数（ProxyURL）的参数 fixedURL，因此这是闭包。</p><h3 id="Web-中间件"><a href="#Web-中间件" class="headerlink" title="Web 中间件"></a>Web 中间件</h3><p>在 Web 开发中，中间件一般都会使用闭包。比如 Echo 框架中的一个中间件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// BasicAuthWithConfig returns an BasicAuth middleware with config.</span><br><span class="hljs-comment">// See `BasicAuth()`.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BasicAuthWithConfig</span><span class="hljs-params">(config BasicAuthConfig)</span></span> echo.MiddlewareFunc &#123;<br><span class="hljs-comment">// Defaults</span><br><span class="hljs-keyword">if</span> config.Validator == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;echo: basic-auth middleware requires a validator function&quot;</span>)<br>&#125;<br>  ...<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(next echo.HandlerFunc)</span></span> echo.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c echo.Context)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">/// 省略很多代码</span><br>      ...<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，echo.MiddlewareFunc 是一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MiddlewareFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(HandlerFunc)</span></span> HandlerFunc<br></code></pre></td></tr></table></figure><p>而 echo.HandlerFunc 也是一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(Context)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>所以，上面的函数嵌套了几层，是典型的闭包。</p><h3 id="这是闭包吗？"><a href="#这是闭包吗？" class="headerlink" title="这是闭包吗？"></a>这是闭包吗？</h3><p>在 Go 中不支持函数嵌套定义，函数内嵌套函数，必须通过匿名函数的形式。匿名函数在 Go 中是很常见的，比如开启一个 goroutine，通常通过匿名函数。</p><p>现在有一个问题，以下代码是闭包吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := <span class="hljs-number">5</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;a =&quot;</span>, a)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果按照上面网上一般的回答，这不是闭包，因为并没有返回函数。但按照维基百科的定义，这个属于闭包。有没有其他证据呢？</p><p>在 Go 语言规范中，关于函数字面值（匿名函数）有这么一句话：</p><blockquote><p>Function literals are <em>closures</em>: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.</p></blockquote><p>也就是说，函数字面值（匿名函数）是闭包，它们可以引用外层函数定义的变量。</p><p>此外，在官方 FAQ 中有这样的说明：</p><p><a href="https://docs.studygolang.com/doc/faq#closures_and_goroutines">What happens with closures running as goroutines?</a></p><p>例子是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br>    values := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Println(v)<br>            done &lt;- <span class="hljs-literal">true</span><br>        &#125;()<br>    &#125;<br><br>    <span class="hljs-comment">// wait for all goroutines to complete before exiting</span><br>    <span class="hljs-keyword">for</span> _ = <span class="hljs-keyword">range</span> values &#123;<br>        &lt;-done<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 Go 中很常见的代码（很容易写错的），FAQ 称开启 goroutine 的那个匿名函数是一个闭包。</p><h2 id="03-汇编看看实现"><a href="#03-汇编看看实现" class="headerlink" title="03 汇编看看实现"></a>03 汇编看看实现</h2><p>回到开始的题目，我们通过汇编看看，Go 闭包的实现，是不是按照维基百科说的，「闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）」。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go tool compile -S main.go<br></code></pre></td></tr></table></figure><p>看关键代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)TEXT<span class="hljs-string">&quot;&quot;</span>.app(SB), ABIInternal, $<span class="hljs-number">24</span><span class="hljs-number">-8</span><br><span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)MOVQ(TLS), CX<br><span class="hljs-number">0x0009</span> <span class="hljs-number">00009</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)CMPQSP, <span class="hljs-number">16</span>(CX)<br><span class="hljs-number">0x000d</span> <span class="hljs-number">00013</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)PCDATA$<span class="hljs-number">0</span>, $<span class="hljs-number">-2</span><br><span class="hljs-number">0x000d</span> <span class="hljs-number">00013</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)JLS<span class="hljs-number">96</span><br><span class="hljs-number">0x000f</span> <span class="hljs-number">00015</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)PCDATA$<span class="hljs-number">0</span>, $<span class="hljs-number">-1</span><br><span class="hljs-number">0x000f</span> <span class="hljs-number">00015</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)SUBQ$<span class="hljs-number">24</span>, SP<br><span class="hljs-number">0x0013</span> <span class="hljs-number">00019</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)MOVQBP, <span class="hljs-number">16</span>(SP)<br><span class="hljs-number">0x0018</span> <span class="hljs-number">00024</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)LEAQ<span class="hljs-number">16</span>(SP), BP<br><span class="hljs-number">0x001d</span> <span class="hljs-number">00029</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)FUNCDATA$<span class="hljs-number">0</span>, gclocals·<span class="hljs-number">2</span>a5305abe05176240e61b8620e19a815(SB)<br><span class="hljs-number">0x001d</span> <span class="hljs-number">00029</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span>)FUNCDATA$<span class="hljs-number">1</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)<br><span class="hljs-number">0x001d</span> <span class="hljs-number">00029</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)LEAQ<span class="hljs-keyword">type</span>.noalg.<span class="hljs-keyword">struct</span> &#123; F <span class="hljs-type">uintptr</span>; <span class="hljs-string">&quot;&quot;</span>.t <span class="hljs-type">string</span> &#125;(SB), AX<br><span class="hljs-number">0x0024</span> <span class="hljs-number">00036</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQAX, (SP)<br><span class="hljs-number">0x0028</span> <span class="hljs-number">00040</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)PCDATA$<span class="hljs-number">1</span>, $<span class="hljs-number">0</span><br><span class="hljs-number">0x0028</span> <span class="hljs-number">00040</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)CALLruntime.newobject(SB)<br><span class="hljs-number">0x002d</span> <span class="hljs-number">00045</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQ<span class="hljs-number">8</span>(SP), AX<br><span class="hljs-number">0x0032</span> <span class="hljs-number">00050</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)LEAQ<span class="hljs-string">&quot;&quot;</span>.app.func1(SB), CX<br><span class="hljs-number">0x0039</span> <span class="hljs-number">00057</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQCX, (AX)<br><span class="hljs-number">0x003c</span> <span class="hljs-number">00060</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQ$<span class="hljs-number">2</span>, <span class="hljs-number">16</span>(AX)<br><span class="hljs-number">0x0044</span> <span class="hljs-number">00068</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)LEAQ<span class="hljs-keyword">go</span>.<span class="hljs-type">string</span>.<span class="hljs-string">&quot;Hi&quot;</span>(SB), CX<br><span class="hljs-number">0x004b</span> <span class="hljs-number">00075</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">7</span>)MOVQCX, <span class="hljs-number">8</span>(AX)<br><span class="hljs-number">0x004f</span> <span class="hljs-number">00079</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)MOVQAX, <span class="hljs-string">&quot;&quot;</span>.~r0+<span class="hljs-number">32</span>(SP)<br><span class="hljs-number">0x0054</span> <span class="hljs-number">00084</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)MOVQ<span class="hljs-number">16</span>(SP), BP<br><span class="hljs-number">0x0059</span> <span class="hljs-number">00089</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)ADDQ$<span class="hljs-number">24</span>, SP<br><span class="hljs-number">0x005d</span> <span class="hljs-number">00093</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)RET<br><span class="hljs-number">0x005e</span> <span class="hljs-number">00094</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)NOP<br></code></pre></td></tr></table></figure><p>其中 <code>LEAQ type.noalg.struct &#123; F uintptr; &quot;&quot;.t string &#125;(SB), AX</code> 这行表明 Go 对闭包的实现和维基百科说的类似。</p><p>现在看看下面这种是不是这么实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := <span class="hljs-number">5</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;a =&quot;</span>, a)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>看看汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go tool compile -S test.go<br><span class="hljs-string">&quot;&quot;</span>.main.func1 STEXT size=215 args=0x8 locals=0x50 funcid=0x0<br>  0x0000 00000 (test.go:9)TEXT<span class="hljs-string">&quot;&quot;</span>.main.func1(SB), ABIInternal, <span class="hljs-variable">$80</span>-8<br>  0x0000 00000 (test.go:9)MOVQ(TLS), CX<br>  0x0009 00009 (test.go:9)CMPQSP, 16(CX)<br>  0x000d 00013 (test.go:9)PCDATA<span class="hljs-variable">$0</span>, $-2<br>  0x000d 00013 (test.go:9)JLS205<br>  0x0013 00019 (test.go:9)PCDATA<span class="hljs-variable">$0</span>, $-1<br>  0x0013 00019 (test.go:9)SUBQ<span class="hljs-variable">$80</span>, SP<br>  0x0017 00023 (test.go:9)MOVQBP, 72(SP)<br>  0x001c 00028 (test.go:9)LEAQ72(SP), BP<br>  0x0021 00033 (test.go:9)FUNCDATA<span class="hljs-variable">$0</span>, gclocals·69c1753bd5f81501d95132d08af04464(SB)<br>  0x0021 00033 (test.go:9)FUNCDATA<span class="hljs-variable">$1</span>, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)<br>  0x0021 00033 (test.go:10)MOVQ<span class="hljs-string">&quot;&quot;</span>.a+88(SP), AX<br>  0x0026 00038 (test.go:10)MOVQAX, (SP)<br>  0x002a 00042 (test.go:10)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$0</span><br>  0x002a 00042 (test.go:10)CALLruntime.convT64(SB)<br>  0x002f 00047 (test.go:10)MOVQ8(SP), AX<br>  0x0034 00052 (test.go:10)MOVQAX, <span class="hljs-string">&quot;&quot;</span>..autotmp_21+64(SP)<br>  0x0039 00057 (test.go:10)LEAQ<span class="hljs-built_in">type</span>.[2]interface &#123;&#125;(SB), CX<br>  0x0040 00064 (test.go:10)MOVQCX, (SP)<br>  0x0044 00068 (test.go:10)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$1</span><br>  0x0044 00068 (test.go:10)CALLruntime.newobject(SB)<br>  0x0049 00073 (test.go:10)MOVQ8(SP), AX<br>  0x004e 00078 (test.go:10)LEAQtype.string(SB), CX<br>  0x0055 00085 (test.go:10)MOVQCX, (AX)<br>  0x0058 00088 (test.go:10)LEAQ<span class="hljs-string">&quot;&quot;</span>..stmp_1(SB), CX<br>  0x005f 00095 (test.go:10)MOVQCX, 8(AX)<br>  0x0063 00099 (test.go:10)LEAQtype.int(SB), CX<br>  0x006a 00106 (test.go:10)MOVQCX, 16(AX)<br>  0x006e 00110 (test.go:10)PCDATA<span class="hljs-variable">$0</span>, $-2<br>  0x006e 00110 (test.go:10)CMPLruntime.writeBarrier(SB), <span class="hljs-variable">$0</span><br>  0x0075 00117 (test.go:10)JNE189<br>  0x0077 00119 (test.go:10)MOVQ<span class="hljs-string">&quot;&quot;</span>..autotmp_21+64(SP), CX<br>  0x007c 00124 (test.go:10)MOVQCX, 24(AX)<br>  0x0080 00128 (test.go:10)PCDATA<span class="hljs-variable">$0</span>, $-1<br>  0x0080 00128 (test.go:10)PCDATA<span class="hljs-variable">$1</span>, $-1<br></code></pre></td></tr></table></figure><p>发现并没有这样的结构体，可见 Go 对这种情况做了特殊处理，因为它不是重复使用的匿名函数。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>通过以上的讲解，对闭包应该有了更清晰的认识。如果面试中再被问到闭包，你可以这么回答：</p><blockquote><p>对闭包来说，函数在该语言中得是一等公民。一般来说，一个函数返回另外一个函数，这个被返回的函数可以引用外层函数的局部变量，这形成了一个闭包。通常，闭包通过一个结构体来实现，它存储一个函数和一个关联的上下文环境。但 Go 语言中，匿名函数就是一个闭包，它可以直接引用外部函数的局部变量，因为 Go 规范和 FAQ 都这么说了。</p></blockquote><p>面试官会不会被你惊到：原来如此，后一种说法我之前没有注意过。</p><blockquote><p>4 月 14 日更新：</p><p>来自<a href="https://mp.weixin.qq.com/s/gfyW0pBIHsf2oYluQNbP8A">微信公众号</a>的读者 **gopher **留言：</p><p>noalg 代表不会生成 equal 和 hash 函数，因为闭包的 struct 是匿名的，不存在比较或者作为 key 的场景。<br>F uintptr 更准确的说应该是 .F uintptr，编译器生成的符号大部分都是.开头的。<br>“”.t string 表示捕获了一个 string 类型的变量 t，而且是 by value 而不是 by reference，因为”We use value capturing for values &lt;&#x3D; 128 bytes that are never reassigned after capturing (effectively constant).”。<br>通过 (func)(*struct) 的类型转换，即可通过 .F 找到对应的函数。<br>题外话：closure 通过 struct 实现只是为了 GC 更友好，另外匿名 struct 是为了不同的 package 共用 struct 的可能性。</p></blockquote><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/go-closure/">https://polarisxu.studygolang.com/posts/go/action/go-closure/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer（3）</title>
      <link href="/2023/07/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%EF%BC%883%EF%BC%89/"/>
      <url>/2023/07/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>f1()、f2()、f3() 函数分别返回什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r++<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br>t := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>t = t + <span class="hljs-number">5</span><br>&#125;()<br><span class="hljs-keyword">return</span> t<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">int</span>)</span></span> &#123;<br>r = r + <span class="hljs-number">5</span><br>&#125;(r)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>1 5 1。</p><p>​对于<code>f1()</code>和<code>f2()</code>昨天就解析过了，这里不作过多赘述。</p><p>​<code>f3()</code>中<code>defer</code>语句中注册的是一个匿名函数，在这个匿名函数中，参数 r 是按值传递的，也就是传递的是 r 的副本。因此，这个匿名函数中的 r 和外层函数 f3() 中的 r 实际上是两个不同的变量。在匿名函数中，r 被加上了 5，但这个修改只是对匿名函数中的 r 副本进行的，不会影响外层函数 f3() 中的 r。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型断言2</title>
      <link href="/2023/07/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%802/"/>
      <url>/2023/07/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%802/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>ShowA() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">interface</span> &#123;<br>ShowB() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Work <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowA() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowB() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a A = Work&#123;<span class="hljs-number">3</span>&#125;<br>s := a.(Work)<br>fmt.Println(s.ShowA())<br>fmt.Println(s.ShowB())<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 13 23</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：A。</p><p>知识点：类型断言。很简单，不多解释。 </p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer对返回值的影响</title>
      <link href="/2023/07/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%AF%B9%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2023/07/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer%E5%AF%B9%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increaseA</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i++<br>&#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increaseB</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r++<br>&#125;()<br><span class="hljs-keyword">return</span> r<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(increaseA())<br>fmt.Println(increaseB())<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1 1</li><li>B. 0 1</li><li>C. 1 0</li><li>D. 0 0</li></ul><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>B。</p><p>​在Go语言的函数中的<code>return</code>语句在底层并不是原子操作，它分为 <strong>返回值赋值</strong> 和 <strong>RET指令</strong>两部分，而 <strong>defer</strong>的执行时机就在返回值赋值操作后，RET指令执行前。</p><p>​对于 <code>increaseA()</code>来说，先进行返回值赋值，即 返回i的值赋值给一个临时变量，值为0（待执行RET指令后，再将该变量返回到调用该函数的地方）；再调用defer语句，将 i++，此时并不会影响到返回值，故输出为0</p><p>​对于<code>increaseB()</code>来说，不同的是，它的返回值参数是具名返回值，这样系统就不会为它创建一个新变量，而是直接将返回值赋值该具名返回值上，然后调用defer语句后的函数，将返回值 r++，故此时的返回值变为1.</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短变量声明</title>
      <link href="/2023/07/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%88%A4%E6%96%AD/"/>
      <url>/2023/07/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码中，x 已声明，y 没有声明，判断每条语句的对错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span> x, _ := f()<br><span class="hljs-number">2.</span> x, _ = f()<br><span class="hljs-number">3.</span> x, y := f()<br><span class="hljs-number">4.</span> x, y = f()<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>错、对、对、错。</p><ol><li>x 已经声明了，且后面是 <code>_</code> 空标识符，故不能再使用 <code>:=</code></li><li>x 已经声明，故可以使用 <code>=</code>重新赋值</li><li>虽然 x 已经声明，但 y 没有声明，只要有一个未声明的变量，就可以使用 <code>:=</code></li><li>y 未声明，不能使用赋值符号 <code>=</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go中不支持隐式转换</title>
      <link href="/2023/07/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/07/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：<span id="more"></span></h1><p>有下面 3 行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 32 位机器</span><br><span class="hljs-number">1</span>）<span class="hljs-keyword">var</span> x <span class="hljs-type">int32</span> = <span class="hljs-number">32.0</span><br><span class="hljs-number">2</span>）<span class="hljs-keyword">var</span> y <span class="hljs-type">int</span> = x<br><span class="hljs-number">3</span>）<span class="hljs-keyword">var</span> z <span class="hljs-type">rune</span> = x<br></code></pre></td></tr></table></figure><p>它们是否能编译通过？为什么？</p><p>如果面试时问这道题，你需要想想面试官想考察你什么。</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><h2 id="01-数字字面量"><a href="#01-数字字面量" class="headerlink" title="01 数字字面量"></a>01 数字字面量</h2><p>在 Go 语言中，字面量是无类型（untyped）的。无类型是什么意思？无类型意味着可以赋值给类似类型的变量或常量。用上面例子，32.0 是无类型的浮点数字面量，因此它可以赋值给任意数字相关类型变量（或常量）。以下都是合法的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int64</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">float32</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> d <span class="hljs-type">complex64</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> e <span class="hljs-type">byte</span> = <span class="hljs-number">32.0</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">rune</span> = <span class="hljs-number">32.0</span><br></code></pre></td></tr></table></figure><p>所以上题中 1）是正确的。</p><h2 id="02-不同类型"><a href="#02-不同类型" class="headerlink" title="02 不同类型"></a>02 不同类型</h2><p>在目前 Go 1.16 版本中（实际上只有很早期的版本不是），int 类型在 32 位机器占 4 字节，64 位机器占 8 字节。所以，在 32 位机器上，int32 和 int 的内存占用和内存布局是完全一样的。但 Go 语言不会做隐式类型转换，int 和 int32 是不同的类型，因此上题中 2）编译不通过。</p><h2 id="03-类型别名"><a href="#03-类型别名" class="headerlink" title="03 类型别名"></a>03 类型别名</h2><p>熟悉 C 语言的小伙伴，看到 Go 中以下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myint <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>会以为 myint 和 int 是一样的，认为 myint 是 int 的别名。而实际上，myint 是和 int 完全不一样的类型，只不过 myint 的底层类型是 int，它们直接可以强制类型转换，却不会隐式转换。关于这点无需多讲，重点要讲的是类型别名。</p><p>从 Go1.9 开始引入了类型别名，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">AliasDecl = identifier, <span class="hljs-string">&quot;=&quot;</span>, Type .<br></code></pre></td></tr></table></figure><p>具体例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> intalias = <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>myint 是新类型，和 int 不一样；而 intalias 却和 int 一样，它只是 int 的别名：所有使用 intalias 的地方都可以使用 int。</p><p>那为什么 Go 中会引入类型别名呢？Russ Cox 的论文 <a href="https://talks.golang.org/2016/refactor.article">Codebase Refactoring (with help from Go)</a> 介绍了它的背景。总结一下类型别名的用途，主要有两点：</p><ul><li>在大规模重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码会使用新包中的类型，有些代码使用旧包中的类型， 最典型的是 <code>context</code> 包。最开始，context 包名是 <code>golang.org/x/net/context</code>，1.7 开始，引入标准库，这样一来，存在两份。Go 1.9 开始采用别名重构了它；</li><li>允许一个庞大的包分解成内部的几个小包，但是小包中的类型需要集中暴漏在上层的大包中；</li></ul><p>在 Go 中，你可以为任意类型定义别名，比如数组、结构体、指针、函数、接口、Slice、Map、Channel 等，包括为自定义类型定义别名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> F = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">type</span> I = <span class="hljs-keyword">interface</span>&#123;&#125;<br>...<br></code></pre></td></tr></table></figure><p>此外，还可以为其他包中的类型定义别名，比如为标准库类型定义别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyReader = bufio.Reader<br></code></pre></td></tr></table></figure><p>关于类型别名的一些注意事项：</p><ul><li>别名和原类型是一样的，因此 switch-type 结构中，不能存在两个 case，一个是原类型，一个是别名；</li><li>类型别名不能循环定义，比如以下是不允许的：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T = <span class="hljs-keyword">struct</span> &#123;<br>next *T1<br>&#125;<br><br><span class="hljs-keyword">type</span> T1 = T<br></code></pre></td></tr></table></figure><ul><li>因为别名和原类型是一样的，因此共享同样的方法集，不论这个方法是定义在原类型还是别名上；</li><li>别名的导出性可以和原类型不一样；</li><li>不能为别的包的类型通过定义别名来增加方法。以下行为是不允许的：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyReader = bufio.Reader<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(MyReader)</span></span> AliasMethod() &#123;<br>fmt.Println(<span class="hljs-string">&quot;This is alias method&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译报错：<code>cannot define new methods on non-local type bufio.Reader</code>。</p><p>回到开头题目的 3），rune 是什么类型？定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">rune</span> = <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><p>很显然，rune 是 int32 的别名，因此题目中 3）也能编译通过。</p><p>除了 rune，Go 内置类型中，还有 byte 是 uint8 的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">byte</span> = <span class="hljs-type">uint8</span><br></code></pre></td></tr></table></figure><p>需要说明的是，在 Go1.9 之前，rune 和 byte 的别名性质就存在，是编译器负责处理的。只是 Go1.9 之后，别名可以用于其他类型了。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>一道看似简单的题目，如果你能够分析透彻，把语言的变化都说出来，我相信面试官会给你加分。</p><p>今天的题目，你做对了吗？</p><p>题解来自：<a href="https://polarisxu.studygolang.com/posts/go/action/type-and-alias/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/type-and-alias/。</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一元运算符</title>
      <link href="/2023/07/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2023/07/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>Go101 发布的一条 twitter。以下代码是否能正常运行，结果是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    v := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>    *v = <span class="hljs-number">2</span><br>    <span class="hljs-built_in">println</span>(<span class="hljs-number">5</span>/+-*v)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>大家肯定很懵。我看到时也蒙圈了。</p><p>试着运行了一下，竟然输出了 -2 。。。我忍不住“卧槽”。。。</p><p>我不得不说，Go101 扣的真细节。</p><p>于是我尝试着找一些线索，看看为什么可以这样写。</p><h2 id="01-直接看汇编"><a href="#01-直接看汇编" class="headerlink" title="01 直接看汇编"></a>01 直接看汇编</h2><p>遇到一些不解的地方，有时候借助汇编也许能得到答案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -S main.go<br></code></pre></td></tr></table></figure><p>看关键的几行汇编：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">0x001d 00029 (main.go:6)PCDATA<span class="hljs-variable">$1</span>, <span class="hljs-variable">$0</span><br>0x001d 00029 (main.go:6)NOP<br>0x0020 00032 (main.go:6)CALLruntime.printlock(SB)<br>0x0025 00037 (main.go:6)MOVQ$-2, (SP)<br>0x002d 00045 (main.go:6)CALLruntime.printint(SB)<br>0x0032 00050 (main.go:6)CALLruntime.printnl(SB)<br>0x0037 00055 (main.go:6)CALLruntime.printunlock(SB)<br></code></pre></td></tr></table></figure><p>从 <code>MOVQ $-2, (SP)</code> 看出，直接编译器直接计算出 -2 了。。。（可以进一步加上 -N 来禁止优化，但没有没有看出额外特别的）</p><h2 id="02-看规范"><a href="#02-看规范" class="headerlink" title="02 看规范"></a>02 看规范</h2><p>之前的一些题解，我总是在 Go 语言规范中找到解释，因此这次也不例外。</p><p>在运算符章节，Go 中有如下几个一元运算符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">unary_op = <span class="hljs-string">&quot;+&quot;</span> | <span class="hljs-string">&quot;-&quot;</span> | <span class="hljs-string">&quot;!&quot;</span> | <span class="hljs-string">&quot;^&quot;</span> | <span class="hljs-string">&quot;*&quot;</span> | <span class="hljs-string">&quot;&amp;&quot;</span> | <span class="hljs-string">&quot;&lt;-&quot;</span> .<br></code></pre></td></tr></table></figure><p>其中，+、- 和 * 同时也是算术运算符中的加、减和乘。</p><p>接着，在运算符优先级处提到：一元运算符有最高的优先级。</p><p>我们分析题目中的表达式：<code>5/+-*v</code>。5 后面 &#x2F;，很显然，这是除法。而 + 前面没有操作数，因此是一个一元运算符；同理 - 和 <code>*</code> 也是一元运算符。而一元运算符有最高的优先级，因此这个表达式优先计算 <code>+-*v</code> 的值。那这个东西为什么又合法呢？</p><p>在规范中有这么一句话：</p><blockquote><p>对于整数操作数，一元运算符 <code>+</code> , <code>-</code> 和 <code>^</code> 有如下定义：（省略了 ^ 的解释）</p><p>+x 　　　　 是 0 + x<br>-x 取其负值 是 0 - x</p></blockquote><p>也就是说，<code>+-*v</code> 相当于：<code>0+(0-(*v))</code>。（为什么一元运算符左结合，因为一元，必须得有运算数，得跟着运算数走）</p><p>这样一来，结果变成了求 5&#x2F;-2 的值，结果自然是 -2（别跟我说应该是 2.5）。</p><p>（规范参考 Bekcpear 翻译版：<a href="https://hao.studygolang.com/golang_spec.html%EF%BC%89">https://hao.studygolang.com/golang_spec.html）</a></p><h2 id="03-其他语言的行为"><a href="#03-其他语言的行为" class="headerlink" title="03 其他语言的行为"></a>03 其他语言的行为</h2><p>看到这，我不禁想看看其他语言怎么实现的。（没有指针的语言，就只能包含 &#x2F;+- 了）</p><p><strong>C 语言</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> *p = &amp;i;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-number">5</span>/+-*p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果也是 -2。</p><p><strong>Java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span> &#123;<br>       System.out.println(<span class="hljs-number">5</span>/+-<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果也是 -2。</p><p><strong>PHP</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>/+-<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>结果是 -2.5。（弱类型语言嘛）</p><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">5</span>/+-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>结果是 -3。（Python 对 &#x2F; 的处理和别的语言还是不太一样）</p><p><strong>JS</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">5</span>/+-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>结果和 PHP 一样，-2.5。</p><p>最后看看 <strong>Rust</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-number">5</span>/+-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器告诉我：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: expected expression, found `+`<br></code></pre></td></tr></table></figure><p>Rust 果然不一样！我们不一样、不一样。。。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>奇淫技巧，如果能顺便学一点知识，那是极好的。当然，最关键的是希望有探索精神，找到其中的原因，举一反三，也许这点比较重要。</p><p>题解来自：<a href="https://polarisxu.studygolang.com/posts/go/action/operator/">https://polarisxu.studygolang.com/posts/go/action/operator/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口的动态类型、动态值、静态类型</title>
      <link href="/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E5%80%BC%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8A%A8%E6%80%81%E5%80%BC%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>ShowA() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">interface</span> &#123;<br>ShowB() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Work <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowA() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowB() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := Work&#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> a A = c<br><span class="hljs-keyword">var</span> b B = c<br>fmt.Println(a.ShowB())<br>fmt.Println(b.ShowA())<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 23 13</li><li>B. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>知识点：接口的静态类型。a、b 具有相同的动态类型和动态值，分别是结构体 work 和 {3}；a 的静态类型是 A，b 的静态类型是 B，接口 A 不包括方法 ShowB()，接口 B 也不包括方法 ShowA()，编译报错。</p><p>看下编译的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">a.ShowB undefined (<span class="hljs-built_in">type</span> A has no field or method ShowB)<br>b.ShowA undefined (<span class="hljs-built_in">type</span> B has no field or method ShowA)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>silce/array</title>
      <link href="/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/silce-array/"/>
      <url>/2023/07/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/silce-array/</url>
      
        <content type="html"><![CDATA[<h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：<span id="more"></span></h1><p><strong>1、以下代码输出什么？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">1</span>&#125;<br>    fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：编译错误；B：[2 1]；C：[0 0 1]；D：[0 1]</p><p><strong>2、以下代码输出什么？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">1</span>: <span class="hljs-number">77</span>, <span class="hljs-number">88</span>&#125;<br><span class="hljs-built_in">println</span>(<span class="hljs-built_in">len</span>(x), x[<span class="hljs-number">2</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>A：5 66；B：5 88；C：7 88；D：以上都不对</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>第 1 题是 Go 语言爱好者周刊<a href="https://mp.weixin.qq.com/s/4HI78Yd1ENVFCWHCESlPBg">第 87</a>的题目。</p><p>正确答案是：C，正确率 52%。这道题相对简单，但依然有近一半的人答错了。</p><p>而第 2 题是<a href="https://mp.weixin.qq.com/s/pgIoGnOd0CMPHFc4HD0xFA">周刊第 88 期</a>的题目，正确答案也是 C，只有 25%。</p><p>这涉及到 array&#x2F;slice 的一些相关知识。</p><h2 id="01-数组和切片"><a href="#01-数组和切片" class="headerlink" title="01 数组和切片"></a>01 数组和切片</h2><p>关于两者，Go 语言规范中都有明确定义。</p><p><a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-array-types-rt-rp-rp-ruby">数组</a>是这么说明的：</p><blockquote><p>数组是单一类型元素的有序序列，该单一类型称为元素类型。元素的个数被称为数组长度，并且不能为负值。长度是数组类型的一部分；它必须为一个可以被 int 类型的值所代表的非负常量。</p></blockquote><p>这里一个关键点就是，长度是数组的一部分，因此 [3]int 和 [4]int 是不同类型。</p><p>再看看<a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-slice-types-rt-rp-rp-ruby">切片</a>：</p><blockquote><p>切片是针对一个底层数组的连续段的描述符，它提供了对该数组内有序序列元素的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量被称为切片长度，且不能为负。未初始化的切片的值为 <code>nil</code> 。</p></blockquote><p>从 EBNF 的表示可以看出区别：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ArrayType</span>   = <span class="hljs-string">&quot;[&quot;</span>, ArrayLength, <span class="hljs-string">&quot;]&quot;</span>, ElementType .<br><span class="hljs-attribute">SliceType</span> = <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>, ElementType .<br></code></pre></td></tr></table></figure><p>也就是说，长度不是切片类型的一部分，切片长度可变。</p><h2 id="02-常见字面量初始化"><a href="#02-常见字面量初始化" class="headerlink" title="02 常见字面量初始化"></a>02 常见字面量初始化</h2><p>我不打算讲解数组&#x2F;切片初始化的各种情况，主要介绍常见的字面量初始化，以及和上面题目相关的部分。</p><p>通常我们会这么初始化一个数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intSet = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>[]</code> 中的 6，它表示数组的长度。因为初始化时，我们只给定了 3 个数，因此后 3 个元素是 0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[2 4 6 0 0 0]<br></code></pre></td></tr></table></figure><p>注意和这种写法的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intSet = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><p>对于切片来说，一般这样初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intSlice = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment">// 或基于 intSet 进行初始化</span><br><span class="hljs-keyword">var</span> intSlice = intSet[:]<br></code></pre></td></tr></table></figure><p>当然，针对 Slice，更多时候是通过 make 创建，然后其他方式初始化，这里不展开了。</p><h2 id="03-特殊的初始化"><a href="#03-特殊的初始化" class="headerlink" title="03 特殊的初始化"></a>03 特殊的初始化</h2><p>在 Go语言规范「<a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-composite-literals-rt-rp-rp-ruby">Composite literals</a>」部分对数组和切片的字面值初始化进行了规定，因为数组和切片类似，我们这里只说切片的情况。</p><p>先看组合字面值的 EBNF 表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">CompositeLit  = LiteralType, LiteralValue .<br>LiteralType   = StructType | ArrayType | <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>, ElementType |<br>                SliceType | MapType | TypeName .<br>LiteralValue  = <span class="hljs-string">&quot;&#123;&quot;</span>, [ ElementList, [ <span class="hljs-string">&quot;,&quot;</span> ] ], <span class="hljs-string">&quot;&#125;&quot;</span> .<br>ElementList   = KeyedElement, &#123; <span class="hljs-string">&quot;,&quot;</span>, KeyedElement &#125; .<br>KeyedElement  = [ Key, <span class="hljs-string">&quot;:&quot;</span> ], Element .<br>Key           = FieldName | Expression | LiteralValue .<br>FieldName     = identifier .<br>Element       = Expression | LiteralValue .<br></code></pre></td></tr></table></figure><p>从上到下看，简单解释一下：</p><ul><li>第 1 行，表示组合字面值由 LiteralType 和 LiteralValue 构成，其中 LiteralType 表示组合字面值的类型，LiteralValue 表示值；</li><li>第 2 行，解释 LiteralType，它可以是 <code>=</code> 后面的类型。允许的类型有：结构体、数组、切片、map 等，其中还可以是类似 <code>[…]int</code> 的形式；</li><li>第 4 行，解释 LiteralValue，它由一对 <code>&#123;&#125;</code> 包裹，其中包含可选的 ElementList；</li><li>第 5 行，解释 ElementList，它由若干 KeyedElement 组成；</li><li>第 6 行，解释 KeyedElement，这是<strong>该篇题目的重点之处</strong>。在 EBNF 中，<code>[]</code> 表示这部分是可选的，因此表示具体元素时，一般 Key 可以省略（map 不能省略），这就是通常数组和切片的初始化语法；</li></ul><p>在这个之后，规范上给出了针对数组和切片字面值的应用规则：</p><ol><li>数组中的每个元素有一个关联的标记其位置的整数索引。</li><li><strong>带键的元素使用该键作为其索引</strong>。这个键必须是可被类型 int 所表示的一个非负常量；而且如果其被赋予了类型的话则必须是整数类型。</li><li><strong>不带键的元素使用之前元素的索引加一</strong>。如果第一个元素没有键，则其索引为零。</li></ol><p>根据以上 3 点，我们很容易知道，在 <code>a := []int&#123;2: 1&#125;</code> 中，我们指定了第 3 个元素（注意索引是从 0 开始的）的值为 1，根据数组&#x2F;切片的特性，自然存在第 1、2 个元素，没有指定值时，Go 会为其设置默认值。因此这个写法和下面的写法等价：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>对于第 88 期的题目：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">1</span>: <span class="hljs-number">77</span>, <span class="hljs-number">88</span>&#125;<br></code></pre></td></tr></table></figure><p>指定了第 5 个元素（对应索引是 4），值是 44。根据上面规则的第三点，55、66 都没有指定索引，因此它们的索引是前一个元素的索引加一，即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">5</span>: <span class="hljs-number">55</span>, <span class="hljs-number">6</span>: <span class="hljs-number">66</span><br></code></pre></td></tr></table></figure><p>下一个元素是 <code>1: 77</code>，为其指定了索引 1，因此它的下一元素 88 的索引就是 2 了，因此这个定义相当于如下的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">5</span>: <span class="hljs-number">55</span>, <span class="hljs-number">6</span>: <span class="hljs-number">66</span>, <span class="hljs-number">1</span>: <span class="hljs-number">77</span>, <span class="hljs-number">2</span>: <span class="hljs-number">88</span>&#125;<br></code></pre></td></tr></table></figure><p>同样，因为数组&#x2F;切片的特性，缺少的元素（索引 0 和 3）值是 0，而整个切片的长度是最大索引加一，即 7。</p><h2 id="04-总结"><a href="#04-总结" class="headerlink" title="04 总结"></a>04 总结</h2><p>别觉得这道题目恶心，实际中这么写代码可能也确实会被打（当然，第 87 题的写法还是很有可能的）。这里主要是希望大家多掌握一些规范、细节，我想不少人不清楚，原来数组（切片）也可以指定索引进行初始化。语言语法毕竟必须严谨，而这些都在 Go 语言规范里。</p><p>延伸思考：第 88 期的题目，如果改为这样结果又如何？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">3</span>: <span class="hljs-number">77</span>, <span class="hljs-number">88</span>&#125;<br></code></pre></td></tr></table></figure><p>欢迎大胆的留言说出你的答案！</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-88/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-88/。</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map使用</title>
      <link href="/2023/07/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面代码中 A B 两处应该怎么修改才能顺利编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>        <span class="hljs-comment">//A</span><br>m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> v := m[<span class="hljs-string">&quot;b&quot;</span>]; v != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">//B</span><br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>正确的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-comment">// A</span><br>m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> v, ok := m[<span class="hljs-string">&quot;b&quot;</span>]; !ok &#123; <span class="hljs-comment">//B</span><br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>A 处，只声明了map m ,并没有分配内存空间，不能直接赋值，需要使用 make()，都提倡使用 make() 或者字面量的方式直接初始化 map。</p><p>B 处，<code>v,k := m[&quot;b&quot;]</code> 当 key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，k 返回 false。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片的长度和容量</title>
      <link href="/2023/07/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F/"/>
      <url>/2023/07/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>切片 a、b、c 的长度和容量分别是多少？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>a := s[:<span class="hljs-number">0</span>]<br>b := s[:<span class="hljs-number">2</span>]<br>c := s[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-built_in">cap</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>a、b、c 的长度和容量分别是 0 3、2 3、1 2。</p><p>知识点：数组或切片的截取操作。截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，截取得到的<strong>切片长度和容量计算方法是 j-i、l-i</strong>。操作符 [i:j:k]，k 主要是用来限制切片的容量，但是不能大于数组的长度 l，截取得到的<strong>切片长度和容量计算方法是 j-i、k-i</strong>。</p><p>a切片截取<code>s[:]</code>相当于<code>s[0:0]</code>，故长度为0，容量为<code>l - i = 3 - 0 = 3；</code></p><p>b切片截取<code>s[:2]</code>相当于<code>s[0:2]</code>,故长度为<code>j - i = 2 - 0 = 2</code>，容量为<code>l - i = 3 - 0 = 3；</code></p><p>c切片截取<code>s[1:2:cap(s)]</code>相当于<code>s[1:2:3]</code>,故长度为<code>j - i = 2 - 1 = 1</code>,容量为<code>l - i = 3 - 1 = 2</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/07/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/07/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">interface</span> &#123;<br>ShowA() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">interface</span> &#123;<br>ShowB() <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Work <span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowA() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w Work)</span></span> ShowB() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> w.i + <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := Work&#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> a A = c<br><span class="hljs-keyword">var</span> b B = c<br>fmt.Println(a.ShowA())<br>fmt.Println(b.ShowB())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：13 23。</p><p>知识点：接口。一种类型实现多个接口，结构体 Work 分别实现了接口 A、B，所以接口变量 a、b 调用各自的方法 ShowA() 和 ShowB()，输出 13、23。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>int类型强制转换为string类型</title>
      <link href="/2023/07/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAstring%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/07/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/int%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAstring%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := <span class="hljs-number">65</span><br>    fmt.Println(<span class="hljs-type">string</span>(i))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. A</li><li>B. 65</li><li>C. compilation error</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><p>UTF-8 编码中，十进制数字 65 对应的符号是 A。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nil切片和空切片</title>
      <link href="/2023/06/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87/"/>
      <url>/2023/06/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码下划线处可以填入哪个选项？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s1 []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> s2 = []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">if</span> __ == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;yes nil&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;no nil&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-string">``</span><br><br>- A. s1<br>- B. s2<br>- C. s1、s2 都可以<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：C。</p><p>知识点：nil 切片和空切片。</p><ol><li>空切片：空切片是一个长度为 0 的切片，它是一个有效的切片对象。可以通过使用字面量或使用 <code>make</code> 函数创建一个空切片。例如，<code>[]int&#123;&#125;</code> 或 <code>make([]int, 0)</code> 都可以创建一个空切片。空切片可以进行追加元素、访问索引等操作，只是没有任何元素。</li><li>nil 切片：nil 切片是一个未分配底层数组的切片。它的零值就是 nil。nil 切片不能进行任何操作，包括追加元素、访问索引等，因为它没有底层数组可供操作。</li><li>nil 切片和 nil 相等，一般用来表示一个不存在的切片；空切片和 nil 不相等，表示一个空的集合。</li></ol><p>​都可以填入，但当填入的是<code>s1</code>时，表示为nil切片与<code>nil</code>相等，故输出<code>yes nil</code></p><p>​当填入<code>s2</code>时，表示为空切片，空切片与nil不相等，故输出<code>no nil</code></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goroutine后语句的调用</title>
      <link href="/2023/06/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E5%90%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%B0%83%E7%94%A8/"/>
      <url>/2023/06/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E5%90%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">go</span> fmt.Println(&lt;-ch1)<br>    ch1 &lt;- <span class="hljs-number">5</span><br>    time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：5、B：不能编译；C：运行时死锁</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>答案为<code>C</code>。因为goroutine后的的函数在调用之前，参数就已经被求好值了，也就是说<code>main</code>函数执行到<code>go fmt.Println(&lt;- ch1)</code>时，会先求<code>&lt;-ch1</code>此时，由于不存在除<code>main</code>外的goroutine为<code>ch1</code>传值，故程序运行时死锁。</p><p>以下解析来自<a href="https://mp.weixin.qq.com/s/kma8hvdLVPIkZnKw_MaSKg">Go语言爱好者周刊第 78 期</a>的一道题。当时正确率有点低，才 35%，可见不少人的基础还是不扎实。</p><p>此题如果改为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(&lt;-ch1)<br>  &#125;()<br>ch1 &lt;- <span class="hljs-number">5</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果就是 A 了。对比下你能知道原因了吧！</p><p>在 Go 语言规范中，关于 <a href="https://docs.studygolang.com/ref/spec#Go_statements">go 语句</a>有这么一句描述：</p><blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">GoStmt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;go&quot;</span> Expression .<br></code></pre></td></tr></table></figure><p>The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for <a href="https://docs.studygolang.com/ref/spec#Expression_statements">expression statements</a>.</p><p>The function value and parameters are <a href="https://docs.studygolang.com/ref/spec#Calls">evaluated as usual</a> in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete.</p></blockquote><p>这里说明，go 语句后面的函数调用，其参数会先求值，这和普通的函数调用求值一样。在规范中<a href="https://docs.studygolang.com/ref/spec#Calls">调用部分</a>是这样描述的：</p><blockquote><p>Given an expression <code>f</code> of function type <code>F</code>,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(a1, a2, … an)</span></span><br></code></pre></td></tr></table></figure><p>calls <code>f</code> with arguments <code>a1, a2, … an</code>. Except for one special case, arguments must be single-valued expressions <a href="https://docs.studygolang.com/ref/spec#Assignability">assignable</a> to the parameter types of <code>F</code> and are evaluated before the function is called.</p></blockquote><p>大意思是说，函数调用之前，实参就被求值好了。</p><p>因此这道题目 <code>go fmt.Println(&lt;-ch1)</code> 语句中的 <code>&lt;-ch1</code> 是在 main goroutine 中求值的。这相当于一个无缓冲的 chan，发送和接收操作都在一个 goroutine 中（main goroutine）进行，因此造成死锁。</p><p>更进一步，大家可以通过汇编看看上面两种方式的不同。</p><p>此外，defer 语句也要注意。比如下面的做法是不对的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-built_in">recover</span>()<br></code></pre></td></tr></table></figure><p>而应该使用这样的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">recover</span>()<br>&#125;()<br></code></pre></td></tr></table></figure><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/。</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变函数</title>
      <link href="/2023/06/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0/"/>
      <url>/2023/06/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>对 add() 函数调用正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> args &#123;<br>sum += arg<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. add(1, 2)</li><li>B. add(1, 3, 7)</li><li>C. add([]int{1, 2})</li><li>D. add([]int{1, 3, 7}…)</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：ABD。</p><p>知识点：可变函数。在 Go 中，可变函数（Variadic Function）是一种特殊类型的函数，可以接受可变数量的参数。我们可以在函数定义中使用 <code>...</code> 语法来表示可变参数，使得函数可以接受任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(numbers ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>total := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> numbers &#123;<br>total += num<br>&#125;<br><span class="hljs-keyword">return</span> total<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result := sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)      <span class="hljs-comment">// 调用可变函数并传递多个参数</span><br>fmt.Println(result)         <span class="hljs-comment">// 输出结果: 6</span><br><br>result = sum(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 调用可变函数并传递多个参数</span><br>fmt.Println(result)         <span class="hljs-comment">// 输出结果: 30</span><br><br>nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;   <span class="hljs-comment">// 使用切片作为参数</span><br>result = sum(nums...)       <span class="hljs-comment">// 使用 ... 展开切片作为可变函数的参数</span><br>fmt.Println(result)         <span class="hljs-comment">// 输出结果: 60</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go中的*p++</title>
      <link href="/2023/06/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E7%9A%84-p/"/>
      <url>/2023/06/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/Go%E4%B8%AD%E7%9A%84-p/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incr</span><span class="hljs-params">(p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>*p++<br><span class="hljs-keyword">return</span> *p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p :=<span class="hljs-number">1</span><br>incr(&amp;p)<br>fmt.Println(p)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. 1</li><li>B. 2</li><li>C. 3</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>​一元运算符具有最高优先级。由于++和–运算符形成的是语句，而不是表达式，因此它们不属于运算符层次结构。因此，语句<em>p++与（</em>p）++相同。</p><p>知识点：指针，incr() 函数里的 p 是 <code>*int</code> 类型的指针，指向的是 main() 函数的变量 p 的地址。 第 2 行代码是将该地址的值执行一个自增操作，incr() 返回自增后的结果。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string只是可读的</title>
      <link href="/2023/06/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E5%8F%AA%E6%98%AF%E5%8F%AF%E8%AF%BB%E7%9A%84/"/>
      <url>/2023/06/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/string%E5%8F%AA%E6%98%AF%E5%8F%AF%E8%AF%BB%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下列选项正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello&quot;</span><br>str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span><br>fmt.Println(str)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. hello</li><li>B. xello</li><li>C. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考代码及解析：C。</p><p>知识点：Go 语言中的字符串是只读的。</p><p>如果想要修改字符串中的某个字符，可以将字符串转换为字节数组 ([]byte)，然后通过索引修改字节数组中的对应位置的值，最后再将字节数组转换回字符串。</p><p>以下是修改字符串的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello&quot;</span><br>strBytes := []<span class="hljs-type">byte</span>(str)<br>strBytes[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span><br>str = <span class="hljs-type">string</span>(strBytes)<br>fmt.Println(str)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体嵌套</title>
      <link href="/2023/06/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97/"/>
      <url>/2023/06/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)<br>p.ShowB()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;<br>People<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := Teacher&#123;&#125;<br>t.ShowA()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">showA<br>showB<br></code></pre></td></tr></table></figure><p>知识点：结构体嵌套。这道题可以结合第 12 天的第三题一起看，Teacher 没有自己 ShowA()，所以调用内部类型 People 的同名方法，需要注意的是第 5 行代码调用的是 People 自己的 ShowB 方法。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行defer会保存一份副本</title>
      <link href="/2023/06/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%89%A7%E8%A1%8Cdefer%E4%BC%9A%E4%BF%9D%E5%AD%98%E4%B8%80%E4%BB%BD%E5%89%AF%E6%9C%AC/"/>
      <url>/2023/06/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%89%A7%E8%A1%8Cdefer%E4%BC%9A%E4%BF%9D%E5%AD%98%E4%B8%80%E4%BB%BD%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;  <br>    fmt.Println(i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := <span class="hljs-number">5</span><br>    <span class="hljs-keyword">defer</span> hello(i)<br>    i = i + <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5。<br></code></pre></td></tr></table></figure><p>这个例子中，hello() 函数的参数在执行 defer 语句的时候会保存一份副本，在实际调用 hello() 函数时用，所以是 5.</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>名言金句</title>
      <link href="/2023/06/23/%E9%98%85%E8%AF%BB/%E5%90%8D%E8%A8%80%E9%87%91%E5%8F%A5/"/>
      <url>/2023/06/23/%E9%98%85%E8%AF%BB/%E5%90%8D%E8%A8%80%E9%87%91%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="1、陈凯先院士讲话："><a href="#1、陈凯先院士讲话：" class="headerlink" title="1、陈凯先院士讲话："></a><strong>1、陈凯先院士讲话：</strong><span id="more"></span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">不是因为有了希望才坚持，而是因为坚持了才有希望。<br><br>不是因为有了机会才去争取，而是因为争取了才有机会。<br><br>不是因为成长了才去承担，而是因为承担了才会成长。<br><br>不是因为会了才去做，而是因为做了才能会。<br><br>不是因为拥有了才去付出，而是因为付出了才会拥有。<br><br>不是因为突破了才去挑战，而是因为挑战了才有突破。<br><br>不是因为有了收获才去感恩，而是因为感恩了才会有收获。<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局变量声明</title>
      <link href="/2023/06/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
      <url>/2023/06/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>定义一个包内全局字符串变量，下面语法正确的是（多选）：</p><ul><li>A. var str string</li><li>B. str :&#x3D; “”</li><li>C. str &#x3D; “”</li><li>D. var str &#x3D; “”</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">AD。<br></code></pre></td></tr></table></figure><p>B 短变量声明只支持局部变量声明；C 是赋值，str 必须在这之前已经声明。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体嵌套：外部覆盖内部</title>
      <link href="/2023/06/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%EF%BC%9A%E5%A4%96%E9%83%A8%E8%A6%86%E7%9B%96%E5%86%85%E9%83%A8/"/>
      <url>/2023/06/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%EF%BC%9A%E5%A4%96%E9%83%A8%E8%A6%86%E7%9B%96%E5%86%85%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)<br>p.ShowB()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;<br>People<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;<br>fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := Teacher&#123;&#125;<br>t.ShowB()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：teacher showB。</p><p>知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化输入%+d</title>
      <link href="/2023/06/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-d/"/>
      <url>/2023/06/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-d/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := <span class="hljs-number">-5</span><br>    j := +<span class="hljs-number">5</span><br>    fmt.Printf(<span class="hljs-string">&quot;%+d %+d&quot;</span>, i, j)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. -5 +5</li><li>B. +5 +5</li><li>C. 0 0</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>A.</p><p><code>%d</code>表示输出十进制数字，<code>+</code>表示输出数值的符号。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>delete删除map键值对</title>
      <link href="/2023/06/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/delete%E5%88%A0%E9%99%A4map%E9%94%AE%E5%80%BC%E5%AF%B9/"/>
      <url>/2023/06/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/delete%E5%88%A0%E9%99%A4map%E9%94%AE%E5%80%BC%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-built_in">delete</span>(s, <span class="hljs-string">&quot;h&quot;</span>)<br>    fmt.Println(s[<span class="hljs-string">&quot;h&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. runtime panic</li><li>B. 0</li><li>C. compilation error</li></ul><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​删除map不存在的键值对时，不会报错，相当于没用任何作用；获取不存在的键值对时，返回该类型对应的零值，所以返回0。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nil的动态值和动态类型</title>
      <link href="/2023/06/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E5%8A%A8%E6%80%81%E5%80%BC%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/06/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E5%8A%A8%E6%80%81%E5%80%BC%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;nil&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;not nil&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. nil</li><li>B. not nil</li><li>C. compilation error</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这是很常见的问题。</p><p>参考答案及解析：A。</p><p>​在 Go 语言中，接口的动态值（dynamic value）是指接口变量实际持有的值，而动态类型（dynamic type）是指接口变量所对应的具体类型。</p><p>​当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cap函数</title>
      <link href="/2023/06/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/cap%E5%87%BD%E6%95%B0/"/>
      <url>/2023/06/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/cap%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下哪种类型可以使用 cap() 函数？</p><ul><li>A. array</li><li>B. slice</li><li>C. map</li><li>D. channel</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：ABD。</p><p>知识点：cap()，cap() 函数不适用 map。详情参考：<a href="https://docs.studygolang.com/pkg/builtin/#cap">https://docs.studygolang.com/pkg/builtin/#cap</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组之间的比较</title>
      <link href="/2023/06/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2023/06/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>b := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">if</span> a == b &#123;<br>fmt.Println(<span class="hljs-string">&quot;equal&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;not equal&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. compilation error</li><li>B. equal</li><li>C. not equal</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><p> Go语言中，数组之间的比较需要注意下面这几个点：</p><ul><li>数组长度必须相等才能进行比较</li><li>数组类型必须一致才能进行比较</li><li>数组元素的值逐个比较：进行数组比较时，会逐个比较数组中的元素值。如果所有元素的值都相等，则认为两个数组相等；如果存在不相等的元素，则认为两个数组不相等。</li></ul><p>题目中两个数组的长度不相等，故无法比较，会导致编译错误<code> compilation error</code></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片的第三个参数</title>
      <link href="/2023/06/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/2023/06/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    t := a[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-number">4</span>]<br>    fmt.Println(t[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.3</li><li>B.4</li><li>C.compilation error</li></ul><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。</p><p>假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：</p><p><strong>长度：j-i，容量：k-i</strong></p><p>截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：<strong>j-i、k-i。</strong></p><p>所以例子中，切片 t 下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>    t := a[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>:<span class="hljs-number">4</span>]<br>    fmt.Println(t[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.3</li><li>B.4</li><li>C.compilation error</li></ul><h3 id="答案解析：-1"><a href="#答案解析：-1" class="headerlink" title="答案解析："></a>答案解析：</h3><p>参考答案及解析：B。</p><p>知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。</p><p>假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：</p><p><strong>长度：j-i，容量：k-i</strong></p><p>截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：<strong>j-i、k-i。</strong></p><p>所以例子中，切片 t 为 [4]，长度和容量都是 1。为 [4]，长度和容量都是 1。</p><p>以上解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体嵌套接口</title>
      <link href="/2023/06/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/06/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码能否通过编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> worker <span class="hljs-keyword">interface</span> &#123;<br>work()<br>&#125;<br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>worker<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br>fmt.Println(w)<br>&#125;<br></code></pre></td></tr></table></figure><p>A: 能；B: 不能；C: 不知道</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这里答错的原因在于 worker 是一个接口，如果是一个普通的类型，相信大家会答对。一个结构体竟然可以嵌入一个接口？！</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>我们都知晓 Go 没有继承，但可以通过内嵌类型模拟部分继承的功能。大家要记住，接口也是类型，自然也将它作为嵌入类型。如果题目的 person 接口体改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>worker worker<br>&#125;<br></code></pre></td></tr></table></figure><p>相信会有更多人答对，这和嵌入类型唯一的区别在于是否显示指定了字段名，其他并无区别。</p><p>将接口作为嵌入类型可能让人感觉有些奇怪：那这个类型不是默认就实现了这个接口？！确实是这样的，所以才有了题目中这一句能编译通过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br></code></pre></td></tr></table></figure><p>只不过，因为实例化 person 时，没有给 worker 指定值，因此 person 中的 worker 是 nil，调用它的话会报错，但编译是没问题的。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>有人可能要问，嵌入接口有实际用途吗？我找一个标准库中的例子。</p><p>在 sort 包中，有一个接口：Interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Len is the number of elements in the collection.</span><br>Len() <span class="hljs-type">int</span><br><span class="hljs-comment">// Less reports whether the element with</span><br><span class="hljs-comment">// index i should sort before the element with index j.</span><br>Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br><span class="hljs-comment">// Swap swaps the elements with indexes i and j.</span><br>Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是用于排序的。还有另外一个结构体：<a href="https://docs.studygolang.com/src/sort/sort.go?s=7078:7105#L239">reverse</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// This embedded Interface permits Reverse to use the methods of</span><br><span class="hljs-comment">// another Interface implementation.</span><br>Interface<br>&#125;<br></code></pre></td></tr></table></figure><p>它就内嵌了一个 Interface，用于排序的反转。</p><p>而内嵌接口的关键在于如何给这个内嵌的接口赋值。sort 包有一个函数：Reverse</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span></span> Interface &#123;<br><span class="hljs-keyword">return</span> &amp;reverse&#123;data&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中实例化 reverse 时，直接通过传递的 Interface 实例赋值给 reverse 的内嵌接口，然后 reverse 类型可以有选择的重新实现内嵌的 Interface 的方法。比如 Less 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> r.Interface.Less(j, i)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>回到上面的题目，如果我们通过实例化的 w 调用 work 方法会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;&#125;<br>w.work()<span class="hljs-comment">// panic</span><br></code></pre></td></tr></table></figure><p>和上面 reverse 类似，你需要给 person 中的 worker 实例化，也就是需要一个实现了 worker 接口的类型实例。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span></span> work() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;I am &quot;</span>, s.name, <span class="hljs-string">&quot;, I am learning&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这样实例化 person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w worker = person&#123;worker: student&#123;<span class="hljs-string">&quot;polarisxu&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><p>你掌握了吗？</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/">https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据竞争</title>
      <link href="/2023/06/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/"/>
      <url>/2023/06/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码有什么问题，怎么解决？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">total, sum := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        total += i<br>    &#125;()<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;total:%d sum %d&quot;</span>, total, sum)<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><h2 id="01-考点一"><a href="#01-考点一" class="headerlink" title="01 考点一"></a>01 考点一</h2><p>我相信很多人应该一眼看出了其中的一个问题，那就是 i 使用的问题。常见的题目是这样的：以下代码，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(i)<br>  &#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">1e9</span>)<br></code></pre></td></tr></table></figure><p>相信很多人知道，会输出一堆 11（可能还有其他的数字），而不是期望的输出 1 到 10。</p><p>怎么改进？你应该也知晓。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(i)<br>  &#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">1e9</span>)<br></code></pre></td></tr></table></figure><p>（当然这里的输出顺序是乱的，大家应该清楚）</p><h2 id="02-考点二"><a href="#02-考点二" class="headerlink" title="02 考点二"></a>02 考点二</h2><p>该题的第二个考点：data race。因为存在多 goroutine 同时写 total 变量的问题，所以有数据竞争。可以加上 -race 参数验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run -race main.go<br>==================<br>WARNING: DATA RACE<br>Read at 0x00c0001b4020 by goroutine 8:<br>  main.main.func1()<br>      /Users/xuxinhua/main.go:12 +0x57<br><br>Previous write at 0x00c0001b4020 by main goroutine:<br>  main.main()<br>      /Users/xuxinhua/main.go:9 +0x10b<br><br>Goroutine 8 (running) created at:<br>  main.main()<br>      /Users/xuxinhua/main.go:11 +0xe7<br>==================<br></code></pre></td></tr></table></figure><p>这可以通过加锁的方式解决：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mutex sync.Mutex<br>total, sum := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  sum += i<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    mutex.Lock()<br>    total += i<br>    mutex.Unlock()<br>  &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，也可以通过 atomic 包解决：（注意 total 的类型，因为 atomic.AddInt64 需要）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>  sum += i<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    atomic.AddInt64(&amp;total, <span class="hljs-type">int64</span>(i))<br>  &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 -race 你验证，发现 data race 没了。</p><p>细心的你不知道发现没有，以上代码我故意把最后的 fmt 输出那一行去掉了，因为它用了 total 变量，避免它导致 data race。这引出考点三。</p><h2 id="03-考点三"><a href="#03-考点三" class="headerlink" title="03 考点三"></a>03 考点三</h2><p>我上面都没有给完整的代码，因为经过上面两步，最终的结果还是不对的。从上面说的 fmt 输出代码去掉就说明还有问题。</p><p>初学 Go 应该遇到类似这样的问题，下面代码一般没有输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>原因是 main 函数先退出了，开启的 goroutine 根本没有机会执行。所以，常见的解决办法是在最后加一个 Sleep：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;()<br>  <br>  time.Sleep(<span class="hljs-number">1e9</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Sleep 会让 main goroutine 休眠，调度器调度其他 goroutine 运行。</p><p>回到开头的题目其实也存在这个问题，通过在 fmt 语句之前加上 Sleep，基本能得到正确的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        atomic.AddInt64(&amp;total, <span class="hljs-type">int64</span>(i))<br>    &#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">1e9</span>)<br><br>fmt.Printf(<span class="hljs-string">&quot;total:%d sum %d&quot;</span>, total, sum)<br></code></pre></td></tr></table></figure><p>但如果加上 -race 发现还是有问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run -race main.go<br>==================<br>WARNING: DATA RACE<br>Read at 0x00c00001c0b0 by main goroutine:<br>  main.main()<br>      /Users/xuxinhua/main.go:20 +0xe4<br><br>Previous write at 0x00c00001c0b0 by goroutine 7:<br>  <span class="hljs-built_in">sync</span>/atomic.AddInt64()<br>      /Users/xuxinhua/.go/current/src/runtime/race_amd64.s:276 +0xb<br>  main.main.func1()<br>      /Users/xuxinhua/main.go:15 +0x44<br><br>Goroutine 7 (finished) created at:<br>  main.main()<br>      /Users/xuxinhua/main.go:14 +0xa4<br>==================<br>total:55 <span class="hljs-built_in">sum</span> 55Found 1 data race(s)<br></code></pre></td></tr></table></figure><p>所以，这种方式是不靠谱的，这时正确的方式是使用 sync.WaitGroup。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;sync/atomic&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        sum += i<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            atomic.AddInt64(&amp;total, <span class="hljs-type">int64</span>(i))<br>        &#125;(i)<br>    &#125;<br>    wg.Wait()<br><br>    fmt.Printf(<span class="hljs-string">&quot;total:%d sum %d&quot;</span>, total, sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/">https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有点难度：json和slice</title>
      <link href="/2023/06/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%BA%A6%EF%BC%9Ajson%E5%92%8Cslice/"/>
      <url>/2023/06/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%9C%89%E7%82%B9%E9%9A%BE%E5%BA%A6%EF%BC%9Ajson%E5%92%8Cslice/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> AutoGenerated <span class="hljs-keyword">struct</span> &#123;<br>Age   <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Child []<span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;child&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jsonStr1 := <span class="hljs-string">`&#123;&quot;age&quot;: 14,&quot;name&quot;: &quot;potter&quot;, &quot;child&quot;:[1,2,3]&#125;`</span><br>a := AutoGenerated&#123;&#125;<br>json.Unmarshal([]<span class="hljs-type">byte</span>(jsonStr1), &amp;a)<br>aa := a.Child<br>fmt.Println(aa)<br>jsonStr2 := <span class="hljs-string">`&#123;&quot;age&quot;: 12,&quot;name&quot;: &quot;potter&quot;, &quot;child&quot;:[3,4,5,7,8,9]&#125;`</span><br>json.Unmarshal([]<span class="hljs-type">byte</span>(jsonStr2), &amp;a)<br>fmt.Println(aa)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>结果为什么是 [1 2 3] [3 4 5] 呢？</p><p>这道题涉及到两个知识点：</p><ul><li>json 解析；</li><li>slice；</li></ul><h2 id="1、json-解析"><a href="#1、json-解析" class="headerlink" title="1、json 解析"></a>1、json 解析</h2><p>关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。<a href="https://docs.studygolang.com/pkg/encoding/json/#Unmarshal%E3%80%82">https://docs.studygolang.com/pkg/encoding/json/#Unmarshal。</a></p><blockquote><p>Unmarshal 解析 JSON 编码的数据，并将结果存入 v 指向的值。如果 v 为 nil 或不是指针，则 Unmarshal 返回 InvalidUnmarshalError。</p><p>Unmarshal 和 Marshal 做相反的操作，必要时申请 map、slice 或指针，有如下的附加规则：</p><ul><li><p>为了将 JSON 数据解码写入一个指针，Unmarshal 首先处理 JSON 数据为 JSON 字面值 null 的情况。此时，Unmarshal 会将指针设置为 nil。否则，Unmarshal 会将 JSON 数据解码为指针所指向的值。如果指针为 nil，则 Unmarshal 为其分配一个新值并使指针指向它。</p></li><li><p>为了将 JSON 数据解码为实现 Unmarshaler 接口的值，Unmarshal 调用该值的 UnmarshalJSON 方法，包括当输入为 JSON null 时。否则，如果该值实现 encoding.TextUnmarshaler 且输入是带引号的 JSON 字符串，则 Unmarshal 会使用该字符串的未加引号形式来调用该值的 UnmarshalText 方法。</p></li><li><p>要将 json 数据解码写入一个结构体，函数会匹配输入对象的键和 Marshal 使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配；</p></li><li><p>为了将 JSON 数据解码到结构中，Unmarshal 将传入的对象键与 Marshal 使用的键（结构字段名称或其 Tag）进行匹配，希望使用精确匹配，但还接受不区分大小写的匹配。默认情况下，没有相应结构字段的对象键将被忽略（有关替代方法，请参见 Decoder.DisallowUnknownFields）。</p></li><li><p>要将 JSON 数据解码写入一个接口类型值，Unmarshal 将其中之一存储在接口值中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Bool</span>                   对应<span class="hljs-title class_">JSON</span>布尔类型<br>float64                对应<span class="hljs-title class_">JSON</span>数字类型<br><span class="hljs-built_in">string</span>                 对应<span class="hljs-title class_">JSON</span>字符串类型<br>[]<span class="hljs-keyword">interface</span>&#123;&#125;          对应<span class="hljs-title class_">JSON</span>数组<br>map[<span class="hljs-built_in">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; 对应<span class="hljs-title class_">JSON</span>对象<br>nil                    对应<span class="hljs-title class_">JSON</span>的<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure></li><li><p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p></li><li><p>为了将 JSON 数组解码为 Go 数组，Unmarshal 将 JSON 数组元素解码为对应的 Go 数组元素。如果 Go 数组长度小于 JSON 数组，则其他 JSON 数组元素将被丢弃。如果 JSON 数组长度小于 Go 数组，则将其他 Go 数组元素会设置为零值。</p></li><li><p>要将 JSON 对象解码到 map 中，Unmarshal 首先要建立将使用的 map。如果 map 为零，Unmarshal 会分配一个新 map。否则，Unmarshal 会重用现有 map，保留现有条目（item）。然后，Unmarshal 将来自 JSON 对象的键&#x2F;值对存储到 map 中。map 的键类型必须是任意字符串类型、整数或实现了 json.Unmarshaler 或 encoding.TextUnmarshaler 接口的类型。</p></li><li><p>如果 JSON 值不适用于给定的目标类型，或者 JSON 数字写入目标类型时溢出，则 Unmarshal 会跳过该字段并尽最大可能完成解析。如果没有遇到更多的严重错误，则 Unmarshal 返回一个 UnmarshalTypeError 来描述最早的此类错误。但无法确保有问题的字段之后的所有其余字段都将被解析到目标对象中。</p></li><li><p>JSON 的 null 值解码为 Go 的接口、指针、切片时会将它们设为 nil，因为 null 在 JSON 里一般表示“不存在”。 因此将 JSON null 解码到任何其他 Go 类型中不会影响该值，并且不会产生任何错误。</p></li><li><p>解析带引号的字符串时，无效的 UTF-8 或无效的 UTF-16 不会被视为错误。而是将它们替换为 Unicode 字符 U+FFFD。</p></li></ul></blockquote><p>跟此题相关的是下面这点：</p><blockquote><p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p></blockquote><p>因此第一次解析时，a.Child 是 [1 2 3]，aa 自然也是 [1 2 3]。第二次解析时，a.Child 的长度会被重置为 0，也就说里面的值会被重置（比如 a.Child &#x3D; a.Child[:0]），然后将 3,4,5,7,8,9 一个个 append 到 a.Child 中。</p><p>而 append 操作可能会涉及到底层数组的扩容：当原来的容量不足时，会进行扩容。怎么扩容的呢？目前的版本（Go1.15.x）按照如下规则扩容：（扩容规则依赖具体实现，不同版本可能不一样）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get element of array, growing if necessary.</span><br><span class="hljs-keyword">if</span> v.Kind() == reflect.Slice &#123;<br>  <span class="hljs-comment">// Grow slice if necessary</span><br>  <span class="hljs-keyword">if</span> i &gt;= v.Cap() &#123;<br>    newcap := v.Cap() + v.Cap()/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> newcap &lt; <span class="hljs-number">4</span> &#123;<br>      newcap = <span class="hljs-number">4</span><br>    &#125;<br>    newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)<br>    reflect.Copy(newv, v)<br>    v.Set(newv)<br>  &#125;<br>  <span class="hljs-keyword">if</span> i &gt;= v.Len() &#123;<br>    v.SetLen(i + <span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始容量最小为 4；</li><li>之后按照容量的一半扩容，所以容量是 4、6、9、13、19…</li></ul><p>有人问上题为什么 aa 的容量是 4，这里正好解释了。</p><p>因此，第一次解析，aa.Child 是：[1 2 3]，cap &#x3D; 4。第二次解析，aa.Child 先被重置，之后将 3,4,5,7,8,9 一个个 append，最后 aa.Child 是：[3 4 5 6 7 8 9], cap &#x3D; 6。</p><h2 id="2、slice"><a href="#2、slice" class="headerlink" title="2、slice"></a>2、slice</h2><p>以上就是能从 json Unmarshal 文档能学到的相关知识。接下来关键在于 slice。关于 slice 的知识，网上很多教程，这里只讲解和该题相关的内容。</p><p>1）aa :&#x3D; a.Child 意味着什么？</p><p>先看 a.Child 的内部结构。</p><p><img src="/images/json02.png" alt="img"></p><p>赋值给 aa 后呢？aa 和 a.Child 共用底层数组。</p><p>这里有引入一个小知识点，aa :&#x3D; a.Child 后，以下代码输出的两个地址是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%p,%p\n&quot;</span>, a.Child, aa)<br></code></pre></td></tr></table></figure><p>它们输出的都是底层数组的地址，这里一定要注意。通过它们，你可以验证底层数组扩容了（地址变了，表明扩容了）。</p><p>如果要输出 slice 本身的地址，应该这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%p,%p\n&quot;</span>, &amp;a.Child, &amp;aa)<br></code></pre></td></tr></table></figure><p>2）执行第二次 json 解析后</p><p>根据上文的讲解，底层数组从索引 0 位置开始依次被 3、4、5、7 填充。因为 aa 的 len 是 3，所以即使底层数组变成了 3、4、5、7，aa 看到却是 3、4、5。</p><p>当再继续解析时，底层数组容量不够，因此进行扩容，cap 变成 6，将原底层数组的元素拷贝一份到新的数组中。所以最后 a.Child 的底层数组是这个新的底层数组：[3 4 5 7 8 9]，cap &#x3D; 6。而 aa 的底层数组还是原来的。最后的内部表示是这样的。</p><p><img src="/images/json04.png" alt="img"></p><h2 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h2><p>总结起来两点：</p><ul><li>json 解析的规则，文档上明确说明了；（有人评论说跟 json 没关系，但我觉得很多人根本不知道 json 对这块是怎么处理的，正因为有这样的处理，才引出了 slice 扩容的问题）</li><li>slice 内部表示和 append 导致扩容。</li></ul><p>希望你已经彻底掌握了以上知识点。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/">https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个不同类型的数值能否相加？</title>
      <link href="/2023/06/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E5%80%BC%E8%83%BD%E5%90%A6%E7%9B%B8%E5%8A%A0%EF%BC%9F/"/>
      <url>/2023/06/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E5%80%BC%E8%83%BD%E5%90%A6%E7%9B%B8%E5%8A%A0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    a := <span class="hljs-number">5</span><br>    b := <span class="hljs-number">8.1</span><br>    fmt.Println(a + b)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.13.1</li><li>B.13</li><li>C.compilation error</li></ul><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">C</span><br></code></pre></td></tr></table></figure><p>​Go语言的类型机制更加严格，没有隐式类型转换，所以不同类型的数据不能直接参与同一个运算。</p><p>​a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变函数参数</title>
      <link href="/2023/06/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
      <url>/2023/06/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(num ...<span class="hljs-type">int</span>)</span></span> &#123;  <br>    num[<span class="hljs-number">0</span>] = <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    i := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>    hello(i...)<br>    fmt.Println(i[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.18</li><li>B.5</li><li>C.Compilation error</li></ul><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析:"></a>答案解析:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><p>​由于切片是引用类型，在函数调用过程中，实际上是将切片的底层数组传递给了 <code>hello</code> 函数。故在函数中是对切片的底层数组进行修改，所以主函数中输出的值也随着被修改了，即18。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对nil的map取值</title>
      <link href="/2023/06/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9nil%E7%9A%84map%E5%8F%96%E5%80%BC/"/>
      <url>/2023/06/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9nil%E7%9A%84map%E5%8F%96%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;  <br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[person]<span class="hljs-type">int</span><br>    p := person&#123;<span class="hljs-string">&quot;mike&quot;</span>&#125;<br>    fmt.Println(m[p])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A.0</li><li>B.1</li><li>C.Compilation error</li></ul><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>这段代码会输出一个零值，即 <code>0</code>。</p><p>原因是在代码中定义了一个 <code>map[person]int</code> 类型的变量 <code>m</code>，但是没有对其进行初始化。在没有进行初始化操作时，<code>map</code> 的零值为 <code>nil</code>，也就是一个空的 <code>map</code>。</p><p>在打印语句中，尝试通过 <code>m[p]</code> 获取 <code>map</code> 中键为 <code>p</code> 的值。由于 <code>m</code> 是一个空的 <code>map</code>，并没有键为 <code>p</code> 的项，因此返回其值类型的零值，即 <code>0</code>。</p><p>因此，代码输出为 <code>0</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于channel</title>
      <link href="/2023/06/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Echannel/"/>
      <url>/2023/06/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Echannel/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于 channel，下面语法正确的是：</p><ul><li>A. var ch chan int</li><li>B. ch :&#x3D; make(chan int)</li><li>C. &lt;- ch</li><li>D. ch &lt;-</li></ul><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ABC。<br></code></pre></td></tr></table></figure><p>​A、B 都是声明 channel；C 读取 channel；写 channel 是必须带上值，所以 D 错误。</p><p>​需要注意的是，A选项中，使用 <code>var ch chan int</code> 声明了一个通道变量 <code>ch</code>，但没有对其进行初始化操作，没有创建一个可用的通道。在使用通道之前，需要使用 <code>ch = make(chan int)</code> 进行初始化。</p><p>​若尝试向未初始化的通道发送数据，但由于通道未初始化，这将导致发送操作在无缓冲通道上被阻塞</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goroutine执行速度快</title>
      <link href="/2023/06/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BF%AB/"/>
      <url>/2023/06/06/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/goroutine%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">var</span> wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">println</span>(i)<br><span class="hljs-keyword">defer</span> wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>输出结果不唯一，代码存在风险, 所有 go 语句未必都能执行到。</p><p>这是使用 WaitGroup 经常犯下的错误！请各位同学多次运行就会发现输出都会不同甚至又出现报错的问题。 这是因为 go 执行太快了，导致 wg.Add(1) 还没有执行 main 函数就执行完毕了。wg.Add 的位置放错了。</p><p>改为下面代码试试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">var</span> wg = &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt; N; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>            <span class="hljs-built_in">println</span>(i)<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>        &#125;(i)<br>    &#125;<br><br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>以上解析来自<a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>channel</title>
      <link href="/2023/06/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/channel/"/>
      <url>/2023/06/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/channel/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>执行下面的代码会发生什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>a, ok := &lt;-ch<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;close&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;a: &quot;</span>, a)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">close</span>(ch)<br>fmt.Println(<span class="hljs-string">&quot;ok&quot;</span>)<br>time.Sleep(time.Second * <span class="hljs-number">100</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>记住 channel 的一些关键特性：</p><ul><li>给一个 nil channel 发送数据，造成永远阻塞</li><li>从一个 nil channel 接收数据，造成永远阻塞</li><li>给一个已经关闭的 channel 发送数据，引起 panic</li><li>从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</li><li>无缓冲的channel是同步的，而有缓冲的channel是非同步的</li></ul><p>15字口诀：“空读写阻塞，写关闭异常，读关闭空零”，往已经关闭的 channel 写入数据会 panic。</p><p>本题中，因为 main 在开辟完两个 goroutine 之后，立刻关闭了 ch， 结果就是 panic：</p><blockquote><p>panic: send on closed channel</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型断言</title>
      <link href="/2023/06/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%882%EF%BC%89/"/>
      <url>/2023/06/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否编译通过？如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := GetValue()<br><span class="hljs-keyword">switch</span> i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;int&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;string&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;interface&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;unknown&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​该代码无法编译通过。</p><p>原因是在 <code>switch i.(type)</code> 语句中，<code>i</code> 是一个普通的 <code>int</code> 类型变量，而 <code>i.(type)</code> 只能用于接口类型的断言。因此，编译器会报错。</p><p>​如果想要判断一个变量的类型，可以使用 <code>reflect</code> 包来实现。以下是修改后的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetValue</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := GetValue()<br><span class="hljs-keyword">switch</span> reflect.TypeOf(i).Kind() &#123;<br><span class="hljs-keyword">case</span> reflect.Int:<br>fmt.Println(<span class="hljs-string">&quot;int&quot;</span>)<br><span class="hljs-keyword">case</span> reflect.String:<br>fmt.Println(<span class="hljs-string">&quot;string&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unknown&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>​编译失败。考点：类型断言，类型断言的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型断言。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数赋值给变量</title>
      <link href="/2023/06/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F/"/>
      <url>/2023/06/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出什么以及原因？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> []<span class="hljs-type">string</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    h := hello<br>    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;nil&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;not nil&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>A. nil</li><li>B. not nil</li><li>C. compilation error</li></ul><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​B。</p><p>​在Go语言中，函数变量可以存储函数的地址。在 <code>main</code> 函数中，变量 <code>h</code> 被赋值为 <code>hello</code> 函数的地址。即使 <code>hello</code> 函数返回了一个空切片 <code>nil</code>，它仍然被认为不是 <code>nil</code>。因此，条件 <code>h == nil</code> 不满足，程序会执行 <code>else</code> 分支，输出 “not nil”。</p><p>以下解析来自<a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>​这道题目里面，是将函数 hello 赋值给变量 h，而不是函数的返回值（即不是进行函数调用），所以输出 not nil。注意 Go 中函数是一等公民。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>init函数</title>
      <link href="/2023/06/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0(2)/"/>
      <url>/2023/06/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于 init 函数，下面说法正确的是：</p><ul><li>A. 一个包中，可以包含多个 init 函数；</li><li>B. 程序运行时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数；</li><li>C. main 包中，不能有 init 函数；</li><li>D. init 函数可以被其他函数调用；</li></ul><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​AB。</p><p>关于 init() 函数有几个需要注意的地方：</p><ol><li>init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等;</li><li>一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数；</li><li>同一个包中多个 init() 函数的执行顺序没有明确定义，<strong>但是不同包的init函数是根据包导入的依赖关系决定的</strong>;</li><li>init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误;</li><li>一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次；</li><li>引入包，不可出现死循坏。即A import B,B import A，这种情况编译失败；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量和非常量的溢出</title>
      <link href="/2023/06/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%9E%E5%B8%B8%E9%87%8F%E7%9A%84%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/06/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%9E%E5%B8%B8%E9%87%8F%E7%9A%84%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>今天给两道类似的题目，注意，有半数以上的人可能会做错！</p><p>题一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br><br>    <span class="hljs-built_in">println</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>题二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br><br>    <span class="hljs-built_in">println</span>(b)<br>&#125;<br></code></pre></td></tr></table></figure><p>它们分别输出什么？请写出你的答案，能解释原因最好。</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这是站长在去年双节期间公众号「polarisxu」上发布的题目。</p><p>答对的人真不多（半数以上答错了），特别是题一，一半以上竟然是 128，难道不知道 int8 能表示的范围吗？[-128, 127]。不过为什么答案是：题一 -128，题二编译错误？</p><p>其实这是一道计算机基础题。</p><p>先看看网友 Jayce 的解释：第一题是 -128（untyped const）&#x2F; -1 (int8 var)，untyped 隐式转换为 int8，刚好在范围内，结果是 128 ，溢出 int8 的范围。因为结果不是常量，允许溢出，最高位为符号位，变成了补码，刚好又是 -128。 第二题 -128 和 -1 都是 const，直接在编译时求值，untyped 的 -128 隐式转 int8，结果为 128，仍然是一个 const。const 转换时不允许溢出，编译错误。 其实差别就是表达式的值，题一不是常量题二是，常量类型转换不允许溢出后 truncate。</p><h2 id="关于补码"><a href="#关于补码" class="headerlink" title="关于补码"></a>关于补码</h2><p>如果你忘了补码（<code>Two&#39;s Complement</code>，2 的补码，一般直接称为补码），这里简单做个说明。</p><p>先问一个问题：在计算机内部 -1 二进制表示是什么（假如为 int8）？</p><p>我们很容易这么想：1 的二进制是 00000001，而最高位是符号位，因此 -1 是 10000001。因为 1 + (-1) &#x3D; 0，但 00000001 + 10000001 &#x3D; 10000010，很显然，这个结果不是 0。这是原码表示。</p><p><img src="https://polarisxu.studygolang.com/posts/basic/imgs/complement01.png" alt="原码形式"></p><p>所以，计算机内部采用补码（Two’s Complement）表示负数。补码怎么得到呢？一般分两步：</p><p><img src="https://polarisxu.studygolang.com/posts/basic/imgs/complement02.png" alt="-1的补码表示"></p><ul><li>第一步，每一个二进制位都取相反值，0 变成 1，1 变成 0。比如，00000001 的相反值就是 11111110。</li><li>第二步，将上一步得到的值加 1。11111110 就变成 11111111。</li></ul><p><img src="https://polarisxu.studygolang.com/posts/basic/imgs/complement03.png" alt="补码形式的加法"></p><p>关于原码、反码和补码，可以看这篇文章：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html%EF%BC%8C%E5%BE%88%E8%AF%A6%E7%BB%86%E3%80%82">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html，很详细。</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="先看题一"><a href="#先看题一" class="headerlink" title="先看题一"></a>先看题一</h3><p>因为 <code>var b int8 = -128 / a</code> 不是常量表达式，因此 untyped 常量 -128 隐式转换为 int8 类型（即和 a 的类型一致），所以 <code>-128 / a</code> 的结果是 int8 类型，值是 128，超出了 int8 的范围。因为结果不是常量，允许溢出，128 的二进制表示是 10000000，正好是 -128 的补码。所以，第一题的结果是 -128。</p><blockquote><p>关于整数溢出的 Go 语言规范说明：<a href="https://hao.studygolang.com/golang_spec.html#id158%E3%80%82">https://hao.studygolang.com/golang_spec.html#id158。</a></p></blockquote><p>在 Go 语言规范中关于整数运算有这样的说明：<a href="https://hao.studygolang.com/golang_spec.html#id327">https://hao.studygolang.com/golang_spec.html#id327</a></p><blockquote><p>对于两个整数值 x 和 y ，其整数商 q &#x3D; x &#x2F; y 和余数 r &#x3D; x % y 满足如下关系：</p><p>x &#x3D; q*y + r 且 |r| &lt; |y|</p><p>这个规则有一个例外，如果对于 x 的整数类型来说，被除数 x 是该类型中最负的那个值，那么，因为 补码 的 整数溢出 ，商 q &#x3D; x &#x2F; -1 等于 x （并且 r &#x3D; 0 ）。</p></blockquote><p>所以例外情况有：</p><table><thead><tr><th align="left">类型</th><th align="left">x, q 的值</th></tr></thead><tbody><tr><td align="left">int8</td><td align="left">-128</td></tr><tr><td align="left">int16</td><td align="left">-32768</td></tr><tr><td align="left">int32</td><td align="left">-2147483648</td></tr><tr><td align="left">int64</td><td align="left">-9223372036854775808</td></tr></tbody></table><h3 id="再看题二"><a href="#再看题二" class="headerlink" title="再看题二"></a>再看题二</h3><p>对于 <code>var b int8 = -128 / a</code>，因为 a 是 int8 类型常量，所以 <code>-128 / a</code> 是常量表达式，在编译器计算，结果必然也是常量。因为 a 的类型是 int8，因此 -128 也会隐式转为 int8 类型，128 这个结果超过了 int8 的范围，但常量不允许溢出，因此编译报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这题并非 Go 独有，而是计算机的基础。比如相应的 C 语言程序，结果和 Go 对应程序是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对应题一</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">char</span> a = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">char</span> b = <span class="hljs-number">-128</span> / a;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, b);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果 -128。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 对应题二</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> a = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">char</span> b = <span class="hljs-number">-128</span> / a;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, b);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译报错。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/basic/complement/%E3%80%82">https://polarisxu.studygolang.com/posts/basic/complement/。</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体实例json系列化</title>
      <link href="/2023/05/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8Bjson%E7%B3%BB%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/31/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8Bjson%E7%B3%BB%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := <span class="hljs-keyword">struct</span> &#123;<br>time.Time<br>N <span class="hljs-type">int</span><br>&#125;&#123;<br>time.Date(<span class="hljs-number">2020</span>, <span class="hljs-number">12</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, time.UTC),<br><span class="hljs-number">5</span>,<br>&#125;<br><br>m, _ := json.Marshal(t)<br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, m)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：<code>&#123;&quot;Time&quot;: &quot;2020-12-20T00:00:00Z&quot;, &quot;N&quot;: 5&#125;</code>；B：<code>&quot;2020-12-20T00:00:00Z&quot;</code>；C：<code>&#123;&quot;N&quot;: 5&#125;</code>；D：<code>&lt;nil&gt;</code></p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>这是来自<a href="https://mp.weixin.qq.com/s/oDMSFjjzGbu7kkERM8ilGw">《Go语言爱好者周刊第74期》</a>的题目，正确率 12%。</p><p>大家不用在乎是不是刁钻的题目，通过题目能学到知识才是最重要的。</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>对一个结构体实例进行 json 系列化，直觉很容易选 A。但很显然，不可能这么简单，因此需要仔细看代码。至于选 C 和 D 的人，多半是瞎猜的吧，当然选 B 也不排除有瞎猜的。</p><p>为什么选 B 呢？我想借助一个例子讲解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br>  <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  name  <span class="hljs-type">string</span><br>  hobby <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  person := Person&#123;name: <span class="hljs-string">&quot;polarisxu&quot;</span>, hobby: <span class="hljs-string">&quot;Golang&quot;</span>&#125;<br>  m, _ := json.Marshal(person)<br>  fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, m)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你认为输出 <code>&#123;&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang&quot;&#125;</code>，那你得去补补 encoding&#x2F;json 包的知识了。要想输出 <code>&#123;&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang”&#125;</code>，一般我们会这么做：将 Person 的字段导出，同时设置上 tag。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>  Hobby <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;hobby&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但如果我们不想导出 Person 的字段呢？可以通过实现 Marshaler 来做到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> MarshalJSON() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;&quot;name&quot;:&quot;`</span>+p.name+<span class="hljs-string">`&quot;,&quot;hobby&quot;:&quot;`</span>+p.hobby+<span class="hljs-string">`&quot;&#125;`</span>), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>回到题目上，<a href="https://docs.studygolang.com/pkg/time/#Time">time.Time</a> 是什么类型？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Time <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// contains filtered or unexported fields</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个没有导出任何字段的结构体类型，因此它肯定<a href="https://docs.studygolang.com/src/time/time.go?s=38148:38191#L1230">实现了 Marshaler 接口</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MarshalJSON implements the json.Marshaler interface.</span><br><span class="hljs-comment">// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> MarshalJSON() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> y := t.Year(); y &lt; <span class="hljs-number">0</span> || y &gt;= <span class="hljs-number">10000</span> &#123;<br><span class="hljs-comment">// RFC 3339 is clear that years are 4 digits exactly.</span><br><span class="hljs-comment">// See golang.org/issue/4556#c15 for more discussion.</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;Time.MarshalJSON: year outside of range [0,9999]&quot;</span>)<br>&#125;<br><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(RFC3339Nano)+<span class="hljs-number">2</span>)<br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>b = t.AppendFormat(b, RFC3339Nano)<br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br><span class="hljs-keyword">return</span> b, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这么说，答案不应该就是 A 吗？别急。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>如果 t 是这么定义的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">t := <span class="hljs-keyword">struct</span> &#123;<br>  Time time.Time<br>  N <span class="hljs-type">int</span><br>&#125;&#123;<br>  time.Date(<span class="hljs-number">2020</span>, <span class="hljs-number">12</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, time.UTC),<br>  <span class="hljs-number">5</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>那结果就是 A。而题目中，time.Time 是内嵌的。你学习 Go 时，应该看过通过内嵌来模拟继承的功能吧！</p><p>正是因为内嵌，t 的方法集包括了 time.Time 的方法集，所以，t 自动实现了 Marshaler 接口。因此答案是 B。</p><p>其实这道题的情况，在日常工作中还真有可能遇到。所以，当你内嵌某个类型时，特别这个类型不是你自己定义的，需要留意这种情况。</p><p>一般解决这个问题的方法有两种：1）不内嵌；2）重新实现 MarshalJSON 方法。</p><p>然而这道题无法重新实现 MarshalJSON 方法，因为结构体类型是匿名的。只能通过不内嵌来得到正确的结果。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>最后一起看下 json.Marshal 函数的文档，主要看下面这段：</p><blockquote><p>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</p></blockquote><p>大意是说，如果值实现了 json.Marshaler 接口并且不是 nil 指针，则 Marshal 函数会调用其 MarshalJSON 方法以生成 JSON。如果不存在 MarshalJSON 方法，但该值实现 encoding.TextMarshaler 接口，则 Marshal 函数调用其 MarshalText 方法并将结果编码为 JSON 字符串。</p><p>可见，json.Marshal 函数优先调用 MarshalJSON，然后是 MarshalText，如果都没有，才会走正常的类型编码逻辑。</p><p>答案解析来自：<a href="https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/%E3%80%82">https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/。</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空接口和非空接口</title>
      <link href="/2023/05/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%9E%E7%A9%BA%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/05/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%9E%E7%A9%BA%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码打印出来什么内容，说出为什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Show()<br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Show() &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span> People &#123;<br><span class="hljs-keyword">var</span> stu *Student<br><span class="hljs-keyword">return</span> stu<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> live() == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;AAAAAAA&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;BBBBBBB&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​答案解析：</p><p><strong>结果</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BBBBBBB</span><br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>我们需要了解<code>interface</code>的内部结构，才能理解这个题目的含义。（源码基于 Go1.17）</p><p>interface 在使用的过程中，共有两种表现形式</p><p>一种为**空接口(empty interface)**，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> MyInterface <span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>另一种为<strong>非空接口(non-empty interface)</strong>, 定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInterface <span class="hljs-keyword">interface</span> &#123;<br>function()<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种 interface 类型在底层分别用两种<code>struct</code>表示，空接口为<code>eface</code>, 非空接口为<code>iface</code>。</p><hr><h4 id="空接口-eface"><a href="#空接口-eface" class="headerlink" title="空接口 eface"></a>空接口 eface</h4><p>空接口 eface 结构，由两个属性构成，一个是类型信息 _type，一个是数据信息。其数据结构声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;      <span class="hljs-comment">// 空接口</span><br>    _type *_type         <span class="hljs-comment">// 类型信息</span><br>    data  unsafe.Pointer <span class="hljs-comment">// 指向数据的指针(go 语言中特殊的指针类型 unsafe.Pointer 类似于 c 语言中的void*)</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>_type 属性</strong>：是 Go 语言中所有类型的公共描述，Go 语言几乎所有的数据结构都可以抽象成 <code>_type</code>，是所有类型的公共描述，**_type 负责决定 data 应该如何解释和操作，** <code>_type</code> 的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> _type <span class="hljs-keyword">struct</span> &#123;<br>size       <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 类型大小</span><br>ptrdata    <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 前缀持有所有指针的内存大小</span><br>hash       <span class="hljs-type">uint32</span>  <span class="hljs-comment">// 数据 hash 值</span><br>tflag      tflag<br>align      <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 对齐</span><br>fieldalign <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 嵌入结构体时的对齐</span><br>kind       <span class="hljs-type">uint8</span>   <span class="hljs-comment">// kind 有些枚举值 kind 等于 0 是无效的</span><br><span class="hljs-comment">// function for comparing objects of this type</span><br><span class="hljs-comment">// (ptr to object A, ptr to object B) -&gt; ==?</span><br>equal     <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span><br>gcdata    *<span class="hljs-type">byte</span><br>str       nameOff<br>ptrToThis typeOff<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>data 属性</strong>： 表示指向具体的实例数据的指针，它是一个<code>unsafe.Pointer</code>类型，相当于一个 C 的万能指针<code>void*</code>。</p><hr><h4 id="非空接口-iface"><a href="#非空接口-iface" class="headerlink" title="非空接口 iface"></a>非空接口 iface</h4><p>iface 表示 non-empty interface 的数据结构，非空接口初始化的过程就是初始化一个 iface 类型的结构，其中<code>data</code>的作用与 <code>eface</code> 的相同，这里不再多加描述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>  tab  *itab<br>  data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>iface 结构中最重要的是 itab 结构（结构如下），每一个 <code>itab</code> 都占 32 字节的空间。itab 可以理解为<code>pair&lt;interface type, concrete type&gt;</code> 。itab 里面包含了 interface 的一些关键信息，比如 method 的具体实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;<br>  inter  *interfacetype   <span class="hljs-comment">// 接口自身的元信息</span><br>  _type  *_type           <span class="hljs-comment">// 具体类型的元信息</span><br>  hash   <span class="hljs-type">int32</span>            <span class="hljs-comment">// _type 里也有一个同样的 hash，此处多放一个是为了方便运行接口断言</span><br>  _      [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br>  fun    [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span>       <span class="hljs-comment">// 函数指针，指向具体类型所实现的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中值得注意的字段，个人理解如下：</p><ol><li><code>interface type</code>包含了一些关于 interface 本身的信息，比如<code>package path</code>，包含的<code>method</code>。这里的interfacetype 是定义 interface 的一种抽象表示。</li><li><code>_type</code>表示具体化的类型，与 eface 的 <code>_type</code> 类型相同。</li><li><code>hash</code>字段其实是对<code>_type.hash</code>的拷贝，它会在 interface 的实例化时，用于快速判断目标类型和接口中的类型是否一致。另，Go 的 interface 的 Duck-typing 机制也是依赖这个字段来实现。</li><li><code>fun</code>字段其实是一个动态大小的数组，虽然声明时是固定大小为 1，但在使用时会直接通过 fun 指针获取其中的数据，并且不会检查数组的边界，所以该数组中保存的元素数量是不确定的。</li></ol><hr><p>所以，People 拥有一个 Show 方法，属于非空接口，People 的内部定义是一个<code>iface</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>    Show()  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span> People &#123;<br>    <span class="hljs-keyword">var</span> stu *Student<br>    <span class="hljs-keyword">return</span> stu      <br>&#125;<br></code></pre></td></tr></table></figure><p>stu 是一个指向 nil 的空指针，但是最后<code>return stu</code> 会触发匿名变量 <code>People = stu</code> 值拷贝动作，所以最后<code>live()</code>放回给上层的是一个<code>People insterface&#123;&#125;</code>类型，也就是一个<code>iface struct&#123;&#125;</code>类型。 stu 为 nil，只是<code>iface</code>中的 data 为 nil 而已。 但是<code>iface struct&#123;&#125;</code>本身并不为 nil.</p><p>所以如下判断的结果为<code>BBBBBBB</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <br>    <span class="hljs-keyword">if</span> live() == <span class="hljs-literal">nil</span> &#123;  <br>        fmt.Println(<span class="hljs-string">&quot;AAAAAAA&quot;</span>)      <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;BBBBBBB&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承与多态的特点</title>
      <link href="/2023/05/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B9/"/>
      <url>/2023/05/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码能通过编译吗？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> People <span class="hljs-keyword">interface</span> &#123;<br>Speak(<span class="hljs-type">string</span>) <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> Speak(think <span class="hljs-type">string</span>) (talk <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> think == <span class="hljs-string">&quot;love&quot;</span> &#123;<br>talk = <span class="hljs-string">&quot;You are a good boy&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>talk = <span class="hljs-string">&quot;hi&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> peo People = Student&#123;&#125;<br>think := <span class="hljs-string">&quot;love&quot;</span><br>fmt.Println(peo.Speak(think))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​在接口类型的变量中持有的是对象的指针而不是对象本身，因此对于实现接口的类型，需要使用指针赋值给接口类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> peo People = Student&#123;&#125;<br></code></pre></td></tr></table></figure><p>​将 <code>Student&#123;&#125;</code> 的结构体字面量赋值给 <code>peo</code>，此时会发生编译错误，因为 <code>Student&#123;&#125;</code> 的类型是 <code>Student</code>，而不是 <code>*Student</code>。</p><p>要使代码通过编译，需要将 <code>Student&#123;&#125;</code> 转换为 <code>*Student</code> 类型的指针，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> peo People = &amp;Student&#123;&#125;<br></code></pre></td></tr></table></figure><p>这样，<code>peo</code> 变量持有的是 <code>*Student</code> 类型的指针，可以调用 <code>peo.Speak()</code> 方法。</p><p>以下解析来自 <a href="https://studygolang.com/interview/question">Go语言中文网</a></p><p>​继承与多态的特点</p><p>在 golang 中对多态的特点体现从语法上并不是很明显。</p><p>我们知道发生多态的几个要素：</p><p>1、有interface接口，并且有接口定义的方法。</p><p>2、有子类去重写interface的接口。</p><p>3、有父类指针指向子类的具体对象</p><p>那么，满足上述 3 个条件，就可以产生多态效果，就是，父类指针可以调用子类的具体方法。</p><p>所以上述代码报错的地方在 <code>var peo People = Student&#123;&#125;</code> 这条语句， <code>Student&#123;&#125;</code> 已经重写了父类 <code>People&#123;&#125;</code> 中的 <code>Speak(string) string</code> 方法，那么只需要用父类指针指向子类对象即可。（Go 中不叫父类，这里是为了好理解）</p><p>所以应该改成 <code>var peo People = &amp;Student&#123;&#125;</code> 即可编译通过。（People 为 interface 类型，就是指针类型）</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go程序设计语言》</title>
      <link href="/2023/05/28/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B/"/>
      <url>/2023/05/28/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>阅读本书，请点击：<a href="/file/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80.pdf">Go程序设计语言</a></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nil的使用</title>
      <link href="/2023/05/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/nil%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面赋值正确的是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">A. <span class="hljs-keyword">var</span> x = <span class="hljs-literal">nil</span><br>B. <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-literal">nil</span><br>C. <span class="hljs-keyword">var</span> x <span class="hljs-type">string</span> = <span class="hljs-literal">nil</span><br>D. <span class="hljs-keyword">var</span> x <span class="hljs-type">error</span> = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​BD。</p><p>​在 Go 语言中，nil 是一个预定义的标识符，用于表示空值或空指针。根据不同的类型，可以使用不同的方式来赋值为 nil。在选项 B 中，使用了空接口类型（interface{}），可以将其赋值为 nil。在选项 D 中，使用了 error 类型，也可以将其赋值为 nil。</p><p>​选项 A 和选项 C 是不正确的。在 Go 语言中，nil 不能直接赋值给变量，而且字符串类型和 nil 之间不存在直接赋值的语义。</p><p>​因此，选项 B 和选项 D 是正确的方式来将变量赋值为 nil。</p><p>以下解析来自 Go<a href="https://studygolang.com/interview/question">语言中文网</a></p><p>​参考答案及解析：BD。这道题考的知识点是 nil。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看它的源码就知道，所以 D 是对的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iota</title>
      <link href="/2023/05/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota/"/>
      <url>/2023/05/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/iota/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面代码能通过编译吗？如果可以，输出什么内容？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>x = <span class="hljs-literal">iota</span><br>_<br>y<br>z = <span class="hljs-string">&quot;zz&quot;</span><br>k <br>p = <span class="hljs-literal">iota</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>fmt.Println(x,y,z,k,p)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>可以通过编译，输出如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> zz zz <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​这里考察的知识点是<strong>iota</strong></p><p>​<strong>iota是golang语言的常量计数器,只能在常量的表达式中使用。</strong></p><p>​iota最初的值为0，并且会随着const的出现，进行自增长。在上述代码中，const表达式中有6个变量，故iota从初始化为0，然后自增到5。</p><p>​所以输出如上。</p><p>详情可以参考 <a href="https://www.cnblogs.com/zsy/p/5370052.html">连接</a></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值引用只读</title>
      <link href="/2023/05/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%AA%E8%AF%BB/"/>
      <url>/2023/05/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%AA%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>以下代码能否编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = student<br>list[<span class="hljs-string">&quot;student&quot;</span>].Name = <span class="hljs-string">&quot;LDB&quot;</span><br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​编译失败。</p><p><code>map[string]Student</code> 的 value 是一个 Student 结构值，所以当<code>list[&quot;student&quot;] = student</code>,是一个值拷贝过程。而<code>list[&quot;student&quot;]</code>则是一个值引用。那么值引用的特点是<code>只读</code>。所以对<code>list[&quot;student&quot;].Name = &quot;LDB&quot;</code>的修改是不允许的。</p><p><strong>方法一：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = student<br><span class="hljs-comment">//list[&quot;student&quot;].Name = &quot;LDB&quot;</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方法1:</span><br><span class="hljs-comment">    */</span><br>    tmpStudent := list[<span class="hljs-string">&quot;student&quot;</span>]<br>    tmpStudent.Name = <span class="hljs-string">&quot;LDB&quot;</span><br>    list[<span class="hljs-string">&quot;student&quot;</span>] = tmpStudent<br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment">方法1:</span><br><span class="hljs-comment">*/</span><br>tmpStudent := list[<span class="hljs-string">&quot;student&quot;</span>]<br>tmpStudent.Name = <span class="hljs-string">&quot;LDB&quot;</span><br>list[<span class="hljs-string">&quot;student&quot;</span>] = tmpStudent<br></code></pre></td></tr></table></figure><p>是先做一次值拷贝，做出一个<code>tmpStudent副本</code>,然后修改该副本，然后再次发生一次值拷贝复制回去，<code>list[&quot;student&quot;] = tmpStudent</code>,但是这种会在整体过程中发生 2 次结构体值拷贝，性能很差。</p><p><strong>方法二</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>list = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student)<br><br>student := Student&#123;<span class="hljs-string">&quot;Aceld&quot;</span>&#125;<br><br>list[<span class="hljs-string">&quot;student&quot;</span>] = &amp;student<br>list[<span class="hljs-string">&quot;student&quot;</span>].Name = <span class="hljs-string">&quot;LDB&quot;</span><br><br>fmt.Println(list[<span class="hljs-string">&quot;student&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将 map 的类型的 value 由 Student 值，改成 Student 指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> list <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Student<br></code></pre></td></tr></table></figure><p>这样，我们实际上每次修改的都是指针所指向的 Student 空间，指针本身是常指针，不能修改，<code>只读</code>属性，但是指向的 Student 是可以随便修改的，而且这里并不需要值拷贝。只是一个指针的赋值。</p><p>以上分析来自<a href="https://studygolang.com/interview/question">Go语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串连接</title>
      <link href="/2023/05/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5/"/>
      <url>/2023/05/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于字符串连接，下面语法正确的是？</p><ul><li>A. str :&#x3D; ‘abc’ + ‘123’</li><li>B. str :&#x3D; “abc” + “123”</li><li>C. str :&#x3D; ‘123’ + “abc”</li><li>D. fmt.Sprintf(“abc%d”, 123)</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BD</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在 Go 中，字符串连接使用双引号 <code>&quot;</code> 表示字符串字面值，而不是单引号 <code>&#39;</code>。因此，选项 B 中的 <code>&quot;abc&quot; + &quot;123&quot;</code> 表示将两个字符串连接起来，得到结果字符串 <code>&quot;abc123&quot;</code>。</p><p>​选项 A 中的单引号 <code>&#39;</code> 表示字符字面值，不能直接用于字符串连接。</p><p>​选项 C 中的 <code>&#39;123&#39;</code> 是无效的表达式，因为字符字面值只能包含一个字符。</p><p>​选项 D 使用 <code>fmt.Sprintf</code> 函数可以实现字符串格式化，将字符串和其他类型的值进行组合。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型定义和类型别名</title>
      <link href="/2023/05/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D/"/>
      <url>/2023/05/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否通过编译？如果通过，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> MyInt1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> MyInt2 = <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> =<span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> i1 MyInt1 = i <br><span class="hljs-keyword">var</span> i2 MyInt2 = i<br>fmt.Println(i1,i2)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。</p><p>​<code>type MyInt1 int</code>是创建了新类型MyInt1</p><p>​<code>type MyInt2 = int</code>是创建了int的类型别名MyInt2</p><p>​<code>var i1 MyInt1 = i </code>代码中相当于将int类型的变量赋值给MyInt类型的变量，Go是强类型语言，编译肯定不通过，</p><p>​而<code>var i2 MyInt2 = i</code>中的MyInt2只是int的别名，其本质还是int，所以可以赋值。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针变量访问成员变量</title>
      <link href="/2023/05/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
      <url>/2023/05/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>通过指针变量 p 访问其成员变量 name，有哪几种方式？（多选）</p><ul><li>A.p.name</li><li>B.(&amp;p).name</li><li>C.(*p).name</li><li>D.p-&gt;name</li></ul><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AC</span><br></code></pre></td></tr></table></figure><p>A. <code>p.name</code>：直接使用指针变量 <code>p</code> 访问其成员变量 <code>name</code>。</p><p>C. <code>(*p).name</code>：通过解引用指针变量 <code>p</code>，然后访问其成员变量 <code>name</code>。</p><p>B. <code>(&amp;p).name</code> 是不正确的，因为 <code>&amp;p</code> 表示取 <code>p</code> 的地址，得到的是一个指向指针变量 <code>p</code> 的指针，而非指针变量 <code>p</code> 自身。</p><p>D. <code>p-&gt;name</code> 是 C&#x2F;C++ 中的语法，而在 Go 中是不支持的。</p><p>参考程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> F <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := F&#123;<br>name: <span class="hljs-string">&quot;ft&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> p *F <span class="hljs-comment">// 将指针类型声明为 *F</span><br>p = &amp;f<br>fmt.Println(p)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短变量声明</title>
      <link href="/2023/05/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
      <url>/2023/05/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否通过编译，如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span>(<br>size := <span class="hljs-number">1024</span><br>max_size = size*<span class="hljs-number">2</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(size,max_size)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。</p><p><code>:=</code>是短变量声明，可以用来声明和初始化局部变量。题目中的<code>var</code>也是用来声明变量的，故这里会报错。</p><p>对于短变量声明的使用，有以下限制</p><ol><li>必须使用显示初始化</li><li>不能提供数据类型</li><li>只能在函数内使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make+append</title>
      <link href="/2023/05/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make-append/"/>
      <url>/2023/05/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/make-append/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>写出程序的运行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br>    fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3]<br></code></pre></td></tr></table></figure><p>解析：使用make关键字，不仅会分配内存，还会对变量进行初始化，这里将长度为10的切片全部初始化为0。</p><p>​然后用append往里面添加元素，就在10个0后面追加3个元素，即答案。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>append</title>
      <link href="/2023/05/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append/"/>
      <url>/2023/05/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：跟前两天的重复，当作复习了"><a href="#题目：跟前两天的重复，当作复习了" class="headerlink" title="题目：跟前两天的重复，当作复习了"></a>题目：<span id="more"></span>跟前两天的重复，当作复习了</h1><p>下面这段代码能否通过编译，如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。append()的第二个参数不能直接使用slice，需要使用…操作符，将一个切片追加到另一个切片上:<code>append(s1, s2...)</code>。或者直接跟上元素，形如:append(s1, 1, 2, 3)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2...)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对指针执行append操作</title>
      <link href="/2023/05/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9%E6%8C%87%E9%92%88%E6%89%A7%E8%A1%8Cappend%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/05/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9%E6%8C%87%E9%92%88%E6%89%A7%E8%A1%8Cappend%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>list = <span class="hljs-built_in">append</span>(list, <span class="hljs-number">1</span>)<br>fmt.Println(list)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>​不能通过编译，new([]int) 之后的 list 是一个 <code>*[]int</code> 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。</p><p>正确的使用方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>*list = <span class="hljs-built_in">append</span>(*list, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Println(*list)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量取地址</title>
      <link href="/2023/05/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%8F%96%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/05/17/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%B8%B8%E9%87%8F%E5%8F%96%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面代码有什么问题？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> cl = <span class="hljs-number">100</span><br><br><span class="hljs-keyword">var</span> bl = <span class="hljs-number">123</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    <span class="hljs-built_in">println</span>(&amp;bl,bl)<br>    <span class="hljs-built_in">println</span>(&amp;cl,cl)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析:"></a>答案解析:</h2><p>在 Go 语言中，常量在编译时被解析和计算，并直接嵌入到生成的可执行文件中。这意味着在程序运行时，常量的值已经被硬编码到了指令中，而不需要为其分配内存空间。</p><p>常量的值在编译阶段就已经确定，并且是不可变的。由于常量的值是固定的，编译器可以直接将其替换为字面值。因此，在运行时并不需要为常量分配内存空间，也不需要为其保存内存地址。</p><p>与常量不同，变量的值是在运行时动态确定的，因此需要为变量分配内存空间，并且变量在内存中有对应的地址。</p><p>总结起来，常量在编译时被解析和计算，并且其值直接嵌入到生成的可执行文件中，因此不占用内存地址。而变量的值在运行时确定，需要为其分配内存空间，并且具有对应的内存地址。</p><p>以下解析来自 Go<a href="https://studygolang.com/interview/question">语言中文网</a></p><p>考点：<strong>常量</strong></p><p>常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cannot take the address of cl<br></code></pre></td></tr></table></figure><p>内存四区概念：</p><h4 id="A-数据类型本质："><a href="#A-数据类型本质：" class="headerlink" title="A.数据类型本质："></a>A.数据类型本质：</h4><p>固定内存大小的别名</p><h4 id="B-数据类型的作用："><a href="#B-数据类型的作用：" class="headerlink" title="B. 数据类型的作用："></a>B. 数据类型的作用：</h4><p>编译器预算对象(变量)分配的内存空间大小。</p><h4 id="C-内存四区"><a href="#C-内存四区" class="headerlink" title="C. 内存四区"></a>C. 内存四区</h4><p>流程说明</p><p>1、操作系统把物理硬盘代码load到内存</p><p>2、操作系统把c代码分成四个区</p><p>3、操作系统找到main函数入口执行</p><h5 id="栈区-Stack-："><a href="#栈区-Stack-：" class="headerlink" title="栈区(Stack)："></a>栈区(Stack)：</h5><p>空间较小，要求数据读写性能高，数据存放时间较短暂。由编译器自动分配和释放，存放函数的参数值、函数的调用流程方法地址、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区)</p><h5 id="堆区-heap"><a href="#堆区-heap" class="headerlink" title="堆区(heap):"></a>堆区(heap):</h5><p>空间充裕，数据存放时间较久。一般由开发者分配及释放(但是Golang中会根据变量的逃逸现象来选择是否分配到栈上或堆上)，启动Golang的GC由GC清除机制自动回收。</p><h5 id="全局区-静态全局变量区"><a href="#全局区-静态全局变量区" class="headerlink" title="全局区-静态全局变量区:"></a>全局区-静态全局变量区:</h5><p>全局变量的开辟是在程序在<code>main</code>之前就已经放在内存中。而且对外完全可见。即作用域在全部代码中，任何同包代码均可随时使用，在变量会搞混淆，而且在局部函数中如果同名称变量使用<code>:=</code>赋值会出现编译错误。</p><p>全局变量最终在进程退出时，由操作系统回收。</p><blockquote><p>我么在开发的时候，尽量减少使用全局变量的设计</p></blockquote><h6 id="全局区-常量区："><a href="#全局区-常量区：" class="headerlink" title="全局区-常量区："></a>全局区-常量区：</h6><p>常量区也归属于全局区，常量为存放数值字面值单位，即不可修改。或者说的有的常量是直接挂钩字面值的。</p><p>比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> cl = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>cl是字面量10的对等符号。</p><p>所以在golang中，常量是无法取出地址的，因为字面量符号并没有地址而言。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体比较</title>
      <link href="/2023/05/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83/"/>
      <url>/2023/05/16/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>下面代码是否可以编译通过？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>sn1 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br>sn2 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br><span class="hljs-keyword">if</span> sn1 == sn2 &#123;<br>fmt.Println(<span class="hljs-string">&quot;sn1 == sn2&quot;</span>)<br>&#125;<br><br>sm1 := <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>m   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, m: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;<br><br>sm2 := <span class="hljs-keyword">struct</span> &#123;<br>age <span class="hljs-type">int</span><br>m   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, m: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;<br><br><span class="hljs-keyword">if</span> sm1 == sm2 &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 == sm2&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>编译不通过，因为map属于不可比较类型。</p><blockquote><p>.&#x2F;prog.go:31:9: invalid operation: sm1 &#x3D;&#x3D; sm2 (struct containing map[string]string cannot be compared)</p></blockquote><p>考点：结构体比较</p><blockquote><p>结构体比较规则注意1：只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。</p></blockquote><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">sn1 := <span class="hljs-keyword">struct</span> &#123;<br>age  <span class="hljs-type">int</span><br>name <span class="hljs-type">string</span><br>&#125;&#123;age: <span class="hljs-number">11</span>, name: <span class="hljs-string">&quot;qq&quot;</span>&#125;<br><br>sn3:= <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-type">string</span><br>    age  <span class="hljs-type">int</span><br>&#125;&#123;age:<span class="hljs-number">11</span>, name:<span class="hljs-string">&quot;qq&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><code>sn3</code>与<code>sn1</code>就不是相同的结构体了，不能比较。</p><blockquote><p><strong>结构体比较规则注意2</strong>：结构体是相同的，但是结构体属性中有不可以比较的类型，如<code>map</code>,<code>slice</code>，则结构体不能用<code>==</code>比较。</p></blockquote><p>可以使用reflect.DeepEqual进行比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reflect.DeepEqual(sm1, sm2) &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 == sm2&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;sm1 != sm2&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://studygolang.com/interview/question">文章出处</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于len的细节</title>
      <link href="/2023/05/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Elen%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>/2023/05/15/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%85%B3%E4%BA%8Elen%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">const</span> s = <span class="hljs-string">&quot;Go101.org&quot;</span><br><br><span class="hljs-comment">// len(s) == 9</span><br><span class="hljs-comment">// 1 &lt;&lt; 9 == 512</span><br><span class="hljs-comment">// 512 / 128 == 4</span><br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>A、0 0；B、0 4；C：4 0；D：4 4</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>答案是 4 0（即选 C）。</p><p>不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所以会重新思考。</p><p>好几个群都问，为什么结果会是 4 0，希望我解释下。因此有了此文。</p><p>这个小题涉及到几个知识点。</p><h2 id="len-函数的结果"><a href="#len-函数的结果" class="headerlink" title="len 函数的结果"></a>len 函数的结果</h2><p>要注意，len 是一个内置函数。在官方标准库文档<a href="https://docs.studygolang.com/pkg/builtin/#len">关于 len 函数</a> 有这么一句：</p><blockquote><p>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification’s “Length and capacity” section for details.</p></blockquote><p>明确支持，当参数是字符串字面量和简单 array 表达式，len 函数返回值是常量，这很重要。</p><p>上题中，如果 <code>const s = &quot;Go101.org”</code> 改为 <code>var s = &quot;Go101.org&quot;</code> 结果又会是什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;Go101.org&quot;</span><br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是 0 0。</p><p>但改为这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> s = [<span class="hljs-number">9</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>&#125;<br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果又是 4 0。</p><p>接着看文档那句话的后半句，查看 Go 语言规范中<a href="https://hao.studygolang.com/golang_spec.html#id221">关于长度和容量的说明</a> 。</p><blockquote><p>内置函数 len 和 cap 获取各种类型的实参并返回一个 int 类型结果。实现会保证结果总是一个 int 值。</p><p>如果 s 是一个字符串常量，那么 len(s) 是一个常量 。如果 s 类型是一个数组或到数组的指针且表达式 s 不包含 信道接收 或（非常量的） 函数调用的话， 那么表达式 len(s) 和 cap(s) 是常量；这种情况下， s 是不求值的。否则的话， len 和 cap 的调用结果不是常量且 s 会被求值。</p></blockquote><p>可见题目中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s) / <span class="hljs-number">128</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">byte</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">len</span>(s[:]) / <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure><p>第一句的 len(s) 是常量（因为 s 是字符串常量）；而第二句的 len(s[:]) 不是常量。这是这两条语句的唯一区别：两个 len 的返回结果数值并无差异，都是 9，但一个是常量一个不是。</p><h2 id="关于位移操作"><a href="#关于位移操作" class="headerlink" title="关于位移操作"></a>关于位移操作</h2><p>根据上面的分析，现在问题的关键在于位移运算这里。Go 语言规范中有<a href="https://docs.studygolang.com/ref/spec#Operators">这么一句</a> ：</p><blockquote><p>The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.</p></blockquote><p>大意是：在位移表达式的右侧的操作数必须为整数类型，或者可以被 uint 类型的值所表示的无类型的常量。如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。</p><p>这里的关键在于常量位移表达式。根据上文的分析，<code>1 &lt;&lt; len(s)</code> 是常量位移表达式，而 <code>1 &lt;&lt; len(s[:])</code> 不是。</p><p>规范上关于常量表达式中，还有<a href="https://docs.studygolang.com/ref/spec#Constant_expressions">这么一句</a> ：</p><blockquote><p>If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.</p></blockquote><p>大意是：如果常量 位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ）</p><p>因此对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code> 是一个常量位移表达式，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</p><p>而对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，因为 <code>1 &lt;&lt; len(s[:])</code> 不是一个常量位移表达式，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型）。</p><p>为什么是 byte 类型，大家可能还是有点晕。这要回到关于常量的说明上。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是在编译的时候进行计算的。在 Go 语言中，常量分两种：无类型和有类型。Go 规范上说，字面值常量， true , false , iota 以及一些仅包含无类型的恒定操作数的 常量表达式 是无类型的。</p><p>那有类型常量是怎么来的呢？一般有两种：显示声明或隐式得到。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">23</span><br><span class="hljs-keyword">const</span> b <span class="hljs-type">float32</span> = <span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>无类型常量都有一个默认类型（无类型常量的默认类型分别是 bool , rune , int , float64 , complex128 或 string）。当在上下文中需要请求该常量为一个带类型的值时，这个 默认类型 便指向该常量隐式转换后的类型。</p><p>所以 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code> 中，根据规范定义，1 会隐式转换为 byte 类型，因此 <code>1 &lt;&lt; len(s[:])</code> 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一道很具迷惑性的题目引出这么多小知识点。可能有人要喷：讨论这些有什么用？这也太细节了。我想说的是，Go 语言规范，细节点很多，能多掌握一些没坏处，说不定将来实际工作就遇到了类似的问题呢？！以上的知识点，很细节，但我认为也是挺有价值的。</p><p>当然了，你怎么说都行，你都是对的，你开心就好！</p><p>答案来自：<a href="https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/">https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interface</title>
      <link href="/2023/05/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/interface/"/>
      <url>/2023/05/14/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/interface/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>Go 1.15 中 var i interface{} &#x3D; a 会有额外堆内存分配吗？</p><p>具体代码是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a  <span class="hljs-type">int</span> = <span class="hljs-number">3</span><br><span class="hljs-comment">// 以下有额外内存分配吗？</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = a<br></code></pre></td></tr></table></figure><p>查看答案</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p>在 Go 中，接口被实现为一对指针（请参阅 Russ Cox 的 Go 数据结构：<a href="https://research.swtch.com/interfaces">接口</a>）：指向有关类型信息的指针和指向值的指针。可以简单的表示为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br>    tab  *itab<br>    data unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 tab 是指向类型信息的指针；data 是指向值的指针。因此，一般来说接口意味着必须在堆中动态分配该值。</p><p>然而，**<a href="https://docs.studygolang.com/doc/go1.15">Go 1.15 发行说明</a>**在 runtime 部分中提到了一个有趣的改进：</p><blockquote><p>Converting a small integer value into an interface value no longer causes allocation.</p></blockquote><p>意思是说，将小整数转换为接口值不再需要进行内存分配。小整数是指 0 到 255 之间的数。</p><p>我们实际简单测试一下。</p><p>创建一个包 smallint，在包中创建文件 smallint.go，加上如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> smallint<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Convert</span><span class="hljs-params">(val <span class="hljs-type">int</span>)</span></span> []<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>        slice[i] = val<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> slice<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更好的看到效果，函数中进行了 100 次 int 到 interface 的转换。写个基准测试 smallint_test.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> smallint_test<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;testing&quot;</span><br>    <span class="hljs-string">&quot;test/smallint&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkConvert</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>        result := smallint.Convert(<span class="hljs-number">12</span>)<br>        _ = result<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分别使用 Go1.14 和 Go1.15 版本进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go version<br>go version go1.14.7 darwin/amd64<br>$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8      569830       1966 ns/op     2592 B/op      101 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 1.647s<br>$ go version<br>go version go1.15 darwin/amd64<br>$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8     1859451        655 ns/op     1792 B/op        1 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 2.178s<br></code></pre></td></tr></table></figure><p>接着讲 smallint_test.go 中调用 Convert 的参数由 12 改为 256，再次使用 Go1.15 运行，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -bench . -benchmem ./...<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-built_in">test</span>/smallint<br>BenchmarkConvert-8      551546       2049 ns/op     2592 B/op      101 allocs/op<br>PASS<br>ok   <span class="hljs-built_in">test</span>/smallint 1.502s<br></code></pre></td></tr></table></figure><p>证明了上面提到的优化点。</p><p>那么，你想过它大概怎么实现的吗？因为上文提到，Go 中接口的实现，使用一个指针字段指向接口值。现在竟然不再额外进行内存分配，说明做了什么特殊的事情。</p><p>其实答案非常简单。如果你对 Python、Java 等语言熟悉，应该知道大概如何实现的。Go 中如何做的，可以在 <strong><a href="https://go-review.googlesource.com/c/go/+/216401">Go CL 216401</a></strong> 中（合并到**<a href="https://github.com/golang/go/commit/9828c43288a53d3df75b1f73edad0d037a91dff8">此提交</a>**中了，GitHub 上更易于阅读）找到。具体来说就是 Go 中定义了一个特殊的静态数组，该数组由 256 个整数组成（0 到 255）。当必须分配内存以将整数存储在堆上，并将其转换为接口的一部分时，它首先检查是否它可以只返回指向数组中适当元素的指针。这种经常使用的值的静态分配，是一种很常见的优化手段。例如，Python 对小整数执行类似的操作，Java 也有常量池，进行类似的优化处理。</p><p>实际上，Go 以前有一个优化，如果你将 0 转换为接口值，它将返回一个指向特殊静态零值的指针。这次新的 0-255 优化替代了该值。</p><p>对具体实现细节感兴趣的，可以阅读下上文提到的提交。</p><p>答案解析来自：<a href="https://mp.weixin.qq.com/s/1r0nt8nA3foDRRrbRp4omg">https://mp.weixin.qq.com/s/1r0nt8nA3foDRRrbRp4omg</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按位或操作符</title>
      <link href="/2023/05/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%89%E4%BD%8D%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2023/05/13/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%8C%89%E4%BD%8D%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>以下代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a, b <span class="hljs-type">float64</span> = <span class="hljs-number">1.0</span>, <span class="hljs-number">4.0</span><br>fmt.Println(a | b)<br>&#125;<br></code></pre></td></tr></table></figure><p>A：5；B：+Inf；C：panic；D：不能编译</p><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>正确答案：D</p><p><code>|</code> 操作是按位或操作符，它的操作数只能是整数，而上面这道题的操作数是 float64，因此编译不通过。</p><p>这是 Go 规范的内容 <a href="https://docs.studygolang.com/ref/spec#Arithmetic_operators%EF%BC%9A">https://docs.studygolang.com/ref/spec#Arithmetic_operators：</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">+    <span class="hljs-built_in">sum</span>                    integers, floats, complex values, strings<br>-    difference             integers, floats, complex values<br>*    product                integers, floats, complex values<br>/    quotient               integers, floats, complex values<br>%    remainder              integers<br><br>&amp;    bitwise AND            integers<br>|    bitwise OR             integers<br>^    bitwise XOR            integers<br>&amp;^   bit clear (AND NOT)    integers<br><br>&lt;&lt;   <span class="hljs-string">left shift             integer &lt;&lt; integer &gt;= 0</span><br><span class="hljs-string">&gt;&gt;   right shift            integer &gt;&gt; integer &gt;= 0</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>append的使用</title>
      <link href="/2023/05/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/12/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/append%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否通过编译，如果可以，输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>​不能通过编译。append()的第二个参数不能直接使用slice，需要使用…操作符，将一个切片追加到另一个切片上:<code>append(s1, s2...)</code>。或者直接跟上元素，形如:append(s1, 1, 2, 3)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s2 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>&#125;<br>s1 = <span class="hljs-built_in">append</span>(s1, s2...)<br>fmt.Println(s1)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new的易错点</title>
      <link href="/2023/05/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/"/>
      <url>/2023/05/11/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>list := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>list = <span class="hljs-built_in">append</span>(list, <span class="hljs-number">1</span>)<br>fmt.Println(list)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​不能通过编译，new([]int) 之后的 list 是一个 <code>*[]int</code> 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。</p><p>​如果想要用，应该解引用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">list := *<span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>​输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1]</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言高性能编程》</title>
      <link href="/2023/05/10/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
      <url>/2023/05/10/%E9%98%85%E8%AF%BB/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://geektutu.com/post/high-performance-go.html">Go 语言高性能编程 | 极客兔兔 (geektutu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go高性能编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new和make的区别</title>
      <link href="/2023/05/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/05/10/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>new()和make()的区别？</p><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p><code>new</code>和<code>make</code>都是Go语言中用来分配内存的内置函数，但是他们的用途不同。</p><p>​<code>new</code>函数用于为任何类型分配内存，它返回指向新分配了类型零值的指针。例如<code>new(int)</code>返回一个指向新分配的<code>int</code>类型零值的指针。</p><p>​<code>make</code>函数只能用于创建引用类型的变量，如<strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>类型。它会为引用类型的变量分配内存，并初始化该类型的值，并返回该变量的引用，即可以通过该变量访问和修改切片中的元素。</p><p>​简而言之，<code>new</code>只分配内存，而<code>make</code>除了分配内存外，还会初始化值。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>init函数</title>
      <link href="/2023/05/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0/"/>
      <url>/2023/05/09/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/init%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>init() 函数是什么时候执行的？</p><h3 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h3><p><code>init()</code> 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证。</p><p>一句话总结： import –&gt; const –&gt; var –&gt; <code>init()</code> –&gt; <code>main()</code></p><p>答案解析来自：<a href="https://geektutu.com/post/qa-golang-2.html#Q1-init-%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F">init() 函数是什么时候执行的？</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go好文分享</title>
      <link href="/2023/05/08/Go/Go%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB/"/>
      <url>/2023/05/08/Go/Go%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="好文链接如下"><a href="#好文链接如下" class="headerlink" title="好文链接如下"></a>好文链接如下<span id="more"></span></h1><blockquote><p>本文所有内容来自Go语言中文网的转载，用于自己方便学习。</p></blockquote><h4 id="185期"><a href="#185期" class="headerlink" title="185期"></a>185期</h4><h5 id="1-如何解决-Go-with-Grafana-Pyroscope-中的内存泄漏问题"><a href="#1-如何解决-Go-with-Grafana-Pyroscope-中的内存泄漏问题" class="headerlink" title="1.如何解决 Go with Grafana Pyroscope 中的内存泄漏问题"></a>1.<a href="https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/">如何解决 Go with Grafana Pyroscope 中的内存泄漏问题</a></h5><h5 id="2-为什么-defer-的执行顺序和注册顺序不同？✔"><a href="#2-为什么-defer-的执行顺序和注册顺序不同？✔" class="headerlink" title="2.为什么 defer 的执行顺序和注册顺序不同？✔"></a>2.<a href="https://mp.weixin.qq.com/s/xpjNOwn1kNICQE4TmjpQZg">为什么 defer 的执行顺序和注册顺序不同？</a>✔</h5><h5 id="3-Go-语言中没有枚举类型，但是我们可以这样做✔"><a href="#3-Go-语言中没有枚举类型，但是我们可以这样做✔" class="headerlink" title="3.Go 语言中没有枚举类型，但是我们可以这样做✔"></a>3.<a href="https://mp.weixin.qq.com/s/QFr_Pgt9GzOG3zlgcXEVwQ">Go 语言中没有枚举类型，但是我们可以这样做</a>✔</h5><h5 id="4-Go-单元测测时尽量用-fake-object"><a href="#4-Go-单元测测时尽量用-fake-object" class="headerlink" title="4.Go 单元测测时尽量用 fake object"></a>4.<a href="https://mp.weixin.qq.com/s/yycu10nLvpC0XiRemSy3lA">Go 单元测测时尽量用 fake object</a></h5><h4 id="184期"><a href="#184期" class="headerlink" title="184期"></a>184期</h4><h5 id="1-最小的Go二进制"><a href="#1-最小的Go二进制" class="headerlink" title="1.最小的Go二进制"></a>1.<a href="https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb">最小的Go二进制</a></h5><h5 id="2-Go-开发命令行程序指南"><a href="#2-Go-开发命令行程序指南" class="headerlink" title="2.Go 开发命令行程序指南"></a>2.<a href="https://mp.weixin.qq.com/s/Qyp35Q6UjtZHfwkDUWbEog">Go 开发命令行程序指南</a></h5><h5 id="3-如何用一个端口同时暴露-HTTP1-x2F-2、gRPC-协议？"><a href="#3-如何用一个端口同时暴露-HTTP1-x2F-2、gRPC-协议？" class="headerlink" title="3.如何用一个端口同时暴露 HTTP1&#x2F;2、gRPC 协议？"></a>3.<a href="https://mp.weixin.qq.com/s/e-QNv5-Ip2EcDp-S6CuXEg">如何用一个端口同时暴露 HTTP1&#x2F;2、gRPC 协议？</a></h5><h5 id="4-Go-测试综合指南"><a href="#4-Go-测试综合指南" class="headerlink" title="4.Go 测试综合指南"></a>4.<a href="https://blog.jetbrains.com/zh-hans/go/2023/01/03/comprehensive-guide-to-testing-in-go/">Go 测试综合指南</a></h5><h4 id="183期"><a href="#183期" class="headerlink" title="183期"></a>183期</h4><h5 id="1、-为什么-Go-不支持-T-转换为-interface"><a href="#1、-为什么-Go-不支持-T-转换为-interface" class="headerlink" title="1、[为什么 Go 不支持 ]T 转换为 []interface"></a>1、[为什么 Go 不支持 <a href="https://mp.weixin.qq.com/s/lG-sswO8i6w_6sMztvyOjw">]T 转换为 []interface</a></h5><h5 id="2、Golang反射学习：手写一个RPC"><a href="#2、Golang反射学习：手写一个RPC" class="headerlink" title="2、Golang反射学习：手写一个RPC"></a>2、<a href="https://mp.weixin.qq.com/s/PzfiMXiYjfGQFHW_0hTS4A">Golang反射学习：手写一个RPC</a></h5><h5 id="3、如何用-Go-进行正确的性能剖析？"><a href="#3、如何用-Go-进行正确的性能剖析？" class="headerlink" title="3、如何用 Go 进行正确的性能剖析？"></a>3、<a href="https://blog.pickme.lk/how-to-get-profiling-right-with-go-813ff89d4757">如何用 Go 进行正确的性能剖析？</a></h5><h5 id="4、gRPC-监控对高性能系统的重要性"><a href="#4、gRPC-监控对高性能系统的重要性" class="headerlink" title="4、gRPC 监控对高性能系统的重要性"></a>4、<a href="https://www.groundcover.com/blog/grpc-monitoring">gRPC 监控对高性能系统的重要性</a></h5><h5 id="5、gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？"><a href="#5、gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？" class="headerlink" title="5、gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？"></a>5、<a href="https://mp.weixin.qq.com/s/BHrxHQrMKZrhb34hR3La5w">gin框架中Context的Get、Query、Param函数都是从哪里获取数据的？</a></h5><h5 id="6、Go-Mutex：保护并发访问共享资源的利器"><a href="#6、Go-Mutex：保护并发访问共享资源的利器" class="headerlink" title="6、Go Mutex：保护并发访问共享资源的利器"></a>6、<a href="https://mp.weixin.qq.com/s/y6lppalSRwLhCjS9yQYuUQ">Go Mutex：保护并发访问共享资源的利器</a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>空结构体</title>
      <link href="/2023/05/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2023/05/08/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>空 struct{} 占多少空间？有什么用途？</p><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(unsafe.Sizeof(<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>set := <span class="hljs-built_in">make</span>(Set)<br><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125; &#123;<br>set[item] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>fmt.Println(<span class="hljs-built_in">len</span>(set)) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">if</span> _, ok := set[<span class="hljs-string">&quot;A&quot;</span>]; ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;A exists&quot;</span>) <span class="hljs-comment">// A exists</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-ch<br><span class="hljs-comment">// do something</span><br>&#125;()<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，声明只包含方法的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Lamp <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> On() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;On&quot;</span>)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> Off() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Off&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>答案解析来源：<a href="https://geektutu.com/post/qa-golang-1.html#Q16-%E7%A9%BA-struct-%E7%9A%84%E7%94%A8%E9%80%94">空 struct{} 的用途</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何确认两个map是否相等</title>
      <link href="/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E4%B8%A4%E4%B8%AAmap%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
      <url>/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E4%B8%A4%E4%B8%AAmap%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：<span id="more"></span></h1><p>​如何确认两个map是否相等？</p><h4 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h4><p>map 深度相等的条件：</p><ol><li>都为 nil</li><li>非空、长度相等，指向同一个 map 实体对象</li><li>相应的 key 指向的 value “深度”相等</li></ol><p>直接将使用 map1 &#x3D;&#x3D; map2 是错误的。这种写法只能比较 map 是否为 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> n <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br>fmt.Println(m == <span class="hljs-literal">nil</span>)<br>fmt.Println(n == <span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">// 不能通过编译</span><br><span class="hljs-comment">//fmt.Println(m == n)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>因此只能是遍历 map 的每个元素，比较元素是否都是深度相等。</p><p>答案解析来自：<a href="https://golang.design/go-questions/map/compare/">https://golang.design/go-questions/map/compare/</a></p><p>其实还可以采用反射进行判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>( <br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;relflect&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> n <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br>    fmt.Println(reflect.DeepEqual(m,n))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对map的元素取地址</title>
      <link href="/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9map%E7%9A%84%E5%85%83%E7%B4%A0%E5%8F%96%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/05/07/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%AF%B9map%E7%9A%84%E5%85%83%E7%B4%A0%E5%8F%96%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h4><p>​以下代码能否成功编译通过？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>fmt.Println(&amp;m[<span class="hljs-string">&quot;qcrao&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>​这段代码是错误的，会引起编译错误。</p><p>​原因是 <code>&amp;m[&quot;qcrao&quot;]</code> 语句是无效的，因为 <code>m[&quot;qcrao&quot;]</code> 返回的是一个值，而非一个变量，所以不能对其取地址。</p><p>​如果需要对 map 中的某个值取地址，应该先将其赋值给一个变量，再对变量取地址。例如，可以修改代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>    value := m[<span class="hljs-string">&quot;qcrao&quot;</span>]<br>    fmt.Println(&amp;value)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的返回值</title>
      <link href="/2023/05/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
      <url>/2023/05/05/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码有什么缺陷：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span>(total <span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> x+y, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>​第二个返回值没有命名。</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号（）；如果只有要给返回值且命名也必须加上括号。这里第一个返回值有命名total，第二个没有命名，所以错误。</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//两个都加上命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (total <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> x + y, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">//两个都不命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> x + y, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map可以边遍历边删除吗</title>
      <link href="/2023/05/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E5%8F%AF%E4%BB%A5%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4%E5%90%97/"/>
      <url>/2023/05/04/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E5%8F%AF%E4%BB%A5%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E5%88%A0%E9%99%A4%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><p>Go 的 map 可以边遍历边删除吗？</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>​map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。</p><p>上面说的是发生在多个协程同时读写同一个 map 的情况下。 如果在同一个协程内边遍历边删除，并不会检测到同时读写，理论上是可以这样做的。但是，遍历的结果就可能不会是相同的了，有可能结果遍历结果集中包含了删除的 key，也有可能不包含，这取决于删除 key 的时间：是在遍历到 key 所在的 bucket 时刻前或者后。</p><p>一般而言，这可以通过读写锁来解决：sync.RWMutex。</p><p>读之前调用 RLock() 函数，读完之后调用 RUnlock() 函数解锁；写之前调用 Lock() 函数，写完之后，调用 Unlock() 解锁。</p><p>另外，sync.Map 是线程安全的 map，也可以使用。</p><p>参考答案来自：<a href="https://golang.design/go-questions/map/delete-on-range/">https://golang.design/go-questions/map/delete-on-range/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用append向slice添加元素</title>
      <link href="/2023/05/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%94%A8append%E5%90%91slice%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0/"/>
      <url>/2023/05/03/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%94%A8append%E5%90%91slice%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面两段代码输出什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    fmt.Println(s)<br>&#125;<br><br><span class="hljs-comment">// 2.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br><span class="hljs-number">2.</span>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ol><li>创建了一个长度为5的整数切片因为是使用make创建了，故是创建并初始化为0，然后将1、2、3三个整数追加到切片的末尾，最终输出切片的所有元素。由于append函数会自动扩容切片，因此最终输出的是一个长度为8的整数切片，包含5个0和1、2、3三个整数。</li><li>这段代码创建了一个空的整数切片，然后将1、2、3、4四个整数追加到切片的末尾，最终输出切片的所有元素。由于append函数会自动扩容切片，因此最终输出的是一个长度为4的整数切片，包含1、2、3、4四个整数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map为什么是无序的？</title>
      <link href="/2023/05/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%9F/"/>
      <url>/2023/05/02/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/map%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>map 的 key 为什么是无序的？</p><p>在遍历 map 的时候，我们会发现，输出的 key 是无序的。为什么？</p><h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>​map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。</p><p>​当然，如果我就一个 hard code 的 map，我也不会向 map 进行插入删除的操作，按理说每次遍历这样的 map 都会返回一个固定顺序的 key&#x2F;value 序列吧。的确是这样，但是 Go 杜绝了这种做法，因为这样会给新手程序员带来误解，以为这是一定会发生的事情，在某些情况下，可能会酿成大错。</p><p>​当然，Go 做得更绝，当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key&#x2F;value 对了。</p><p>​多说一句，“迭代 map 的结果是无序的”这个特性是从 go 1.0 开始加入的。</p><p>答案解析来自：<a href="https://golang.design/go-questions/map/unordered/">https://golang.design/go-questions/map/unordered/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer_执行顺序</title>
      <link href="/2023/05/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/05/01/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/defer-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:<span id="more"></span></h1><p>下面这段代码输出的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">package main<br><br>import (<br>    &quot;fmt&quot;<br>)<br><br>func main() &#123;<br>    defer_call()<br>&#125;<br><br>func defer_call() &#123;<br>    defer func() &#123; fmt.Println(&quot;打印前&quot;) &#125;()<br>    defer func() &#123; fmt.Println(&quot;打印中&quot;) &#125;()<br>    defer func() &#123; fmt.Println(&quot;打印后&quot;) &#125;()<br><br>    panic(&quot;触发异常&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">打印后<br>打印中<br>打印前<br>panic: 触发异常<br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在函数返回或者发生panic时，defer语句会按照先进后出的顺序执行，若是因为发生panic退出函数，则最后再执行panic语句。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再练for-range</title>
      <link href="/2023/04/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%86%8D%E7%BB%83for-range/"/>
      <url>/2023/04/30/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%86%8D%E7%BB%83for-range/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>下面这段代码输出的是什么？请说明原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> key,val := <span class="hljs-keyword">range</span> slice &#123;<br>m[key] = &amp;val<br>&#125;<br><br><span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k,<span class="hljs-string">&quot;-&gt;&quot;</span>,*v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">3</span> -&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​for range 循环的时候会创建每个元素的副本，而不是元素的引用。</p><p>​在使用<strong>for-range</strong>循环里，每次遍历使用的val都是对同一个元素的遍历赋值，故在第一个for循环里，每次使用的都是<strong>val</strong>的元素进行赋值，即map中所有的元素的值都是变量val的地址。</p><p>​在最后一次遍历时，<strong>val</strong>指向slice的最后一个元素的地址，即3的地址。故最后的输出都是3。</p><h4 id="正确的写法："><a href="#正确的写法：" class="headerlink" title="正确的写法："></a>正确的写法：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> slice &#123;<br>v := val<br>m[key] = &amp;v<br>&#125;<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(k, <span class="hljs-string">&quot;-&gt;&quot;</span>, *v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型断言</title>
      <link href="/2023/04/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
      <url>/2023/04/29/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>如果 Add() 函数的调用代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a Integer = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b Integer = <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = &amp;a<br>sum := i.(*Integer).Add(b)<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>则Add函数定义正确的是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">A.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span></span> Add(b Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br>B.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Integer)</span></span> Add(b *Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> a + *b<br>&#125;<br><br>C.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span></span> Add(b Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> *a + b<br>&#125;<br><br>D.<br><span class="hljs-keyword">type</span> Integer <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Integer)</span></span> Add(b *Integer) Integer &#123;<br>        <span class="hljs-keyword">return</span> *a + *b<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AC</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​在 <code>main</code> 函数中，<code>i</code> 被定义为一个接口类型的变量，它的值是指向变量 <code>a</code> 的指针。当调用 <code>Add</code> 函数时，使用了类型断言 <code>i.(*Integer)</code> 来将接口类型的变量 <code>i</code> 转换为 <code>*Integer</code> 类型。类型断言的语法为 <code>x.(T)</code>，其中 <code>x</code> 是一个接口类型的表达式，<code>T</code> 是一个类型。类型断言检查 <code>x</code> 的动态类型是否等于 <code>T</code>，如果检查成功，则返回 <code>x</code> 的动态值，否则会引发运行时恐慌。</p><p>​在这个例子中，由于 <code>i</code> 的动态类型为 <code>*Integer</code>，因此类型断言成功，并返回了指向变量 <code>a</code> 的指针。因此，当调用 <code>Add</code> 函数时，可以使用指针接收器 <code>*Integer</code>（选项 C），也可以使用值接收器 <code>Integer</code>（选项 A）。在 Go 语言中，当使用指针调用一个值接收器方法时，编译器会自动解引用该指针。</p><p>​同时，由于 <code>b</code> 是一个值类型的变量，所以在 <code>Add</code> 函数中应该使用值类型的参数 <code>Integer</code>。因此，选项 B 和 D 都是错误的。</p><p>​综上所述，正确答案是 A 和 C。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>switch语句</title>
      <link href="/2023/04/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/switch%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/04/28/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/switch%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于switch语句，下面说法正确的有?</p><ul><li>A. 条件表达式必须为常量或者整数；</li><li>B. 单个case中，可以出现多个结果选项；</li><li>C. 需要用break来明确退出一个case；</li><li>D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span>、D<br></code></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>A：错误。条件表达式可以是任何类型的表达式，而不仅仅是常量或整数，比如字符串、浮点数、布尔值等都是可以的。<br>B：正确。在单个case语句块中，可以有多个结果选项。比如，可以在一个case中执行多个语句，也可以用表达式或者函数，用分号分隔即可，</p><p>C：错误。在switch语句中，每个case语句块执行完毕后会自动退出，不需要使用break语句来明确退出。但是，在某些情况下，可能需要在case中使用break语句，以避免执行下一个case。</p><p>D：正确。当在一个case中使用了fallthrough关键字时，程序会跳过当前case中的break语句，并执行紧跟的下一个case。如果没有使用fallthrough关键字，则当前case执行完毕后会自动退出switch语句。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang小知识</title>
      <link href="/2023/04/27/Go/Golang%E9%A2%98%E5%BA%93/"/>
      <url>/2023/04/27/Go/Golang%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转化</title>
      <link href="/2023/04/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/"/>
      <url>/2023/04/27/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于类型转化，下面选项正确的是？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">A.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = i<br><br>B.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = (MyInt)i<br><br>C.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = MyInt(i)<br><br>D.<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> j MyInt = i.(MyInt)<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">C</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ul><li>​A选项是错误的，因为将int类型的变量赋值给MyInt类型的变量是不允许的。</li><li>选项 B 是错误的，应该是使用类型转换语法将 int 类型的变量转换为 MyInt 类型，即 <code>var j MyInt = MyInt(i)</code>。</li><li>对于选项 C，使用类型转换表达式 <code>MyInt(i)</code> 可以将 <code>i</code> 的值从 <code>int</code> 类型转换为 <code>MyInt</code> 类型，并将结果赋给 <code>j</code>。</li><li>对于选项 D，使用类型断言 <code>i.(MyInt)</code> 是错误的，因为 <code>i</code> 的底层类型是 <code>int</code>，而不是 <code>MyInt</code>，所以无法将其转换为 <code>MyInt</code> 类型。</li></ul><p><strong>类型断言</strong>：用于将接口类型的值转换为具体的类型。在转换的过程中需要注意以下几点：</p><ol><li>语法：value.(type)<ul><li>value：接口类型的值</li><li>type：需要转换的具体类型</li></ul></li><li>转换前需要判断接口类型的值是否为 nil 或者对应类型的零值，避免在转换时出现 panic。</li></ol><p>下面是一个类型断言的正确使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">1</span><br><br>v, _ := i.(<span class="hljs-type">int</span>)<br>str, _ := i.(<span class="hljs-type">string</span>)<br>fmt.Println(<span class="hljs-string">&quot;v type is&quot;</span>, reflect.TypeOf(v))<br>fmt.Println(<span class="hljs-string">&quot;str type is&quot;</span>, reflect.TypeOf(str))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">v <span class="hljs-keyword">type</span> is <span class="hljs-type">int</span><br>str <span class="hljs-keyword">type</span> is <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多重赋值</title>
      <link href="/2023/04/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC/"/>
      <url>/2023/04/26/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目<span id="more"></span></h1><h4 id="下面代码输出正确的是？"><a href="#下面代码输出正确的是？" class="headerlink" title="下面代码输出正确的是？"></a>下面代码输出正确的是？</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">1</span><br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br>i, s[i<span class="hljs-number">-1</span>] = <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Z&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;s: %v \n&quot;</span>, s)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">A. s: [Z,B,C]<br>B. s: [A,Z,C]<br></code></pre></td></tr></table></figure><h4 id="正确答案："><a href="#正确答案：" class="headerlink" title="正确答案："></a>正确答案：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>​多重赋值分为两个步骤，有先后顺序：</p><ul><li>计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；</li><li>赋值；</li></ul><p>​所以本题，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 <code>i, s[0] = 2, &quot;Z&quot;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环语句</title>
      <link href="/2023/04/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/04/25/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下<span id="more"></span></h2><p>关于循环语句，下面说法正确的有（）</p><ul><li>A. 循环语句既支持 for 关键字，也支持 while 和 do-while；</li><li>B. 关键字 for 的基本使用方法与 C&#x2F;C++ 中没有任何差异；</li><li>C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；</li><li>D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；</li></ul><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">C、D<br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ul><li><p>A. 该选项不正确。Go语言中只支持for循环语句，而不支持while和do-while循环语句。但是for循环的使用方法较为灵活，使用 <code>for</code> 循环来模拟这些语句的效果。可以满足大部分循环需求。</p></li><li><p>选项 B 中的说法不正确，因为 Go 语言中的 <code>for</code> 语句与 C&#x2F;C++ 中略有不同。例如：</p><ul><li>条件语句中不需要括号；</li><li>可以省略条件语句，相当于 <code>while(true)</code>；</li><li>提供了一个更高级的 <code>break</code>，可以选择中断哪一个循环；</li><li>不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</li></ul></li><li><p>C. 该选项正确。Go语言的for循环语句支持continue和break关键字来控制循环流程，同时还提供了一个更高级的break，可以选择中断指定的循环语句。</p><ul><li><p>这里使用<strong>Loop</strong>标签，用于选择需要中断哪一个循环，下面的例子选择中断外面的循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>Loop:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// 使用标签选择中断外层循环</span><br><span class="hljs-keyword">break</span> Loop<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i:%d, j:%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 标签名为 Loop，用于中断外层循环</span><br>fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">i:<span class="hljs-number">0</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">1</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">2</span><br>i:<span class="hljs-number">1</span>, j:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>下面的例子选择中断内部循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>Loop:<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// 使用标签选择中断外层循环</span><br><span class="hljs-keyword">break</span> Loop<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;i:%d, j:%d\n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 标签名为 Loop，用于中断内层循环</span><br>fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">i:<span class="hljs-number">0</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">1</span><br>i:<span class="hljs-number">0</span>, j:<span class="hljs-number">2</span><br>i:<span class="hljs-number">1</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">2</span>, j:<span class="hljs-number">0</span><br>i:<span class="hljs-number">2</span>, j:<span class="hljs-number">1</span><br>i:<span class="hljs-number">2</span>, j:<span class="hljs-number">2</span><br>Done!<br></code></pre></td></tr></table></figure></li><li><p>对比上述两种情况，应该就能大概理解这个<strong>Loop</strong>的用法了。</p></li></ul></li><li><p>D. 该选项正确。Go语言中的for循环语句不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</p><ul><li><pre><code class="go">//会报错for i := 0, j := 1; i &lt; 10; i ++&#123;        ...    &#125;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- ```go<br>  <span class="hljs-regexp">//</span>可以正常使用<br>  <span class="hljs-regexp">//</span>平行赋值： i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>  <br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《MySQL必知必会》</title>
      <link href="/2023/04/24/%E9%98%85%E8%AF%BB/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"/>
      <url>/2023/04/24/%E9%98%85%E8%AF%BB/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>持续更新中……<span id="more"></span></p><h1 id="《MySQL必知必会》"><a href="#《MySQL必知必会》" class="headerlink" title="《MySQL必知必会》"></a>《MySQL必知必会》</h1><h2 id="一、了解SQL"><a href="#一、了解SQL" class="headerlink" title="一、了解SQL"></a>一、了解SQL</h2><h3 id="1、数据库基础"><a href="#1、数据库基础" class="headerlink" title="1、数据库基础"></a>1、数据库基础</h3><p><strong>数据库</strong>：一个以某种有组织的方式存储的数据集合。</p><p><strong>表</strong>：一种结构化的文件，可用来存储某种特定类型的数据。数据库中的每个表都有一个自己的名字，用来标识自己，此名字是唯一的。</p><blockquote><p><strong>表名</strong>：相同数据库不能两次使用相同的表名，不同数据库可以使用相同的表名。</p></blockquote><p><strong>列</strong>：表中的一个字段。所有表都说由一个或者多个列组成的。可以把数据库想象成一个网格，每一列存储着一条特定的信息，如一个列存储所有顾客的编号，另一个列存储所有顾客的地址。</p><p><strong>数据类型</strong>：每个表列都有相应的数据类型，它限制该列中存储的数据。</p><p><strong>行</strong>：表中的数据是按行存储的，所保存的每个记录存储在自己的行内，如果将表想象成网格，网格中垂直的列为表列，水平行为表行。例如顾客表可以每行存储一个顾客，表中的行数为记录的总数。</p><p><strong>主键</strong>：一列或者一组列。其值能够唯一区分表中的每个行。表中每一行都应该有可以唯一标识自己的一列。</p><p>​唯一标识表中每行的这个列或者这组列称为主键。主键用来表示要给特定的行。</p><blockquote><p><strong>应该总是定义主键</strong>：虽然并不是总需要主键，但为每个表创建一个主键，以便于以后的数据操作和管理。</p></blockquote><p>​表中的任何列都可以作为主键，只有满足以下条件：</p><ul><li>任意两行不具有相同的 主键值</li><li>每个行都必须有一个主键值（主键列不允许NULL值）</li></ul><p>​在使用多列作为主键时，上述条件必须应用到构造主键的所有列，所有列值的组合必须是唯一的。</p><h3 id="2、什么是SQL"><a href="#2、什么是SQL" class="headerlink" title="2、什么是SQL"></a>2、什么是SQL</h3><p><strong>SQL</strong>是结构化查询语言的缩写。SQL是一种专门用来与数据库通信的语言。</p><p><strong>SQL的优点</strong>：</p><ul><li>几乎所有重要的DBMS都支持SQL，所以学习此语言使你几乎能与所有数据库打交道。</li><li>简单易学。</li><li>虽然看上去很简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li></ul><h2 id="二、MySQL简介"><a href="#二、MySQL简介" class="headerlink" title="二、MySQL简介"></a>二、MySQL简介</h2><h3 id="1、什么是MySQL"><a href="#1、什么是MySQL" class="headerlink" title="1、什么是MySQL"></a>1、什么是MySQL</h3><p>​<strong>MySQL</strong>：数据的所有存储、检索、管理和吹了实际上是由数据库软件——DBMS（数据库管理系统）完成的。MySQL是一种DBMS，即它是一种数据库软件。</p><p>​MySQL数据库是基于客户机-服务器的数据库。</p><h3 id="2、MySQL工具"><a href="#2、MySQL工具" class="headerlink" title="2、MySQL工具"></a>2、MySQL工具</h3><p>​<strong>mysql命令行实用程序</strong>：每个MySQL安装都会有一个mysql的简单命令行使用程序。在使用这个实用程序的时候，需要注意：</p><ul><li>命令行输入在mysql&gt;之后</li><li>命令用;或者\g结束，仅按Enter不执行命令</li><li>输入help或者\h获取帮助。</li><li>输入quit或者exit退出命令行实用程序。</li></ul><p><strong>MySQL Administrator</strong>：是一个图形交互客户机，用于简化MySQL服务器的管理。</p><p><strong>MySQL Query Browser</strong>：一个图形交互客户机，用来编写和执行MySQL命令。</p><h2 id="三、使用MySQL"><a href="#三、使用MySQL" class="headerlink" title="三、使用MySQL"></a>三、使用MySQL</h2><h3 id="1、连接"><a href="#1、连接" class="headerlink" title="1、连接"></a>1、连接</h3><p><strong>信息</strong>：连接MySQl，需要以下信息：</p><ul><li>主机名——连接本地MySQL服务器，为localhost；</li><li>端口（如果使用默认端口3306之外的端口）；</li><li>一个合法的用户名；</li><li>用户口令。</li></ul><h3 id="2、选择数据库"><a href="#2、选择数据库" class="headerlink" title="2、选择数据库"></a>2、选择数据库</h3><p><code>use</code>：一个关键字，用于执行任意数据库操作前选择一个数据库。</p><h3 id="3、了解数据库和表"><a href="#3、了解数据库和表" class="headerlink" title="3、了解数据库和表"></a>3、了解数据库和表</h3><p><strong>查看数据库</strong>：在你不知道可以使用哪些数据库名时，可以使用<code>SHOW DATABASES</code>显示这些信息</p><p>​<code>SHOW DATABASES</code>；返回可用数据库的一个列表。</p><p><strong>查看要给数据库内的表的列表</strong>：可以使用<code>SHOW TABLES</code></p><p>​<code>SHOW TABLES</code>；返回当前选择的数据库内的可用表的列表。</p><p><strong>查看表的信息</strong>：<code>SHOW COLUMNS FROM TABLE</code>要求给出一个表名，它对于每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值、以及其他信息。</p><p><strong>所支持的其他SHOW语句</strong>：</p><ul><li><code>SHOW STATUS</code>，用于显示广泛的服务器状态信息；</li><li><code>SHOW CREATE DATABASE</code>和<code>SHOW CREATE TABLE</code>，分别用来显示创建特定数据库或表的MySQL语句；</li><li><code>SHOW GRANTS</code>用来显示授权用户的安全权限</li><li><code>SHO ERRORS</code>和<code>SHOW WARNINGS</code>用来显示服务器错误或者警告信息。</li></ul><h2 id="四、检索数据"><a href="#四、检索数据" class="headerlink" title="四、检索数据"></a>四、检索数据</h2><h3 id="1、SELECT语句"><a href="#1、SELECT语句" class="headerlink" title="1、SELECT语句"></a>1、SELECT语句</h3><p>​SQL语句是用简单的英语单词构成的，这些单词称为关键词，每个SQL语句都是由一个或者多个关键字构成的。</p><p>​最经常使用的SQL语句就是<code>SELECT</code>语句，它的用途是从一个或者多个表中检索信息。使用<code>SELECT</code>检索信息，至少给出两条信息——想选择什么，以及从什么地方开始选择。</p><h3 id="2、检索单个列"><a href="#2、检索单个列" class="headerlink" title="2、检索单个列"></a>2、检索单个列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name <br>FROM products;<br></code></pre></td></tr></table></figure><p>​上述语句利用<code>SELECT</code>语句从<code>products</code>表中检索一个名为<code>prod_name</code>的列。</p><h3 id="3、检索多个列"><a href="#3、检索多个列" class="headerlink" title="3、检索多个列"></a>3、检索多个列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price <br>FROM products;<br></code></pre></td></tr></table></figure><h3 id="4、检索所有列"><a href="#4、检索所有列" class="headerlink" title="4、检索所有列"></a>4、检索所有列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM products;<br></code></pre></td></tr></table></figure><h3 id="5、检索不同的行"><a href="#5、检索不同的行" class="headerlink" title="5、检索不同的行"></a>5、检索不同的行</h3><p>执行下面语句，会返回所有匹配的行，但其中有很多重复的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id <br>From products;<br></code></pre></td></tr></table></figure><p>如果你不想要每个值每次都出现，怎么办？例如，你想得出products表中产品的所有供应商的ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT vend_id<br>FROM products;<br></code></pre></td></tr></table></figure><p> 解决的办法是使用<code>DISTINCT</code>，顾名思义，此关键字指示MySQL只返回不同的值。</p><h3 id="6、限制结果"><a href="#6、限制结果" class="headerlink" title="6、限制结果"></a>6、限制结果</h3><p>​<strong>SELECT</strong>语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或者前几行，可以使用<strong>LIMIT</strong>子句。</p><p>​此语句使用<strong>SELECT</strong>语句检索单个列。<code>LIMIT 5</code>指示<strong>MySQL</strong>返回不多于5行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name <br>FROM products<br>LIMIT 5;<br></code></pre></td></tr></table></figure><p>​为得出下一个5行，可以指定要检索的开始和行数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name <br>FROM products<br>LIMIT 5, 5;<br></code></pre></td></tr></table></figure><p><code>LIMIT 5, 5</code>指示<strong>MySQL</strong>返回从<strong>行5</strong>开始的<strong>5行</strong>。第一个数为开始为止，第二个数为要检索的行数。</p><blockquote><p>⭐<strong>行0</strong>：检索出来的第一行为行0，而不是行1，因此<code>LIMIT 1, 1</code>将检索出来第二行而不是第一行。</p></blockquote><blockquote><p>⭐<strong>在行数不够时</strong>：<strong>LIMIT</strong>中指定要检索的行数为检索的最大行数，如果没用足够的行，<strong>MySQL</strong>将只返回它能返回的那么多行。</p></blockquote><h3 id="7、使用完全限定的表名"><a href="#7、使用完全限定的表名" class="headerlink" title="7、使用完全限定的表名"></a>7、使用完全限定的表名</h3><p>​迄今为止使用的<strong>SQL</strong>例子只能通过列名引用列。也可能会使用完全限定的名字来引用列（同时使用表名和列名）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select products.prod_name<br>FROM products;<br></code></pre></td></tr></table></figure><p>​这条<strong>SQL</strong>语句在功能上等于本章最开始使用的那一条语句，但这里指定了一个完全限定的列名。</p><p>​表名也可以是完全限定的，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select products.prod_name<br>FROM book.products;<br></code></pre></td></tr></table></figure><p>​这条SQL语句在功能上等于刚刚使用的那条语句（假设products表确实存在book数据库中）</p><p>​虽然这种表示很麻烦，但是有些情形需要这么用，后面会介绍。</p><h2 id="五、排序检索数据"><a href="#五、排序检索数据" class="headerlink" title="五、排序检索数据"></a>五、排序检索数据</h2><h3 id="1、排序数据"><a href="#1、排序数据" class="headerlink" title="1、排序数据"></a>1、排序数据</h3><p>​正如前面所述，下面的<strong>SQL</strong>语句返回某个数据库表的单个列，但却没用特定的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products;<br></code></pre></td></tr></table></figure><p>​其次，检索出来的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序会收到MySQL重用收回存储空间的影响。因此，如果补明确控制的话，不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</p><p>​为了明确地排序用<strong>SELECT</strong>语句检索出来的数据，可以用<strong>ORDER BY</strong>自居。<strong>ORDER BY</strong>子句取一个或多个列的名字，据此对输出进行排序。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><p>​这条语句除了指示<strong>MySQL</strong>对<code>prod_name</code>列以字母顺序排序数据的<strong>ORDER BY</strong>子句外，与前面的语句相同。</p><h3 id="2、按多个列排序"><a href="#2、按多个列排序" class="headerlink" title="2、按多个列排序"></a>2、按多个列排序</h3><p>​下面的语句指示<strong>MySQL</strong>按照——先按价格，然后再按名称排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price<br>FROM products<br>ORDER BY prod_price, prod_name;<br></code></pre></td></tr></table></figure><h3 id="3、指定排序方向"><a href="#3、指定排序方向" class="headerlink" title="3、指定排序方向"></a>3、指定排序方向</h3><p>​数据排序分为——升序排序（默认）、降序排序。</p><p>​当我们想使用降序排序的时候，必须指定<strong>DESC</strong>关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price<br>FROM products<br>ORDER BY prod_price DESC;<br></code></pre></td></tr></table></figure><p>​但是，如果打算用多个列排序怎么办？下面的例子以降序排序产品（最贵的在前面），然后再对产品名排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name, prod_price<br>FROM products<br>ORDER BY prod_price DESC, prod_name;<br></code></pre></td></tr></table></figure><blockquote><p><strong>DESC</strong>关键字只应用到直接位于其前面的列名。如果想在多个列上进行降序排序，必须对每个列指定<strong>DECS</strong>关键字。</p><p>与<strong>DESC</strong>对应的是<strong>ASC</strong>关键字，在升序排序时可以指定它，但实际上没用多大用处，因为升序是默认的。</p></blockquote><p>​使用<strong>ORDER BY</strong>和<strong>LIMIT</strong>的组合，能够找出一个列中最高或者最低的只。下面的例子演示如何找出最昂贵物品的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_price<br>FROM products<br>ORDER BY prod_price DESC<br>LIMIT 1<br></code></pre></td></tr></table></figure><p>​<code>prod_price DESC</code>保证行是按照最昂贵到最便宜检索的，而<code>LIMIT 1</code>告诉<strong>MySQL</strong>仅返回一行。</p><h2 id="六、过滤数据"><a href="#六、过滤数据" class="headerlink" title="六、过滤数据"></a>六、过滤数据</h2><h3 id="1、使用WHERE子句"><a href="#1、使用WHERE子句" class="headerlink" title="1、使用WHERE子句"></a>1、使用WHERE子句</h3><p>​数据库表一般包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件，搜索条件也称为过滤条件。</p><p>​在SELECT语句中，数据根据WHERE子中指定的搜索条件进行过滤WHERE子句在表名之后给出，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE prod_price = 2.50;<br></code></pre></td></tr></table></figure><p>​这条语句从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行。</p><h3 id="2、WHERE子句操作符"><a href="#2、WHERE子句操作符" class="headerlink" title="2、WHERE子句操作符"></a>2、WHERE子句操作符</h3><p>​<img src="/images/where.png" alt="子句操作符"></p><h4 id="（1）检查单个值"><a href="#（1）检查单个值" class="headerlink" title="（1）检查单个值"></a>（1）检查单个值</h4><p>​上面举的例子就是，我们再举一个例子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select prod_name, prod_price<br>FROM products<br>where prod_name = &#x27;fuses&#x27;;<br></code></pre></td></tr></table></figure><p>​检查<code>WHERE prod_name=fuses</code>语句，它返回prod_name的值为Fuses的一行。MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配。</p><h4 id="（2）不匹配检查"><a href="#（2）不匹配检查" class="headerlink" title="（2）不匹配检查"></a>（2）不匹配检查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select vend_id, prod_name<br>FROM products<br>where vend_id &lt;&gt; 1003<br></code></pre></td></tr></table></figure><p>​上述例子是列出不是由供应商1003制造的所有产品。</p><p>下面是相同的例子，只是用的是**!&#x3D;<strong>而不是</strong>&lt;&gt;**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select vend_id, prod_name<br>FROM products<br>where vend_id != 1003<br></code></pre></td></tr></table></figure><h4 id="（3）范围值检查"><a href="#（3）范围值检查" class="headerlink" title="（3）范围值检查"></a>（3）范围值检查</h4><p>​为了检查某个范围的值，可使用BETWEEN操作符。其语法与其他WHERE子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。</p><p>​例如，BETWEEN操作符可用来检索价格在5美元和10美元之间或日期在指定的开始日期和结束日期之间的所有产品，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECTprod_name,prod_price <br>FROMproducts <br>WHEREprod_price BETWEEN 5 AND 10;<br></code></pre></td></tr></table></figure><p>​从这个例子中可以看到，在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。</p><h4 id="（4）空值检查"><a href="#（4）空值检查" class="headerlink" title="（4）空值检查"></a>（4）空值检查</h4><p>​在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值<strong>NULL</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id<br>FROM customers<br>WHERE cust_email IS NULL<br></code></pre></td></tr></table></figure><p>​ustomers包含有具有空值的列，如果在文件中没有某位顾客的电子邮件地址，则cust_email列将包含NULL值:</p><h2 id="七、数据过滤"><a href="#七、数据过滤" class="headerlink" title="七、数据过滤"></a>七、数据过滤</h2><h3 id="1、组合WHERE子句"><a href="#1、组合WHERE子句" class="headerlink" title="1、组合WHERE子句"></a>1、组合WHERE子句</h3><p>​第6章中介绍的所有WHERE子句在过滤数据时使用的都是单一的条件。为了进行更强的过滤控制，MySQL允许给出多个WHERE子句。这些子句可以两种方式使用:以AND子句的方式或OR子句的方式使用。</p><h4 id="（1）AND操作符"><a href="#（1）AND操作符" class="headerlink" title="（1）AND操作符"></a>（1）AND操作符</h4><p>​为了通过不止一个列进行过滤，可使用AND操作符给WHERE子句附加条件。下面的代码给出了一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_price, prod_name<br>FROM products<br>WHERE vend_id = 1003 AND prod_price &lt;= 10<br></code></pre></td></tr></table></figure><p>​此SQL语句检索由供应商1003制造且价格小于等于10美元的所有产品的名称和价格。这条SELECT语句中的WHERE子句包含两个条件，并且用AND关键字联结它们。AND指示DBMS只返回满足所有给定条件的行。如果某个产品由供应商1003制造，但它的价格高于10美元，则不检索它。类似，如果产品价格小于10美元，但不是由指定供应商制造的也不被检索。</p><h4 id="（2）OR操作符"><a href="#（2）OR操作符" class="headerlink" title="（2）OR操作符"></a>（2）OR操作符</h4><p>​<strong>OR</strong>操作符与<strong>AND</strong>操作符不同，它指示<strong>MySQL</strong>检索匹配任一条件的行，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id = 1002 OR vend_id = 1003;<br></code></pre></td></tr></table></figure><p>​此SQL语句检索由任一个指定供应商制造的所有产品的产品名和价格。OR操作符告诉DBMS匹配任一条件而不是同时匹配两个条件。</p><h4 id="（3）计算次序"><a href="#（3）计算次序" class="headerlink" title="（3）计算次序"></a>（3）计算次序</h4><p>​WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂和高级的过滤。<br>​但是，组合AND和OR带来了一个有趣的问题。为了说明这个问题，来看一个例子。假如需要列出价格为10美元(含）以上且由1002或1003制造的所有产品。下面的SELECT语句使用AND和OR操作符的组合建立了一个WHERE子句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price, vend_id<br>FROM products<br>WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &gt;= 10;<br></code></pre></td></tr></table></figure><p>​上面的结果返回的行中有两行价格小于10美元，显然，返回的行未按预期的进行过滤。为什么会这样呢?原因在于计算的次序。SQL(像多数语言一样）在处理OR操作符前，优先处理AND操作符。当SQL看到上述WHERE子句时，它理解为由供应商1003制造的任何价格为10美元(含）以上的产品，或者由供应商1002制造的任何产品，而不管其价格如何。换句话说，由于AND在计算次序中优先级更高，操作符被错误地组合了。</p><p>​此问题的解决方法是使用圆括号明确地分组相应的操作符。请看下面的SELECT语句及输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price, vend_id<br>FROM products<br>WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;<br></code></pre></td></tr></table></figure><p>​这条SELECT语句与前一条的唯一差别是，这条语句中，前两个条件用圆括号括了起来。因为圆括号具有较AND或OR操作符高的计算次序，DBMS首先过滤圆括号内的OR条件。这时，SQL语句变成了选择由供应商1002或1003制造的且价格都在10美元(含）以上的任何产品，这正是我们所希望的。</p><blockquote><p>​<strong>在WHERE子句中使用圆括号</strong> 任何时候使用具有AND和OR操作符的WHERE子句,都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。</p></blockquote><h3 id="2、IN操作符"><a href="#2、IN操作符" class="headerlink" title="2、IN操作符"></a>2、IN操作符</h3><p>​圆括号在<strong>WHERE</strong>子句中还有另外一种用法。<strong>IN</strong>操作符用来指定条件范围，范围中的每个条件都可以进行匹配。<strong>IN</strong>取合法值的由逗号分隔的清单，全都括在圆括号中。下面的例子说明了这个操作符:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id in(1002, 1003)<br>ORDER BY prod_name<br></code></pre></td></tr></table></figure><p>​此<strong>SELECT</strong>语句检索供应商1002和<strong>1003</strong>制造的所有产品。IN操作符后跟由逗号分隔的合法值清单，整个清单必须括在圆括号中。</p><p>​如果你认为<strong>IN</strong>操作符完成与OR相同的功能，那么你的这种猜测是对的。下面的<strong>SQL</strong>语句完成与上面的例子相同的工作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id = 1002 OR vend_id = 1003<br>ORDER BY prod_name<br></code></pre></td></tr></table></figure><p>​为什么要使用IN操作符?其优点具体如下?</p><ul><li>在使用长的合法选项清单时，<strong>IN</strong>操作符的语法更清楚且更直观。</li><li>在使用<strong>IN</strong>时，计算的次序更容易管理（因为使用的操作符更少)。<strong>IN</strong>操作符一般比<strong>OR</strong>操作符清单执行更快。</li><li><strong>IN</strong>的最大优点是可以包含其他<strong>SELECT</strong>语句,使得能够更动态地建立<strong>WHERE</strong>子句。第14章将对此进行详细介绍。</li></ul><h3 id="3、NOT操作符"><a href="#3、NOT操作符" class="headerlink" title="3、NOT操作符"></a>3、<strong>NOT</strong>操作符</h3><p>​<strong>WHERE</strong>子句中的<strong>NOT</strong>操作符有且只有一个功能，那就是否定它之后所跟的任何条件。</p><p>​下面的例子说明<strong>NOT</strong>的使用。为了列出除<strong>1002</strong>和<strong>1003</strong>之外的所有供应商制造的产品，可编写如下的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, prod_price<br>FROM products<br>WHERE vend_id NOT IN (1002, 1003)<br>ORDER BY prod_name<br></code></pre></td></tr></table></figure><p>​这里的<strong>NOT</strong>否定跟在它之后的条件，因此，<strong>MySQ</strong>L不是匹配<strong>1002</strong>和<strong>1003</strong>的<strong>vend_id</strong>，而是匹配<strong>1002</strong>和<strong>1003</strong>之外供应商的<strong>vend_id</strong>。<br>​为什么使用<strong>NOT</strong>?对于简单的<strong>WHERE</strong>子句，使用<strong>NOT</strong>确实没有什么优势。但在更复杂的子句中，<strong>NOT</strong>是非常有用的。例如，在与<strong>IN</strong>操作符联合使用时，<strong>NOT</strong>使找出与条件列表不匹配的行非常简单。</p><blockquote><p><strong>MySQL中的NOT</strong> <strong>MySQL</strong>支持使用<strong>NOT</strong>对<strong>IN</strong>、<strong>BETWEEN</strong>和<strong>EXISTS</strong>子句取反,这与多数其他<strong>DBMS</strong>允许使用<strong>NOT</strong>对各种条件取反有很大的差别。</p></blockquote><h2 id="八、用通配符进行过滤"><a href="#八、用通配符进行过滤" class="headerlink" title="八、用通配符进行过滤"></a>八、用通配符进行过滤</h2><h3 id="1、LIKE操作符"><a href="#1、LIKE操作符" class="headerlink" title="1、LIKE操作符"></a>1、<strong>LIKE</strong>操作符</h3><h4 id="（1）百分号（-）通配符"><a href="#（1）百分号（-）通配符" class="headerlink" title="（1）百分号（%）通配符"></a>（1）百分号（%）通配符</h4><p>​最常使用的通配符是百分号(<strong>%</strong>)。在搜索串中，**%<strong>表示任何字符出现任意次数。例如，为了找出所有以词</strong>jet<strong>起头的产品，可使用以下</strong>SELECT**语句;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &quot;jet%&quot;;<br></code></pre></td></tr></table></figure><p>​此例子使用了搜索模式’<strong>jet%</strong>‘。在执行这条子句时，将检索任意以<strong>jet</strong>起头的词。**%**告诉MySQL接受jet之后的任意字符，不管它有多少字符。</p><p>​通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。下面的例子使用两个通配符，它们位于模式的两端:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &quot;%anvil%&quot;;<br></code></pre></td></tr></table></figure><p>​搜索模式’<strong>%anvil%</strong>‘表示匹配任何位置包含文本<strong>anvil</strong>的值，而不论它之前或之后出现什么字符。</p><p>​通配符也可以出现在搜索模式的中间，虽然这样做不太有用。下面的例子找出以<strong>s</strong>起头以<strong>e</strong>结尾的所有产品:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &quot;s%e&quot;;<br></code></pre></td></tr></table></figure><p>​重要的是要注意到，除了一个或多个字符外，**%<strong>还能匹配0个字符。</strong>%**代表搜索模式中给定位置的0个、1个或多个字符。</p><h4 id="（2）下划线（-通配符"><a href="#（2）下划线（-通配符" class="headerlink" title="（2）下划线（_)通配符"></a>（2）下划线（_)通配符</h4><p>​另一个有用的通配符是下划线**(_)**。下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。</p><p>​举一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE &#x27;_ ton anvil&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>ANV021 ton anvil</p><p>ANV032 ton anvil</p></blockquote><p>​此WHERE子句中的搜索模式给出了后面跟有文本的两个通配符。结果只显示匹配搜索模式的行:第一行中下划线匹配1，第二行中匹配2。.5 ton anvil产品没有匹配，因为搜索模式要求匹配两个通配符而不是一个。对照一下，下面的SELECT语句使用%通配符，返回三行产品:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">SELECT prod_id, prod_name<br>FROM products<br>WHERE prod_name LIKE <span class="hljs-string">&#x27;% ton anvil&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>ANV01.5 ton anvil<br>ANV021 ton anvil<br>ANV032 ton anvil</p></blockquote><h3 id="2、通配符使用技巧"><a href="#2、通配符使用技巧" class="headerlink" title="2、通配符使用技巧"></a>2、通配符使用技巧</h3><p>​正如所见，MySQL的通配符很有用。但这种功能是有代价的:通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li><p>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</p></li><li><p>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</p></li><li><p>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</p><p>总之，通配符是一种极重要和有用的搜索工具，以后我们经常会用到它。</p></li></ul><h2 id="九、用正则表达式进行搜索"><a href="#九、用正则表达式进行搜索" class="headerlink" title="九、用正则表达式进行搜索"></a>九、用正则表达式进行搜索</h2><h3 id="1、正则表达式介绍"><a href="#1、正则表达式介绍" class="headerlink" title="1、正则表达式介绍"></a>1、正则表达式介绍</h3><p>​前两章中的过滤例子允许用匹配、.比较和通配操作符寻找数据。对于基本的过滤（或者甚至是某些不那么基本的过滤)，这样就足够了。但随着过滤条件的复杂性的增加，WHERE子句本身的复杂性也有必要增加。<br>​这也就是正则表达式变得有用的地方。正则表达式是用来匹配文本的特殊的串(字符集合)。如果你想从一个文本文件中提取电话号码，可以使用正则表达式。如果你需要查找名字中间有数字的所有文件，可以使用一个正则表达式。如果你想在一个文本块中找到所有重复的单词，可以使用一个正则表达式。如果你想替换一个页面中的所有URL为这些URL的实际HTML链接,也可以使用一个正则表达式(对于最后这个例子，或者是两个正则表达式)。<br>​所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。有见识的程序员和网络管理员已经关注作为他们技术工具重要内容的正则表达式很长时间了。<br>​正则表达式用正则表达式语言来建立，正则表达式语言是用来完成刚讨论的所有工作以及更多工作的一种特殊语言。与任意语言一样，正则表达式具有你必须学习的特殊的语法和指令。</p><h3 id="2、使用MySQL正则表达式"><a href="#2、使用MySQL正则表达式" class="headerlink" title="2、使用MySQL正则表达式"></a>2、使用MySQL正则表达式</h3><p>​那么，正则表达式与MySQL有何关系?已经说过，正则表达式的作用是匹配文本,将一个模式(正则表达式)与一个文本串进行比较。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。</p><h3 id="（1）基本字符匹配"><a href="#（1）基本字符匹配" class="headerlink" title="（1）基本字符匹配"></a>（1）基本字符匹配</h3><p>​我们从一个非常简单的例子开始。下面的语句检索列<strong>prod_name</strong>包含文本<strong>1000</strong>的所有行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;1000&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><p>​除关键字<strong>LIKE</strong>被<strong>REGEXP</strong>替代外，这条语句看上去非常像使用LIKE的语句(第8章)。它告诉<strong>MySQL</strong>: <strong>REGEXP</strong>后所跟的东西作为正则表达式(与文字正文1000匹配的一个正则表达式）处理。</p><p>​为什么要费力地使用正则表达式?在刚才的例子中，正则表达式确实没有带来太多好处（可能还会降低性能)，不过，请考虑下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;.000&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>JetPack 1000<br>JetPack 2000</p></blockquote><p>​这里使用了正则表达式**.000<strong>。.是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，</strong>1000<strong>和</strong>2000**都匹配且返回。</p><blockquote><p>​<strong>匹配不区分大小写</strong> MySQL中的正则表达式匹配(自版本3.23.4后)不区分大小写(即,大写和小写都匹配)。为区分大小写,可使用<strong>BINARY</strong>关键字,如<code>WHERE prod_name REGEXPBINARY &#39;JetPack .000&#39;</code>.</p></blockquote><h3 id="（2）进行OR匹配"><a href="#（2）进行OR匹配" class="headerlink" title="（2）进行OR匹配"></a>（2）进行OR匹配</h3><p>​为搜索两个串之一(或者为这个串，或者为另一个串)，使用|，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;1000|2000&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>JetPack 1000<br>JetPack 2000</p></blockquote><p>​语句中使用了正则表达式<code>1000 | 2000</code>。**|<strong>为正则表达式的</strong>OR<strong>操作符。它表示匹配其中之一，因此</strong>1000<strong>和</strong>2000<strong>都匹配并返回。使用|从功能上类似于在</strong>SELECT<strong>语句中使用</strong>OR<strong>语句，多个</strong>OR**条件可并入单个正则表达式。</p><h3 id="（3）匹配几个字符之一"><a href="#（3）匹配几个字符之一" class="headerlink" title="（3）匹配几个字符之一"></a>（3）匹配几个字符之一</h3><p>​匹配任何单一字符。但是，如果你只想匹配特定的字符，怎么办?可通过指定一组用**[和]**括起来的字符来完成，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;[123] Ton&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>1 ton anvil<br>2 ton anvil</p></blockquote><p>​这里，使用了正则表达式<code>[ 123] Ton</code>。<code>[ 123]</code>定义一组字符，它的意思是匹配1或2或3，因此，1 ton和2 ton都匹配且返回(没有3 ton)。<br>​正如所见,<strong>[ ]<strong>是另一种形式的OR语句。事实上,正则表达式<code>[ 123]Ton</code>为<code>[ 1|2|3]Ton</code>的缩写，也可以使用后者。但是，需要用</strong>[]<strong>来定义</strong>OR</strong>语句查找什么。为更好地理解这一点，请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;1|2|3 Ton&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>prod_name<br>1 ton anvil<br>2 ton anvil<br>JetPack 1000<br>JetPack 2000<br>TNT (1 stick)</p></blockquote><p>​这并不是期望的输出。两个要求的行被检索出来，但还检索出了另外3行。之所以这样是由于MySQL假定你的意思是’1’或’2’或’3 ton’。除非把字符|括在一个集合中，否则它将应用于整个串。</p><p>​字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1、2或3，但[^123]却匹配除这些字符外的任何东西。</p><h3 id="（4）匹配范围"><a href="#（4）匹配范围" class="headerlink" title="（4）匹配范围"></a>（4）匹配范围</h3><p>​集合可用来定义要匹配的一个或多个字符。例如，下面的集合将匹配数字0到9:</p><blockquote><p>[0123456789]</p></blockquote><p>​为简化这种类型的集合，可使用-来定义一个范围。下面的式子功能上等同于上述数字列表:</p><blockquote><p>[0-9]</p></blockquote><p>​范围不限于完整的集合，**[ 1-3]<strong>和</strong>[6-9]<strong>也是合法的范围。此外，范围不一定只是数值的，</strong>[a-z]**匹配任意字母字符。<br>举一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP &#x27;[1-5] Ton&#x27;<br>ORDER BY prod_name;<br></code></pre></td></tr></table></figure><blockquote><p>prod_name<br>.5 ton anvil<br>1 ton anvil<br>2 ton anvil</p></blockquote><p>​这里使用正则表达式<code>[ 1-5] Ton</code>。**[ 1-5]<strong>定义了一个范围，这个表达式意思是匹配1到5，因此返回3个匹配行。由于</strong>5 ton**匹配，所以返回.<strong>5 ton</strong>。</p><h3 id="（5）匹配特殊字符"><a href="#（5）匹配特殊字符" class="headerlink" title="（5）匹配特殊字符"></a>（5）匹配特殊字符</h3><p>​正则表达式语言由具有特定含义的特殊字符构成。我们已经看到**.<strong>、</strong>[]<strong>、</strong>|**和-等，还有其他一些字符。请问，如果你需要匹配这些字符，应该怎么办呢?</p><p>​例如,如果要找出包含**.**字符的值,怎样搜索?请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name<br>FROM vendors<br>WHERE vend_name REGEXP &#x27;.&#x27;<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><blockquote><p>vend_name<br>ACME<br>Anvils R Us<br>Furball Inc.<br>Jet Set<br>Jouets Et Ours<br>LT Supplies</p></blockquote><p>​这并不是期望的输出，**.<strong>匹配任意字符，因此每个行都被检索出来。<br>​为了匹配特殊字符，必须用<code>\\</code>为前导。<code>ll-</code>表示查找</strong>-<strong>，<code>ll.</code>表示查找</strong>.**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name<br>FROM vendors<br>WHERE vend_name REGEXP &#x27;\\.&#x27;<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><blockquote><p>vend_name<br>Furball Inc.</p></blockquote><p>​有字符都必须以这种方式转义。这包括**.<strong>、</strong>|<strong>、</strong>[]**以及迄今为止使用过的其他特殊字符。</p><h3 id="（6）匹配字符类"><a href="#（6）匹配字符类" class="headerlink" title="（6）匹配字符类"></a>（6）匹配字符类</h3><p>​存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类。如下：</p><p><img src="/images/%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB.png" alt="字符类"></p><h2 id="十、创建计算字段"><a href="#十、创建计算字段" class="headerlink" title="十、创建计算字段"></a>十、创建计算字段</h2><h2 id="十一、使用数据处理函数"><a href="#十一、使用数据处理函数" class="headerlink" title="十一、使用数据处理函数"></a>十一、使用数据处理函数</h2><h3 id="1、使用函数"><a href="#1、使用函数" class="headerlink" title="1、使用函数"></a>1、使用函数</h3><p>​大多数SQL实现支持以下类型的函数。</p><ul><li>用于处理文本串（如删除或填充值，转换值为大写或小写)的文本函数。</li><li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算)的数值函数。</li><li>用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的日期和时间函数。</li><li>返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。</li></ul><h4 id="（1）文本处理函数"><a href="#（1）文本处理函数" class="headerlink" title="（1）文本处理函数"></a>（1）文本处理函数</h4><p>​下面是一个使用upper()函数的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, UPPER(vend_name) AS vend_name_upcase<br>FROM vendors<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><blockquote><p>vend_namevend_name_upcase<br>ACMEACME<br>Anvils R UsANVILS R US<br>Furball Inc.FURBALL INC.<br>Jet SetJET SET<br>Jouets Et OursJOUETS ET OURS<br>LT SuppliesLT SUPPLIES</p></blockquote><p>​正如所见，<strong>upper()<strong>将文本转换为大写，因此本例子中每个供应商都列出两次，第一次为</strong>vendors</strong>表中存储的值，第二次作为列<strong>vend_name_upcase</strong>转换为大写。</p><p>​下面列出了常用的文本处理函数：</p><p><img src="/images/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png"></p><p><img src="/images/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B01.png" alt="常用的文本处理函数"></p><p>​上面SOUNDEX需要做进一步的解释。SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对sOUNDEX的支持。<br>​下面给出一个使用Soundex()函数的例子。customers表中有一个顾客coyote Inc.，其联系名为Y.Lee。但如果这是输入错误，此联系名实际应该是Y.Lie,怎么办?显然,按正确的联系名搜索不会返回数据，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE cust_contact = &#x27;Y. Lie&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact</p></blockquote><p>​现在试一下使用<strong>Soundex()<strong>函数进行搜索，它匹配所有发音类似于</strong>Y.Lie</strong>的联系名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE Soundex(cust_contact) = Soundex(&#x27;Y. Lie&#x27;);<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact<br>Coyote Inc.Y Lee</p></blockquote><h4 id="（2）日期和时间处理函数"><a href="#（2）日期和时间处理函数" class="headerlink" title="（2）日期和时间处理函数"></a>（2）日期和时间处理函数</h4><p>​日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。<br>​一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。<br>​下面列出了某些常用的日期和时间处理函数。</p><p><img src="/images/%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" alt="常用日期和时间处理函数"></p><p>​需要注意的是MySQL使用的日期格式。无论你什么时候指定一<br>个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式<code>yyyy-mm-dd</code>。因此，2<strong>005年9月1日</strong>，给出为<strong>2005-09-01</strong>。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性（如，04&#x2F;05&#x2F;06是<strong>2006年5月4日</strong>或2006年4月5日或<strong>2004年5月6日</strong>或……)。</p><p>​因此基本的日期比较应该很简单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE order_date = &#x27;2005-09-01&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_numorder_date<br>10001200052005-09-01 00:00:00</p></blockquote><p>​但是，使用<code>WHERE order_date = &#39;2005-09-01&#39;</code>可靠吗?<strong>order_ date</strong>的数据类型为<strong>datetime</strong>。这种类型存储日期及时间值。样例表中的值全都具有时间值<strong>00:00:00</strong>,但实际中很可能并不总是这样。如果用当前日期和时间存储订单日期(因此你不仅知道订单日期，还知道下订单当天的时间)，怎么办?比如，存储的<strong>order_date</strong>值为<strong>2005-09-01 11:30:05</strong>，则<code>WHERE order_date = &#39;2005-09-01&#39;</code>失败。即使给出具有该日期的一行，也不会把它检索出来，因为<strong>WHERE</strong>匹配失败。<br>​解决办法是指示MySQL仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较。为此，必须使用Date()函数。Date(order_date)指示MySQL仅提取列的日期部分，更可靠的SELECT语句为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE Date(order_date) = &#x27;2005-09-01&#x27;;<br></code></pre></td></tr></table></figure><p>​不过，还有一种日期比较需要说明。如果你想检索出<strong>2005年9月</strong>下的所有订单，怎么办?简单的相等测试不行，因为它也要匹配月份中的天数。有几种解决办法，其中之一如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE Date(order_date) BETWEEN &#x27;2005-09-01&#x27; AND &#x27;2005-09-30&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_numorder_date<br>10001200052005-09-01 00:00:00<br>10003200062005-09-12 00:00:00<br>10004200072005-09-30 00:00:00</p></blockquote><p>​还有另外一种办法（一种不需要记住每个月中有多少天或不需要操心闰年2月的办法):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, order_num,order_date<br>FROM orders<br>WHERE YEAR(order_date) = 2005 AND Month(order_date) = 9;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_numorder_date<br>10001200052005-09-01 00:00:00<br>10003200062005-09-12 00:00:00<br>10004200072005-09-30 00:00:00</p></blockquote><p>​Year()是一个从日期(或日期时间)中返回年份的函数。类似，Month( )从日期中返回月份。因此, <code>WHERE Year(order_date)= 2005 AND Month (order_date) =9</code>检索出<strong>order_date</strong>为2005年9月的所有行。</p><h4 id="（3）数值处理函数"><a href="#（3）数值处理函数" class="headerlink" title="（3）数值处理函数"></a>（3）数值处理函数</h4><p>​数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期-时间处理函数的使用那么频繁。</p><p>​具有讽刺意味的是，在主要DBMS的函数中，数值函数是最一致最统一的函数。下面列出一些常用的数值处理函数。</p><p><img src="/images/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0.png" alt="常用数值处理函数"></p><h2 id="十二、汇总数据"><a href="#十二、汇总数据" class="headerlink" title="十二、汇总数据"></a>十二、汇总数据</h2><h3 id="1、聚集函数"><a href="#1、聚集函数" class="headerlink" title="1、聚集函数"></a>1、聚集函数</h3><p>​我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有以下几种。</p><ul><li>确定表中行数（或者满足某个条件或包含某个特定值的行数)。</li><li>获得表中行组的和。</li><li>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。</li></ul><p>​上述例子都需要对表中数据（而不是实际数据本身）汇总。因此，返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了)。重复一遍，实际想要的是汇总信息。<br>​为方便这种类型的检索，MySQL给出了5个聚集函数，见下图1。这些函数能进行上述罗列的检索。</p><p><img src="/images/SQL%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0.png" alt="SQL聚集函数"></p><h4 id="（1）AVG-函数"><a href="#（1）AVG-函数" class="headerlink" title="（1）AVG()函数"></a>（1）AVG()函数</h4><p>​**AVG( )**通过对表中行数计数并计算特定列值之和，求得该列的平均值。AVG ( )可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。</p><p>下面的例子使用<strong>AVG()<strong>返回</strong>products</strong>表中所有产品的平均价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(prod_price) AS avg_price<br>FROMproducts;<br></code></pre></td></tr></table></figure><p>​此SELECT语句返回值<strong>avg_Price</strong>，它包含<strong>products</strong>表中所有产品的平均价格。<strong>avg_price</strong>是一个别名。</p><p>​**AVG()**也可以用来确定特定列或行的平均值。下面的例子返回特定供应商所提供产品的平均价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(prod_price) AS avg_price<br>FROMproducts<br>WHERE vend_id = 1003;<br></code></pre></td></tr></table></figure><blockquote><p>avg_price<br>13.212857</p></blockquote><p>​这条SELECT语句与前一条的不同之处在于它包含了<strong>WHERE</strong>子句。此<strong>WHERE</strong>子句仅过滤出<strong>vend_id</strong>为1003的产品，因此<br>​<strong>avg_price</strong>中返回的值只是该供应商的产品的平均值。</p><h4 id="（2）COUNT-函数"><a href="#（2）COUNT-函数" class="headerlink" title="（2）COUNT()函数"></a>（2）COUNT()函数</h4><p>​<em>*COUNT()<strong>函数进行计数。可利用</strong>COUNT()<strong>确定表中行的数目或符合特定条件的行的数目。<br>​COUNT( )函数有两种使用方式。<br>​使用</strong>COUNT(* )<strong>对表中行的数目进行计数,不管表列中包含的是空<br>值</strong>（NULL)<strong>还是非空值。<br>​使用</strong>COUNT (column)<strong>对特定列中具有值的行进行计数，忽略</strong>NULL</em>*值。<br>​下面的例子返回<strong>customers</strong>表中客户的总数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) AS num_cust <br>FROM customers;<br></code></pre></td></tr></table></figure><blockquote><p>num_cust<br>5</p></blockquote><p>​在此例子中，利用<strong>COUNT (*)<strong>对所有行计数，不管行中各列有什么值。计数值在</strong>num_cust</strong>中返回。</p><p>​下面的例子只对具有电子邮件地址的客户计数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(cust_email) AS num_cust <br>FROM customers;<br></code></pre></td></tr></table></figure><blockquote><p>num_cust<br>3</p></blockquote><p>​这条<strong>SELECT</strong>语句使用<strong>COUNT (cust_email)<strong>对</strong>cust_email</strong>列中有值的行进行计数。在此例子中,<strong>cust_email</strong>的计数为3(表示5个客户中只有3个客户有电子邮件地址)。</p><blockquote><p><strong>NULL</strong> 值如果指定列名，则指定列的值为空的行被COUNT()函数忽略，但如果**COUNT ()*<em>函数中用的是星号（</em>),则不忽略。</p></blockquote><h4 id="（3）MAX-函数"><a href="#（3）MAX-函数" class="headerlink" title="（3）MAX()函数"></a>（3）MAX()函数</h4><p>**MAX()**返回指定列中的最大值。MAX()要求指定列名，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX(prod_price) AS max_price <br>FROM products;<br></code></pre></td></tr></table></figure><blockquote><p>max_price<br>55.00</p></blockquote><p>​这里，<strong>MAX()<strong>返回</strong>products</strong>表中最贵的物品的价格。</p><h4 id="（4）MIN-函数"><a href="#（4）MIN-函数" class="headerlink" title="（4）MIN()函数"></a>（4）MIN()函数</h4><p>​<strong>MIN()<strong>的功能正好与MAX()功能相反，它返回指定列的</strong>最小值</strong>。与**MAX ()**一样，MIN()要求指定列名，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT min(prod_price) AS max_price <br>FROM products;<br></code></pre></td></tr></table></figure><blockquote><p>max_price<br>2.50</p></blockquote><h4 id="（5）SUM-函数"><a href="#（5）SUM-函数" class="headerlink" title="（5）SUM()函数"></a>（5）SUM()函数</h4><p>​SUM()用来返回指定列值的和（总计）。</p><p>​下面举一个例子，<strong>orderitems</strong>表包含订单中实际的物品，每个物品有相应的数量（ <strong>quantity</strong>)。可如下检索所订购物品的总数（所有<strong>quantity</strong>值之和):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(quantity) AS items_ordered <br>FROM orderitems<br>WHERE order_num = 20005;<br></code></pre></td></tr></table></figure><blockquote><p>items_ordered<br>19</p></blockquote><p>​<strong>SUM()<strong>也可以用来合计计算值。在下面的例子中，合计每项物品的</strong>item_price*quantity</strong>，得出总的订单金额:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(quantity * item_price) AS items_ordered <br>FROM orderitems<br>WHERE order_num = 20005;<br></code></pre></td></tr></table></figure><blockquote><p>items_ordered<br>149.87</p></blockquote><h3 id="2、聚集不同值-DISTINCT"><a href="#2、聚集不同值-DISTINCT" class="headerlink" title="2、聚集不同值 DISTINCT"></a>2、聚集不同值 DISTINCT</h3><p>​下面的例子使用<strong>AVG()<strong>函数返回特定供应商提供的产品的平均价格。它与上面的SELECT语句相同，但使用了</strong>DISTINCT</strong>参数，因此平均值只考虑各个不同的价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(DISTINCT prod_price) AS avg_price <br>FROM products<br>WHERE vend_id = 1003;<br></code></pre></td></tr></table></figure><blockquote><p>avg_price<br>15.998000</p></blockquote><p>​可以看到，在使用了<strong>DISTINCT</strong>后，此例子中的<strong>avg_price</strong>比较高，因为有多个物品具有相同的较低价格。排除它们提升了平均价格。</p><h3 id="3、组合聚集函数"><a href="#3、组合聚集函数" class="headerlink" title="3、组合聚集函数"></a>3、组合聚集函数</h3><p>​目前为止的所有聚集函数例子都只涉及单个函数。但实际上<strong>SELECT</strong>语句可根据需要包含多个聚集函数。请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) AS num_items,<br>MIN(prod_price) AS price_min,<br>MAX(prod_price) AS price_max,<br>AVG(prod_price) AS price_avg<br>FROM products;<br></code></pre></td></tr></table></figure><blockquote><p>num_itemsprice_minprice_maxprice_avg<br>142.5055.0016.133571</p></blockquote><p>​这里用单条SELECT语句执行了4个聚集计算，返回4个值( <strong>products</strong>表中物品的数目，产品价格的最高、最低以及平均值）。</p><h2 id="十三、分组数据"><a href="#十三、分组数据" class="headerlink" title="十三、分组数据"></a>十三、分组数据</h2><h3 id="1、数据分组"><a href="#1、数据分组" class="headerlink" title="1、数据分组"></a>1、数据分组</h3><p>​从上一章知道，SQL聚集函数可用来汇总数据。这使我们能够对行进行计数，计算和与平均数，获得最大和最小值而不用检索所有数据。<br>​目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。提示一下，下面的例子返回供应商1003提供的产品数目:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) AS num_prods <br>FROM products<br>WHERE vend_id = 1003;<br></code></pre></td></tr></table></figure><blockquote><p>num_prods<br>7</p></blockquote><p>​但如果要返回每个供应商提供的产品数目怎么办?或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办?<br>​这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。</p><h3 id="2、创建分组"><a href="#2、创建分组" class="headerlink" title="2、创建分组"></a>2、创建分组</h3><p>​分组是在SELECT语句的<strong>GROUP BY</strong>子句中建立的。理解分组的最好办法是看一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, COUNT(*) AS num_prods <br>FROM products<br>GROUP BY vend_id;<br></code></pre></td></tr></table></figure><blockquote><p>vend_idnum_prods<br>10013<br>10022<br>10037<br>10052</p></blockquote><p>​上面的SELECT语句指定了两个列，<strong>vend_id</strong>包含产品供应商的<strong>ID</strong>，<strong>num_prods</strong>为计算字段（用<strong>COUNT(*)<strong>函数建立)。GROUP BY<br>子句指示MySQL按</strong>vend_id</strong>排序并分组数据。这导致对每个<strong>vend_id</strong>而不是整个表计算<strong>num_prods</strong>一次。从输出中可以看到,供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。<br>因为使用了<strong>GROUP BY</strong>，就不必指定要计算和估值的每个组了。系统会自动完成。<strong>GROUP BY</strong>子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。<br>​在具体使用<strong>GROUP BY</strong>子句前，需要知道一些重要的规定。</p><ul><li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果在<strong>GROUP BY</strong>子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算(所以不能从个别的列取回数据)。</li><li><strong>GROUP BY</strong>子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在SELECT中使用表达式，则必须在<strong>GROUP BY</strong>子句中指定相同的表达式。不能使用别名。</li><li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li><li>如果分组列中具有<strong>NULL</strong>值，则<strong>NULL</strong>将作为一个分组返回。如果列中有多行<strong>NULL</strong>值，它们将分为一组。</li><li><strong>GROUP BY</strong>子句必须出现在WHERE子句之后，<strong>ORDER BY</strong>子句之前。</li></ul><h3 id="3、过滤分组"><a href="#3、过滤分组" class="headerlink" title="3、过滤分组"></a>3、过滤分组</h3><p>​除了能用<strong>GROUP BY</strong>分组数据外，MySQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，可能想要列出至少有两个订单的所有顾客。为得出这种数据，必须基于完整的分组而不是个别的行进行过滤。<br>​我们已经看到了<strong>WHERE</strong>子句的作用(第6章中引入)。但是，在这个例子中<strong>WHERE</strong>不能完成任务，因为<strong>WHERE</strong>过滤指定的是行而不是分组。事实上，<strong>WHERE</strong>没有分组的概念。<br>​那么，不使用<strong>WHERE</strong>使用什么呢? MySQL为此目的提供了另外的子句，那就是<strong>HAVING</strong>子句。<strong>HAVING</strong>非常类似于WHERE。事实上，目前为止所学过的所有类型的<strong>WHERE</strong>子句都可以用<strong>HAVING</strong>来替代。唯一的差别是<strong>WHERE</strong>过滤行，而<strong>HAVING</strong>过滤分组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id, COUNT(*) AS orders<br>FROM orders<br>GROUP BY cust_id<br>HAVING COUNT(*) &gt;= 2;<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorders<br>100012</p></blockquote><p>​这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(* ) &gt;&#x3D;2(两个以上的订单）的那些分组。</p><p>​那么，有没有在一条语句中同时使用<strong>WHERE</strong>和<strong>HAVING</strong>子句的需要呢﹖事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点,可增加一条<strong>WHERE</strong>子句，过滤出过去12个月内下过的订单。然后再增加<strong>HAVING</strong>子句过滤出具有两个以上订单的分组。</p><p>​为更好地理解，请看下面的例子，它列出具有<strong>2个</strong>（含)以上、价格10(含）以上的产品的供应商:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, COUNT(*) AS num_prods <br>FROM products<br>WHERE prod_price &gt;= 10<br>GROUP BY vend_id<br>HAVING COUNT(*) &gt;= 2<br></code></pre></td></tr></table></figure><blockquote><p>vend_idnum_prods<br>10034<br>10052</p></blockquote><p>​这条语句中，第一行是使用了聚集函数的基本SELECT，它与前面的例子很相像。WHERE子句过滤所有prod_price至少为10的行。然后按vend_id分组数据，HAVING子句过滤计数为2或2以上的分组。</p><p>​如果没有WHERE子句，将会多检索出两行（供应商1002，销售的所有产品价格都在10以下;供应商1001，销售3个产品，但只有一个产品的价格大于等于10):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, COUNT(*) AS num_prods <br>FROM products<br>GROUP BY vend_id<br>HAVING COUNT(*) &gt;= 2<br></code></pre></td></tr></table></figure><blockquote><p>vend_idnum_prods<br>10013<br>10022<br>10037<br>10052</p></blockquote><h3 id="4、分组和排序"><a href="#4、分组和排序" class="headerlink" title="4、分组和排序"></a>4、分组和排序</h3><p>​虽然<strong>GROUPBY</strong>和<strong>ORDER BY</strong>经常完成相同的工作，但它们是非常不同的。下面汇总了它们之间的差别。</p><p>ORDER BY</p><ul><li>排序产生的输出</li><li>任意列都可以使用(甚至非选择的列也可以使用)</li><li>不一定需要</li></ul><p>GROUP BY</p><ul><li>分组行。但输出可能不是分组的顺序</li><li>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</li><li>如果与聚集函数一起使用列（或表达式)，则必须使用</li></ul><p>​上面列出的第一项差别极为重要。我们经常发现用GROUP BY分组的数据确实是以分组顺序输出的。但情况并不总是这样，它并不是SQL规范所要求的。此外，用户也可能会要求以不同于分组的顺序排序。仅因为你以某种方式分组数据（获得特定的分组聚集值)，并不表示你需要以相同的方式排序输出。应该提供明确的ORDER BY子句，即使其效果等同于GROUP BY子句也是如此。</p><blockquote><p><strong>不要忘记ORDER</strong> BY一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p></blockquote><p>​为说明<strong>GROUP BY</strong>和ORDER BY的使用方法，请看一个例子。下面的SELECT语句类似于前面那些例子。它检索总计订单价格大于等于50的订单的订单号和总计订单价格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT order_num, SUM(quantity * item_price) AS ordertotal <br>FROM orderitems<br>GROUP BY order_num <br>HAVING SUM(quantity * item_price) &gt;= 50<br></code></pre></td></tr></table></figure><blockquote><p>order_numordertotal<br>20005149.87<br>2000655.00<br>200071000.00<br>20008125.00</p></blockquote><p>​为按总计订单价格排序输出，需要添加<strong>ORDER BY</strong>子句，如下所示;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT order_num, SUM(quantity * item_price) AS ordertotal <br>FROM orderitems<br>GROUP BY order_num <br>HAVING SUM(quantity * item_price) &gt;= 50<br>ORDER BY ordertotal;<br></code></pre></td></tr></table></figure><blockquote><p>order_numordertotal<br>2000655.00<br>20008125.00<br>20005149.87<br>200071000.00</p></blockquote><p>​在这个例子中，<strong>GROUP BY</strong>子句用来按订单号(order_num列)分组数据，以便<em><em>SUM(</em> )<strong>函数能够返回总计订单价格。</strong>HAVING</em>*子句过滤数据，使得只返回总计订单价格大于等于<strong>50</strong>的订单。最后，用<strong>ORDER BY</strong>子句排序输出。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="十四、使用子查询"><a href="#十四、使用子查询" class="headerlink" title="十四、使用子查询"></a>十四、使用子查询</h2><h3 id="1、利用子查询进行过滤"><a href="#1、利用子查询进行过滤" class="headerlink" title="1、利用子查询进行过滤"></a>1、利用子查询进行过滤</h3><p>​订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。<br>现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索?下面列出具体的步骤。</p><p>​(1)检索包含物品TNT2的所有订单的编号。</p><p>​(2)检索具有前一步骤列出的订单编号的所有客户的ID。</p><p>​(3)检索前一步骤返回的所有客户ID的客户信息。</p><p>​上述每个步骤都可以单独作为一个查询来执行。可以把<strong>一条SELECT</strong>语句返回的结果<strong>用于另一条SELECT</strong>语句的WHERE子句。<br>​也可以使用子查询来把3个查询组合成一条语句。<br>​第一条SELECT语句的含义很明确,对于prod_id为TNT2的所有订单物品，它检索其order_num列。输出列出两个包含此物品的订单:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT order_num<br>FROM orderitems<br>WHERE prod_id = &#x27;TNT2&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>order_num<br>20005<br>20007</p></blockquote><p>​下一步，检索具有前一步骤列出的订单编号的所有客户的ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id<br>FROM orders<br>WHERE order_num IN (20005, 20007);<br></code></pre></td></tr></table></figure><blockquote><p>cust_id<br>10001<br>10004</p></blockquote><p>​现在，把第一个查询变为子查询，组合成两个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_id<br>FROM orders<br>WHERE order_num IN (SELECT order_num<br>FROM orderitems<br>WHERE prod_id = &#x27;TNT2&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>cust_id<br>10001<br>10004</p></blockquote><p>​在<strong>SELECT</strong>语句中，子查询总是<strong>从内向外</strong>处理。在处理上面的SELECT语句时，MySQL实际上执行了两个操作。<br>首先，它执行下面的查询:<br><code>SELECT order_num FROM orderitems wHERE prod_id=&#39;TNT2&#39;</code><br>此查询返回两个订单号:20005和20007。然后，这两个值以IN操作符要求的逗号分隔的格式传递给外部查询的WHERE子句。外部查询变成:<br>​<code>SELECT cust_id FROM orders WHERE order_num IN (20005,20007)</code><br>可以看到，输出是正确的并且与前面硬编码WHERE子句所返回的值相同。</p><p>​现在得到了订购物品TNT2的所有客户的ID。下一步是检索这些客户ID的客户信息。检索两列的SQL语句为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE cust_id  IN (10001, 10004)<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact<br>Coyote Inc.Y Lee<br>Yosemite Place Y Sam</p></blockquote><p>​可以把其中的WHERE子句转换为子查询而不是硬编码这些客户ID:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers<br>WHERE cust_id IN (SELECT cust_id<br>FROM orders<br>WHERE order_num IN (SELECT order_num<br>FROM orderitems<br>WHERE prod_id = &#x27;TNT2&#x27;))<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_contact<br>Coyote Inc.Y Lee<br>Yosemite Place Y Sam</p></blockquote><h3 id="2、作为计算字段使用子查询"><a href="#2、作为计算字段使用子查询" class="headerlink" title="2、作为计算字段使用子查询"></a>2、作为计算字段使用子查询</h3><p>​使用子查询的另一方法是创建计算字段。假如需要显示customers表中<strong>每个客户的订单总数</strong>。订单与相应的客户ID存储在orders表中。<br>为了执行这个操作，遵循下面的步骤。<br>​(1)从customers表中检索客户列表。<br>​(2)对于检索出的每个客户，统计其在orders表中的订单数目。</p><p>​为了对每个客户执行*<em>COUNT(</em>)<strong>计算，应该将</strong>COUNT (*)**作为一个子查询。请看下面的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>cust_name,<br>cust_state,<br>( SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id ) AS orders <br>FROM<br>customers <br>ORDER BY<br>cust_name<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_stateorders<br>Coyote Inc.MI2<br>E FuddIL 1<br>Mouse House   OH       0<br>Wascals  IN        1<br>Yosemite Place AZ1</p></blockquote><p>​这条SELECT语句对customers表中每个客户返回3列:cust_name、cust_state和orders。orders是一个<strong>计算字段</strong>，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一次。在此例子中，该子查询执行了5次，因为检索出了5个客户。<br>​子查询中的<strong>WHERE</strong>子句与前面使用的<strong>WHERE</strong>子句稍有不同,因为它使用了完全限定列名（在第4章中首次提到)。下面的语句告诉SQL比较<strong>orders表中的cust_id</strong>与<strong>当前正从customers</strong>表中检索的<strong>cust_id</strong>:<br><code>wHERE orders.cust_id = customers.cust_id</code></p><h2 id="十五、联结表"><a href="#十五、联结表" class="headerlink" title="十五、联结表"></a>十五、联结表</h2><h3 id="1、联结"><a href="#1、联结" class="headerlink" title="1、联结"></a>1、联结</h3><p>​SQL最强大的功能之一就是能在数据检索查询的执行中联结( join)表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是学习SQL的一个极为重要的组成部分。</p><h4 id="（1）关系表"><a href="#（1）关系表" class="headerlink" title="（1）关系表"></a>（1）关系表</h4><p>​理解关系表的最好方法是来看一个现实世界中的例子。<br>​假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。<br>​现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢?将这些数据与产品信息分开存储的理由如下。</p><ul><li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li><li>如果供应商信息改变（例如，供应商搬家或电话号码变动)，只需改动一次即可。</li><li>如果有重复数据（即每种产品都存储供应商信息)，很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li></ul><p>​关键是，相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系( relational ) )互相关联。<br>​在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。<strong>vendors</strong>表包含所有供应商信息，每个供应商占一行，<strong>每个供应商具有唯一</strong>的标识。此标识称为<strong>主键</strong>( primary key)(，可以是供应商ID或任何其他唯一值。<br>​<strong>products</strong>表只存储产品信息，它除了存储供应商ID(<strong>vendors</strong>表的主键）外不存储其他供应商信息。<strong>vendors表的主键</strong>又叫作<strong>products的外键</strong>，它将vendors表与products表关联，利用<strong>供应商ID</strong>能从vendors表中找出相应供应商的详细信息。</p><blockquote><p><strong>外键(foreign key)</strong>外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。<br>    这样做的好处如下:</p><ul><li>供应商信息不重复，从而不浪费时间和空间;</li><li>如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动;</li><li>由于数据无重复，显然数据是一致的，这使得处理数据更简单。</li></ul><p>​总之，关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。(foreign key)外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p></blockquote><blockquote><p><strong>可伸缩性(scale)</strong>能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好( scale well )。</p></blockquote><h4 id="（2）为什么要使用联结"><a href="#（2）为什么要使用联结" class="headerlink" title="（2）为什么要使用联结"></a>（2）为什么要使用联结</h4><p>​正如所述，分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。<br>​如果数据存储在多个表中，怎样用单条SELECT语句检索出数据?答案是使用<strong>联结</strong>。简单地说，联结是一种机制，用来在一条SELECT语句中<strong>关联表</strong>，因此称之为<strong>联结</strong>。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><h3 id="2、创建联结"><a href="#2、创建联结" class="headerlink" title="2、创建联结"></a>2、创建联结</h3><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可，请看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, prod_name, prod_price<br>FROM vendors, products<br>WHERE vendors.vend_id = products.vend_id<br>ORDER BY vend_name, prod_name<br></code></pre></td></tr></table></figure><blockquote><p>vend_nameprod_nameprod_price<br>ACMEBird seed10.00<br>ACMECarrots2.50<br>ACMEDetonator13.00<br>ACMESafe50.00<br>ACMESling4.49<br>ACMETNT (1 stick)2.50<br>ACMETNT (5 sticks)10.00<br>Anvils R Us.5 ton anvil5.99<br>Anvils R Us1 ton anvil9.99<br>Anvils R Us2 ton anvil14.99<br>Jet SetJetPack 100035.00<br>Jet SetJetPack 200055.00<br>LT SuppliesFuses3.42<br>LT SuppliesOil can8.99</p></blockquote><p>​我们来考察一下此代码。SELECT语句与前面所有语句一样指定要检索的列。这里,最大的差别是所指定的两个列(prod_name<br>和prod_price)在一个表中，而另一个列(vend_name)在另一个表中。<br>​现在来看FROM子句。与以前的SELECT语句不一样，这条语句的FROM子句列出了两个表,分别是vendors和products。它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确联结，WHERE子句指示MySQL匹配<strong>vendors表中的vend_id</strong>和<strong>products表中的vend_id</strong>。<br>​可以看到要匹配的两个列以<strong>vendors.vend_id</strong>和<strong>products.vend_id</strong>指定。这里需要这种<strong>完全限定列名</strong>，因为如果只给出vend_id，则MySQL不知道指的是哪一个（它们有两个，每个表中一个)。</p><h4 id="（1）WHERE子句的重要性"><a href="#（1）WHERE子句的重要性" class="headerlink" title="（1）WHERE子句的重要性"></a>（1）WHERE子句的重要性</h4><p>​在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。<strong>WHERE</strong>子句作为<strong>过滤条件</strong>，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。</p><blockquote><p><strong>笛卡儿积(cartesian product)</strong>由没有联结条件的表关系返回的结果为<strong>笛卡儿积</strong>。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p></blockquote><p>​对于<strong>笛卡尔积</strong>的理解可以对比下述代码与上一个例子进行理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, prod_name, prod_price<br>FROM vendors, products<br>ORDER BY vend_name, prod_name<br></code></pre></td></tr></table></figure><blockquote><p>vend_nameprod_nameprod_price<br>ACME.5 ton anvil5.99<br>ACME1 ton anvil9.99<br>ACME2 ton anvil14.99<br>ACMEBird seed10.00<br>ACMECarrots2.50<br>ACMEDetonator13.00<br>ACMEFuses3.42<br>ACMEJetPack 100035.00<br>ACMEJetPack 200055.00<br>ACMEOil can8.99<br>ACMESafe50.00<br>ACMESling4.49<br>ACMETNT (1 stick)2.50<br>ACMETNT (5 sticks)10.00<br>Anvils R Us.5 ton anvil5.99<br>Anvils R Us1 ton anvil9.99<br>Anvils R Us2 ton anvil14.99<br>Anvils R UsBird seed10.00<br>Anvils R UsCarrots2.50<br>Anvils R UsDetonator13.00<br>Anvils R UsFuses3.42<br>Anvils R UsJetPack 100035.00<br>Anvils R UsJetPack 200055.00<br>Anvils R UsOil can8.99<br>Anvils R UsSafe50.00<br>Anvils R UsSling4.49<br>Anvils R UsTNT (1 stick)2.50<br>Anvils R UsTNT (5 sticks)10.00<br>Furball Inc..5 ton anvil5.99<br>Furball Inc.1 ton anvil9.99<br>Furball Inc.2 ton anvil14.99<br>Furball Inc.Bird seed10.00<br>Furball Inc.Carrots2.50<br>Furball Inc.Detonator13.00<br>Furball Inc.Fuses3.42<br>Furball Inc.JetPack 100035.00<br>Furball Inc.JetPack 200055.00<br>Furball Inc.Oil can8.99<br>Furball Inc.Safe50.00<br>Furball Inc.Sling4.49<br>Furball Inc.TNT (1 stick)2.50<br>Furball Inc.TNT (5 sticks)10.00<br>Jet Set.5 ton anvil5.99<br>Jet Set1 ton anvil9.99<br>Jet Set2 ton anvil14.99<br>Jet SetBird seed10.00<br>Jet SetCarrots2.50<br>Jet SetDetonator13.00<br>Jet SetFuses3.42<br>Jet SetJetPack 100035.00<br>Jet SetJetPack 200055.00<br>Jet SetOil can8.99<br>Jet SetSafe50.00<br>Jet SetSling4.49<br>Jet SetTNT (1 stick)2.50<br>Jet SetTNT (5 sticks)10.00<br>Jouets Et Ours.5 ton anvil5.99<br>Jouets Et Ours1 ton anvil9.99<br>Jouets Et Ours2 ton anvil14.99<br>Jouets Et OursBird seed10.00<br>Jouets Et OursCarrots2.50<br>Jouets Et OursDetonator13.00<br>Jouets Et OursFuses3.42<br>Jouets Et OursJetPack 100035.00<br>Jouets Et OursJetPack 200055.00<br>Jouets Et OursOil can8.99<br>Jouets Et OursSafe50.00<br>Jouets Et OursSling4.49<br>Jouets Et OursTNT (1 stick)2.50<br>Jouets Et OursTNT (5 sticks)10.00<br>LT Supplies.5 ton anvil5.99<br>LT Supplies1 ton anvil9.99<br>LT Supplies2 ton anvil14.99<br>LT SuppliesBird seed10.00<br>LT SuppliesCarrots2.50<br>LT SuppliesDetonator13.00<br>LT SuppliesFuses3.42<br>LT SuppliesJetPack 100035.00<br>LT SuppliesJetPack 200055.00<br>LT SuppliesOil can8.99<br>LT SuppliesSafe50.00<br>LT SuppliesSling4.49<br>LT SuppliesTNT (1 stick)2.50<br>LT SuppliesTNT (5 sticks)10.00</p></blockquote><p>​从上面的输出中可以看到，相应的笛卡儿积不是我们所想要的。这里返回的数据用每个供应商匹配了每个产品，它包括了<br>供应商不正确的产品。实际上有的供应商根本就没有产品。</p><h4 id="（2）内部联结"><a href="#（2）内部联结" class="headerlink" title="（2）内部联结"></a>（2）内部联结</h4><p>​目前为止所用的联结称为<strong>等值联结</strong>，它基于两个表之间的相等测试。这种联结也称为<strong>内部联结</strong>。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的SELECT语句返回与前面例子完全相同的数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_name, prod_name, prod_price<br>FROM vendors<br>INNER JOIN products <br>ON vendors.vend_id = products.vend_id<br></code></pre></td></tr></table></figure><blockquote><p>vend_nameprod_nameprod_price<br>Anvils R Us.5 ton anvil5.99<br>Anvils R Us1 ton anvil9.99<br>Anvils R Us2 ton anvil14.99<br>LT SuppliesFuses3.42<br>LT SuppliesOil can8.99<br>ACMEDetonator13.00<br>ACMEBird seed10.00<br>ACMECarrots2.50<br>ACMESafe50.00<br>ACMESling4.49<br>ACMETNT (1 stick)2.50<br>ACMETNT (5 sticks)10.00<br>Jet SetJetPack 100035.00<br>Jet SetJetPack 200055.00</p></blockquote><h4 id="（3）联结多个表"><a href="#（3）联结多个表" class="headerlink" title="（3）联结多个表"></a>（3）联结多个表</h4><p>​SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_name, vend_name, prod_price, quantity<br>FROM orderitems, products, vendors<br>WHERE products.vend_id = vendors.vend_id <br>AND orderitems.prod_id = products.prod_id<br>AND order_num = 20005<br></code></pre></td></tr></table></figure><blockquote><p>prod_namevend_nameprod_pricequantity<br>.5 ton anvilAnvils R Us5.9910<br>1 ton anvilAnvils R Us9.993<br>TNT (5 sticks)ACME10.005<br>Bird seedACME10.001</p></blockquote><p>​此例子显示编号为<strong>20005</strong>的订单中的物品。订单物品存储在<strong>orderitems</strong>表中。每个产品按其产品ID存储，它引用<strong>products</strong>表中的产品。这些产品通过供应商<strong>ID</strong>联结到<strong>vendors</strong>表中相应的供应商，供应商ID存储在每个产品的记录中。这里的<strong>FROM</strong>子句列出了3个表，而<strong>WHERE</strong>子句定义了这两个联结条件，而第三个联结条件用来过滤出订单<strong>20005</strong>中的物品。</p><h2 id="十六、创建高级联结"><a href="#十六、创建高级联结" class="headerlink" title="十六、创建高级联结"></a>十六、创建高级联结</h2><h3 id="1、使用表别名"><a href="#1、使用表别名" class="headerlink" title="1、使用表别名"></a>1、使用表别名</h3><p>​给列起别名的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CONCAT(RTrim(vend_name),&#x27;(&#x27;,RTRIM(vend_country), &#x27;)&#x27;) AS vend_title <br>FROM vendors<br>ORDER BY vend_name;<br></code></pre></td></tr></table></figure><p>​<code>CONCAT(RTrim(vend_name), &#39;(&#39;, RTRIM(vend_country), &#39;)&#39;) AS vend_title</code>: 这个部分使用<code>CONCAT</code>函数将两个列的值组合在一起，创建了一个新的名为<code>vend_title</code>的列。<code>RTRIM</code>函数用于从列的末尾去掉空格，因此<code>RTRIM(vend_name)</code>和<code>RTRIM(vend_country)</code>将去除这些列中可能存在的多余空格。最终结果会将每个供应商的名称和国家组合成一个标题，并将其放在括号中</p><p>​别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由:</p><ul><li>缩短SQL语句;</li><li>允许在单条SELECT语句中多次使用相同的表。</li></ul><p>下面的例子，就是运用了别名的方式，其功能与上一章的例子基本相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT cust_name, cust_contact<br>FROM customers AS c, orders AS o, orderitems AS oi  <br>WHERE c.cust_id = o.cust_id<br>AND oi.order_num = o.order_num<br>AND prod_id = &#x27;TNT2&#x27;<br></code></pre></td></tr></table></figure><h3 id="2、使用不同类型的联结"><a href="#2、使用不同类型的联结" class="headerlink" title="2、使用不同类型的联结"></a>2、使用不同类型的联结</h3><h4 id="（1）自联结"><a href="#（1）自联结" class="headerlink" title="（1）自联结"></a>（1）自联结</h4><p>​如前所述，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表。下面举一个例子。<br>​假如你发现某物品(其<strong>ID</strong>为<strong>DTNTR</strong>）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产<strong>ID</strong>为<strong>DTNTR</strong>的物品的供应商，然后找出这个供应商生产的其他物品。下面是解决此问题的一种方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT prod_id, prod_name<br>FROM products<br>WHERE vend_id = (SELECT vend_id<br> FROM products<br> WHERE prod_id = &#x27;DTNTR&#x27;);<br></code></pre></td></tr></table></figure><blockquote><p>prod_idprod_name<br>DTNTRDetonator<br>FBBird seed<br>FCCarrots<br>SAFESafe<br>SLINGSling<br>TNT1TNT (1 stick)<br>TNT2TNT (5 sticks)</p></blockquote><p>​这是第一种解决方案，它使用了<strong>子查询</strong>。内部的<strong>SELECT</strong>语句做了一个简单的检索，返回生产ID为DTNTR的物品供应商的vend_id。该ID用于外部查询的WHERE子句中，以便检索出这个供应商生产的所有物品（第14章中讲授了子查询的所有内容。更多信息请参阅该章)。</p><p>​下面是使用联结的相同查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT p1.prod_id, p1.prod_name<br>FROM products AS p1, products AS p2<br>WHERE p1.vend_id = p2.vend_id<br>AND p2.prod_id = &#x27;DTNTR&#x27;;<br></code></pre></td></tr></table></figure><p>​此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对<br>products的引用具有<strong>二义性</strong>，因为MySQL不知道你引用的是products表中的哪个实例。<br>​为解决此问题，使用了表别名。products的第一次出现为别名<strong>p1</strong>，第二次出现为别名p2。现在可以将这些别名用作表名。例如，SELECT语句使用<strong>p1前缀明确地给出所需列的全名</strong>。如果不这样，MySQL将返回错误，因为分别存在两个名为prod_id、prod_name的列。MySQL不知道想要的是哪一个列（即使它们事实上是同一个列)。WHERE（通过<strong>匹配p1中的vend_id和p2中的vend_id</strong>）首先联结两个表，然后按<strong>第二个表中的prod_id过滤数据</strong>，返回所需的数据。</p><h4 id="（2）自然联结"><a href="#（2）自然联结" class="headerlink" title="（2）自然联结"></a>（2）自然联结</h4><p>​自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符(SELECT *)，对所有其他表的列使用明确的子集来完成的。下面举一个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price<br>FROM customers AS c, orders AS o, orderitems AS oi <br>WHERE c.cust_id = o.cust_id<br>AND oi.order_num = o.order_num<br>AND prod_id = &#x27;FB&#x27;<br></code></pre></td></tr></table></figure><p>​在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p><h4 id="（3）外部联结"><a href="#（3）外部联结" class="headerlink" title="（3）外部联结"></a>（3）外部联结</h4><p>​许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。例如，可能需要使用联结来完成以下工作:</p><ul><li>对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户;</li><li>列出所有产品以及订购数量，包括没有人订购的产品;</li><li>计算平均销售规模，包括那些至今尚未下订单的客户。</li></ul><p>​在上述例子中，联结<strong>包含了那些在相关表中没有关联行的行</strong>。这种类型的联结称为<strong>外部联结</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_id, orders.order_num<br>FROM customers INNER JOIN orders<br>ON customers.cust_id = orders.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_num<br>1000120005<br>1000120009<br>1000320006<br>1000420007<br>1000520008</p></blockquote><p>​可以看到只输出了有订单的客户，而那些没有订单的客户被忽略了，为了检索所有客户，可如下进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_id, orders.order_num<br>FROM customers LEFT OUTER JOIN orders<br>ON customers.cust_id = orders.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_num<br>1000120005<br>1000120009<br>10002NULL<br>1000320006<br>1000420007<br>1000520008</p></blockquote><p>​类似于上一章中所看到的内部联结,这条SELECT语句使用了关键字<code>OUTER JOIN</code>来指定联结的类型（而不是在WHERE子句中指定)。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用<code>OUTER JOIN</code>语法时，必须使用<strong>RIGHT</strong>或<strong>LEFT</strong>关键字指定包括其所有行的表（RIGHT指出的是<code>OUTER JOIN</code>右边的表，而LEFT指出的是<code>OUTER JOIN</code>左边的表)。上面的例子使用<code>LEFT OUTERJOIN</code>从FROM子句的左边表( <strong>customers</strong>表）中选择所有行。为了从右边的表中选择所有行，应该使用<code>RIGHT OUTER JOIN</code>，如下例所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_id, orders.order_num<br>FROM customers RIGHT OUTER JOIN orders<br>ON customers.cust_id = orders.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_idorder_num<br>1000120005<br>1000120009<br>1000320006<br>1000420007<br>1000520008</p></blockquote><blockquote><p><strong>外部联结的类型</strong>存在两种基本的外部联结形式:左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说,左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此,两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。</p></blockquote><h3 id="3、使用带聚集函数的联结"><a href="#3、使用带聚集函数的联结" class="headerlink" title="3、使用带聚集函数的联结"></a>3、使用带聚集函数的联结</h3><p>​虽然至今为止聚集函数的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。<br>​请看下面的例子。如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT ()函数的代码可完成此工作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord <br>FROM customers INNER JOIN orders<br>ON customers.cust_id = orders.cust_id<br>GROUP BY customers.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_idnum_ord<br>Coyote Inc.   100012<br>Wascals 100031<br>Yosemite Place100041<br>E Fudd100051</p></blockquote><p>​此SELECT语句使用<strong>INNER JOIN</strong>将<strong>customers</strong>和<strong>orders</strong>表互相关联。GROUP BY子句按客户分组数据，因此，函数调用<code>COUNT (orders.order_num)</code>对每个客户的订单计数，将它作为<strong>num_ord</strong>返回。<br>​聚集函数也可以方便地与其他联结一起使用。请看下面的例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord <br>FROM customers LEFT OUTER JOIN orders<br>ON customers.cust_id = orders.cust_id<br>GROUP BY customers.cust_id<br></code></pre></td></tr></table></figure><blockquote><p>cust_namecust_idnum_ord<br>Coyote Inc.100012<br>Mouse House100020<br>Wascals  100031<br>Yosemite Place10004 1<br>E Fudd 100051</p></blockquote><p>​这个例子使用左外部联结来包含所有客户，甚至包含那些没有任何下订单的客户。结果显示也包含了客户<strong>Mouse House</strong>，它<br>有0个订单。</p><h3 id="4、使用联结和联结条件"><a href="#4、使用联结和联结条件" class="headerlink" title="4、使用联结和联结条件"></a>4、使用联结和联结条件</h3><p>​汇总一下关于联结及其使用的某些要点。</p><ul><li>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</li><li>保证使用正确的联结条件，否则将返回不正确的数据。</li><li>应该总是提供联结条件，否则会得出笛卡儿积。</li><li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li></ul><h2 id="十七、组合查询"><a href="#十七、组合查询" class="headerlink" title="十七、组合查询"></a>十七、组合查询</h2><h3 id="1、组合查询"><a href="#1、组合查询" class="headerlink" title="1、组合查询"></a>1、组合查询</h3><pre><code class="hljs"> MySQL允许执行多个查询(多条SELECT语句)，并将结果作为单个查询结果集返回。这些组合查询通常称为并（ union)或复合查询。有两种基本情况，其中需要使用组合查询:</code></pre><ul><li>在单个查询中从不同的表返回类似结构的数据;</li><li>对单个表执行多个查询，按单个查询返回数据。</li></ul><h3 id="2、创建组合查询"><a href="#2、创建组合查询" class="headerlink" title="2、创建组合查询"></a>2、创建组合查询</h3><h4 id="（1）使用UNION"><a href="#（1）使用UNION" class="headerlink" title="（1）使用UNION"></a>（1）使用UNION</h4><p>​<strong>UNION</strong>的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字<strong>UNION</strong>。<br>​举一个例子，假如需要价格<strong>小于等于5</strong>的所有物品的一个列表，而且还想包括供应商<strong>1001</strong>和1002<strong>生产</strong>的所有物品（不考虑价格)。当然，可以利用WHERE子句来完成此工作，不过这次我们将使用UNION。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION<br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (1001, 1002)<br></code></pre></td></tr></table></figure><blockquote><p>vend_idprod_idprod_price<br>1003FC2.50<br>1002FU13.42<br>1003SLING4.49<br>1003TNT12.50<br>1001ANV015.99<br>1001ANV029.99<br>1001ANV0314.99<br>1002OL18.99</p></blockquote><p>​第一条SELECT检索<strong>价格不高于5</strong>的所有物品。第二条SELECT使用IN找出供应商<strong>1001</strong>和<strong>1002</strong>生产的所有物品。<strong>UNION</strong>指示MySQL<strong>执行</strong>两条SELECT语句，并把输出组<strong>合成</strong>单个查询结果集。</p><h4 id="（2）UNION规则"><a href="#（2）UNION规则" class="headerlink" title="（2）UNION规则"></a>（2）UNION规则</h4><pre><code class="hljs"> **UNION**的使用规则如下：</code></pre><ul><li><strong>UNION</strong>必须由<strong>两条</strong>或两条以上的SELECT语句组成，语句之间用关键字<strong>UNION</strong>分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字)。</li><li><strong>UNION</strong>中的每个查询必须包含<strong>相同的列</strong>、<strong>表达式</strong>或聚集函数（不过各个列不需要以相同的次序列出)。</li><li>列数据类型必须兼容:类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型)。</li></ul><p>​如果遵守了这些基本规则或限制,则可以将并用于任何数据检索任务。</p><h4 id="（3）包含或取消重复的行"><a href="#（3）包含或取消重复的行" class="headerlink" title="（3）包含或取消重复的行"></a>（3）包含或取消重复的行</h4><p>​上面的例子的两个SELECT语句，如果分别执行的话，是有9行输出结果的，但使用UNION关键字的话，只输出8行，这是因为有一行重复元素。</p><p>​这是因为在使用UNION时，重复的行被自动取消，这是默认行为，但如果需要，可以改变它。只需要使用<strong>UNION ALL</strong>而不是<strong>UNION</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION ALL<br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (1001, 1002)<br></code></pre></td></tr></table></figure><blockquote><p>vend_idprod_price<br>10032.50<br>10023.42<br>10034.49<br>10032.50<br>10015.99<br>10019.99<br>100114.99<br>10023.42<br>10028.99</p></blockquote><h4 id="（4）对组成查询结果排序"><a href="#（4）对组成查询结果排序" class="headerlink" title="（4）对组成查询结果排序"></a>（4）对组成查询结果排序</h4><p>​SELECT语句的输出用<strong>ORDER BY</strong>子句排序。在用UNION组合查询时，只能使用一条<strong>ORDER BY</strong>子句，它必须出现在<strong>最后一条SELECT语句之后</strong>。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句，上一个例子排序后的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION <br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (1001, 1002)<br>ORDER BY vend_id, prod_price<br></code></pre></td></tr></table></figure><blockquote><p>vend_idprod_idprod_price<br>1001ANV015.99<br>1001ANV029.99<br>1001ANV0314.99<br>1002FU13.42<br>1002OL18.99<br>1003FC2.50<br>1003TNT12.50<br>1003SLING4.49</p></blockquote><p>​这条UNION在最后一条SELECT语句后使用了ORDER BY子句。虽然ORDER BY子句似乎只是最后一条SELECT语句的组成部分，但实际上MySQL将用它来<strong>排序</strong>所有SELECT语句返回的<strong>所有结果</strong>。</p><h2 id="十八、全文本搜索"><a href="#十八、全文本搜索" class="headerlink" title="十八、全文本搜索"></a>十八、全文本搜索</h2><h3 id="1、理解全文本搜索"><a href="#1、理解全文本搜索" class="headerlink" title="1、理解全文本搜索"></a>1、理解全文本搜索</h3><pre><code class="hljs"> 在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们)，哪些词不匹配，它们匹配的频率，等等。</code></pre><h3 id="2、使用全文本搜索"><a href="#2、使用全文本搜索" class="headerlink" title="2、使用全文本搜索"></a>2、使用全文本搜索</h3><h3 id="（1）创建全文本搜索"><a href="#（1）创建全文本搜索" class="headerlink" title="（1）创建全文本搜索"></a>（1）创建全文本搜索</h3><p>​一般在创建表时启用全文本搜索。CREATE TABLE语句(第21章中介绍）接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。<br>下面的CREATE语句演示了FULLTEXT子句的使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE productnotes<br>(<br>note_id INT NOT NULL auto_INCREMENT,<br>prod_id char(10) NOT NULL,<br>note_date DATETIME NOT NULL,<br>note_text TEXT NULL,<br>PRIMARY KEY(note_id),<br>FULLTEXT(note_text)<br>)ENGINE=MyISAM;<br></code></pre></td></tr></table></figure><p>​第21章将详细考察<strong>CREATE TABLE</strong>语句。现在，只需知道这条<br>CREATE TABLE语句定义表<strong>productnotes</strong>并列出它所包含的<br>列即可。这些列中有一个名为<strong>note_text</strong>的列，为了进行全文本搜索，MySQL根据子句<strong>FULLTEXT</strong> ( note_text)的指示对它进行索引。这里的FULLTEXT索引单个列，如果需要也可以指定多个列。<br>​在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，<br>索引随之自动更新。</p><h3 id="（2）进行全文本搜索"><a href="#（2）进行全文本搜索" class="headerlink" title="（2）进行全文本搜索"></a>（2）进行全文本搜索</h3><p>​在索引之后，使用两个函数<strong>Match ( )<strong>和</strong>Against()<strong>执行全文本搜索，其中Match()指定被</strong>搜索的列</strong>，Against()指定要使用的<strong>搜索表达式</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT note_text<br>FROM productnotes<br>WHERE MATCH(note_text) Against(&#x27;rabbit&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>note_text<br>Customer complaint: rabbit has been able to detect trap, food apparently less effective now.<br>Quantity varies, sold by the sack load.<br>All guaranteed to be bright and orange, and suitable for use as rabbit bait.</p></blockquote><p>​此SELECT语句检索单个列<strong>note_text</strong>。由于WHERE子句，一个全文本搜索被执行。<strong>Match(note_text)<strong>指示</strong>MySQL</strong>针对指定的列进行搜索，Against <strong>( ‘ rabbit ‘ )<strong>指定词</strong>rabbit</strong>作为搜索文本。由于有两行包含词<strong>rabbit</strong>，这两个行被返回。</p><h3 id="（3）使用查询扩展"><a href="#（3）使用查询扩展" class="headerlink" title="（3）使用查询扩展"></a>（3）使用查询扩展</h3><p>​<strong>查询扩展</strong>用来设法放宽所返回的全文本搜索结果的范围。考虑下面的情况。你想找出所有<strong>提到anvils</strong>的注释。只有一个注释包含词anvils,但你还想找出可能<strong>与你的搜索有关</strong>的所有其他行，即使它们不包含词anvils。<br>​这也是查询扩展的一项任务。在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索:</p><ul><li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行;</li><li>其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简要地解释MySQL如何断定什么有用，什么无用)。</li><li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</li></ul><p>​利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词。</p><p> 下面是一个简单的全文本搜索，没有查询扩展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT note_text<br>FROM productnotes<br>WHERE MATCH(note_text) Against(&#x27;anvils&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>note_text<br>Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.</p></blockquote><p>​下面是相同的查询，但这次使用查询扩展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT note_text<br>FROM productnotes<br>WHERE MATCH(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION)<br></code></pre></td></tr></table></figure><blockquote><p>note_text<br>Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils.<br>Customer complaint:<br>Sticks not individually wrapped, too easy to mistakenly detonate all at once.<br>Recommend individual wrapping.<br>Customer complaint:<br>Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.<br>Please note that no returns will be accepted if safe opened using explosives.<br>Customer complaint: rabbit has been able to detect trap, food apparently less effective now.<br>Customer complaint:<br>Circular hole in safe floor can apparently be easily cut with handsaw.<br>Matches not included, recommend purchase of matches or detonator (item DTNTR).</p></blockquote><p>​这次返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关,但因为它包含第一行中的两个词(customer和recommend)，所以也被检索出来。第3行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名)。<br>​正如所见，查询扩展极大地增加了返回的行数，但这样做也增加了你实际上并不想要的行的数目。</p><h2 id="十九、插入数据"><a href="#十九、插入数据" class="headerlink" title="十九、插入数据"></a>十九、插入数据</h2><h3 id="1、数据插入"><a href="#1、数据插入" class="headerlink" title="1、数据插入"></a>1、数据插入</h3><p>​顾名思义，<strong>INSERT</strong>是用来插入（或添加）行到数据库表的。插入可以用几种方式使用:</p><ul><li>插入完整的行;</li><li>插入行的一部分;</li><li>插入多行;</li><li>插入某些查询的结果。</li></ul><h3 id="2、插入完整的行"><a href="#2、插入完整的行" class="headerlink" title="2、插入完整的行"></a>2、插入完整的行</h3><p>​把数据插入表中最简单的方法是使用基本的<strong>INSERT</strong>语法，它要求指定表名和被插入到新行的值。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO customers<br>VALUES<br>( NULL, &#x27;Pep E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL );<br></code></pre></td></tr></table></figure><p>​此例子插入一个新客户到customers表。存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。如果某个列没有值(如上面的cust_contact和cust_email列),应该使用NULL值（假定表允许对该列指定空值)。各个列必须以它们在表定义中出现的次序填充。第一列cust_id也为NULL。这是因为每次插入一个新行时，该列由MySQL自动增量。你不想给出一个值（这是MySQL的工作)，又不能省略此列（如前所述，必须给出每个列)，所以指定一个NULL值（它被MySQL忽略，MySQL在这里插入下一个可用的cust_id值)。<br>​虽然这种语法很简单，但并不安全，应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。因此，编写依赖于特定列次序的SQL语句是很不安全的。如果这样做，有时难免会出问题。<br>​编写INSERT语句的更安全（不过更烦琐）的方法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO customers ( cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email )<br>VALUES<br>( &#x27;Pep E. LaPew&#x27;, &#x27;100 Main Street&#x27;, &#x27;Los Angeles&#x27;, &#x27;CA&#x27;, &#x27;90046&#x27;, &#x27;USA&#x27;, NULL, NULL );<br></code></pre></td></tr></table></figure><p>​因为提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。你会发现cust_id的NULL值是不必要的，cust_id列并没有出现在列表中，所以不需要任何值。</p><h3 id="3、插入多个行"><a href="#3、插入多个行" class="headerlink" title="3、插入多个行"></a>3、插入多个行</h3><p>​有两种方法：</p><ul><li><p>可以使用多条INSERT语句，每条语句用一个分号结束，如下：</p></li><li><pre><code class="mysql">INSERT INTO TABLE_NAME(...) VALUES(...);INSERT INTO TABLE_NAME(...) VALUES(...);...<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>- ```mysql<br>  INSERT INTO <span class="hljs-built_in">TABLE_NAME</span>(...)<br>  <span class="hljs-built_in">VALUES</span>(...),(...)...;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="4、插入检索出的数据"><a href="#4、插入检索出的数据" class="headerlink" title="4、插入检索出的数据"></a>4、插入检索出的数据</h3><p>​INSERT一般用来给表插入一个指定列值的行。但是，INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中。这就是所谓的INSERT SELECT,顾名思义，它是由一条INSERT语句和一条SELECT语句组成的。<br>​假如你想从另一表中合并客户列表到你的customers表。不需要每次读取一行，然后再将它用INSERT插入，可以如下进行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO customers ( cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country ) SELECT<br>cust_id,<br>cust_contact,<br>cust_email,<br>cust_name,<br>cust_address,<br>cust_city,<br>cust_state,<br>cust_zip,<br>cust_country <br>FROM<br>custnew;<br></code></pre></td></tr></table></figure><p>​这个例子使用INSERT SELECT从custnew中将所有数据导入customers。SELECT语句从custnew检索出要插入的值，而不是列出它们。SELECT中列出的每个列对应于customers表名后所跟的列表中的每个列。这条语句将插入多少行有赖于custnew表中有多少行。如果这个表为空，则没有行被插入（也不产生错误，因为操作仍然是合法的)。如果这个表确实含有数据，则所有数据将被插入到customers。<br>​这个例子导入了cust_id（假设你能够确保cust_id的值不重复)。你也可以简单地省略这列（从INSERT和SELECT中)，这样MySQL就会生成新值。<br>​INSERT SELECT中的列名为简单起见,这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上,MySQL甚至不关心SELECT返回的列名,它使用的是列的位置,因此SELECT中的第一列(不管其列名）将用来填充表列中指定的第一个列,第二列将用来填充表列中指定的第二个列，如此等等,这对于从使用不同列名的表中导入数据是非常有用的。<br>​INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据。</p><h2 id="二十、更新和删除数据"><a href="#二十、更新和删除数据" class="headerlink" title="二十、更新和删除数据"></a>二十、更新和删除数据</h2><h3 id="1、更新数据"><a href="#1、更新数据" class="headerlink" title="1、更新数据"></a>1、更新数据</h3><p>​为了更新（修改）表中的数据，可使用UPDATE语句。可采用两种方式使用<strong>UPDATE</strong>:</p><ul><li>更新表中特定行;</li><li>更新表中所有行。</li></ul><p>下面分别对它们进行介绍。</p><p>​UPDATE语句非常容易使用，甚至可以说是太容易使用了。基本的UPDATE语句由3部分组成，分别是:</p><ul><li>要更新的表;</li><li>列名和它们的新值;</li><li>确定要更新行的过滤条件。</li></ul><p>​举一个简单例子。客户10005现在有了电子邮件地址，因此他的记录需要更新，语句如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE customers<br>SET cust_email = &#x27;elmer@fudd.com&#x27;<br>WHERE cust_id = 10005<br></code></pre></td></tr></table></figure><p>​更新多个列的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE customers <br>SET cust_email = &#x27;elmer@fudd.com&#x27;,<br>cust_name = &#x27;The Fudds&#x27; <br>WHERE<br>cust_id = 10005<br></code></pre></td></tr></table></figure><p>​在更新多个列时，只需要使用单个SET命令，每个“列&#x3D;值”对之间用逗号分隔。</p><p>​为了删除某个列的值，可以设置它为NULL，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE customers <br>SET cust_email = NULL <br>WHERE<br>cust_id = 10005<br></code></pre></td></tr></table></figure><h3 id="2、删除数据"><a href="#2、删除数据" class="headerlink" title="2、删除数据"></a>2、删除数据</h3><p>​为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方式使用DELETE:</p><ul><li>从表中删除特定的行;</li><li>从表中删除所有行。</li></ul><p>​下面的语句从customers表中删除一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM customers<br>WHERE cust_id = 10006<br></code></pre></td></tr></table></figure><p>​上述例子，只删除客户10006，若省略WHERE子句，它将删除表中每个客户。</p><p>​DELETE不需要列名或通配符。<strong>DELETE</strong>删除整行而不是删除列。为了删除指定的列，请使用<strong>UPDATE</strong>语句。</p><h3 id="3、更新和删除的指导原则"><a href="#3、更新和删除的指导原则" class="headerlink" title="3、更新和删除的指导原则"></a>3、更新和删除的指导原则</h3><p>​前一节中使用的UPDATE和DELETE语句全都具有WHERE子句，这样做的理由很充分。如果省略了WHERE子句，则UPDATE或DELETE将被应用到表中所有的行。换句话说，如果执行UPDATE而不带WHERE子句，则表中每个行都将用新值更新。类似地，如果执行DELETE语句而不带WHERE子句，表的所有数据都将被删除。<br>​下面是许多SQL程序员使用UPDATE或DELETE时所遵循的习惯。除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。<br>​保证每个表都有主键(如果忘记这个内容，请参阅第15章)，尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围)。在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。使用强制实施引用完整性的数据库（关于这个内容，请参阅第15章)，这样MySQL将不允许删除具有与其他表相关联的数据的行。</p><h2 id="二十一、创建和操作表"><a href="#二十一、创建和操作表" class="headerlink" title="二十一、创建和操作表"></a>二十一、创建和操作表</h2><h3 id="1、创建表"><a href="#1、创建表" class="headerlink" title="1、创建表"></a>1、创建表</h3><p>​<strong>MySQL</strong>不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。</p><p>​创建表的方法有两种：</p><ul><li>使用具有交互创建和管理表的工具；</li><li>表也可以直接用<strong>MySQL</strong>语句操纵。</li></ul><p>可以使用<strong>CREATE TABLE</strong>创建表。在使用交互工具时，实际上使用的是<strong>MySQL</strong>语句。但是这些语句不上用户编写的，界面工具会自动生成并执行相应的<strong>MySQL</strong>语句（改现有表等操作也是如此）。</p><h4 id="（1）表创建基础"><a href="#（1）表创建基础" class="headerlink" title="（1）表创建基础"></a>（1）表创建基础</h4><p>​使用<strong>CREATE TABLE</strong>创建表时，必须给出下列信息：</p><ul><li>新表的名字，在关键字<strong>CREATE TABLE</strong></li><li>表列的名字和定义，用逗号隔开</li></ul><p><strong>CREATE TABLE</strong>语句也可能会包括其他关键字或选项，但至少包括<strong>表名</strong>和<strong>列的细节</strong>。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE customers (<br>  cust_id int NOT NULL AUTO_INCREMENT,<br>  cust_name char(50) NOT NULL,<br>  cust_address char(50) DEFAULT NULL,<br>  cust_city char(50) DEFAULT NULL,<br>  cust_state char(5) DEFAULT NULL,<br>  cust_zip char(10) DEFAULT NULL,<br>  cust_country char(50) DEFAULT NULL,<br>  cust_contact char(50) DEFAULT NULL,<br>  cust_email char(255) DEFAULT NULL,<br>  PRIMARY KEY (cust_id)<br>) ENGINE=InnoDB<br></code></pre></td></tr></table></figure><p>​从上面的例子可以看到，表名紧跟在<strong>CREATE TABLE</strong>关键字后面，实际的表定义(所有列)括在圆括号中。各列之间用逗号隔开。这个表由9列组成，每列的定义以列名（在表中必须是唯一的）开始，后跟列的数据类型。表的的主键可以在创建表时用<strong>PRIMARY KEY</strong>关键字指定。</p><h4 id="（2）使用NULL值"><a href="#（2）使用NULL值" class="headerlink" title="（2）使用NULL值"></a>（2）使用NULL值</h4><p>​<strong>NULL</strong>值就是没用值或缺值。允许<strong>NULL</strong>即允许插入列时不给出该列的值，不允许<strong>NULL</strong>值的列不接受该列没有值的行，换句话说，在插入或更新行时，该列必须有值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE orders (<br>  order_num int NOT NULL AUTO_INCREMENT,<br>  order_date datetime NOT NULL,<br>  cust_id int NOT NULL,<br>  PRIMARY KEY (order_num),<br>  KEY fk_orders_customers (cust_id),<br>  CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id)<br>) ENGINE=InnoDB <br></code></pre></td></tr></table></figure><p>​上面这个例子，创建了orders表。该表包括3个列，分别是订单号、订单日期、客户ID，由于3个列都需要，因此每个列的定义都包含<strong>NOT NULL</strong>。如果试图插入没用值的列，将会返回错误，且插入失败。</p><p>​下一个例子混合了<strong>NULL</strong>和<strong>NOT NULL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE vendors (<br>  vend_id int NOT NULL AUTO_INCREMENT,<br>  vend_name char(50) NOT NULL,<br>  vend_address char(50) DEFAULT NULL,<br>  vend_city char(50) DEFAULT NULL,<br>  vend_state char(5) DEFAULT NULL,<br>  vend_zip char(10) DEFAULT NULL,<br>  vend_country char(50) DEFAULT NULL,<br>  PRIMARY KEY (vend_id)<br>) ENGINE=InnoDB<br></code></pre></td></tr></table></figure><p>​由于供应商和供应商名字子列是必需的，因此使用<strong>NOT NULL</strong>，其余5个列都允许<strong>NULL</strong>值。<strong>NULL</strong>为默认值，如果不指定<strong>NOT NULL</strong>，则认定为<strong>NULL</strong>。</p><h4 id="（3）主键再介绍"><a href="#（3）主键再介绍" class="headerlink" title="（3）主键再介绍"></a>（3）主键再介绍</h4><p>​主键值必须唯一。即主键如果使用单个列，则其值必须唯一；如果使用多个列，则这些列的组合之必须唯一。</p><p>​下面是单个列作为主键的语句定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">PRIMARY KEY (vend_id)<br></code></pre></td></tr></table></figure><p>​为创建多个列组成的主键，应该以逗号分隔的列给出各列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE orderitems (<br>  order_num int NOT NULL,<br>  order_item int NOT NULL,<br>  prod_id char(10) NOT NULL,<br>  quantity int NOT NULL,<br>  item_price decimal(8,2) NOT NULL,<br>  PRIMARY KEY (order_num,order_item),<br>  KEY fk_orderitems_products (prod_id),<br>  CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num),<br>  CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id)<br>) ENGINE=InnoDB <br></code></pre></td></tr></table></figure><p>​每个订单有多项物品，但每个订单任何时候都只有1个第一项物品，1个第二项物品，如此等待。因此订单号（order_num列）和订单物品（order_item列）的组合是唯一的，因此可以作为主键。</p><h4 id="（4）AUTO-INCREMENT"><a href="#（4）AUTO-INCREMENT" class="headerlink" title="（4）AUTO_INCREMENT"></a>（4）AUTO_INCREMENT</h4><p>​观察一下<strong>customers</strong>表和<strong>orders</strong>表。<strong>customers</strong>表中的顾客列由<strong>cust_id</strong>唯一标识，每个顾客有一个唯一的编号。</p><p>​只要能保证每个顾客的编号不同，其值是多少都可以，为了方便我们引入<strong>AUTO_INCREMENT</strong>，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">cust_id int NOT NULL AUTO_INCREMENT,<br></code></pre></td></tr></table></figure><p>​<strong>AUTO_INCREMENT</strong>告诉<strong>MySQL</strong>，本列每当增加一行时自动增量。每次执行<strong>INSERT</strong>操作时，<strong>MySQL</strong>自动对该列增量，给该列赋予下一个可用的值，这样给每个行分配一个唯一的cust_id，从而可用用作主键的值。</p><p>​每个表只允许一个<strong>AUTO_INCREMENT</strong>列，而且它必须被索引。</p><h4 id="（5）指定默认值"><a href="#（5）指定默认值" class="headerlink" title="（5）指定默认值"></a>（5）指定默认值</h4><p>​如果在插入行时没有给出值，<strong>MySQL</strong>允许指定此时使用的默认值。默认值用<strong>CREATE TABLE</strong>语句的列定义中的<strong>DEFAULT</strong>关键字指定。</p><blockquote><p>​<strong>不允许函数</strong>：与大多数<strong>DBMS</strong>不一样，<strong>MySQL</strong>不允许使用函数作为默认值，它只支持常量。</p><p>​<strong>使用默认值而不是NULL值</strong> 许多数据库开发人员使用默认值而不是<strong>NULL</strong>列。</p></blockquote><h4 id="（6）引擎类型"><a href="#（6）引擎类型" class="headerlink" title="（6）引擎类型"></a>（6）引擎类型</h4><p>​迄今为止使用的<strong>CREATE TABLE</strong>语句全都以<strong>ENGINE&#x3D;InnoDB</strong>语句结束。</p><p>​与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候此引擎都隐藏在DBMS内，不需要过多关注它。</p><p>​但MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。<br>为什么要发行多种引擎呢?因为它们具有各自不同的功能和特性为不同的任务选择正确的引擎能获得良好的功能和灵活性。</p><p>当然，你完全可以忽略这些数据库引擎。如果省略ENGINE&#x3D;语句则使用默认引擎(很可能是MyISAM)，多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE&#x3D;语句很重要的原因(也就是为什么本书的样列表中使用两种引的原因)。</p><p>以下是几个需要知道的引擎:</p><ul><li>InnoDB是一个可靠的事务处理引擎(参见第26章)，它不支持全文本搜索;</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存(不是磁盘)中，速度很快(特别适合于临时表);</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索(参见第18章)，但不支持事务处理。</li></ul><h3 id="2、更新表"><a href="#2、更新表" class="headerlink" title="2、更新表"></a>2、更新表</h3><p>​更新表，可以使用<strong>ALTER TABLE</strong>语句。</p><p>​想要更新表，必须给出以下信息：</p><ul><li>在<strong>ALTER TABLE</strong>后给出要更改的表名。</li><li>所做更改的列表。</li></ul><p>​下面的例子给<strong>vendors</strong>表添加一个<strong>vend_phone</strong>列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table vendors<br>add vend_phone char(20);<br></code></pre></td></tr></table></figure><p>​删除刚刚增加的列，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table vendors<br>DROP COLUMN vend_phone;<br></code></pre></td></tr></table></figure><h3 id="3、删除表"><a href="#3、删除表" class="headerlink" title="3、删除表"></a>3、删除表</h3><p>​使用<strong>DROP TABLE</strong> 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE xx<br></code></pre></td></tr></table></figure><h3 id="4、重命名表"><a href="#4、重命名表" class="headerlink" title="4、重命名表"></a>4、重命名表</h3><p>使用<strong>RENAME TABLE</strong>即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RENAME TABLE xx TO yy<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程</title>
      <link href="/2023/04/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8D%8F%E7%A8%8B/"/>
      <url>/2023/04/24/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h1><p>关于协程，下面说法正确的是（ ）</p><ul><li>A. 协程和线程都可以实现程序的并发执行；</li><li>B. 线程比协程更轻量级；</li><li>C. 协程不存在死锁问题；</li><li>D. 通过 channel 来进行协程间的通信；</li></ul><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>、D<br></code></pre></td></tr></table></figure><h4 id="解析如下："><a href="#解析如下：" class="headerlink" title="解析如下："></a>解析如下：</h4><p>A. 协程和线程都可以实现程序的并发执行：协程和线程都是在并发编程中使用的技术，它们可以让程序在同时处理多个任务时更高效地运行。协程和线程之间的主要区别在于它们的执行方式和使用的资源，但都可以实现程序的并发执行。</p><p>B. 线程比协程更轻量级：这个说法是不准确的，因为线程和协程之间的比较并不是简单的轻重量级的问题。协程相对于线程来说，它们的初始栈大小更小，创建和销毁的开销更小，上下文切换的开销也更小，所以在大量并发的情况下，协程的表现要优于线程。但是，在一些需要密集计算或者I&#x2F;O操作较多的场景下，线程的表现可能更好。</p><p>C. 协程不存在死锁问题：这个说法是不准确的，因为协程和线程都存在死锁问题，而且在协程中，由于存在共享数据和共享锁的情况，死锁问题可能更加严重。</p><p>D. 通过 channel 来进行协程间的通信：协程之间的通信通常是通过channel来实现的。Channel提供了一种安全且高效的机制，允许协程在不同的执行线程中进行通信和数据交换。通常，一个协程将数据放入通道中，而另一个协程从通道中读取该数据。通过这种方式，协程之间可以实现同步、互斥和数据共享。</p><h4 id="扩展知识："><a href="#扩展知识：" class="headerlink" title="扩展知识："></a>扩展知识：</h4><blockquote><p>协程和线程都是并发执行的基本单位，但它们有着不同的特点和应用场景。</p><p><strong>相同点：</strong></p><ol><li>都可以实现并发执行，从而提高程序的性能；</li><li>都可以被抢占（即暂停执行，并让出CPU资源）；</li><li>都可以与其他并发执行的单位（协程或线程）进行通信和同步。</li></ol><p><strong>不同点：</strong></p><ol><li>线程是由操作系统调度的，而协程是由程序自己调度的。线程的调度是由操作系统内核实现的，而协程的调度则是在用户空间中完成的，这使得协程的切换比线程更加轻量级，开销更小。</li><li>在创建和销毁的开销方面，协程的代价更小。线程需要占用较多的内存和系统资源，而协程只需要占用少量的栈空间和调度器资源。</li><li>线程之间的切换需要进行上下文切换（即保存当前线程的状态，以便恢复执行），而协程的切换则不需要进行上下文切换，只需要保存协程的上下文信息即可。</li><li>线程之间的通信和同步需要使用诸如锁、信号量、条件变量等同步机制，而协程之间的通信和同步则可以通过channel等更为简单的方式实现。</li></ol><p>总的来说，协程更适合于IO密集型的任务，如网络编程和文件处理等，而线程更适合于CPU密集型的任务，如图像处理和大数据计算等。在实际应用中，可以根据任务的特点和需求选择合适的并发执行方式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range 又又又来了</title>
      <link href="/2023/04/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range-map/"/>
      <url>/2023/04/23/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range-map/</url>
      
        <content type="html"><![CDATA[<h2 id="下面代码里的ocounter的输出值？"><a href="#下面代码里的ocounter的输出值？" class="headerlink" title="下面代码里的ocounter的输出值？"></a>下面代码里的ocounter的输出值？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">21</span>,<br><span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">22</span>,<br><span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">23</span>,<br>&#125;<br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;A&quot;</span>)<br>&#125;<br>counter++<br>fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">2</span>或者<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>​因为for range map是无序的，故如果第一次循环到A,则输出3，否则输出2。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找两个正序数组的中位数</title>
      <link href="/2023/04/22/%E5%88%B7%E9%A2%98/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2023/04/22/%E5%88%B7%E9%A2%98/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：寻找两个正序数组的中位数"><a href="#题目：寻找两个正序数组的中位数" class="headerlink" title="题目：寻找两个正序数组的中位数"></a>题目：寻找两个正序数组的中位数<span id="more"></span></h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p> 示例 1：</p><blockquote><p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p></blockquote><p>提示：</p><ul><li><p>nums1.length &#x3D;&#x3D; m</p></li><li><p>nums2.length &#x3D;&#x3D; n</p></li><li><p>0 &lt;&#x3D; m &lt;&#x3D; 1000</p></li><li><p>0 &lt;&#x3D; n &lt;&#x3D; 1000</p></li><li><p>1 &lt;&#x3D; m + n &lt;&#x3D; 2000</p></li><li><p>-106 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 106</p></li></ul><p>来源：力扣（LeetCode）</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><h4 id="（1）暴力"><a href="#（1）暴力" class="headerlink" title="（1）暴力"></a>（1）暴力</h4><p>​直接将两个数组合并，然后进行排序，直接算出中位数:</p><ul><li>数组长度为奇数，数组的中位数为<code>a[len / 2]</code></li><li>数组长度为偶数，数组的中位数为<code>(a[len / 2] + a[len / 2 - 1]) / 2</code></li></ul><p>​这题的时间复杂度的上限在排序，是<code>O((n + m)long(n + m))</code>，显然没有达到题目的要求， 但也勉强可以AC。</p><p>​代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i ++)<br>            res.<span class="hljs-built_in">push_back</span>(nums1[i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i ++)<br>            res.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> len = res.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len &amp; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> res[len / <span class="hljs-number">2</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>((res[len / <span class="hljs-number">2</span>] + res[len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2.0</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2023/04/22/%E5%88%B7%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/04/22/%E5%88%B7%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：无重复字符的最长子串"><a href="#题目：无重复字符的最长子串" class="headerlink" title="题目：无重复字符的最长子串"></a>题目：无重复字符的最长子串<span id="more"></span></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><blockquote><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:</p><blockquote><p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p>输入: s &#x3D; “pwwkew”<br>输出: 3</p></blockquote><p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：</p><ul><li><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</p></li><li><p>s 由英文字母、数字、符号和空格组成</p></li></ul><p>来源：力扣（LeetCode）</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​用哈希表<code>map&lt;char, int&gt;</code>将每一个字符与其出现次数作为键值对存起来，然后利用双指针从前往后扫描即可：</p><ol><li>如果当前字符只出现了一次，则更新最长串的长度，并继续向后扫描</li><li>如果当前字符出现了不止一次，则将尾指针向前挪，挪至当前字符只出现一次为止，然后更新最长串的长度，并继续向后扫描。</li></ol><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            hash[s[i]] ++;<br>            <span class="hljs-keyword">while</span> (hash[s[i]] &gt; <span class="hljs-number">1</span>) &#123;<br>                hash[s[j]] --;<br>                j ++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2023/04/22/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/04/22/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：两数之和"><a href="#题目：两数之和" class="headerlink" title="题目：两数之和"></a>题目：两数之和<span id="more"></span></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><blockquote><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.</p></blockquote><p>示例 2：</p><blockquote><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]</p></blockquote><p>示例 3：</p><blockquote><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p></blockquote><p>提示：</p><ul><li><p>每个链表中的节点数在范围 [1, 100] 内</p></li><li><p>0 &lt;&#x3D; Node.val &lt;&#x3D; 9</p></li><li><p>题目数据保证列表表示的数字不含前导零</p></li></ul><p>来源：力扣（LeetCode）</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​这题的思想和高精度类似，都是从低位开始算，然后逐渐进位到高位，只不过这里的用的链表的形式。</p><p>​在模拟需要注意：</p><ol><li>​从低位到高位，逐位相加，如果和大于10，就保留个位，即<code>t % 10</code></li><li>如果最高位有进位，则在最前面补1</li></ol><p>​这里还用到了一个做链表题目的小技巧：</p><blockquote><p>​添加一个虚拟头节点：<code>ListNode *head = new ListNode(-1);</code>，这样可以不用特判处理完后的链表是否为空，返回的形式都是res -&gt; next</p></blockquote><p>下面是链表进行加入一个数的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>cur-&gt;next = temp;<br>cur = temp;<br></code></pre></td></tr></table></figure><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = head;<br>        <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || t)&#123;<br>            <span class="hljs-keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>            cur = cur-&gt;next;<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 模拟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 链表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range又来啦~</title>
      <link href="/2023/04/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E5%8F%88%E6%9D%A5%E4%BA%86/"/>
      <url>/2023/04/22/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range%E5%8F%88%E6%9D%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h2 id="下面这段代码输出结果正确吗？"><a href="#下面这段代码输出结果正确吗？" class="headerlink" title="下面这段代码输出结果正确吗？"></a>下面这段代码输出结果正确吗？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123;<br>bar <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := []Foo&#123;<br>&#123;<span class="hljs-string">&quot;A&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;B&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;C&quot;</span>&#125;,<br>&#125;<br>s2 := <span class="hljs-built_in">make</span>([]*Foo, <span class="hljs-built_in">len</span>(s1))<br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> s1 &#123;<br>s2[i] = &amp;value<br>&#125;<br>fmt.Println(s1[<span class="hljs-number">0</span>], s1[<span class="hljs-number">1</span>], s1[<span class="hljs-number">2</span>])<br>fmt.Println(s2[<span class="hljs-number">0</span>], s2[<span class="hljs-number">1</span>], s2[<span class="hljs-number">2</span>])<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输出：<br>&#123;A&#125; &#123;B&#125; &#123;C&#125;<br>&amp;&#123;A&#125; &amp;&#123;B&#125; &amp;&#123;C&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p>​s2输出的结果是<code>&amp;&#123;C&#125;&amp;&#123;C&#125;&amp;&#123;C&#125;</code>，故上述的输出是错误的。</p><p>​在前面的题目，我们提到过，for-range使用短变量声明(:&#x3D;)的形式迭代变量时，变量i、value每次在循环题中都会被重用，而不是重新声明。故s2每次填充的都说value的地址，而在组后一次循环中，value被赋值为{C}。因此s2输出显示三个&amp;{C}。</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s1 &#123;<br>s2[i] = &amp;s1[i]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2023/04/21/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/04/21/%E5%88%B7%E9%A2%98/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：两数之和"><a href="#题目：两数之和" class="headerlink" title="题目：两数之和"></a>题目：两数之和<span id="more"></span></h2><p>​给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>​你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>​你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p></blockquote><p>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p></blockquote><p>提示：</p><blockquote><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4<br>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9<br>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9<br>只会存在一个有效答案</p></blockquote><p>题目来源：力扣（LeetCode）</p><h4 id="解题思路一："><a href="#解题思路一：" class="headerlink" title="解题思路一："></a>解题思路一：</h4><p>​题意很清楚，就是要从一个数组里找到唯一存在的一对数的和为<code>target</code>，并返回他们的下标，很容易就能想到暴力：两层循环分别枚举一遍数组，如果<code>nums[i] + nums[j] == target</code>，就找到了答案，然后将其放入<code>vector</code>中返回即可，时间复杂度O(n^2)，勉强能过。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(i), res.<span class="hljs-built_in">push_back</span>(j);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解题思路二："><a href="#解题思路二：" class="headerlink" title="解题思路二："></a>解题思路二：</h4><p>​这题比较友好，n的数据范围比较小，但如果n的范围更大，显然是过不了的，故我们需要想一想别的 方法。</p><p>​这里有一种非常巧妙的方法：哈希表。</p><p>​我们只需要枚举一次数组，然后在每一次枚举时，我们需要做：</p><blockquote><ol><li>判断<code>target - nums[i]</code>是否存在哈希表中</li><li>将nums[i]插入哈希表中</li></ol></blockquote><p>​然后就能找到答案了。</p><p>​解释：由于数据只有一组解，假设答案为[i, j]（i &lt; j），则当我们循环到j时，nums[i]一定会存在哈希表中，且有nums[i] + nums[j] &#x3D; target，故一定能找到解。</p><p>​时间复杂度：只扫描一遍数组，且哈希表的插入和查询操作的复杂度是O(1)，故总时间复杂度为O(n)</p><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> another = target - nums[i];<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(another))<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i), res.<span class="hljs-built_in">push_back</span>(hash[another]);<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与slice</title>
      <link href="/2023/04/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87/"/>
      <url>/2023/04/21/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="问题：下面这段代码输出什么？"><a href="#问题：下面这段代码输出什么？" class="headerlink" title="问题：下面这段代码输出什么？"></a>问题：下面这段代码输出什么？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>​这一题与前面的 <a href="https://oyto.github.io/2023/04/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range/">for - range</a>很相似，一眼就能看出来，因为for-range执行前是将原数组进行拷贝，所以在循环里改变的数组，是不会影响到我们循环时的副本的，所以答案为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>​但事实并非如此，我们在之前的题目中，a是数组，而在这里a是slice。slice是引用类型，故其是一个指向底层数组的指针，因此我们在循环使用的副本依旧是一个指向原底层数组的副本，故对切片所有的操作，都会影响到底层数组，所以考研通过v获得修改后的数组元素。</p><p>​你学会了吗？</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slice</title>
      <link href="/2023/04/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/slice/"/>
      <url>/2023/04/20/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/slice/</url>
      
        <content type="html"><![CDATA[<h2 id="问题：下面这段代码输出什么？"><a href="#问题：下面这段代码输出什么？" class="headerlink" title="问题：下面这段代码输出什么？"></a>问题：下面这段代码输出什么？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(s ...<span class="hljs-type">int</span>)</span></span> &#123;<br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)<br>slice[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>slice[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>change(slice...)<br>fmt.Println(slice)<br>change(slice[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]...)<br>fmt.Println(slice)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="答案如下"><a href="#答案如下" class="headerlink" title="答案如下"></a>答案如下</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>​第一次调用change函数时，在函数内需要往切片里加入一个元素，但此时slice切片的长度已经达到了容量的上限，故需要扩容。当一个slice需要扩容时，Go会创建一个新的数组，将原有数组的元素复制到新数组中，并将新的元素插入到新数组中，故原slice的底层数组不变</p><p>​第二次调用change函数时，使用了操作符<code>[i,j]</code>获得一个新的切片，假定为 slice1，它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，没有达到容量的上限，所以在使用 change() 函数中对 slice1增加元素时，底层数组的修改会影响到原切片。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for-range</title>
      <link href="/2023/04/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range/"/>
      <url>/2023/04/19/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/for-range/</url>
      
        <content type="html"><![CDATA[<h2 id="下面这段代码输出什么？"><a href="#下面这段代码输出什么？" class="headerlink" title="下面这段代码输出什么？"></a>下面这段代码输出什么？<span id="more"></span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>​range 表达式是副本参与循环，即对于<code>range x</code>，我们复制了x，这里假设将其拷贝到b，在for循环里执行的时候，每次遍历的就是x的副本b，在例子里，就是每次遍历的是a的副本b，而不是a本身，则实际的range循环代码是下面这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = a<span class="hljs-comment">//相当于这里在循环之前，隐式先将a数组拷贝到b里</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> b &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>​因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。</p><p>​如果想要 r 和 a 一样输出，修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> &amp;a &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>&#125;<br>r[i] = v<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;r = &quot;</span>, r)<br>fmt.Println(<span class="hljs-string">&quot;a = &quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p>​输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">r =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>a =  [<span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>​修改后的代码是将地址传入了range表达式，其副本依旧是一个指向原数组a的指针，因此后续所有循环中均是&amp;a指向的原数组参与的，故v能从&amp;a中指向的原数组取出修改后的值。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你了解defer吗？</title>
      <link href="/2023/04/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%BD%A0%E4%BA%86%E8%A7%A3defer%E5%90%97%EF%BC%9F/"/>
      <url>/2023/04/18/Go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E4%BD%A0%E4%BA%86%E8%A7%A3defer%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="你了解defer吗？"><a href="#你了解defer吗？" class="headerlink" title="你了解defer吗？"></a>你了解defer吗？<span id="more"></span></h2><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += n<br><span class="hljs-built_in">recover</span>()<br>&#125;()<br><br><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-keyword">defer</span> f()<br>f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f(<span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题：上面的代码会输出什么？为什么？"><a href="#问题：上面的代码会输出什么？为什么？" class="headerlink" title="问题：上面的代码会输出什么？为什么？"></a>问题：上面的代码会输出什么？为什么？</h3><h3 id="首先我们先来了解一下go语言中的defer："><a href="#首先我们先来了解一下go语言中的defer：" class="headerlink" title="首先我们先来了解一下go语言中的defer："></a>首先我们先来了解一下go语言中的defer：</h3><p>​defer顾名思义，延迟。它是go语言中的一个关键字，主要用在函数或方法前面，作用是用于函数和方法的延迟调用，在语法上，<code>defer</code>与普通的函数调用没有什么区别。</p><p>​在使用上非常简单，只需要弄清楚以下几点即可：</p><ol><li>延迟的函数的什么时候被调用？<ol><li>函数return的时候</li><li>发生panic的时候</li></ol></li><li>延迟调用的语法规则<ol><li>defer关键字后面表达式必须是函数或者方法调用</li><li>延迟内容不能被括号括起来</li></ol></li><li>当一个函数中有多个defer时，他们的执行顺序是<strong>先进后出</strong></li><li>在函数执行return的过程可以分为三步：<ol><li>设置返回值</li><li>执行defer语句</li><li>将结果返回</li></ol></li><li>defer 定义的延迟函数的参数在 defer 语句出时就已经确定下来了</li></ol><p>​知道了这些，上面的题目久很好理解了。</p><p>​正确答案是<strong>7</strong>。</p><p>​当然，很有可能你的答案和正确答案一样，但分析不一定正确，所以接着往下看。</p><p>​这里只对<code>函数f</code>进行讲解：</p><blockquote><ol><li>首先使用defer关键字注册了一个匿名函数，然后这个匿名函数在<code>函数f</code>返回时执行。在这个匿名函数里，使用了<code>recover()</code>，这意味着它可以恢复panic。</li><li>接着定义了一个<code>变量f</code>，类型为<code>func()</code>，这里由于只声明了，但是没有定义，故<code>变量f</code>是一个<code>nil</code>函数。</li><li>然后使用defer关键字将<code>f变量</code>注册成延迟函数，这个延迟函数在<code>函数f</code>返回时会执行，但这个匿名函数是一个<code>nil函数</code>，因此在执行这个延迟函数时会触发panic</li><li>接下来是对<code>变量f</code>的定义 </li><li><code>return n + 1</code>此时，返回值变量<code>r = n + 1</code>，接着执行defer注册的延迟函数，因为defer函数的执行顺序是先进后出的，故先执行<code>变量f</code>，但由于这里注册的是一个<code>nil函数</code>，因此触发panic，接着执行最开始注册的匿名函数，此时<code>r = n + 1 + n</code>，遇到了recover()，所以恢复了panic，将r的值返回</li><li>最后返回给主函数的值<code>r = n + 1 + n = 7</code></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大上升子序列和</title>
      <link href="/2023/04/17/%E5%88%B7%E9%A2%98/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
      <url>/2023/04/17/%E5%88%B7%E9%A2%98/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：最大上升子序列和"><a href="#题目：最大上升子序列和" class="headerlink" title="题目：最大上升子序列和"></a>题目：最大上升子序列和<span id="more"></span></h1><p>一个数的序列 bi，当 b1&lt;b2&lt;…&lt;bS 的时候，我们称这个序列是上升的。</p><p>对于给定的一个序列(a1,a2,…,aN)，我们可以得到一些上升的子序列(ai1,ai2,…,aiK)，这里1≤i1&lt;i2&lt;…&lt;iK≤N。</p><p>比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。</p><p>这些子序列中和最大为18，为子序列(1,3,5,9)的和。</p><p>你的任务，就是对于给定的序列，求出最大上升子序列和。</p><p>注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行是序列的长度N。</p><p>第二行给出序列中的N个整数，这些整数的取值范围都在0到10000(可能重复)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大上升子序列和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">18<br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析:"></a>题目分析:</h4><p>​一看题目就知道是最长上升子序列模型，只不过这里求的是最大和，只需要对代码进行一部分修改即可。</p><p>​DP分析过程如下：</p><p>​<img src="/images/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C.png" alt="最大上升子序列和"></p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = a[i];<span class="hljs-comment">//求的是最大和，故需要加上当前数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + a[i]);<span class="hljs-comment">//状态转移方程</span><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    cout &lt;&lt; res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最长上升子序列模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由数据范围反推算法复杂度以及算法内容</title>
      <link href="/2023/04/16/%E6%9D%82%E7%B1%BB/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/"/>
      <url>/2023/04/16/%E6%9D%82%E7%B1%BB/%E7%94%B1%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="见下图："><a href="#见下图：" class="headerlink" title="见下图："></a>见下图：<span id="more"></span></h1><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4.png" alt="来自y总的总结"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞机降落</title>
      <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E9%A3%9E%E6%9C%BA%E9%99%8D%E8%90%BD/"/>
      <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E9%A3%9E%E6%9C%BA%E9%99%8D%E8%90%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：飞机降落"><a href="#题目：飞机降落" class="headerlink" title="题目：飞机降落"></a>题目：飞机降落<span id="more"></span></h1><p>有 N 架飞机准备降落到某个只有一条跑道的机场。</p><p>其中第 i 架飞机在 Ti 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 Di 个单位时间，即它最早可以于 Ti 时刻开始降落，最晚可以于 Ti+Di 时刻开始降落。</p><p>降落过程需要 Li 个单位时间。</p><p>一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。</p><p>请你判断 N 架飞机是否可以全部安全降落。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多组数据。</p><p>第一行包含一个整数 T，代表测试数据的组数。</p><p>对于每组数据，第一行包含一个整数 N。</p><p>以下 N 行，每行包含三个整数：Ti，Di 和 Li。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组数据，输出 <code>YES</code> 或者 <code>NO</code>，代表是否可以全部安全降落。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 30%30% 的数据，N≤2。<br>对于 100%100% 的数据，1≤T≤10，1≤N≤10，0≤Ti,Di,Li≤10^5</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">100</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">10</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">20</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">NO</span><br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>对于第一组数据，可以安排第 33 架飞机于 00 时刻开始降落，2020 时刻完成降落。安排第 22 架飞机于 2020 时刻开始降落，3030 时刻完成降落。安排第 11 架飞机于 3030 时刻开始降落，4040 时刻完成降落。</p><p>对于第二组数据，无论如何安排，都会有飞机不能及时降落。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​根据题给数据范围n &lt;&#x3D; 10，我们可以大概猜一下是贪心的做法，关于根据数据范围推断算法，可以参考<a href="https://www.acwing.com/blog/content/32/">由数据范围反推算法复杂度以及算法内容</a>。</p><p>​我们可以暴搜所有的方案，即所有飞机的全排列，在暴搜的同时，进行判断 ，当前飞机是否可以放在前一个飞机后面。如果可以，则继续搜索，如果全部的飞机都搜索到了，说明这种顺序是满足条件的，返回True;如果不可以，则停止搜索。</p><p>​判断的条件是：当前飞机的最晚起飞时间需要 &gt;&#x3D; 前一个飞机的降落时间。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Plane</span><br>&#123;<br>    <span class="hljs-type">int</span> t, d, l;<br>&#125;p[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> last)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = p[i].t, d = p[i].d, l = p[i].l;<br>        <span class="hljs-keyword">if</span> (!st[i] &amp;&amp; t + d &gt;= last)<span class="hljs-comment">//当前飞机没有被放过且当前飞机能放在前一个飞机后面</span><br>        &#123;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//最早起飞时间需要在前一个飞机的降落之后也需要在该飞机的最早起飞时间之后，故取两者之最</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(last, t) + l)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <br>    <span class="hljs-keyword">while</span> (t --)<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> t, d, l;<br>            cin &gt;&gt; t &gt;&gt; d &gt;&gt; l;<br>            p[i] = &#123;t, d, l&#125;;<br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> dfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友好城市</title>
      <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/"/>
      <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：友好城市"><a href="#题目：友好城市" class="headerlink" title="题目：友好城市"></a>题目：友好城市<span id="more"></span></h1><p>Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。</p><p>北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。</p><p>每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。</p><p>编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第1行，一个整数N，表示城市数。</p><p>第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>仅一行，输出一个整数，表示政府所能批准的最多申请数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤5000<br>0≤xi≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">22 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">12</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">17 </span><span class="hljs-number">17</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​（1）每个城市上只能建立一座桥</p><p>​（2）所有的桥与桥之间不能相交<br>​目标：最多可以建立多少桥？</p><p>​贪心 + LIS：</p><p>​（1）用pair将每对友好城市绑定在一起，进行排序<br>​（2）对第二关键字求其LIS最长上升子序列的最大值即可</p><p>为何将其中一岸城市从小到大排序即可？<br>    因为如果将一岸的城市从小到大排好序，如果要满足题目要求不相交，则必须满足对岸也是从小到大排序的，否则就会有相交方案，则将某一岸排好序，再对另一岸求一遍<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">最长上升子序列</a>即可。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5010</span>;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N];<br>PII q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; q[i].first &gt;&gt; q[i].second;<br>    <span class="hljs-built_in">sort</span>(q, q + n); <span class="hljs-comment">//高度从低到高排序</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)    <span class="hljs-comment">//故求的时候也要求的是从低到高的最长上升子序列</span><br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (q[i].second &gt; q[j].second) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LIS </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合唱队形</title>
      <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2/"/>
      <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="题目：合唱队形"><a href="#题目：合唱队形" class="headerlink" title="题目：合唱队形"></a>题目：合唱队形<span id="more"></span></h1><p>N 位同学站成一排，音乐老师要请其中的 (N−K)位同学出列，使得剩下的 K 位同学排成合唱队形。     </p><p>合唱队形是指这样的一种队形：设 K 位同学从左到右依次编号为 1，2…，K，他们的身高分别为 T1，T2，…，TK,则他们的身高满足 T1&lt;…<Ti>Ti+1&gt;…&gt;TK(1≤i≤K)。  </p><p>你的任务是，已知所有 N 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行是一个整数 N，表示同学的总数。</p><p>第二行有 N 个整数，用空格分隔，第 i 个整数 Ti是第 i 位同学的身高(厘米)。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤N≤100<br>130≤Ti≤230</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">220</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​要求最少需要几位同学出列，即求合唱队形最多由多少人组成。</p><p>​这题与 <a href="https://oyto.github.io/2023/04/16/%E5%88%B7%E9%A2%98/%E7%99%BB%E5%B1%B1/">登山</a>同出一辙，都是需要求出以某个人的身高为最高点，该点的最长上升子序列最长和下降子序列，求出来之后，枚举所有人的身高，找出最长上升子序列最长与下降子序列之和的最大值，这个最大值就是我们能组成的合唱队形的最大人数，我们再用总的同学数<code>n</code> - <code>最大人数</code>，即可以求出需要最少出列同学数。</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i --)<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j --)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);  <span class="hljs-comment">//中间点求了两次需要减去一次</span><br><br>    cout &lt;&lt; n - res &lt;&lt;  endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>登山</title>
      <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E7%99%BB%E5%B1%B1/"/>
      <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E7%99%BB%E5%B1%B1/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="题目：登山"><a href="#题目：登山" class="headerlink" title="题目：登山"></a>题目：登山<span id="more"></span></h1><p>五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。</p><p>同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。</p><p>队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数N，表示景点数量。</p><p>第二行包含N个整数，表示每个景点的海拔。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最多能浏览的景点数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤N≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">220</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​题目中说按照顺序来浏览这些景点，即只能往右走，不能往左走；不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了，即路线一定是<code>先上后下</code>，这很明显是最长上升子序列模型，我们只需要求出所有景点的最长上升子序列和最长下降子序列，最后枚举所有景点，求出最长上升子序列与最长下降子序列和的最大值即可。</p><p>​这里还需要注意的是，由于求出来的是<code>最长上升子序列与最长下降子序列和的最大值</code>这里的顶点被算了两次，故最后的答案需要减去一次。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], g[N], a[N];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i --)<br>    &#123;<br>        g[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j --)<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) g[i] = <span class="hljs-built_in">max</span>(g[i], g[j] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) res = <span class="hljs-built_in">max</span>(res, f[i] + g[i] - <span class="hljs-number">1</span>);  <span class="hljs-comment">//中间点求了两次需要减去一次</span><br><br>    cout &lt;&lt; res &lt;&lt;  endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怪盗基德的滑翔翼</title>
      <link href="/2023/04/16/%E5%88%B7%E9%A2%98/%E6%80%AA%E7%9B%97%E5%9F%BA%E5%BE%B7%E7%9A%84%E6%BB%91%E7%BF%94%E7%BF%BC/"/>
      <url>/2023/04/16/%E5%88%B7%E9%A2%98/%E6%80%AA%E7%9B%97%E5%9F%BA%E5%BE%B7%E7%9A%84%E6%BB%91%E7%BF%94%E7%BF%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：怪盗基德的滑翔翼"><a href="#题目：怪盗基德的滑翔翼" class="headerlink" title="题目：怪盗基德的滑翔翼"></a>题目：怪盗基德的滑翔翼<span id="more"></span></h1><p>怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。</p><p>而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。</p><p>有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。</p><p>不得已，怪盗基德只能操作受损的滑翔翼逃脱。</p><p>假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。</p><p>初始时，怪盗基德可以在任何一幢建筑的顶端。</p><p>他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。</p><p>因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。</p><p>他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。</p><p>请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入数据第一行是一个整数K，代表有K组测试数据。</p><p>每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤K≤100<br>1≤N≤100<br>0&lt;h&lt;10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">300 </span><span class="hljs-number">207</span> <span class="hljs-number">155</span> <span class="hljs-number">299</span> <span class="hljs-number">298</span> <span class="hljs-number">170</span> <span class="hljs-number">158</span> <span class="hljs-number">65</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">65 </span><span class="hljs-number">158</span> <span class="hljs-number">170</span> <span class="hljs-number">298</span> <span class="hljs-number">299</span> <span class="hljs-number">155</span> <span class="hljs-number">207</span> <span class="hljs-number">300</span><br><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>6<br>9<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​分析题目，我们可以发现，怪盗基德每次可以往左边或者往右边从高的建筑滑向低的建筑，这个模型正于最长上升子序列模型相符，不同的是：这里还需要求最长下降子序列。</p><p>​关于最长上升子序列模型的讲解，见<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">⭐</a></p><p>​知道了最长上升子序列，只需要从后面往前求一遍最长上升子序列，就可以得到最长下降子序列。</p><p>​最后的答案，即为最长上升子序列和最长下降子序列的最大值。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br><br>    <span class="hljs-keyword">while</span> (T --)<br>    &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];<br><br>        <span class="hljs-comment">//正向求解LIS问题</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//反向求解LIS问题</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; i --)<br>        &#123;<br>            f[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt; i; j --)<br>                <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br><br>            res = <span class="hljs-built_in">max</span>(res, f[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方格取数</title>
      <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/"/>
      <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：方格取数"><a href="#题目：方格取数" class="headerlink" title="题目：方格取数"></a>题目：方格取数<span id="more"></span></h1><p>设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif"></p><p>某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。</p><p>在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。</p><p>此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行为一个整数N，表示 N×N 的方格图。</p><p>接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。</p><p>行和列编号从 11 开始。</p><p>一行“0 0 0”表示结束。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示两条路径上取得的最大的和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>N≤10</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">14</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">3</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">14</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">67<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​从左上角走到右下角，于是想到DP中的数字三角形模型。关于数字三角形模型，可以去看这篇文章[线性DP](<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">线性DP - 小樱桃 (oyto.github.io)</a>&#x2F;)。</p><p>​这题的不同点是，这里要取两次数，于是进行DP过程：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs llvm">f[<span class="hljs-type">i1</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-type">i2</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">2</span>]表示所有从(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)分别走到(<span class="hljs-type">i1</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-type">i2</span><span class="hljs-punctuation">,</span>j<span class="hljs-number">2</span>)路径的最大值。<br><br>如何处理“同一个格子不能被重复选择”？<br>    分析后发现，只有当<span class="hljs-type">i1</span> + j<span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-type">i2</span> + j<span class="hljs-number">2</span>时，两条路径的格子才可能重合，<br>    于是可以根据这条性质将思维优化成三维，<br><br>集合：f[k<span class="hljs-punctuation">,</span><span class="hljs-type">i1</span><span class="hljs-punctuation">,</span><span class="hljs-type">i2</span>]表示所有从(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)走到(<span class="hljs-type">i1</span><span class="hljs-punctuation">,</span>k-<span class="hljs-type">i1</span>)<span class="hljs-punctuation">,</span>(<span class="hljs-type">i2</span><span class="hljs-punctuation">,</span>k-<span class="hljs-type">i2</span>)的路径的最大值<br>    k表示两条路线当前走到的格子的横纵坐标之和<br><br>属性：<span class="hljs-keyword">max</span><br><br>状态计算：<br>    以最后一步是从往下走还是往右走进行划分，因为有两次走法，所以被分成了四种情况<br>        下下、下右、右下、右右<br></code></pre></td></tr></table></figure><p>​<strong>为什么下面四个状态转移方程能代表四种状态？</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">原因是，因为k 变小了<span class="hljs-number">1</span>，先不看最后一步，如果i变小<span class="hljs-number">1</span>，则j就不用变；如果i没有变，则j就需要变小<span class="hljs-number">1</span>；<br>上述两种情况刚好对应了最后一步是向下、右走，的横纵坐标变化情况，又因为是两次一起走，故有四种情况。<br><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> f[k - <span class="hljs-number">1</span>][<span class="hljs-type">i1</span> - <span class="hljs-number">1</span>][<span class="hljs-type">i2</span> - <span class="hljs-number">1</span>] + t)<span class="hljs-comment">;   //下 下</span><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> f[k - <span class="hljs-number">1</span>][<span class="hljs-type">i1</span> - <span class="hljs-number">1</span>][<span class="hljs-type">i2</span>] + t)<span class="hljs-comment">;       //下 右</span><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span>(<span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> f[k - <span class="hljs-number">1</span>][<span class="hljs-type">i1</span>][<span class="hljs-type">i2</span> - <span class="hljs-number">1</span>] + t)<span class="hljs-comment">;       //右 下</span><br></code></pre></td></tr></table></figure><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N * <span class="hljs-number">2</span>][N][N], g[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) g[a][b] = c;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= n + n; k ++)   <span class="hljs-comment">//枚举横纵坐标之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++)    <span class="hljs-comment">//枚举第一次走的横坐标</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++)    <span class="hljs-comment">//枚举第二次走的横坐标</span><br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;   <span class="hljs-comment">//计算出两次走的纵坐标</span><br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= n)<br>                &#123;<br>                    <span class="hljs-type">int</span> t = g[i1][j1];  <span class="hljs-comment">//如果两个坐标相等，只加一次，因为第二次走这里，已经被拿走清空了</span><br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += g[i2][j2];   <span class="hljs-comment">//坐标不相同，就两个位置全加上</span><br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>] + t);   <span class="hljs-comment">//下 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2] + t);       <span class="hljs-comment">//下 右</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>] + t);       <span class="hljs-comment">//右 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2] + t);            <span class="hljs-comment">//右 右</span><br>                &#125;<br>            &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n + n][n][n]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字三角形模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最低通行费</title>
      <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9/"/>
      <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%9C%80%E4%BD%8E%E9%80%9A%E8%A1%8C%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：最低通行费"><a href="#题目：最低通行费" class="headerlink" title="题目：最低通行费"></a>题目：最低通行费<span id="more"></span></h1><p>一个商人穿过一个 N×N 的正方形的网格，去参加一个非常重要的商务活动。</p><p>他要从网格的左上角进，右下角出。</p><p>每穿越中间 1 个小方格，都要花费 1 个单位时间。</p><p>商人必须在 (2N−1) 个单位时间穿越出去。</p><p>而在经过中间的每个小方格时，都需要缴纳一定的费用。</p><p>这个商人期望在规定时间内用最少费用穿越出去。</p><p>请问至少需要多少费用？</p><p>注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个整数，表示正方形的宽度 N。</p><p>后面 N 行，每行 N 个不大于 100 的正整数，为网格上每个小方格的费用。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示至少需要的费用。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤100</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span> <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span>  <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span> <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">15</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">6 </span> <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">18</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">23</span> <span class="hljs-number">25</span> <span class="hljs-number">29</span> <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">109<br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>样例中，最小值为 109&#x3D;1+2+5+7+9+12+19+21+33。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​从左上角走到右下角的问题，自然想到DP中的[数字三角形模型](<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">线性DP - 小樱桃 (oyto.github.io)</a>)。</p><p>​唯一不同的是，本题是求路径和的最小值，故这里需要先进行初始化。</p><p>​<strong>为什么要进行初始化呢？</strong></p><p>​因为我们做数字三角形模型是求路径和的最大值，于是我们默认dp数组f[i][j]为0即可，但这里求的是最小值，若我们不进行初始化，最次取的都是0，就会忽略路径上的值，导致答案错误。</p><p>​<strong>初始化</strong></p><p>​我们可以按照下面的方式进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j ++)<br>            f[i][j] = INF;<br></code></pre></td></tr></table></figure><p>​<strong>为什么要从0开始呢？</strong></p><ul><li>​因为第一行的元素进行状态转移的时候，会用到第0行，故如果不初始化第0行的话，会导致第一行求值出错，进而导致答案错误。</li></ul><p>​还有一个细节就是，我们需要初始化<code>f[1][1] = g[1][1]</code>，否则起点就会出错。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            cin &gt;&gt; g[i][j];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j ++)<br>            f[i][j] = INF;<br>            <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]) + g[i][j];<br>    <br>    cout &lt;&lt; f[n][n];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字三角形模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摘花生</title>
      <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%91%98%E8%8A%B1%E7%94%9F/"/>
      <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%91%98%E8%8A%B1%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：摘花生"><a href="#题目：摘花生" class="headerlink" title="题目：摘花生"></a>题目：摘花生<span id="more"></span></h1><p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p><p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p><p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p><p>Hello Kitty只能向东或向南走，不能向西或向北走。</p><p>问Hello Kitty最多能够摘到多少颗花生。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个整数T，代表一共有多少组数据。</p><p>接下来是T组数据。</p><p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p><p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤T≤100,1≤R,C≤100,0≤M≤1000</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>16<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​从左上角走到右下角，且每次只能向东或向南走，即往右或者往下走，裸的数字三角形模型，关于数字三角形模型，可以去看这篇文章[线性DP](<a href="https://oyto.github.io/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/">线性DP - 小樱桃 (oyto.github.io)</a>&#x2F;)。</p><p>​只需要注意，这题是多组输入数据，注意清理上次用过的g, f数组即可。（这题可以不用清零，因为每次需要用到的地方，都会被重新计算进行覆盖）</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> g[N][N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <br>    <span class="hljs-keyword">while</span> (t --)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> g);<br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>        <br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>                cin &gt;&gt; g[i][j];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]) + g[i][j];<br>        <br>        cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字三角形模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冶炼金属</title>
      <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E/"/>
      <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E5%86%B6%E7%82%BC%E9%87%91%E5%B1%9E/</url>
      
        <content type="html"><![CDATA[<h4 id="题目：冶炼金属"><a href="#题目：冶炼金属" class="headerlink" title="题目：冶炼金属"></a>题目：冶炼金属<span id="more"></span></h4><p>小蓝有一个神奇的炉子用于将普通金属 O 冶炼成为一种特殊金属 X。</p><p>这个炉子有一个称作转换率的属性 V，V 是一个正整数，这意味着消耗 V 个普通金属 O 恰好可以冶炼出一个特殊金属 X，当普通金属 O 的数目不足 V 时，无法继续冶炼。</p><p>现在给出了 N 条冶炼记录，每条记录中包含两个整数 A 和 B，这表示本次投入了 A 个普通金属 O，最终冶炼出了 B 个特殊金属 X。</p><p>每条记录都是独立的，这意味着上一次没消耗完的普通金属 O 不会累加到下一次的冶炼当中。</p><p>根据这 N 条冶炼记录，请你推测出转换率 V 的最小值和最大值分别可能是多少，题目保证评测数据不存在无解的情况。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数 N，表示冶炼记录的数目。</p><p>接下来输入 N 行，每行两个整数 A、B，含义如题目所述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出两个整数，分别表示 V 可能的最小值和最大值，中间用空格分开。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 30% 的评测用例，1≤N≤102。对于 60% 的评测用例，1≤N≤103。<br>对于 100% 的评测用例，1≤N≤104，1≤B≤A≤109。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">75 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">53 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">59 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">20 </span><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>当 V&#x3D;20 时，有：⌊7520⌋&#x3D;3，⌊5320⌋&#x3D;2，⌊5920⌋&#x3D;2，可以看到符合所有冶炼记录。</p><p>当 V&#x3D;25 时，有：⌊7525⌋&#x3D;3，⌊5325⌋&#x3D;2，⌊5925⌋&#x3D;2，可以看到符合所有冶炼记录。</p><p>且再也找不到比 20 更小或者比 25 更大的符合条件的 V 值了。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​读过题目后，可以发现题目需要分别找到一个最大值和最小值满足所给条件，而且对于找到的值，我们可以通过判断，能判断出它是大于我们的答案还是小于我们的答案，存在二段性，故可以采用二分做。</p><p>​check函数的书写，对于每个需要检查的值，我们通过其与所有组的数据进行判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> t = a[i] / x;<br><br><span class="hljs-keyword">if</span> (t &lt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-comment">//说明我们找到的这个数太大了，以至于不能转化出的金属不足要求</span><br><span class="hljs-keyword">if</span> (t &gt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> <span class="hljs-comment">//说明我们找到的这个数太大了，以至于转化出的金属超量</span><br><br><span class="hljs-comment">//如果所有的数据都没有出现上述情况，则说明当前这个数，是我们要找的答案</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>​</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = a[i] / x;<br>        <span class="hljs-keyword">if</span> (t &gt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (t &lt; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i] &gt;&gt; b[i];<br>    <br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span> || t == <span class="hljs-number">3</span>) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">check</span>(mid);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span> || t == <span class="hljs-number">2</span>) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Go版本</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> N <span class="hljs-type">int</span> = <span class="hljs-number">10010</span><br><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a, b [N]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> in = bufio.NewReader(os.Stdin)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Fscan(in, &amp;n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>fmt.Fscan(in, &amp;a[i], &amp;b[i])<br>&#125;<br>l, r := <span class="hljs-number">1</span>, <span class="hljs-type">int</span>(<span class="hljs-number">1e9</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> l &gt;= r &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>mid := (l + r) / <span class="hljs-number">2</span><br>t := check(mid)<br><span class="hljs-keyword">if</span> t == <span class="hljs-number">1</span> || t == <span class="hljs-number">3</span> &#123;<br>r = mid<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l = mid + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, l)<br>l, r = <span class="hljs-number">1</span>, <span class="hljs-type">int</span>(<span class="hljs-number">1e9</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> l &gt;= r &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>mid := (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>t := check(mid)<br><span class="hljs-keyword">if</span> t == <span class="hljs-number">1</span> || t == <span class="hljs-number">2</span> &#123;<br>l = mid<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r = mid - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>t := a[i] / x<br><span class="hljs-keyword">if</span> t &gt; b[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">if</span> t &lt; b[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 二分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接龙数列</title>
      <link href="/2023/04/14/%E5%88%B7%E9%A2%98/%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97/"/>
      <url>/2023/04/14/%E5%88%B7%E9%A2%98/%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目：接龙"><a href="#题目：接龙" class="headerlink" title="题目：接龙"></a>题目：接龙<span id="more"></span></h1><p>对于一个长度为 K 的整数数列：A1,A2,…,AK，我们称之为接龙数列当且仅当 Ai 的首位数字恰好等于 Ai−1的末位数字 (2≤i≤K)。</p><p>例如 12,23,35,56,61,1112,23,35,56,61,11 是接龙数列；12,23,34,5612,23,34,56 不是接龙数列，因为 5656 的首位数字不等于 3434 的末位数字。</p><p>所有长度为 11 的整数数列都是接龙数列。</p><p>现在给定一个长度为 N的数列 A1,A2,…,AN，请你计算最少从中删除多少个数，可以使剩下的序列是接龙序列？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 N。</p><p>第二行包含 N个整数 A1,A2,…,AN。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数代表答案。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 20%20% 的数据，1≤N≤20<br>对于 50%50% 的数据，1≤N≤10000<br>对于 100%100% 的数据，1≤N≤10^5，1≤Ai≤10^9。所有 Ai 保证不包含前导 00。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">11 </span><span class="hljs-number">121</span> <span class="hljs-number">22</span> <span class="hljs-number">12</span> <span class="hljs-number">2023</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>删除 2222，剩余 11,121,12,202311,121,12,2023 是接龙数列。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​题目要求最少删除多少个数，即求最长的接龙数列长度。</p><p>​只要前一个数的结尾能和后一个数的开头一样，则可以进行接龙，这一点跟最长上升子序列模型相似：都是前一个数与后一个数存在某一种关系就可以接在一起。</p><p>​DP分析如下：</p><p><img src="/images/%E6%8E%A5%E9%BE%99%E6%95%B0%E5%88%97DP%E8%BF%87%E7%A8%8B.png" alt="接龙数列"></p><p>​分析到这里，代码就可以写了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-type">int</span> l[N], r[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">char</span> num[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        cin &gt;&gt; num;<br>        l[i] = num[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>, r[i] = num[<span class="hljs-built_in">strlen</span>(num) - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>            <span class="hljs-keyword">if</span> (l[i] == r[j]) f[i] = <span class="hljs-built_in">max</span>(f[j] + <span class="hljs-number">1</span>, f[i]);<br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    cout &lt;&lt; n - res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​如果觉得这题就这么结束了，那就大错特错了。</p><p>​我们可以观察数据范围：<code>n &lt;= 100010</code>，而我们的算法的时间复杂度是O(n^2)的，故需要进行优化。</p><p>​我们发现只有当<code>l[i]</code> &#x3D;<code> r[j]</code>时，我们才需要更新状态，故我们可以用一个辅助数组，存下以<code>k</code>结尾的接龙数列有多少个，在更新时直接用<code>f[i] = max(f[i], g[l[i]])</code>进行更新状态即可，紧接着记得要更新<code>g[r[i]] = max(f[i], g[r[i]])</code>。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> f[N], g[N];<br><span class="hljs-type">int</span> l[N], r[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-type">char</span> num[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        cin &gt;&gt; num;<br>        l[i] = num[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>, r[i] = num[<span class="hljs-built_in">strlen</span>(num) - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        f[i] = <span class="hljs-built_in">max</span>(f[i], g[l[i]] + <span class="hljs-number">1</span>);<span class="hljs-comment">//更新状态</span><br>        g[r[i]] = <span class="hljs-built_in">max</span>(f[i], g[r[i]]);<span class="hljs-comment">//更新g数组</span><br>        res = <span class="hljs-built_in">max</span>(res, f[i]);<br>    &#125;<br>    <br>    cout &lt;&lt; n - res &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最长上升子序列模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2023/04/13/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2023/04/13/%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：<span id="more"></span></h4><p>​编写一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。</p><p>例如如下的先序遍历字符串： <code>abc##de#g##f###</code> 其中 <code>#</code> 表示的是空格，空格字符代表空树。</p><p>建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>共一行，包含一个字符串，表示先序遍历字符串。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，输出将输入字符串建立二叉树后中序遍历的序列，字符之间用空格隔开。</p><p>注意，输出中不用包含 <code>#</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>输入字符串长度不超过 100100，且只包含小写字母和 <code>#</code>。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">abc##de#g##f###<br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">c <span class="hljs-selector-tag">b</span> e g d f <span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>​给定先序遍历，求中序遍历。</p><p>​首先我们要知道什么是先序遍历和后序遍历。</p><blockquote><ul><li>先序遍历（Preorder Traversal）：先访问根节点，再递归地遍历左子树和右子树。先序遍历的顺序是根节点 -&gt; 左子树 -&gt; 右子树。</li><li>中序遍历（Inorder Traversal）：先递归地遍历左子树，再访问根节点，最后递归地遍历右子树。中序遍历的顺序是左子树 -&gt; 根节点 -&gt; 右子树。</li><li>后序遍历（Postorder Traversal）：先递归地遍历左子树和右子树，再访问根节点。后序遍历的顺序是左子树 -&gt; 右子树 -&gt; 根节点。</li></ul></blockquote><p>​于是我们以样例为例，画出先序遍历，如下图</p><p>​<img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png" alt="二叉树的遍历"></p><p>​然后我们就可以发现，只要我们在每次搜到空树的时候，即回溯到该节点的父节点后，将当前节点（上一个节点的父节点）时，将其输出就能得到中序遍历。因为每次回溯到的点，都是一个父亲节点，且回溯到了这个点，说明其子节点也已经回溯过了，即输出过了。</p><h4 id="AC代码如下："><a href="#AC代码如下：" class="headerlink" title="AC代码如下："></a>AC代码如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> k;<br>string str;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (str[k] == <span class="hljs-string">&#x27;#&#x27;</span>)  <span class="hljs-comment">//遍历到了空树，回溯的同时，遍历下一个节点</span><br>    &#123;<br>        k ++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> t = str[k ++];     <span class="hljs-comment">//记录当前节点</span><br>    <span class="hljs-built_in">dfs</span>();  <span class="hljs-comment">//遍历左子树，直至走到空树，</span><br>    cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">dfs</span>();  <span class="hljs-comment">//遍历右节点，直至走到空树</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; str;<br>    <br>    <span class="hljs-built_in">dfs</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Go语言版</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> in = bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">var</span> k <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> str[k] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>        k ++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    t := str[k]<br>    k ++<br>    dfs()<br>    fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, t)<br>    dfs()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Fscan(in, &amp;str)<br>    <br>    dfs()<br>    <br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> dfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/04/11/test./index/"/>
      <url>/2023/04/11/test./index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架示例</title>
      <link href="/2023/04/11/%E6%A1%86%E6%9E%B6/Gin%E6%A1%86%E6%9E%B6%E7%A4%BA%E4%BE%8B/"/>
      <url>/2023/04/11/%E6%A1%86%E6%9E%B6/Gin%E6%A1%86%E6%9E%B6%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin框架示例"><a href="#Gin框架示例" class="headerlink" title="Gin框架示例"></a>Gin框架示例<span id="more"></span></h1><h2 id="1、AsciiJSON"><a href="#1、AsciiJSON" class="headerlink" title="1、AsciiJSON"></a>1、AsciiJSON</h2><blockquote><p>​使用 AsciiJSON 生成具有转义的非 ASCII 字符的 ASCII-only JSON。</p></blockquote><h4 id="（1）完整代码"><a href="#（1）完整代码" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎</span><br><br>r.GET(<span class="hljs-string">&quot;/someJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 注册一个 GET 路由，并定义处理函数</span><br>data := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123; <span class="hljs-comment">// 定义一个 map 类型的数据，用于构造 JSON 响应</span><br><span class="hljs-string">&quot;lang&quot;</span>: <span class="hljs-string">&quot;GO语言&quot;</span>,   <span class="hljs-comment">// 设置 &quot;lang&quot; 键的值为 &quot;GO语言&quot;</span><br><span class="hljs-string">&quot;tag&quot;</span>:  <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>, <span class="hljs-comment">// 设置 &quot;tag&quot; 键的值为 &quot;&lt;br&gt;&quot;</span><br>&#125;<br><br>c.AsciiJSON(http.StatusOK, data) <span class="hljs-comment">// 使用 c.AsciiJSON() 方法将 map 数据转换为 ASCII JSON 格式，并作为响应发送给客户端</span><br>&#125;)<br><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 Gin web 服务器，监听在 8080 端口</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点"><a href="#（2）知识点" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>gin.Default()</code>: 这是 Gin 框架的一个方法，用于创建一个带有默认中间件的路由引擎，包括了 <code>logger</code> 和 <code>recovery</code> 中间件，用于记录请求日志和在出现 panic 时进行恢复，防止程序崩溃。</li><li><code>r.GET(&quot;/someJSON&quot;, ...)</code>：路由注册方法，指定一个路径为”&#x2F;someJSON”的GET请求，当客户端请求”some&#x2F;JSON”路径时，会调用后面的处理函数来处理该请求。</li><li><code>fun(c *gin.Context) &#123;...&#125;</code>：这是一个匿名函数，作为路由处理函数，接收一个<code>gin.Context</code>参数。</li><li><code>gin.Context</code>：是Gin框架的一个上下文对象，用于在处理<code>HTTP</code>请求和生成<code>HTTP</code>响应时传递和管理数据。每当 Gin 框架处理一个<code> HTTP</code> 请求时，都会创建一个新的 <code>gin.Context</code> 对象，并将其传递给注册的路由处理函数。它包含了很多有用的方法和属性，用于访问HTTP请求的各种信息，如请求路径、HTTP方法、球请求参数、请求头、请求体等。</li><li><code>data := map[string]interface&#123;&#125;&#123;...&#125;</code>：创建了一个<code>map[string]interface&#123;&#125;</code>类型的变量<code>data</code>，用于构造要返回的<code>JSON</code>数据。这里使用了一个简单的map，包含了连个键值对，分别是”lang”和”tag”。</li><li><code>c.AsciiJSON(http.StatusOK, data)</code>：这是<code>gin.Context</code>的方法，用于将data变量的内容作为<code>ASCII JSON</code>格式的响应返回给客户端。<code>http.StatusOK</code>是HTTP状态码，表示请求成功，这里将其作为响应的状态码。data 变量作为响应的主体内容，通过 <code>ASCII JSON</code> 格式进行序列化，并设置了响应的 <code>Content-Type </code>为 “application&#x2F;json; charset&#x3D;utf-8”。最终，这个处理函数会将生成的响应发送给客户端。</li></ul><h4 id="（3）示例大意"><a href="#（3）示例大意" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>导入了 <code>gin</code> 和 <code>net/http</code> 包，引入了 Gin 框架和标准库中处理 HTTP 请求和响应的功能。</li><li>创建了一个默认的 Gin 路由引擎 <code>r</code>，作为 HTTP 请求的入口。</li><li>注册了一个 GET 路由，路径为 “&#x2F;someJSON”，并定义了一个处理函数，处理函数使用 <code>c.AsciiJSON()</code> 方法将一个定义好的 map 数据转换为 ASCII JSON 格式，并作为响应发送给客户端。</li><li>使用 <code>r.Run()</code> 方法启动了一个 Gin web 服务器，并监听在 8080 端口，等待客户端的 HTTP 请求。</li><li>当客户端通过浏览器或其他 HTTP 客户端访问 “&#x2F;someJSON” 路径时，服务器会返回一个 JSON 格式的响应，包含了定义好的 <code>data</code> 数据，其中 “lang” 键的值为 “GO语言”，”tag” 键的值为 “<br>“。这个响应的内容类型为 ASCII JSON。</li></ol></blockquote><h2 id="2、绑定表单数据至自定义结构体"><a href="#2、绑定表单数据至自定义结构体" class="headerlink" title="2、绑定表单数据至自定义结构体"></a>2、绑定表单数据至自定义结构体</h2><blockquote><p>​下述代码实现了一个简单的Web应用程序，通过Gin框架处理HTTP请求，将从请求中获取的数据绑定到结构体变量，并生成JSON格式的HTTP响应体。</p></blockquote><h4 id="（1）完整代码-1"><a href="#（1）完整代码-1" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-keyword">type</span> StructA <span class="hljs-keyword">struct</span> &#123;<br>FieldA <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_a&quot;`</span> <span class="hljs-comment">// FieldA 是 StructA 的字段，使用 form 标签 &quot;field_a&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StructB <span class="hljs-keyword">struct</span> &#123;<br>NestedStruct StructA <span class="hljs-comment">// NestedStruct 是 StructB 的字段，类型为 StructA</span><br>FieldB       <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_b&quot;`</span> <span class="hljs-comment">// FieldB 是 StructB 的字段，使用 form 标签 &quot;field_b&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StructC <span class="hljs-keyword">struct</span> &#123;<br>NestedStructPointer *StructA <span class="hljs-comment">// NestedStructPointer 是 StructC 的指针字段，指向 StructA</span><br>FieldC              <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_c&quot;`</span> <span class="hljs-comment">// FieldC 是 StructC 的字段，使用 form 标签 &quot;field_c&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StructD <span class="hljs-keyword">struct</span> &#123;<br>NestedAnonyStruct <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// NestedAnonyStruct 是 StructD 的匿名结构体字段</span><br>FieldX <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_x&quot;`</span> <span class="hljs-comment">// FieldX 是匿名结构体的字段，使用 form 标签 &quot;field_x&quot;</span><br>&#125;<br>FieldD <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;field_d&quot;`</span> <span class="hljs-comment">// FieldD 是 StructD 的字段，使用 form 标签 &quot;field_d&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDataB</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> b StructB<br>c.Bind(&amp;b) <span class="hljs-comment">// 将请求数据绑定到 StructB</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;a&quot;</span>: b.NestedStruct, <span class="hljs-comment">// 返回 NestedStruct 的值作为响应，键名为 &quot;a&quot;</span><br><span class="hljs-string">&quot;b&quot;</span>: b.FieldB,       <span class="hljs-comment">// 返回 FieldB 的值作为响应，键名为 &quot;b&quot;</span><br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDataC</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> b StructC<br>c.Bind(&amp;b) <span class="hljs-comment">// 将请求数据绑定到 StructC</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;a&quot;</span>: b.NestedStructPointer, <span class="hljs-comment">// 返回 NestedStructPointer 的值作为响应，键名为 &quot;a&quot;</span><br><span class="hljs-string">&quot;c&quot;</span>: b.FieldC,              <span class="hljs-comment">// 返回 FieldC 的值作为响应，键名为 &quot;c&quot;</span><br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDataD</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> b StructD<br>c.Bind(&amp;b) <span class="hljs-comment">// 将请求数据绑定到 StructD</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;x&quot;</span>: b.NestedAnonyStruct, <span class="hljs-comment">// 返回 NestedAnonyStruct 的值作为响应，键名为 &quot;x&quot;</span><br><span class="hljs-string">&quot;d&quot;</span>: b.FieldD,            <span class="hljs-comment">// 返回 FieldD 的值作为响应，键名为 &quot;d&quot;</span><br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/getb&quot;</span>, GetDataB) <span class="hljs-comment">// 注册 GetDataB 作为 GET /getb 路由的处理函数</span><br>r.GET(<span class="hljs-string">&quot;/getc&quot;</span>, GetDataC) <span class="hljs-comment">// 注册 GetDataC 作为 GET /getc 路由的处理函数</span><br>r.GET(<span class="hljs-string">&quot;/getd&quot;</span>, GetDataD) <span class="hljs-comment">// 注册 GetDataD 作为 GET /getd 路由的处理函数</span><br><br>r.Run() <span class="hljs-comment">// 启动 Gin web 服务器</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-1"><a href="#（2）知识点-1" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>c.Bind(&amp;b)</code>：使用了Gin框架的<code>Bind</code>方法，将从HTTP请求中获取的数据绑定到<code>b</code>变量。<code>&amp;b</code>表示传递<code>b</code>的指针，以便将数据绑定到<code>b</code>变量的字段。</li><li><code>c.JSON(200, gin.H&#123;&quot;a&quot;: b.NestedStruct, &quot;b&quot;: b.FieldB&#125;)</code>：使用Gin框架的<code>JSON</code>方法，生成HTTP响应的JSON格式。<code>200</code>表示HTTP响应的状态码为200，<code>gin.H</code>是Gin框架提供的一种快捷方式，表示一个<code>map[string]interface&#123;&#125;</code>类型的数据结构，用于构造<code>JSON</code>响应体。在这里，构造了一个包含两个键值对的<code>JSON</code>响应体，其中键为<code>a</code>和<code>b</code>，值分别为<code>b.NestedStruct</code>和<code>b.FieldB</code>，这些值来自之前绑定的<code>b</code>变量的字段。</li><li>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，通常用于在不同应用程序之间传输和存储数据。JSON采用键值对的形式表示数据，使用文本格式进行序列化，具有简洁、易读、易解析的特点。</li></ul><h4 id="（3）示例大意-1"><a href="#（3）示例大意-1" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义了四个结构体类型：<code>StructA</code>、<code>StructB</code>、<code>StructC</code>、<code>StructD</code>，分别包含了不同的字段和标签。</li><li>在<code>GetDataB</code>处理函数中，从HTTP请求中绑定数据到<code>StructB</code>类型的变量<code>b</code>，然后生成JSON响应体，包含了<code>b.NestedStruct</code>和<code>b.FieldB</code>字段的值。</li><li>在<code>GetDataC</code>处理函数中，从HTTP请求中绑定数据到<code>StructC</code>类型的变量<code>b</code>，然后生成JSON响应体，包含了<code>b.NestedStructPointer</code>和<code>b.FieldC</code>字段的值。</li><li>在<code>GetDataD</code>处理函数中，从HTTP请求中绑定数据到<code>StructD</code>类型的变量<code>b</code>，然后生成JSON响应体，包含了<code>b.NestedAnonyStruct</code>和<code>b.FieldD</code>字段的值。</li><li>在<code>main</code>函数中，创建了一个Gin的默认路由器，并注册了三个路由（<code>/getb</code>、<code>/getc</code>、<code>/getd</code>），并将对应的处理函数（<code>GetDataB</code>、<code>GetDataC</code>、<code>GetDataD</code>）作为处理函数。最后调用<code>r.Run()</code>启动Gin的web服务器，监听并处理HTTP请求。</li></ol></blockquote><h4 id="（4）使用-curl-命令结果："><a href="#（4）使用-curl-命令结果：" class="headerlink" title="（4）使用 curl 命令结果："></a>（4）使用 <code>curl</code> 命令结果：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">命令行输入：curl <span class="hljs-string">&quot;http://localhost:8080/getb?field_a=hello&amp;field_b=world&quot;</span><br>终端显示：&#123;<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;FieldA&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-string">&quot;world&quot;</span>&#125;<br>命令行输入：curl <span class="hljs-string">&quot;http://localhost:8080/getc?field_a=hello&amp;field_c=world&quot;</span><br>终端显示：&#123;<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;FieldA&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;,<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-string">&quot;world&quot;</span>&#125;<br>命令行输入：curl <span class="hljs-string">&quot;http://localhost:8080/getd?field_x=hello&amp;field_d=world&quot;</span><br>终端显示：&#123;<span class="hljs-string">&quot;d&quot;</span>:<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>:&#123;<span class="hljs-string">&quot;FieldX&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="3、绑定-HTML-复选框"><a href="#3、绑定-HTML-复选框" class="headerlink" title="3、绑定 HTML 复选框"></a>3、绑定 HTML 复选框</h2><h4 id="（1）前置条件"><a href="#（1）前置条件" class="headerlink" title="（1）前置条件"></a>（1）前置条件</h4><blockquote><p>​在main.go文件的同目录下，存在<code>views/form.html</code>目录，且<code>form.html</code>文件里存放了HTML模板文件，如下：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Form Template<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Check some colors<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>Red<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colors[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span>Green<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colors[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;green&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;green&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span>Blue<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colors[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;blue&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="（2）完整代码"><a href="#（2）完整代码" class="headerlink" title="（2）完整代码"></a>（2）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> myForm <span class="hljs-keyword">struct</span> &#123;<br>Colors []<span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;colors[]&quot;`</span> <span class="hljs-comment">/* 定义一个结构体 myForm，其中包含一个 Colors 字段，</span><br><span class="hljs-comment">    用于接收表单提交的 colors[] 参数*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><br>r.LoadHTMLGlob(<span class="hljs-string">&quot;views/*&quot;</span>) <span class="hljs-comment">// 加载 views 目录下的 HTML 模板文件</span><br><br>r.GET(<span class="hljs-string">&quot;/&quot;</span>, indexHandler) <span class="hljs-comment">// 处理根路径的 GET 请求，调用 indexHandler 函数</span><br>r.POST(<span class="hljs-string">&quot;/&quot;</span>, formHandler) <span class="hljs-comment">// 处理根路径的 POST 请求，调用 formHandler 函数</span><br><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 Gin 服务器监听在 8080 端口</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.HTML(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;form.html&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 在响应中渲染 form.html 模板并返回 200 状态码</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">formHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> fakeForm myForm<br>c.Bind(&amp;fakeForm)                 <span class="hljs-comment">// 绑定请求参数到 myForm 结构体</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;color&quot;</span>: fakeForm.Colors&#125;) <span class="hljs-comment">/* 返回 JSON 格式的响应，</span><br><span class="hljs-comment">包含 fakeForm 结构体中的 Colors 字段值*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（3）知识点"><a href="#（3）知识点" class="headerlink" title="（3）知识点"></a>（3）知识点</h4><ul><li><code>r.LoadHTMLGlob(&quot;views/*&quot;)</code>: 加载<code>views</code>目录下的HTML模板文件，用于后续的HTML模板渲染。<code>LoadHTMLGlob()</code>方法接受一个模板文件路径的参数，使用通配符<code>*</code>可以匹配指定目录下的所有文件。</li><li><code>r.GET(&quot;/&quot;, indexHandler)</code>: 注册一个处理根路径的GET请求的路由，当客户端发送GET请求到根路径”&#x2F;“时，Gin会调用<code>indexHandler</code>函数进行处理。<code>indexHandler</code>函数是自定义的处理函数，用于处理根路径的GET请求。</li><li><code>r.POST(&quot;/&quot;, formHandler)</code>: 注册一个处理根路径的POST请求的路由，当客户端发送POST请求到根路径”&#x2F;“时，Gin会调用<code>formHandler</code>函数进行处理。<code>formHandler</code>函数是自定义的处理函数，用于处理根路径的POST请求。</li></ul><h4 id="（4）示例大意"><a href="#（4）示例大意" class="headerlink" title="（4）示例大意"></a>（4）示例大意</h4><blockquote><ol><li>定义了一个名为<code>myForm</code>的结构体，其中包含一个<code>Colors</code>字段，用于接收表单提交的<code>colors[]</code>参数。<code>Colors</code>字段使用了<code>form:&quot;colors[]&quot;</code>标签，表示在表单中使用<code>colors[]</code>作为参数名。</li><li>在<code>main()</code>函数中创建了一个Gin引擎实例，并设置了默认的中间件。</li><li>使用<code>r.LoadHTMLGlob(&quot;views/*&quot;)</code>加载了<code>views</code>目录下的HTML模板文件，用于后续的HTML模板渲染。</li><li>使用<code>r.GET(&quot;/&quot;, indexHandler)</code>注册了一个处理根路径的GET请求的路由，当客户端发送GET请求到根路径”&#x2F;“时，Gin会调用<code>indexHandler</code>函数进行处理。</li><li>使用<code>r.POST(&quot;/&quot;, formHandler)</code>注册了一个处理根路径的POST请求的路由，当客户端发送POST请求到根路径”&#x2F;“时，Gin会调用<code>formHandler</code>函数进行处理。</li><li>定义了<code>indexHandler</code>函数，用于处理根路径的GET请求。该函数通过调用<code>c.HTML()</code>方法，在响应中渲染名为<code>form.html</code>的HTML模板，并返回200状态码。</li><li>定义了<code>formHandler</code>函数，用于处理根路径的POST请求。该函数首先定义了一个名为<code>fakeForm</code>的<code>myForm</code>类型的变量，然后通过调用<code>c.Bind()</code>方法，将请求参数绑定到<code>fakeForm</code>结构体中。最后，通过调用<code>c.JSON()</code>方法，返回一个JSON格式的响应，包含<code>fakeForm</code>结构体中的<code>Colors</code>字段值。</li></ol></blockquote><h2 id="4、绑定查询字符串或表单数据"><a href="#4、绑定查询字符串或表单数据" class="headerlink" title="4、绑定查询字符串或表单数据"></a>4、绑定查询字符串或表单数据</h2><h4 id="（1）完整代码-2"><a href="#（1）完整代码-2" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name     <span class="hljs-type">string</span>    <span class="hljs-string">`form:&quot;name&quot;`</span>                     <span class="hljs-comment">// 表单参数 &quot;name&quot;</span><br>    Address  <span class="hljs-type">string</span>    <span class="hljs-string">`form:&quot;address&quot;`</span>                  <span class="hljs-comment">// 表单参数 &quot;address&quot;</span><br>    Birthday time.Time <span class="hljs-string">`form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;`</span> <br>    <span class="hljs-comment">// 表单参数 &quot;birthday&quot;，使用指定的时间格式和转换为 UTC 时间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    route := gin.Default() <span class="hljs-comment">// 创建默认的 Gin 路由引擎</span><br><br>    route.GET(<span class="hljs-string">&quot;/testing&quot;</span>, startPage) <span class="hljs-comment">// 注册 GET 请求处理函数 &quot;/testing&quot;</span><br><br>    route.Run(<span class="hljs-string">&quot;:8085&quot;</span>) <span class="hljs-comment">// 启动 Gin 服务并监听在 8085 端口</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startPage</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> person Person <span class="hljs-comment">// 创建一个 Person 结构体变量用于存储请求参数</span><br><br>    <span class="hljs-comment">// 使用 Gin 的 ShouldBind 方法将请求参数绑定到 Person 结构体变量上</span><br>    <span class="hljs-comment">// 如果请求是 GET 请求，则使用 Form 绑定引擎（query）进行参数绑定</span><br>    <span class="hljs-comment">// 如果请求是 POST 请求，则首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）绑定引擎</span><br>    <span class="hljs-comment">// 详细绑定规则可以参考：https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L48</span><br>    <span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;person); err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//绑定成功时返回nil，反之返回错误信息</span><br>log.Println(person.Name)<span class="hljs-comment">// 输出绑定后的 Name 字段值</span><br>log.Println(person.Address)<span class="hljs-comment">// 输出绑定后的 Address 字段值</span><br>log.Println(person.Birthday)<span class="hljs-comment">// 输出绑定后的 Birthday 字段值</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>&#125;<br><br>    c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Success&quot;</span>) <span class="hljs-comment">// 返回 &quot;Success&quot; 字符串作为响应</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-2"><a href="#（2）知识点-2" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li>​<code>ShouldBind</code> 是 Gin 框架提供的一个方法，用于将 HTTP 请求中的参数绑定到一个结构体变量上。<code>ShouldBind</code> 方法会根据请求中的参数名称和目标结构体的字段名称进行自动匹配，并将对应的参数值绑定到结构体字段上。在示例代码中的 <code>Person</code> 结构体定义中使用了 <code>form</code> 标签来指定参数的来源和绑定规则，如 <code>form:&quot;name&quot;</code>、<code>form:&quot;address&quot;</code> 和 <code>form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;</code>。这样，在调用 <code>ShouldBind</code> 方法时，Gin 会根据请求中的表单参数名称和结构体字段的标签进行自动匹配和绑定。需要注意的是，<code>ShouldBind</code> 方法在绑定参数时会根据目标结构体字段的类型和标签进行自动转换和验证，如果绑定失败会返回错误信息。因此，在使用 <code>ShouldBind</code> 方法时，需要进行错误处理，可以通过判断返回的错误是否为 <code>nil</code> 来判断参数绑定是否成功。如果绑定失败，可以通过错误信息来获取详细的错误原因，并做相应的处理。</li></ul><h4 id="（3）代码大意"><a href="#（3）代码大意" class="headerlink" title="（3）代码大意"></a>（3）代码大意</h4><blockquote><ol><li>定义了一个 <code>Person</code> 结构体，用于存储请求参数。<code>Person</code> 结构体包含了三个字段：<code>Name</code>、<code>Address</code> 和 <code>Birthday</code>，分别对应请求中的表单参数 “name”、”address” 和 “birthday”。</li><li>创建了一个 Gin 路由引擎 <code>route</code>，使用了默认的中间件。</li><li>注册了一个 HTTP GET 请求的处理函数 <code>startPage</code>，该处理函数通过调用 Gin 的 <code>ShouldBind</code> 方法将请求参数绑定到 <code>Person</code> 结构体变量 <code>person</code> 上。<code>ShouldBind</code> 方法会根据请求的类型（GET 或 POST）和请求的 content-type 自动选择合适的绑定引擎（Form 或 JSON&#x2F;XML 绑定引擎）进行参数绑定。</li><li>在 <code>startPage</code> 函数中，通过打印 <code>person</code> 结构体的字段值来验证参数绑定是否成功。</li><li>最后，返回了一个 HTTP 200 OK 响应，内容为 “Success” 字符串。</li></ol><p>总的来说，这段代码实现了一个简单的 HTTP GET 请求处理函数，使用 Gin 框架来绑定请求参数并处理请求。当请求到达 <code>/testing</code> 路径时，会触发 <code>startPage</code> 函数，将请求参数绑定到 <code>Person</code> 结构体变量，并输出字段值。如果参数绑定失败，则输出错误信息。最后返回一个 “Success” 字符串作为响应。</p></blockquote><h4 id="（4）测试"><a href="#（4）测试" class="headerlink" title="（4）测试"></a>（4）测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">http:<span class="hljs-comment">//localhost:8085/testing?name=ft&amp;address=China&amp;birthday=2023-04-11</span><br></code></pre></td></tr></table></figure><p>若响应成功，可以看到页面中会显示<code>Success</code>；</p><p>若响应成功，且信息匹配成功，终端中会打印出信息。</p><h2 id="5、绑定-Uri"><a href="#5、绑定-Uri" class="headerlink" title="5、绑定 Uri"></a>5、绑定 Uri</h2><h4 id="（1）完整代码-3"><a href="#（1）完整代码-3" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-comment">// Person 结构体用于绑定 URI 参数</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">string</span> <span class="hljs-string">`uri:&quot;id&quot; binding:&quot;required,uuid&quot;`</span> <span class="hljs-comment">// 将 URI 中的 id 参数绑定到 ID 字段，并指定必填和 UUID 格式验证</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`uri:&quot;name&quot; binding:&quot;required&quot;`</span>    <span class="hljs-comment">// 将 URI 中的 name 参数绑定到 Name 字段，并指定必填验证</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>route := gin.Default()<span class="hljs-comment">// 创建默认的 Gin 路由引擎</span><br><br><span class="hljs-comment">// 定义路由处理函数</span><br>route.GET(<span class="hljs-string">&quot;/:name/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> person Person<br><span class="hljs-comment">// 使用 ShouldBindUri 方法将 URI 参数绑定到 Person 结构体</span><br><span class="hljs-keyword">if</span> err := c.ShouldBindUri(&amp;person); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">//绑定成功，返回nil</span><br>c.JSON(<span class="hljs-number">400</span>, gin.H&#123;<span class="hljs-string">&quot;msg&quot;</span>: err.Error()&#125;) <span class="hljs-comment">// 如果绑定失败，返回错误信息</span><br><span class="hljs-keyword">return</span><br>&#125;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;name&quot;</span>: person.Name, <span class="hljs-string">&quot;uuid&quot;</span>: person.ID&#125;) <span class="hljs-comment">// 如果绑定成功，返回绑定后的值</span><br>&#125;)<br><br>route.Run(<span class="hljs-string">&quot;:8088&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-3"><a href="#（2）知识点-3" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>c.ShouldBindUri(&amp;person)</code>: 这是 <code>*gin.Context</code> 上下文对象的方法，用于将 URI 参数绑定到结构体变量 <code>person</code> 上。<code>ShouldBindUri</code> 方法会自动根据结构体字段的 <code>uri</code> 标签和 URI 路径中的参数名称进行匹配和绑定。在示例代码中，<code>ID</code> 字段的 <code>uri</code> 标签指定了参数名称为 <code>id</code>，<code>Name</code> 字段的 <code>uri</code> 标签指定了参数名称为 <code>name</code>。同时，结构体字段的 <code>binding</code> 标签还指定了参数的验证规则，例如 <code>required</code> 表示参数必填，<code>uuid</code> 表示参数的值必须是 UUID 格式。</li><li><code>c.JSON(400, gin.H&#123;&quot;msg&quot;: err.Error()&#125;)</code>: 这是 <code>*gin.Context</code> 上下文对象的方法，用于构建一个 JSON 格式的 HTTP 响应。其中，<code>400</code> 表示 HTTP 状态码为 400（Bad Request），<code>gin.H&#123;&quot;msg&quot;: err.Error()&#125;</code> 表示响应的 JSON 数据，包含一个名为 <code>msg</code> 的字段，值为错误信息的字符串。</li><li><code>c.JSON(200, gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;)</code>: 这是 <code>*gin.Context</code> 上下文对象的方法，用于构建一个 JSON 格式的 HTTP 响应。其中，<code>200</code> 表示 HTTP 状态码为 200（OK），<code>gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;</code> 表示响应的 JSON 数据，包含两个字段，分别为 <code>name</code> 和 <code>uuid</code>，值分别为 <code>person.Name</code> 和 <code>person.ID</code> 的值，即绑定后的 URI 参数值。</li></ul><h4 id="（3）示例大意-2"><a href="#（3）示例大意-2" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><p>上述代码使用了 Gin 框架来创建一个 HTTP 服务器，并定义了一个 GET 请求处理函数，该处理函数绑定了两个 URI 参数（<code>:name</code> 和 <code>:id</code>）到一个自定义的结构体 <code>Person</code> 的字段上。具体而言，代码实现了以下几个功能：</p><ol><li>导入了 <code>github.com/gin-gonic/gin</code> 包，该包是 Gin 框架的核心库，提供了用于构建 Web 应用的 HTTP 路由和中间件功能。</li><li>定义了一个名为 <code>Person</code> 的结构体，该结构体包含了两个字段 <code>ID</code> 和 <code>Name</code>，分别用于绑定 URI 参数 <code>id</code> 和 <code>name</code>。</li><li>创建了一个默认的 Gin 路由引擎实例 <code>route</code>，用于处理 HTTP 请求和路由。</li><li>定义了一个路由处理函数，处理 HTTP GET 请求，该处理函数绑定了路由路径中的 <code>:name</code> 和 <code>:id</code> 参数到 <code>Person</code> 结构体的字段上，并在绑定成功后返回绑定后的值，否则返回错误信息。</li><li>使用 <code>c.ShouldBindUri(&amp;person)</code> 方法将 URI 参数绑定到 <code>Person</code> 结构体的字段上。<code>ShouldBindUri</code> 方法会根据结构体字段的标签信息来解析和验证 URI 参数，并将解析后的值赋给结构体字段。</li><li>如果 URI 参数绑定失败（例如，缺少必填参数或参数格式不符合预期），则通过 <code>c.JSON</code> 方法返回 HTTP 状态码 400（Bad Request）和错误信息。</li><li>如果 URI 参数绑定成功，则通过 <code>c.JSON</code> 方法返回 HTTP 状态码 200（OK）和绑定后的值，包括 <code>Person</code> 结构体中的 <code>Name</code> 和 <code>ID</code> 字段的值。</li><li>最后，通过 <code>route.Run(&quot;:8088&quot;)</code> 启动 HTTP 服务器，监听在本地的 8088 端口上。一旦有请求到达该端口，将会由 Gin 路由引擎处理并调用相应的路由处理函数。</li></ol></blockquote><h4 id="（4）测试-1"><a href="#（4）测试-1" class="headerlink" title="（4）测试"></a>（4）测试</h4><p>网页：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">http:<span class="hljs-comment">//localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3</span><br>http:<span class="hljs-comment">//localhost:8088/thinkerou/not-uuid</span><br></code></pre></td></tr></table></figure><p>终端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">Invoke-WebRequest -Uri <span class="hljs-string">&quot;http://localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3&quot;</span> -Method GET<br><br>Invoke-WebRequest -Uri <span class="hljs-string">&quot;http://localhost:8088/thinkerou/not-uuid&quot;</span> -Method GET<br></code></pre></td></tr></table></figure><h2 id="6、控制Log高亮输出"><a href="#6、控制Log高亮输出" class="headerlink" title="6、控制Log高亮输出"></a>6、控制Log高亮输出</h2><blockquote><p>默认是会高亮（当然这基于你使用的 TTY）。</p></blockquote><h4 id="（1）完整代码-4"><a href="#（1）完整代码-4" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>如果你不想使用日志高亮：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 关闭高亮</span><br>    gin.DisableConsoleColor()<br><br>    <span class="hljs-comment">// 创建一个带有默认中间件（logger和recovery）的gin路由器</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 处理GET请求，路径为&quot;/ping&quot;</span><br>    router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>) <span class="hljs-comment">// 向客户端返回字符串&quot;pong&quot;，状态码为200</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 启动HTTP服务器，监听在端口8080上，等待客户端请求</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>手动设置高亮：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 强制开启日志高亮显示</span><br>    gin.ForceConsoleColor()<br><br>    <span class="hljs-comment">// 创建一个带有默认中间件（logger和recovery）的gin路由器</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 处理GET请求，路径为&quot;/ping&quot;</span><br>    router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>) <span class="hljs-comment">// 向客户端返回字符串&quot;pong&quot;，状态码为200</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 启动HTTP服务器，监听在端口8080上，等待客户端请求</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-4"><a href="#（2）知识点-4" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><code>gin.ForceConsoleColor()</code>: 这是 Gin 框架的一个方法，用于强制开启日志的高亮显示。它可以让 Gin 框架在控制台输出的日志信息更加醒目和易读。</li><li><code>gin.DisableConsoleColor()</code>: 这是 Gin 框架的一个方法，用于关闭日志的高亮显示。当调用了这个方法后，Gin 框架在控制台输出的日志信息将不再具有高亮效果，变为普通的文本显示。</li></ul><h2 id="7、自定义HTTP配置"><a href="#7、自定义HTTP配置" class="headerlink" title="7、自定义HTTP配置"></a>7、自定义HTTP配置</h2><h4 id="（1）完整代码-5"><a href="#（1）完整代码-5" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>​直接使用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例，使用默认的中间件：日志和恢复中间件</span><br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, router) <span class="hljs-comment">// 启动 HTTP 服务器，监听在端口 8080 上，使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>或</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例，使用默认的中间件：日志和恢复中间件</span><br><br>    <span class="hljs-comment">// 创建一个自定义的 http.Server 实例</span><br>    s := &amp;http.Server&#123;<br>        Addr:           <span class="hljs-string">&quot;:8080&quot;</span>,                        <span class="hljs-comment">// 监听的地址和端口</span><br>        Handler:        router,                         <span class="hljs-comment">// 使用创建的路由引擎处理请求</span><br>        ReadTimeout:    <span class="hljs-number">10</span> * time.Second,               <span class="hljs-comment">// 读取请求超时时间</span><br>        WriteTimeout:   <span class="hljs-number">10</span> * time.Second,               <span class="hljs-comment">// 写入响应超时时间</span><br>        MaxHeaderBytes: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>,                         <span class="hljs-comment">// 最大请求头大小</span><br>    &#125;<br><br>    s.ListenAndServe() <span class="hljs-comment">// 启动 HTTP 服务器，监听在指定的地址和端口，并使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-5"><a href="#（2）知识点-5" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><p><code>http.ListenAndServe(&quot;:8080&quot;, router)</code>: 这是 Go 标准库 <code>net/http</code> 提供的一个方法，用于启动一个 HTTP 服务器并监听指定的地址和端口，并使用传入的路由引擎处理请求。在这里，我们指定监听地址为空字符串，表示监听所有可用的网卡，端口为 8080。<code>router</code> 是之前创建的 Gin 路由引擎实例，用于处理请求。</p></li><li><p><code>s := &amp;http.Server&#123;...&#125;</code>这段代码创建了一个 <code>http.Server</code> 实例，并设置了以下配置项：</p></li><li><ol><li><code>Addr</code>：指定服务器监听的地址和端口，这里设置为 <code>:8080</code>，表示监听在本地的 8080 端口。</li><li><code>Handler</code>：设置处理请求的路由引擎，这里使用了之前创建的 <code>router</code>，即 Gin 路由引擎。</li><li><code>ReadTimeout</code>：设置读取请求的超时时间，这里设置为 10 秒，表示如果在 10 秒内没有读取到完整的请求，服务器会关闭连接。</li><li><code>WriteTimeout</code>：设置写入响应的超时时间，这里设置为 10 秒，表示如果在 10 秒内没有完成响应的写入操作，服务器会关闭连接。</li><li><code>MaxHeaderBytes</code>：设置最大请求头的大小，这里设置为 1 &lt;&lt; 20，即 1MB，表示请求头的大小不超过 1MB。</li></ol></li><li><p>这些配置项可以根据具体的需求进行调整，用于自定义 HTTP 服务器的行为，例如设置超时时间、限制请求头大小等。在创建完 <code>http.Server</code> 实例后，可以通过调用 <code>ListenAndServe()</code> 方法来启动服务器，开始监听指定的地址和端口，并使用设置的路由引擎来处理请求。</p></li><li><p><code>s.ListenAndServe()</code>: 这是 http.Server 的一个方法，用于启动 HTTP 服务器，并监听在指定的地址和端口，使用创建的路由引擎处理请求。在这里，<code>s</code> 是之前创建的自定义 http.Server 实例，通过调用 <code>ListenAndServe()</code> 方法来启动服务器。</p></li></ul><h4 id="（3）示例大意-3"><a href="#（3）示例大意-3" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>创建一个默认的 Gin 路由引擎实例，使用了默认的中间件包括日志和恢复中间件。</li><li>创建一个自定义的 <code>http.Server</code> 实例，设置了监听的地址和端口为 <code>:8080</code>，使用之前创建的路由引擎 <code>router</code> 来处理请求，设置了读取请求的超时时间为 10 秒，写入响应的超时时间为 10 秒，最大请求头大小为 1MB。</li><li>调用 <code>ListenAndServe()</code> 方法启动 HTTP 服务器，开始监听指定的地址和端口，并使用创建的路由引擎来处理请求。</li></ol><p>这段代码的目的是创建一个自定义的 HTTP 服务器，使用 Gin 框架来处理请求，并设置了一些自定义的配置项，如超时时间和最大请求头大小。最后通过调用 <code>ListenAndServe()</code> 方法启动服务器，使其开始监听客户端请求。</p></blockquote><h2 id="8、-自定义-Log-文件"><a href="#8、-自定义-Log-文件" class="headerlink" title="8、 自定义 Log 文件"></a>8、 自定义 Log 文件</h2><h4 id="（1）完整代码-6"><a href="#（1）完整代码-6" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 路由引擎实例，不使用默认的中间件</span><br><br><span class="hljs-comment">// 添加自定义的日志中间件，将日志格式化为自定义格式</span><br>router.Use(gin.LoggerWithFormatter(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(param gin.LogFormatterParams)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 自定义日志格式</span><br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s - [%s] \&quot;%s %s %s %d %s \&quot;%s\&quot; %s\&quot;\n&quot;</span>,<br>param.ClientIP,                       <span class="hljs-comment">//客户端 IP 地址</span><br>param.TimeStamp.Format(time.RFC1123), <span class="hljs-comment">//时间戳</span><br>param.Method,                         <span class="hljs-comment">//请求方法</span><br>param.Path,                           <span class="hljs-comment">//请求路径</span><br>param.Request.Proto,                  <span class="hljs-comment">//请求协议版本</span><br>param.StatusCode,                     <span class="hljs-comment">//响应状态码</span><br>param.Latency,                        <span class="hljs-comment">//请求耗时</span><br>param.Request.UserAgent(),            <span class="hljs-comment">//客户端 UserAgent 信息</span><br>param.ErrorMessage,                   <span class="hljs-comment">// 错误信息（若有错误发生时）</span><br>)<br>&#125;))<br><br>router.Use(gin.Recovery()) <span class="hljs-comment">// 添加恢复中间件，用于恢复从 panic 中恢复</span><br><br>router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器，监听在指定的地址和端口，并使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-6"><a href="#（2）知识点-6" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><p><code>router.Use()</code>: 此方法用于向 Gin 路由引擎添加中间件。中间件是处理 HTTP 请求的函数，在请求到达实际的路由处理器之前被执行。在这段代码中，使用 <code>router.Use()</code> 添加了两个中间件函数：</p></li><li><p><code>router.Use()</code>: 此方法用于向 Gin 路由引擎添加中间件。中间件是处理 HTTP 请求的函数，在请求到达实际的路由处理器之前被执行。在这段代码中，使用 <code>router.Use()</code> 添加了两个中间件函数：</p></li><li><p><code>gin.LoggerWithFormatter()</code>: 这个中间件函数用于以自定义格式记录 HTTP 请求日志。<code>param</code> 参数是 <code>gin.LogFormatterParams</code> 类型的实例，包含了有关 HTTP 请求和响应的信息。在给定的代码中，<code>param</code> 被用于格式化一个自定义的日志字符串，其中包括了客户端 IP 地址、时间戳、HTTP 方法、请求路径、协议版本、响应状态码、请求耗时、客户端 UserAgent 信息和错误消息（如果有的话）。</p></li><li><p><code>gin.Recovery()</code>: 这个中间件函数用于从可能在处理 HTTP 请求时发生的 panic 中恢复。如果发生 panic，这个中间件会从中恢复，并向客户端返回一个 500 内部服务器错误的响应。</p></li></ul><h4 id="（3）示例大意-4"><a href="#（3）示例大意-4" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li><p>导入了 <code>fmt</code>、<code>github.com/gin-gonic/gin</code> 和 <code>time</code> 包。</p></li><li><p>在 <code>main()</code> 函数中，创建了一个新的 Gin 路由引擎实例 <code>router</code>，并使用 <code>gin.New()</code> 方法创建了一个不使用默认中间件的路由引擎。</p></li><li><p>使用 <code>router.Use()</code> 方法添加了两个自定义中间件：</p><p>a. <code>gin.LoggerWithFormatter()</code> 中间件，用于将日志格式化为自定义格式。在回调函数中，通过 <code>gin.LogFormatterParams</code> 参数获取了请求和响应的信息，然后使用自定义的格式将这些信息组合成一个日志字符串。</p><p>b. <code>gin.Recovery()</code> 中间件，用于从 panic 中恢复。这将确保在处理请求时发生 panic 时，服务器不会崩溃，而是能够从中恢复，并返回一个 500 内部服务器错误的响应。</p></li><li><p>使用 <code>router.GET()</code> 方法定义了一个处理 HTTP GET 请求的路由，路径为 “&#x2F;ping”。在回调函数中，使用 <code>c.String()</code> 方法向客户端发送一个状态码为 200 的 “pong” 字符串响应。</p></li><li><p>最后，使用 <code>router.Run()</code> 方法启动了 HTTP 服务器，监听在地址 “:8080” 上，并使用创建的路由引擎处理传入的请求。</p></li></ol><p>这段代码的功能是创建一个简单的 HTTP 服务器，监听在端口 8080，当访问 “&#x2F;ping” 路径时，返回一个 “pong” 的响应。同时，还添加了自定义的日志中间件和恢复中间件，以增强服务器的健壮性和可靠性。</p></blockquote><h2 id="9、自定义中间件"><a href="#9、自定义中间件" class="headerlink" title="9、自定义中间件"></a>9、自定义中间件</h2><h4 id="（1）完整代码-7"><a href="#（1）完整代码-7" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Logger</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        t := time.Now() <span class="hljs-comment">// 记录当前时间</span><br><br>        c.Set(<span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>) <span class="hljs-comment">// 设置一个名为 &quot;example&quot; 的自定义变量到 Gin 上下文中</span><br><br>        <span class="hljs-comment">// 请求前的处理逻辑</span><br><br>        c.Next() <span class="hljs-comment">// 执行下一个处理函数</span><br><br>        <span class="hljs-comment">// 请求后的处理逻辑</span><br>        latency := time.Since(t) <span class="hljs-comment">// 计算请求耗时</span><br>        log.Print(latency) <span class="hljs-comment">// 打印请求耗时</span><br><br>        status := c.Writer.Status() <span class="hljs-comment">// 获取响应状态码</span><br>        log.Println(status) <span class="hljs-comment">// 打印响应状态码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 路由引擎实例</span><br><br>    r.Use(Logger()) <span class="hljs-comment">// 使用自定义的 Logger 中间件</span><br><br>    r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        example := c.MustGet(<span class="hljs-string">&quot;example&quot;</span>).(<span class="hljs-type">string</span>) <span class="hljs-comment">// 从 Gin 上下文中获取之前设置的 &quot;example&quot; 变量</span><br><br>        <span class="hljs-comment">// 打印：&quot;12345&quot;</span><br>        log.Println(example)<br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器，监听在指定的地址和端口，并使用创建的路由引擎处理请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-7"><a href="#（2）知识点-7" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><ul><li><p><code>time.Now()</code>: 这是 Go 语言中的时间包 <code>time</code> 中的函数，用于获取当前时间。在这段代码中，用于记录请求处理开始的时间 <code>t</code>，以便后续计算请求耗时。</p></li><li><p><code>c.Set(key string, value interface&#123;&#125;)</code>: 这是 Gin 框架中 <code>Context</code> 对象的方法，用于在 Gin 上下文中设置一个自定义的键值对。在这段代码中，使用该方法将一个名为 “example” 的自定义变量设置到 Gin 上下文中，值为字符串 “12345”。</p></li><li><p><code>c.Next()</code>: 这是 Gin 框架中 <code>Context</code> 对象的方法，用于执行下一个处理函数。在这段代码中，用于将请求传递给下一个处理函数，通常在中间件中使用，确保请求能够继续向后处理。</p></li><li><p><code>time.Since(t)</code>: 这是 Go 语言中的时间包 <code>time</code> 中的函数，用于计算当前时间与给定时间 <code>t</code> 的时间差。在这段代码中，用于计算请求耗时，即当前时间与请求处理开始时间 <code>t</code> 的时间差。</p></li><li><p><code>log.Print(v ...interface&#123;&#125;)</code>: 这是 Go 语言中的日志包 <code>log</code> 中的函数，用于将日志消息打印到标准输出。在这段代码中，用于打印请求耗时 <code>latency</code>和用于打印响应状态码。</p></li><li><p><code>c.Writer.Status()</code>: 这是 Gin 框架中 <code>Context</code> 对象的方法，用于获取响应状态码。在这段代码中，用于获取响应状态码，以便后续打印到日志中。</p></li></ul><h4 id="（3）示例执行过程"><a href="#（3）示例执行过程" class="headerlink" title="（3）示例执行过程"></a>（3）示例执行过程</h4><blockquote><ol><li>在 <code>main()</code> 函数中，首先创建了一个新的 Gin 路由引擎实例 <code>r</code>。</li><li>使用 <code>r.Use(Logger())</code> 将自定义的 <code>Logger</code> 中间件注册到路由引擎 <code>r</code> 中，以便在处理请求时自动调用。</li><li>定义了一个处理 HTTP GET 请求的路由处理函数，路径为 “&#x2F;test”。在这个处理函数中，使用 <code>c.MustGet(&quot;example&quot;)</code> 从 Gin 上下文中获取之前在 <code>Logger</code> 中间件中设置的名为 “example” 的自定义变量，并将其转换为字符串类型。</li><li>在路由处理函数中，使用日志包 <code>log</code> 将获取到的 “example” 变量打印到日志中。</li><li>使用 <code>r.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在地址 “:8080” 并使用创建的路由引擎 <code>r</code> 处理请求。</li><li>当有请求到达时，Gin 框架会依次执行注册到路由引擎的中间件和路由处理函数。</li><li><code>Logger()</code> 中间件会在请求前记录当前时间，并设置一个名为 “example” 的自定义变量到 Gin 上下文中。然后，它会调用 <code>c.Next()</code> 执行下一个处理函数，即路由处理函数。</li><li>路由处理函数会从 Gin 上下文中获取 “example” 变量，并将其打印到日志中。</li><li>当路由处理函数执行完毕后，控制权会返回到 <code>Logger()</code> 中间件，它会计算请求耗时，并将请求耗时和响应状态码打印到日志中。</li><li>最后，HTTP 服务器会根据定义的路由引擎 <code>r</code> 处理请求，并在指定的地址和端口上监听。</li></ol></blockquote><h2 id="10、自定义验证器"><a href="#10、自定义验证器" class="headerlink" title="10、自定义验证器"></a>10、自定义验证器</h2><blockquote><p>可能有问题。略</p></blockquote><h4 id="（1）完整代码-8"><a href="#（1）完整代码-8" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin/binding&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-playground/validator/v10&quot;</span><br>)<br><br><span class="hljs-comment">// Booking contains binded and validated data.</span><br><span class="hljs-keyword">type</span> Booking <span class="hljs-keyword">struct</span> &#123;<br>    CheckIn  time.Time <span class="hljs-string">`form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;`</span><br>    CheckOut time.Time <span class="hljs-string">`form:&quot;check_out&quot; binding:&quot;required,gtfield=CheckIn,bookabledate&quot; time_format:&quot;2006-01-02&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">var</span> bookableDate validator.Func = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(fl validator.FieldLevel)</span></span> <span class="hljs-type">bool</span> &#123;<br>    date, ok := fl.Field().Interface().(time.Time)<br>    <span class="hljs-keyword">if</span> ok &#123;<br>        today := time.Now()<br>        <span class="hljs-keyword">if</span> today.After(date) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    route := gin.Default()<br><br>    <span class="hljs-comment">// 注册自定义验证器函数</span><br>    <span class="hljs-keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;<br>        v.RegisterValidation(<span class="hljs-string">&quot;bookabledate&quot;</span>, bookableDate)<br>    &#125;<br><br>    <span class="hljs-comment">// 定义路由</span><br>    route.GET(<span class="hljs-string">&quot;/bookable&quot;</span>, getBookable)<br><br>    <span class="hljs-comment">// 启动服务</span><br>    route.Run(<span class="hljs-string">&quot;:8085&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBookable</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> b Booking<br>    <span class="hljs-keyword">if</span> err := c.ShouldBindWith(&amp;b, binding.Query); err == <span class="hljs-literal">nil</span> &#123;<br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Booking dates are valid!&quot;</span>&#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-8"><a href="#（2）知识点-8" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><p><code>type Booking struct</code>: 定义了一个结构体类型 <code>Booking</code>，用于存储从请求中绑定和验证后的数据。</p></li><li><p><code>var bookableDate validator.Func</code>: 定义了一个自定义验证器函数 <code>bookableDate</code>，用于验证日期是否可预订。该函数会在后续的验证中使用。</p></li><li><p><code>binding.Validator.Engine()</code>: 获取 Gin 框架中的验证器引擎实例，用于注册自定义验证器函数。</p></li><li><p><code>v.RegisterValidation(&quot;bookabledate&quot;, bookableDate)</code>: 使用 <code>v.RegisterValidation()</code> 方法将自定义验证器函数 <code>bookableDate</code> 注册到 Gin 的验证器引擎中，并指定了验证器的名称为 “bookabledate”。这样，在后续的验证中就可以通过该名称来使用这个自定义验证器函数。</p></li><li><p><code>var bookableDate validator.Func</code>: 定义了一个自定义验证器函数 <code>bookableDate</code>，用于验证日期是否可预订。该函数会在后续的验证中使用。</p></li><li><p><code>c.ShouldBindWith(&amp;b, binding.Query)</code>: 在 <code>getBookable</code> 处理函数中，使用 <code>c.ShouldBindWith()</code> 方法将请求中的数据绑定到 <code>b</code> 变量，并使用 <code>binding.Query</code> 标签指定了从查询参数中获取数据。这样，请求中的数据就会被绑定到 <code>Booking</code> 结构体的字段，并且会进行后续的验证。</p></li><li><p><code>c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</code>: 在验证失败时，使用 <code>c.JSON()</code> 方法将一个 JSON 格式的错误响应发送给客户端，其中包含了一个键值对，键为 “error”，值为验证失败的错误信息。HTTP 状态码被设置为 <code>http.StatusBadRequest</code>，表示请求参数错误。</p></li><li><p>自定义验证器函数，用于验证日期是否可预订，具体实现如下：</p><ul><li><code>func(fl validator.FieldLevel) bool</code>: 这是一个函数类型，参数为 <code>validator.FieldLevel</code>，返回值为 <code>bool</code>。<code>validator.FieldLevel</code> 是一个接口，用于在验证器中获取字段的相关信息，如字段的值、字段的标签等。</li><li><code>fl.Field().Interface().(time.Time)</code>: 使用 <code>fl.Field()</code> 方法获取字段的值，并使用 <code>Interface()</code> 方法将其转换为 <code>interface&#123;&#125;</code> 类型。然后使用类型断言将其转换为 <code>time.Time</code> 类型的值。这样，我们可以在函数中使用字段的实际值进行验证。</li><li><code>today := time.Now()</code>: 使用 <code>time.Now()</code> 函数获取当前的时间，并将其赋值给 <code>today</code> 变量，表示当前的日期时间。</li><li><code>if today.After(date) &#123; return false &#125;</code>: 使用 <code>today.After()</code> 方法比较当前时间和字段值的时间，如果当前时间晚于字段值的时间，则返回 <code>false</code>，表示验证失败，日期不可预订。</li><li><code>return true</code>: 如果验证通过，即当前时间不晚于字段值的时间，返回 <code>true</code>，表示日期可预订。</li></ul><p>总的来说，这个函数的实现逻辑是通过比较当前时间和字段值的时间来判断日期是否可预订，如果当前时间晚于字段值的时间，则认为日期不可预订，返回 <code>false</code>，否则返回 <code>true</code>。</p></li></ul></blockquote><h4 id="（3）示例大意-5"><a href="#（3）示例大意-5" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义了一个 <code>Booking</code> 结构体，包含了两个字段 <code>CheckIn</code> 和 <code>CheckOut</code>，分别表示入住日期和离店日期。这两个字段使用了 Gin 的 <code>form</code> 标签指定了它们在请求参数中的名称，并使用了 <code>binding</code> 标签来指定了验证规则。</li><li>定义了一个名为 <code>bookableDate</code> 的自定义验证器函数，用于验证日期是否可预订。这个函数在验证器中注册为 <code>bookabledate</code>，并在验证过程中获取字段的实际值，比较当前时间和字段值的时间来判断日期是否可预订。</li><li>在 <code>main</code> 函数中，创建了一个 Gin 的默认引擎，用于处理 HTTP 请求。然后使用 <code>binding.Validator.Engine()</code> 方法获取到验证器引擎，并使用 <code>v.RegisterValidation()</code> 方法注册了自定义验证器函数 <code>bookableDate</code>。</li><li>定义了一个名为 <code>getBookable</code> 的处理函数，用于处理 <code>/bookable</code> 路由的 GET 请求。在这个处理函数中，首先创建了一个 <code>Booking</code> 结构体实例 <code>b</code>，然后使用 <code>c.ShouldBindWith()</code> 方法将请求参数绑定到 <code>b</code> 上，并进行验证。如果验证通过，则返回 HTTP 状态码为 200 的 JSON 响应，表示预订日期有效；否则，返回 HTTP 状态码为 400 的 JSON 响应，表示验证失败并返回错误信息。</li><li>启动了 Gin 服务，并监听在 8085 端口上。</li></ol></blockquote><h2 id="11、定义路由日志的格式"><a href="#11、定义路由日志的格式" class="headerlink" title="11、定义路由日志的格式"></a>11、定义路由日志的格式</h2><h4 id="（1）完整代码-9"><a href="#（1）完整代码-9" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 实例作为路由引擎</span><br><br><span class="hljs-comment">// 设置 DebugPrintRouteFunc 函数，用于在控制台打印路由信息</span><br>gin.DebugPrintRouteFunc = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(httpMethod, absolutePath, handlerName <span class="hljs-type">string</span>, nuHandlers <span class="hljs-type">int</span>)</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;endpoint %v %v %v %v\n&quot;</span>, httpMethod, absolutePath, handlerName, nuHandlers)<br>&#125;<br><br><span class="hljs-comment">// 定义 POST /foo 路由，处理函数返回 JSON 响应 &quot;foo&quot;</span><br>r.POST(<span class="hljs-string">&quot;/foo&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;foo&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 定义 GET /bar 路由，处理函数返回 JSON 响应 &quot;bar&quot;</span><br>r.GET(<span class="hljs-string">&quot;/bar&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;bar&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 定义 GET /status 路由，处理函数返回 JSON 响应 &quot;ok&quot;</span><br>r.GET(<span class="hljs-string">&quot;/status&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(http.StatusOK, <span class="hljs-string">&quot;ok&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-9"><a href="#（2）知识点-9" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>gin.DebugPrintRouteFunc</code>: 这是 Gin 框架中的一个变量，用于设置在控制台打印路由信息的函数。您在代码中通过给该变量赋值一个函数来自定义路由信息的打印方式。在您的示例中，设置了一个自定义的打印函数，用于在控制台输出 HTTP 方法、URL 路径、处理函数名和处理函数的数量。其中，<code>httpMethod</code> 是 HTTP 请求方法（如 “GET”、”POST” 等），<code>absolutePath</code> 是路由的完整路径，<code>handlerName</code> 是处理函数的名称，<code>nuHandlers</code> 是处理函数的数量，通过调用 <code>log.Printf</code> 函数将路由调试打印的信息输出到控制台。</li><li><code>r.GET(&quot;/bar&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: 这是 Gin 框架中的一个方法，用于定义一个处理 HTTP GET 请求的路由。在这里，您定义了一个处理 <code>/bar</code> 路径的 GET 请求的路由，并传入一个匿名函数作为处理函数。可以在浏览器中输入网址<code>[localhost:8080/bar](http://localhost:8080/bar)</code>访问。</li><li><code>r.POST(&quot;/foo&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: 这是 Gin 框架中的一个方法，用于定义一个处理 HTTP POST 请求的路由。在这里，您定义了一个处理 <code>/foo</code> 路径的 POST 请求的路由，并传入一个匿名函数作为处理函数。这个匿名函数会在请求到达时被调用，其中 <code>c *gin.Context</code> 是处理函数的参数，表示当前请求的上下文。不能在浏览器中直接输入网址访问，因为这里的是POST请求，需要在客户端输入<code>curl -X POST http://localhost:8080/foo</code>或者在 PowerShell 中发送 HTTP 请求并指定请求方法访问<code>Invoke-RestMethod -Uri &#39;http://localhost:8080/foo&#39; -Method Post</code></li></ul></blockquote><h4 id="（3）示例大意-6"><a href="#（3）示例大意-6" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>导入了所需的包，包括日志处理、HTTP 相关的包以及 Gin 框架的包。</li><li>在 <code>main</code> 函数中创建了一个 Gin 实例 <code>r</code>，作为路由引擎。</li><li>使用 <code>gin.DebugPrintRouteFunc</code> 函数设置了一个自定义的路由调试打印函数，用于在控制台打印路由信息。</li><li>定义了一个处理 POST 请求的路由 <code>/foo</code>，当该路由接收到 POST 请求时，会执行传入的匿名函数，该函数会在 HTTP 响应中返回 JSON 格式的响应 “foo”。</li><li>定义了一个处理 GET 请求的路由 <code>/bar</code>，当该路由接收到 GET 请求时，会执行传入的匿名函数，该函数会在 HTTP 响应中返回 JSON 格式的响应 “bar”。</li><li>定义了一个处理 GET 请求的路由 <code>/status</code>，当该路由接收到 GET 请求时，会执行传入的匿名函数，该函数会在 HTTP 响应中返回 JSON 格式的响应 “ok”。</li><li>调用 <code>r.Run()</code> 启动 HTTP 服务，监听地址为 0.0.0.0:8080。</li></ol></blockquote><h2 id="12、在中间件中使用-Goroutine"><a href="#12、在中间件中使用-Goroutine" class="headerlink" title="12、在中间件中使用 Goroutine"></a>12、在中间件中使用 Goroutine</h2><h4 id="（1）完整代码-10"><a href="#（1）完整代码-10" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br><br>    <span class="hljs-comment">// 定义 /long_async 路由</span><br>    r.GET(<span class="hljs-string">&quot;/long_async&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 创建在 goroutine 中使用的副本</span><br>        cCp := c.Copy()<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-comment">// 用 time.Sleep() 模拟一个长任务。</span><br>            time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><br>            <span class="hljs-comment">// 请注意您使用的是复制的上下文 &quot;cCp&quot;，这一点很重要</span><br>            log.Println(<span class="hljs-string">&quot;Done! in path &quot;</span> + cCp.Request.URL.Path)<br>        &#125;()<br>    &#125;)<br><br>    <span class="hljs-comment">// 定义 /long_sync 路由</span><br>    r.GET(<span class="hljs-string">&quot;/long_sync&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 用 time.Sleep() 模拟一个长任务。</span><br>        time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><br>        <span class="hljs-comment">// 因为没有使用 goroutine，不需要拷贝上下文</span><br>        log.Println(<span class="hljs-string">&quot;Done! in path &quot;</span> + c.Request.URL.Path)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-10"><a href="#（2）知识点-10" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>c.Copy()</code>：创建一个上下文的副本，用于在 goroutine 中使用。在多个 goroutine 中处理请求时，需要使用上下文的副本，以避免竞态条件和并发访问的问题。</li><li><code>go func() &#123; ... &#125;()</code>：这段代码是一个匿名的 Go 语言协程（goroutine），通过 <code>go</code> 关键字开启一个新的并发执行的函数。这个函数中的逻辑很简单，首先通过 <code>time.Sleep(5 * time.Second)</code> 模拟一个耗时的操作，即暂停当前 goroutine 的执行 5 秒钟。在这个暂停期间，当前的 goroutine 不会继续执行，而是让出 CPU 时间给其他 goroutine，从而实现了并发执行。当 <code>time.Sleep()</code> 结束后，该 goroutine 会继续执行剩下的代码。这段代码通过调用 <code>log.Println()</code> 在日志中打印一条消息，内容为 “Done! int path “ + cCp.Request.URL.Path。其中，<code>cCp</code> 是在创建这个 goroutine 时通过 <code>c.Copy()</code> 创建的当前请求上下文的副本，用于记录请求的路径。</li><li><code>time.Sleep()</code>：模拟一个长时间运行的任务，暂停当前 goroutine 的执行一段时间，以模拟耗时的操作。在这段代码中，使用 <code>time.Sleep(5 * time.Second)</code> 暂停当前 goroutine 的执行 5 秒。</li><li><code>c.Request.URL.Path</code>：获取当前请求的路径，用于在日志中记录处理请求的路径。</li><li>通过分别访问<code>long_async</code>目录和<code>long_sync</code>目录，会发现：前者每次刷新页面，后台就会立即打印日志，过五秒后才会打印输出路径；反观后者，每次刷新页面需要过五秒，后台才会同时输出日志和打印路径。<code>long_async</code>当前的 goroutine 不会继续执行，而是让出 CPU 时间给其他 goroutine，从而实现了并发执行。</li></ul></blockquote><h4 id="（3）示例大意-7"><a href="#（3）示例大意-7" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>使用 <code>gin.Default()</code> 创建了一个默认的 Gin 引擎 <code>r</code>，用于处理 HTTP 请求和响应。</li><li>定义了两个路由：<ul><li><code>/long_async</code> 路由，使用 <code>r.GET</code> 方法注册了一个处理 GET 请求的处理函数。在这个处理函数中，通过 <code>c.Copy()</code> 创建了一个上下文副本 <code>cCp</code>，然后使用 <code>go</code> 关键字启动了一个 goroutine，在 goroutine 中使用 <code>time.Sleep()</code> 模拟了一个长时间运行的任务，最后在日志中打印了请求路径信息。</li><li><code>/long_sync</code> 路由，同样使用 <code>r.GET</code> 方法注册了一个处理 GET 请求的处理函数。在这个处理函数中，也使用了 <code>time.Sleep()</code> 模拟了一个长时间运行的任务，但没有使用 goroutine，因此不需要拷贝上下文，直接通过 <code>c</code> 访问了请求路径信息，并在日志中打印了请求路径信息。</li></ul></li><li>使用 <code>r.Run(&quot;:8080&quot;)</code> 启动了一个 web 服务器，监听在本地的 8080 端口上，等待接收来自客户端的请求。</li></ol></blockquote><h2 id="13、优雅地重启或停止"><a href="#13、优雅地重启或停止" class="headerlink" title="13、优雅地重启或停止"></a>13、优雅地重启或停止</h2><h4 id="（1）完整代码-11"><a href="#（1）完整代码-11" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build go1.8</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;os/signal&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个默认的 Gin 路由实例</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 注册一个处理函数到 &quot;/&quot; 路径的 GET 请求</span><br>    router.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 模拟一个长任务，暂停 5 秒</span><br>        time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>        c.String(http.StatusOK, <span class="hljs-string">&quot;Welcome Gin Server&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-comment">// 创建一个 http.Server 实例，配置监听地址和 Gin 路由作为处理器</span><br>    srv := &amp;http.Server&#123;<br>        Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>        Handler: router,<br>    &#125;<br><br>    <span class="hljs-comment">// 启动一个 goroutine 监听和处理 HTTP 请求</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 启动 HTTP 服务器，监听和处理请求</span><br>        <span class="hljs-keyword">if</span> err := srv.ListenAndServe(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;<br>            log.Fatalf(<span class="hljs-string">&quot;listen: %s\n&quot;</span>, err)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-comment">// 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）</span><br>    quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>    signal.Notify(quit, os.Interrupt)<br>    &lt;-quit<br>    log.Println(<span class="hljs-string">&quot;Shutdown Server ...&quot;</span>)<br><br>    <span class="hljs-comment">// 创建一个超时上下文，设置 5 秒超时</span><br>    ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">5</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    <span class="hljs-comment">// 关闭服务器，等待未完成的请求完成或超时</span><br>    <span class="hljs-keyword">if</span> err := srv.Shutdown(ctx); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;Server Shutdown:&quot;</span>, err)<br>    &#125;<br>    log.Println(<span class="hljs-string">&quot;Server exiting&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-11"><a href="#（2）知识点-11" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>srv := &amp;http.Server&#123;        Addr:    &quot;:8080&quot;,        Handler: router,    &#125;</code>创建了一个 <code>http.Server</code> 实例，用于配置 HTTP 服务器的监听地址和请求处理器.<ul><li><code>Addr: &quot;:8080&quot;</code>：指定了服务器监听的地址和端口号。在这里，服务器会监听在本地的 8080 端口上，表示可以通过访问 <code>http://localhost:8080</code> 来与服务器进行通信。</li><li><code>Handler: router</code>：指定了服务器的请求处理器。在这里，使用了 Gin 框架创建的路由实例 <code>router</code> 作为服务器的请求处理器。Gin 路由可以用于注册不同的 HTTP 请求处理函数，根据请求的 URL 路径和 HTTP 方法来进行路由和处理。</li></ul></li><li><code>srv.ListenAndServe()</code>：这是 <code>http.Server</code> 的方法，用于启动服务器并开始监听和处理请求。它会一直在后台运行，直到服务器关闭或发生错误。</li><li><code>err := srv.ListenAndServe()</code>：将 <code>srv.ListenAndServe()</code> 的返回值赋给变量 <code>err</code>，用于捕获可能发生的错误。</li><li><code>err != nil &amp;&amp; err != http.ErrServerClosed</code>：通过条件判断语句检查 <code>err</code> 是否不为空且不等于 <code>http.ErrServerClosed</code>，即判断是否有错误发生且错误不是因为服务器被关闭导致的。</li><li><code>log.Fatalf(&quot;listen: %s\n&quot;, err)</code>：如果有错误发生，使用 <code>log.Fatalf()</code> 方法将错误信息格式化并输出到标准错误（stderr），然后调用 <code>log.Fatal()</code> 方法终止程序的运行。<code>log.Fatalf()</code> 是 <code>log</code> 包的一个函数，它会在输出错误信息后直接调用 <code>os.Exit(1)</code> 终止程序。</li><li><code>quit := make(chan os.Signal)</code>：创建了一个用于接收信号的通道 <code>quit</code>，该通道的类型是 <code>os.Signal</code>，用于接收操作系统发送的信号。</li><li><code>signal.Notify(quit, os.Interrupt)</code>：通过 <code>signal</code> 包的 <code>Notify</code> 函数，将 <code>os.Interrupt</code>（表示中断信号，通常由用户在终端中按下 Ctrl+C 产生）注册到 <code>quit</code> 通道，表示当收到中断信号时，将向 <code>quit</code> 通道发送该信号。</li><li><code>&lt;-quit</code>：通过从 <code>quit</code> 通道中接收信号，代码会一直阻塞在这里，直到接收到中断信号。一旦收到中断信号，代码会继续执行下一行。</li><li><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</code>：通过 <code>context.WithTimeout</code> 函数创建了一个带有超时的上下文 <code>ctx</code>，超时时间设置为 5 秒。<code>context.Background()</code> 返回一个空的上下文作为父上下文。</li><li><code>defer cancel()</code>：使用 <code>defer</code> 语句延迟调用 <code>cancel()</code> 函数，确保在函数执行完毕后取消上下文，以避免资源泄漏。</li><li><code>if err := srv.Shutdown(ctx); err != nil</code>：调用 <code>srv.Shutdown</code> 方法来优雅地关闭服务器，传入之前创建的带有超时的上下文 <code>ctx</code>。该方法会等待服务器处理完当前的请求后再关闭服务器，以实现优雅关闭。</li><li><code>log.Fatal(&quot;Server Shutdown:&quot;, err)</code>：如果服务器关闭过程中发生错误，使用 <code>log.Fatal</code> 输出错误信息并终止程序运行。</li></ul></blockquote><h4 id="（3）示例大意-8"><a href="#（3）示例大意-8" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><p>首先，创建了一个默认的 Gin 路由实例，注册了一个处理函数到 “&#x2F;“ 路径的 GET 请求，其中模拟了一个长任务，暂停 5 秒，然后返回 “Welcome Gin Server” 字符串作为响应。</p><p>接着，创建了一个 http.Server 实例，配置了监听地址为 “:8080”，并将 Gin 路由作为处理器。</p><p>然后，通过启动一个 goroutine 来监听和处理 HTTP 请求，调用 <code>srv.ListenAndServe()</code> 方法来启动 HTTP 服务器。</p><p>接下来，通过使用 <code>os/signal</code> 包来等待中断信号（如 Ctrl+C），一旦接收到中断信号，服务器将开始优雅地关闭。</p><p>创建了一个超时上下文 <code>ctx</code>，设置了 5 秒的超时时间，并通过 <code>srv.Shutdown()</code> 方法来优雅地关闭服务器，等待未完成的请求完成或超时。</p><p>最后，使用 <code>log.Fatal()</code> 输出错误信息并终止程序运行，或者输出 “Server exiting” 消息表示服务器成功退出。</p></blockquote><h2 id="14、路由组"><a href="#14、路由组" class="headerlink" title="14、路由组"></a>14、路由组</h2><h4 id="（1）完整代码-12"><a href="#（1）完整代码-12" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由引擎实例</span><br><br>    <span class="hljs-comment">// 简单的路由组: v1</span><br>    v1 := router.Group(<span class="hljs-string">&quot;/v1&quot;</span>) <span class="hljs-comment">// 创建一个名为 &quot;/v1&quot; 的路由组</span><br>    &#123;<br>        v1.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint) <span class="hljs-comment">// 在 &quot;/v1&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/login&quot;，并将该路由与名为 loginEndpoint 的处理函数绑定</span><br>        v1.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint) <span class="hljs-comment">// 在 &quot;/v1&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/submit&quot;，并将该路由与名为 submitEndpoint 的处理函数绑定</span><br>        v1.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint) <span class="hljs-comment">// 在 &quot;/v1&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/read&quot;，并将该路由与名为 readEndpoint 的处理函数绑定</span><br>    &#125;<br><br>    <span class="hljs-comment">// 简单的路由组: v2</span><br>    v2 := router.Group(<span class="hljs-string">&quot;/v2&quot;</span>) <span class="hljs-comment">// 创建一个名为 &quot;/v2&quot; 的路由组</span><br>    &#123;<br>        v2.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint) <span class="hljs-comment">// 在 &quot;/v2&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/login&quot;，并将该路由与名为 loginEndpoint 的处理函数绑定</span><br>        v2.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint) <span class="hljs-comment">// 在 &quot;/v2&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/submit&quot;，并将该路由与名为 submitEndpoint 的处理函数绑定</span><br>        v2.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint) <span class="hljs-comment">// 在 &quot;/v2&quot; 路由组下定义了一个 HTTP POST 方法的路由 &quot;/read&quot;，并将该路由与名为 readEndpoint 的处理函数绑定</span><br>    &#125;<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-12"><a href="#（2）知识点-12" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>router.Group(&quot;/v1&quot;)&#123;...&#125;</code>: 这是创建了一个名为 “&#x2F;v1” 的路由组。路由组可以用来对一组路由进行分组，方便管理和配置共享的中间件。</li></ul></blockquote><h4 id="（3）示例大意-9"><a href="#（3）示例大意-9" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li><code>func main()</code>: 这是 Go 语言的入口函数，是程序的入口点。</li><li><code>router := gin.Default()</code>: 创建了一个默认的 Gin 路由引擎实例。<code>gin.Default()</code> 函数返回一个默认配置的 Gin 路由引擎，包含了常用的中间件，如日志、恢复等。</li><li><code>v1 := router.Group(&quot;/v1&quot;)</code>: 创建了一个名为 “&#x2F;v1” 的路由组。路由组用于将多个路由进行分组管理，可以对这些路由应用相同的中间件、路由组级别的处理函数等。</li><li><code>v1.POST(&quot;/login&quot;, loginEndpoint)</code>: 在 “&#x2F;v1” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;login”，并将该路由与名为 loginEndpoint 的处理函数绑定。这表示当客户端发送 HTTP POST 请求到 “&#x2F;v1&#x2F;login” 时，将调用 loginEndpoint 函数来处理该请求。</li><li><code>v1.POST(&quot;/submit&quot;, submitEndpoint)</code>: 在 “&#x2F;v1” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;submit”，并将该路由与名为 submitEndpoint 的处理函数绑定。这表示当客户端发送 HTTP POST 请求到 “&#x2F;v1&#x2F;submit” 时，将调用 submitEndpoint 函数来处理该请求。</li><li><code>v1.POST(&quot;/read&quot;, readEndpoint)</code>: 在 “&#x2F;v1” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;read”，并将该路由与名为 readEndpoint 的处理函数绑定。这表示当客户端发送 HTTP POST 请求到 “&#x2F;v1&#x2F;read” 时，将调用 readEndpoint 函数来处理该请求。</li><li><code>v2 := router.Group(&quot;/v2&quot;)</code>: 创建了一个名为 “&#x2F;v2” 的路由组，类似于上面的 “&#x2F;v1” 路由组。</li><li><code>v2.POST(&quot;/login&quot;, loginEndpoint)</code>: 在 “&#x2F;v2” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;login”，并将该路由与名为 loginEndpoint 的处理函数绑定。</li><li><code>v2.POST(&quot;/submit&quot;, submitEndpoint)</code>: 在 “&#x2F;v2” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;submit”，并将该路由与名为 submitEndpoint 的处理函数绑定。</li><li><code>v2.POST(&quot;/read&quot;, readEndpoint)</code>: 在 “&#x2F;v2” 路由组下定义了一个 HTTP POST 方法的路由 “&#x2F;read”，并将该路由与名为 readEndpoint 的处理函数绑定。</li><li><code>router.Run(&quot;:8080&quot;)</code>: 启动 HTTP 服务器并监听在端口 8080。一旦服务器启动，就会开始接受来自客户端的请求，并根据定义的路由规则和处理函数来处理这些请求。</li></ol></blockquote><h2 id="15、如何记录日志"><a href="#15、如何记录日志" class="headerlink" title="15、如何记录日志"></a>15、如何记录日志</h2><h4 id="（1）完整代码-13"><a href="#（1）完整代码-13" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 禁用控制台颜色，将日志写入文件时不需要控制台颜色。</span><br>    gin.DisableConsoleColor()<br><br>    <span class="hljs-comment">// 记录到文件。</span><br>    f, _ := os.Create(<span class="hljs-string">&quot;gin.log&quot;</span>) <span class="hljs-comment">// 创建一个名为 &quot;gin.log&quot; 的文件用于记录日志</span><br>    gin.DefaultWriter = io.MultiWriter(f) <span class="hljs-comment">// 设置 Gin 的默认日志写入器为同时写入文件 f</span><br><br>    <span class="hljs-comment">// 如果需要同时将日志写入文件和控制台，请使用以下代码。</span><br>    <span class="hljs-comment">// gin.DefaultWriter = io.MultiWriter(f, os.Stdout)</span><br><br>    router := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由引擎实例</span><br>    router.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义一个 HTTP GET 方法的路由 &quot;/ping&quot;</span><br>        c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>) <span class="hljs-comment">// 在请求处理函数中返回字符串 &quot;pong&quot;</span><br>    &#125;)<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-13"><a href="#（2）知识点-13" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><p><code>gin.DisableConsoleColor()</code>: 禁用控制台颜色输出，这样在将日志写入文件时不会包含控制台颜色信息。</p></li><li><p><code>f, _ := os.Create(&quot;gin.log&quot;)</code>: 创建一个名为 “gin.log” 的文件用于记录日志，并将文件对象保存在变量 f 中。如果创建文件出现错误，错误会被忽略。</p></li><li><p><code>gin.DefaultWriter = io.MultiWriter(f)</code>: 将文件 f 设置为 Gin 框架的默认日志写入器，这样日志将同时写入文件 f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">wd, err := os.Getwd()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;获取当前工作目录失败:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>logFilePath := wd + <span class="hljs-string">&quot;/gin.log&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;gin.log 文件路径:&quot;</span>, logFilePath)<br></code></pre></td></tr></table></figure><p>可以用这段代码获取当前工作目录，<code>gin.log</code>文件就在该路径下。</p></li></ul></blockquote><h4 id="（3）示例大意-10"><a href="#（3）示例大意-10" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>调用 <code>gin.DisableConsoleColor()</code> 禁用控制台颜色输出，因为日志将被写入文件，不需要控制台颜色。</li><li>调用 <code>os.Create(&quot;gin.log&quot;)</code> 创建一个名为 “gin.log” 的文件，用于记录日志，并将返回的文件对象赋值给变量 <code>f</code>。</li><li>将 <code>f</code> 设置为 Gin 框架的默认日志写入器，通过调用 <code>gin.DefaultWriter = io.MultiWriter(f)</code>。这样，Gin 框架的日志将同时写入 <code>gin.log</code> 文件和控制台（如果需要同时写入文件和控制台，可以注释掉当前行，将下一行的注释取消）。</li><li>调用 <code>gin.Default()</code> 创建一个默认的 Gin 路由引擎实例，并将返回的引擎对象赋值给变量 <code>router</code>。</li><li>使用 <code>router.GET(&quot;/ping&quot;, ...)</code> 定义一个 HTTP GET 方法的路由 “&#x2F;ping”，并传入一个请求处理函数，该函数会在收到请求时返回字符串 “pong”。</li><li>调用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，并监听在端口 8080，等待接收客户端请求。一旦接收到请求，就会调用之前定义的请求处理函数进行处理。</li></ol></blockquote><h2 id="16、HTML渲染"><a href="#16、HTML渲染" class="headerlink" title="16、HTML渲染"></a>16、HTML渲染</h2><h4 id="（1）完整代码-14"><a href="#（1）完整代码-14" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><h4 id="（2）代码解释"><a href="#（2）代码解释" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><h2 id="17、HTTP2-server-推送"><a href="#17、HTTP2-server-推送" class="headerlink" title="17、HTTP2 server 推送"></a>17、HTTP2 server 推送</h2><h4 id="（1）完整代码-15"><a href="#（1）完整代码-15" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;html/template&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-comment">// 定义一个 HTML 模板</span><br><span class="hljs-keyword">var</span> html = template.Must(template.New(<span class="hljs-string">&quot;https&quot;</span>).Parse(<span class="hljs-string">`</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">  &lt;title&gt;Https Test&lt;/title&gt;</span><br><span class="hljs-string">  &lt;script src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">  &lt;h1 style=&quot;color:red;&quot;&gt;Welcome, Ginner!&lt;/h1&gt;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">`</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由引擎实例</span><br>    r.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;./assets&quot;</span>) <span class="hljs-comment">// 将静态文件夹 &quot;./assets&quot; 注册为 &quot;/assets&quot; 的静态资源路径</span><br>    r.SetHTMLTemplate(html) <span class="hljs-comment">// 设置 HTML 模板</span><br><br>    r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义一个 HTTP GET 方法的路由 &quot;/&quot;</span><br>        <span class="hljs-keyword">if</span> pusher := c.Writer.Pusher(); pusher != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 判断是否支持服务器推送</span><br>            <span class="hljs-comment">// 使用 pusher.Push() 做服务器推送</span><br>            <span class="hljs-keyword">if</span> err := pusher.Push(<span class="hljs-string">&quot;/assets/app.js&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>                log.Printf(<span class="hljs-string">&quot;Failed to push: %v&quot;</span>, err) <span class="hljs-comment">// 如果推送失败，则记录日志</span><br>            &#125;<br>        &#125;<br>        c.HTML(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;https&quot;</span>, gin.H&#123; <span class="hljs-comment">// 返回 HTML 模板，并设置状态码和数据</span><br>            <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>        &#125;)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 https://127.0.0.1:8080 上启动服务，使用 TLS 加密</span><br>    r.RunTLS(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-string">&quot;./testdata/server.pem&quot;</span>, <span class="hljs-string">&quot;./testdata/server.key&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-14"><a href="#（2）知识点-14" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>var html = template.Must(template.New(&quot;https&quot;).Parse(...))</code>: 定义了一个名为 <code>html</code> 的 HTML 模板。<code>template.Must</code> 是一个辅助函数，用于将模板解析为 <code>template.Template</code> 对象，并在解析过程中检查是否出错。</li><li><code>r.Static(&quot;/assets&quot;, &quot;./assets&quot;)</code>: 将静态文件夹 <code>&quot;./assets&quot;</code> 注册为 “&#x2F;assets” 的静态资源路径，这样当客户端请求 “&#x2F;assets&#x2F;app.js” 时，会返回位于本地文件系统的 “.&#x2F;assets&#x2F;app.js” 文件作为响应。</li><li><code>r.SetHTMLTemplate(html)</code>: 设置之前定义的 <code>html</code> 模板为 Gin 框架的 HTML 模板。</li><li><code>r.GET(&quot;/&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: 定义一个 HTTP GET 方法的路由 “&#x2F;“，并传入一个请求处理函数，该函数会在收到请求时执行。在这个例子中，请求处理函数中通过 <code>c.Writer.Pusher()</code> 检查是否支持服务器推送。如果支持，通过 <code>pusher.Push(&quot;/assets/app.js&quot;, nil)</code> 进行服务器推送，推送的资源路径为 “&#x2F;assets&#x2F;app.js”。然后使用 <code>c.HTML()</code> 返回之前定义的 HTML 模板，并设置状态码为 200 和数据为 <code>gin.H&#123;&quot;status&quot;: &quot;success&quot;&#125;</code>。</li><li><code>r.RunTLS(&quot;:8080&quot;, &quot;./testdata/server.pem&quot;, &quot;./testdata/server.key&quot;)</code>: 启动 HTTP 服务器，并监听在 8080 端口，并使用 TLS 加密进行安全通信。第二个参数 “.&#x2F;testdata&#x2F;server.pem” 是 TLS 证书文件的路径，第三个参数 “.&#x2F;testdata&#x2F;server.key” 是 TLS 私钥文件的路径，用于在服务器端进行 TLS 握手和加密通信。这样，服务器将通过 HTTPS 监听客户端的请求。</li></ul></blockquote><h4 id="（3）示例大意-11"><a href="#（3）示例大意-11" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义 HTML 模板：使用 <code>template.Must</code> 函数创建了一个名为 “https” 的 HTML 模板，用于返回给客户端。</li><li>创建 Gin 路由引擎实例：使用 <code>gin.Default()</code> 函数创建了一个默认的 Gin 路由引擎实例。</li><li>注册静态文件路径：使用 <code>r.Static()</code> 方法将静态文件夹 “.&#x2F;assets” 注册为 “&#x2F;assets” 的静态资源路径，使得客户端可以通过访问 “&#x2F;assets” 路径来获取静态文件。</li><li>设置 HTML 模板：使用 <code>r.SetHTMLTemplate()</code> 方法设置了之前定义的 HTML 模板。</li><li>定义根路由处理函数：使用 <code>r.GET()</code> 方法定义了一个 HTTP GET 方法的根路由处理函数，该处理函数会返回之前定义的 HTML 模板，并在响应头中设置了支持服务器推送的信息。</li><li>启动 HTTPS 服务器：使用 <code>r.RunTLS()</code> 方法在 “<a href="https://127.0.0.1:8080/">https://127.0.0.1:8080</a>“ 地址上启动了一个监听 TLS 加密的 HTTPS 服务器，使用了之前定义的 TLS 证书和私钥文件。</li></ol></blockquote><h2 id="18、-JSONP"><a href="#18、-JSONP" class="headerlink" title="18、 JSONP"></a>18、 JSONP</h2><blockquote><p>使用 JSONP 向不同域的服务器请求数据。如果查询参数存在回调，则将回调添加到响应体中。</p></blockquote><h4 id="（1）完整代码-16"><a href="#（1）完整代码-16" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><br>r.GET(<span class="hljs-string">&quot;/JSONP&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>data := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 获取 callback 参数值</span><br>callback := c.Query(<span class="hljs-string">&quot;callback&quot;</span>)<br><br><span class="hljs-comment">// 使用 JSONP 格式返回数据</span><br>c.JSONP(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;callback&quot;</span>: callback,<br><span class="hljs-string">&quot;data&quot;</span>:     data,<br>&#125;)<br>&#125;)<br><br><span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-15"><a href="#（2）知识点-15" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>c.Query(&quot;callback&quot;)</code>: <code>c.Query</code> 方法用于获取 HTTP 请求中的查询参数。这里使用 <code>c.Query(&quot;callback&quot;)</code> 获取了名为 “callback” 的查询参数的值</li><li><code>c.JSONP(http.StatusOK, gin.H&#123;...&#125;)</code>: <code>c.JSONP</code> 方法用于将 JSON 数据以 JSONP 格式返回给客户端。<code>http.StatusOK</code> 表示 HTTP 响应状态码为 200，<code>gin.H&#123;...&#125;</code> 表示要返回的 JSON 数据。这里返回了一个包含 “callback” 和 “data” 两个字段的 JSON 数据，其中 “callback” 字段的值为上一步获取的查询参数 “callback” 的值，”data” 字段的值为一个包含 “foo” 字段的 map 数据。</li></ul></blockquote><h2 id="19、Multipart-x2F-Urlencoded-绑定"><a href="#19、Multipart-x2F-Urlencoded-绑定" class="headerlink" title="19、Multipart&#x2F;Urlencoded 绑定"></a>19、Multipart&#x2F;Urlencoded 绑定</h2><h4 id="（1）完整代码-17"><a href="#（1）完整代码-17" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> LoginForm <span class="hljs-keyword">struct</span> &#123;<br>User     <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;user&quot; binding:&quot;required&quot;`</span>     <span class="hljs-comment">// 表单字段 user，使用 binding:&quot;required&quot; 标签表示必填</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;password&quot; binding:&quot;required&quot;`</span> <span class="hljs-comment">// 表单字段 password，使用 binding:&quot;required&quot; 标签表示必填</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br>router.POST(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 使用 c.ShouldBind 方法将请求数据绑定到 LoginForm 结构体</span><br><span class="hljs-keyword">var</span> form LoginForm<br><span class="hljs-keyword">if</span> c.ShouldBind(&amp;form) == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果绑定成功</span><br><span class="hljs-keyword">if</span> form.User == <span class="hljs-string">&quot;user&quot;</span> &amp;&amp; form.Password == <span class="hljs-string">&quot;password&quot;</span> &#123; <span class="hljs-comment">// 判断用户名和密码是否正确</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">401</span>, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">401</span>, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;missing params&quot;</span>&#125;) <span class="hljs-comment">// 如果请求数据缺少必填字段，则返回错误状态</span><br>&#125;<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-16"><a href="#（2）知识点-16" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>type LoginForm struct &#123; ... &#125;</code>: <code>LoginForm</code> 是一个自定义的结构体类型，用于表示登录表单的数据结构。结构体中包含了两个字段：<code>User</code> 和 <code>Password</code>，分别对应表单中的 “user” 和 “password” 字段。</li><li><code>router.POST(&quot;/login&quot;, func(c *gin.Context) &#123; ... &#125;)</code>: <code>router.POST</code> 方法注册了一个 HTTP POST 方法的路由，路由路径为 “&#x2F;login”。当客户端发送 HTTP POST 请求到 “&#x2F;login” 路径时，Gin 会调用传入的匿名函数作为该路由的处理函数。</li><li><code>c.ShouldBind(&amp;form)</code>: <code>c.ShouldBind</code> 方法用于将 HTTP 请求中的数据绑定到指定的结构体对象。这里使用 <code>c.ShouldBind(&amp;form)</code> 将请求数据绑定到 <code>form</code> 变量，该变量是上一步定义的 <code>LoginForm</code> 结构体对象。</li><li><code>c.JSON(200, gin.H&#123;...&#125;)</code>: <code>c.JSON</code> 方法用于将 JSON 数据作为响应发送给客户端。<code>200</code> 表示 HTTP 响应状态码为 200，<code>gin.H&#123;...&#125;</code> 表示要返回的 JSON 数据。这里返回了一个包含 “status” 字段的 JSON 数据，字段的值根据登录表单的用户名和密码进行判断而定。</li><li><code>c.JSON(401, gin.H&#123;...&#125;)</code>: 同样地，<code>c.JSON</code> 方法也可以用于返回 HTTP 响应状态码为 401 的错误响应。这里通过 <code>c.JSON(401, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)</code> 和 <code>c.JSON(401, gin.H&#123;&quot;status&quot;: &quot;missing params&quot;&#125;)</code> 分别返回了未授权和缺少必填字段的错误信息。</li></ul></blockquote><h4 id="（3）示例大意-12"><a href="#（3）示例大意-12" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>定义了一个 LoginForm 结构体，用于绑定 POST 请求中的表单数据。该结构体包含了两个字段，分别是 User 和 Password，使用了 Gin 框架的表单绑定标签进行验证，要求这两个字段都是必填的。</li><li>在 main 函数中创建了一个 Gin 路由实例 router。</li><li>设置了一个 POST 路由 “&#x2F;login”，并定义了处理函数。在该处理函数中，使用 c.ShouldBind 方法将请求数据绑定到 LoginForm 结构体。</li><li>如果绑定成功，即表单数据满足要求，那么进一步判断用户名和密码是否正确，如果正确，则返回 HTTP 状态码 200 和一个 JSON 格式的成功消息；否则，返回 HTTP 状态码 401 和一个 JSON 格式的未授权消息。</li><li>如果请求数据缺少必填字段，即绑定失败，那么返回 HTTP 状态码 401 和一个 JSON 格式的缺少参数消息。</li><li>最后，通过调用 router.Run(“:8080”) 启动 HTTP 服务器并监听在端口 8080，等待客户端请求。</li></ol></blockquote><h2 id="20、表单"><a href="#20、表单" class="headerlink" title="20、表单"></a>20、表单</h2><h4 id="（1）完整代码-18"><a href="#（1）完整代码-18" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br>router.POST(<span class="hljs-string">&quot;/form_post&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>message := c.PostForm(<span class="hljs-string">&quot;message&quot;</span>) <span class="hljs-comment">// 获取表单中的 &quot;message&quot; 字段值</span><br>nick := c.DefaultPostForm(<span class="hljs-string">&quot;nick&quot;</span>, <span class="hljs-string">&quot;anonymous&quot;</span>) <span class="hljs-comment">// 获取表单中的 &quot;nick&quot; 字段值，如果为空则默认为 &quot;anonymous&quot;</span><br><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  <span class="hljs-string">&quot;posted&quot;</span>,<br><span class="hljs-string">&quot;message&quot;</span>: message,<br><span class="hljs-string">&quot;nick&quot;</span>:    nick,<br>&#125;)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8080</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）知识点-17"><a href="#（2）知识点-17" class="headerlink" title="（2）知识点"></a>（2）知识点</h4><blockquote><ul><li><code>c.PostForm(&quot;message&quot;)</code>: 使用 <code>c</code> 上下文对象的 <code>PostForm</code> 方法获取表单中名为 “message” 的字段的值。</li><li><code>c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;)</code>: 使用 <code>c</code> 上下文对象的 <code>DefaultPostForm</code> 方法获取表单中名为 “nick” 的字段的值，如果该字段为空，则返回默认值 “anonymous”。</li></ul></blockquote><h4 id="（3）示例大意-13"><a href="#（3）示例大意-13" class="headerlink" title="（3）示例大意"></a>（3）示例大意</h4><blockquote><ol><li>导入了 “github.com&#x2F;gin-gonic&#x2F;gin” 包，引入 Gin 框架的依赖。</li><li>创建了一个 Gin 路由引擎，使用了默认的中间件。</li><li>定义了一个处理 POST 请求的路由 “&#x2F;form_post”，并传入一个处理函数。</li><li>在处理函数中，使用了 c.PostForm 方法获取表单中的 “message” 字段值，并保存到变量 message 中。</li><li>使用了 c.DefaultPostForm 方法获取表单中的 “nick” 字段值，并保存到变量 nick 中，如果 “nick” 字段为空，则默认值为 “anonymous”。</li><li>使用了 c.JSON 方法返回 JSON 格式的响应，包含了三个键值对： “status”、”message” 和 “nick”。</li><li>调用 router.Run 方法启动 HTTP 服务器并监听在端口 8080，等待客户端的请求。</li></ol></blockquote><h2 id="21、只绑定-url-查询字符串"><a href="#21、只绑定-url-查询字符串" class="headerlink" title="21、只绑定 url 查询字符串"></a>21、只绑定 url 查询字符串</h2><h4 id="（1）完整代码-19"><a href="#（1）完整代码-19" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;name&quot;`</span><br>Address <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;address&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br><span class="hljs-comment">// 定义路由 &quot;/testing&quot;，并将请求交给 startPage 函数处理</span><br>router.Any(<span class="hljs-string">&quot;/testing&quot;</span>, startPage)<br><br>router.Run(<span class="hljs-string">&quot;:8085&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器并监听在端口 8085</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startPage</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> person Person<br><br><span class="hljs-comment">// 使用 ShouldBindQuery 方法将请求中的 Query String 绑定到 person 对象</span><br><span class="hljs-keyword">if</span> c.ShouldBindQuery(&amp;person) == <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;====== Only Bind By Query String ======&quot;</span>)<br>log.Println(person.Name)<br>log.Println(person.Address)<br>&#125;<br><br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Success&quot;</span>) <span class="hljs-comment">// 返回 &quot;Success&quot; 字符串作为响应</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-1"><a href="#（2）代码解释-1" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了一个路由处理函数 <code>startPage</code> 用于处理 “&#x2F;testing” 的请求，可以处理 GET、POST、PUT、DELETE 等任何请求方法。在路由处理函数中，通过 <code>c.ShouldBindQuery()</code> 方法将请求中的 Query String 绑定到 <code>person</code> 对象，其中 <code>person.Name</code> 和 <code>person.Address</code> 分别对应了请求中的 “name” 和 “address” 参数。</p><p>接着使用 <code>log.Println()</code> 方法输出绑定后的字段值到控制台。</p><p>最后，通过调用 <code>c.String()</code> 方法返回状态码 200 和 “Success” 字符串作为响应，表示处理成功。HTTP 服务器监听在端口 8085，并通过 <code>router.Run()</code> 启动。</p></blockquote><h2 id="22、路径中的参数"><a href="#22、路径中的参数" class="headerlink" title="22、路径中的参数"></a>22、路径中的参数</h2><h4 id="（1）完整代码-20"><a href="#（1）完整代码-20" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br><span class="hljs-comment">// 这个处理函数将匹配 /user/john，但不会匹配 /user/ 或 /user</span><br>router.GET(<span class="hljs-string">&quot;/user/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>c.String(http.StatusOK, <span class="hljs-string">&quot;Hello %s&quot;</span>, name)<br>&#125;)<br><br><span class="hljs-comment">// 这个处理函数将匹配 /user/john/ 和 /user/john/send</span><br><span class="hljs-comment">// 如果没有其他路由匹配 /user/john，它将重定向到 /user/john/</span><br>router.GET(<span class="hljs-string">&quot;/user/:name/*action&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>action := c.Param(<span class="hljs-string">&quot;action&quot;</span>)<br>message := name + <span class="hljs-string">&quot; is &quot;</span> + action<br>c.String(http.StatusOK, message)<br>&#125;)<br><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-2"><a href="#（2）代码解释-2" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了两个路由处理函数。第一个处理函数通过路由 “&#x2F;user&#x2F;:name” 匹配 URL 中的 “:name” 参数，并将其值绑定到变量 name 中，然后通过 <code>c.String()</code> 方法返回 “Hello %s” 字符串，其中 %s 会被 name 的值替代。</p><p>第二个处理函数通过路由 “&#x2F;user&#x2F;:name&#x2F;*action” 匹配 URL 中的 “:name” 参数和 “*action” 参数，”*action” 表示匹配 “&#x2F;user&#x2F;:name” 后面的任意路径，将其值绑定到变量 name 和 action 中，然后通过 <code>c.String()</code> 方法返回包含 name 和 action 的消息字符串。</p><p>在 Gin 框架中，路由参数可以通过 <code>:paramName</code> 的方式定义，表示在 URL 中匹配该位置的任意字符串，并将其值作为参数传递给路由处理函数。同时，Gin 还支持通配符 “*”，可以匹配任意路径片段，用于处理较为复杂的路由需求。</p></blockquote><h2 id="23、PureJSON"><a href="#23、PureJSON" class="headerlink" title="23、PureJSON"></a>23、PureJSON</h2><blockquote><p>​通常，JSON 使用 unicode 替换特殊 HTML 字符，例如 &lt; 变为 \ u003c。如果要按字面对这些字符进行编码，则可以使用 PureJSON。Go 1.6 及更低版本无法使用此功能。</p></blockquote><h4 id="（1）完整代码-21"><a href="#（1）完整代码-21" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><br><span class="hljs-comment">// 提供 unicode 实体</span><br>r.GET(<span class="hljs-string">&quot;/json&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;html&quot;</span>: <span class="hljs-string">&quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;</span>,<br>&#125;)<br>&#125;)<br><br><span class="hljs-comment">// 提供字面字符</span><br>r.GET(<span class="hljs-string">&quot;/purejson&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.PureJSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;html&quot;</span>: <span class="hljs-string">&quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;</span>,<br>&#125;)<br>&#125;)<br><br><span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-3"><a href="#（2）代码解释-3" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了三个路由处理函数。其中 <code>/json</code> 路由使用 <code>c.JSON()</code> 方法返回 JSON 格式的响应体，其中包含一个名为 “html” 的字段，值为 “<b>Hello, world!</b>“。<code>c.JSON()</code> 方法会将响应体序列化为 JSON 格式并设置相应的 Content-Type 头，使得返回的响应体在客户端以 JSON 格式展示。</p><p>而 <code>/purejson</code> 路由使用 <code>c.PureJSON()</code> 方法同样返回 JSON 格式的响应体，但不会对响应体中的特殊字符进行转义，保留原始字符。这在某些情况下可能有用，例如当需要返回包含 HTML 标签等特殊字符的响应体时。</p><p>最后，通过调用 <code>r.Run()</code> 方法在 0.0.0.0:8080 上启动 HTTP 服务器并监听请求。Gin 框架的 <code>Run()</code> 方法会自动选择可用的端口并启动服务器。</p></blockquote><h2 id="24、POST-表单中的-URL-参数"><a href="#24、POST-表单中的-URL-参数" class="headerlink" title="24、POST 表单中的 URL 参数"></a>24、POST 表单中的 URL 参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">POST /post?id=<span class="hljs-number">1234</span>&amp;page=<span class="hljs-number">1</span> HTTP/<span class="hljs-number">1.1</span><br>Content-Type: application/x-www-form-urlencoded<br><br>name=manu&amp;message=this_is_great<br></code></pre></td></tr></table></figure><h4 id="（1）完整代码-22"><a href="#（1）完整代码-22" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br>router.POST(<span class="hljs-string">&quot;/post&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><br>id := c.Query(<span class="hljs-string">&quot;id&quot;</span>)               <span class="hljs-comment">// 获取 URL 查询参数 &quot;id&quot;</span><br>page := c.DefaultQuery(<span class="hljs-string">&quot;page&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">// 获取 URL 查询参数 &quot;page&quot;，如果不存在则默认为 &quot;0&quot;</span><br>name := c.PostForm(<span class="hljs-string">&quot;name&quot;</span>)         <span class="hljs-comment">// 获取 POST 表单字段 &quot;name&quot;</span><br>message := c.PostForm(<span class="hljs-string">&quot;message&quot;</span>)   <span class="hljs-comment">// 获取 POST 表单字段 &quot;message&quot;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;id: %s; page: %s; name: %s; message: %s&quot;</span>, id, page, name, message)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-4"><a href="#（2）代码解释-4" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了一个处理 POST 请求的路由处理函数。该处理函数从请求中获取 URL 查询参数 “id” 和 “page”，以及 POST 表单字段 “name” 和 “message” 的值，并将其打印输出。</p><p>使用 <code>c.Query()</code> 方法可以获取 URL 查询参数的值，其中参数为参数名。而使用 <code>c.PostForm()</code> 方法可以获取 POST 表单字段的值，同样参数为字段名。如果 POST 表单中没有指定的字段，可以使用 <code>c.DefaultPostForm()</code> 方法设置一个默认值。</p><p>最后，通过调用 <code>router.Run()</code> 方法在 “:8080” 上启动 HTTP 服务器并监听请求。Gin 框架的 <code>Run()</code> 方法会自动选择可用的端口并启动服务器。</p></blockquote><h2 id="25、查询字符串参数"><a href="#25、查询字符串参数" class="headerlink" title="25、查询字符串参数"></a>25、查询字符串参数</h2><h4 id="（1）完整代码-23"><a href="#（1）完整代码-23" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br><span class="hljs-comment">// 使用现有的基础请求对象解析查询字符串参数。</span><br><span class="hljs-comment">// 示例 URL： /welcome?firstname=Jane&amp;lastname=Doe</span><br>router.GET(<span class="hljs-string">&quot;/welcome&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>firstname := c.DefaultQuery(<span class="hljs-string">&quot;firstname&quot;</span>, <span class="hljs-string">&quot;Guest&quot;</span>) <span class="hljs-comment">// 获取查询参数 &quot;firstname&quot;，如果不存在则默认为 &quot;Guest&quot;</span><br>lastname := c.Query(<span class="hljs-string">&quot;lastname&quot;</span>)                   <span class="hljs-comment">// 获取查询参数 &quot;lastname&quot;</span><br><br>c.String(http.StatusOK, <span class="hljs-string">&quot;Hello %s %s&quot;</span>, firstname, lastname)<br>&#125;)<br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-5"><a href="#（2）代码解释-5" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并定义了一个处理 GET 请求的路由处理函数。该处理函数从 URL 查询参数 “firstname” 和 “lastname” 的值，并将其组合成字符串后作为响应返回。</p><p>使用 <code>c.Query()</code> 方法可以获取 URL 查询参数的值，其中参数为参数名。而使用 <code>c.DefaultQuery()</code> 方法可以获取 URL 查询参数的值，并设置一个默认值，当查询参数不存在时使用。这在示例中用于获取 “firstname” 的值，并设置默认值为 “Guest”。</p><p>Gin 框架的 <code>Run()</code> 方法会自动选择可用的端口并启动 HTTP 服务器，通过调用 <code>router.Run(&quot;:8080&quot;)</code> 在 “:8080” 上启动 HTTP 服务器并监听请求。</p></blockquote><h2 id="26、重定向"><a href="#26、重定向" class="headerlink" title="26、重定向"></a>26、重定向</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    c.Redirect(http.StatusMovedPermanently, <span class="hljs-string">&quot;http://www.google.com/&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="（1）完整代码-24"><a href="#（1）完整代码-24" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    c.Request.URL.Path = <span class="hljs-string">&quot;/test2&quot;</span><br>    r.HandleContext(c)<br>&#125;)<br>r.GET(<span class="hljs-string">&quot;/test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-6"><a href="#（2）代码解释-6" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>​当访问 <code>/test</code> 时，请求的 URL 路径被修改为 <code>/test2</code>，然后再次处理请求。由于 <code>/test2</code> 路径有对应的路由处理函数，所以会返回 <code>&#123;&quot;hello&quot;: &quot;world&quot;&#125;</code> JSON 响应。</p></blockquote><h2 id="27、运行多个服务"><a href="#27、运行多个服务" class="headerlink" title="27、运行多个服务"></a>27、运行多个服务</h2><h4 id="（1）完整代码-25"><a href="#（1）完整代码-25" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;golang.org/x/sync/errgroup&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>g errgroup.Group <span class="hljs-comment">// 全局 errgroup.Group 对象，用于管理多个 Goroutine</span><br>)<br><br><span class="hljs-comment">// 创建并返回一个 Gin 实例，作为 server01 的路由处理器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">router01</span><span class="hljs-params">()</span></span> http.Handler &#123;<br>e := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 实例</span><br>e.Use(gin.Recovery()) <span class="hljs-comment">// 添加 Recovery 中间件，用于处理请求中的错误</span><br>e.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义根路径的 GET 请求处理函数</span><br>c.JSON(<br>http.StatusOK,<br>gin.H&#123;<br><span class="hljs-string">&quot;code&quot;</span>:  http.StatusOK,<br><span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;Welcome server 01&quot;</span>,<br>&#125;,<br>)<br>&#125;)<br><br><span class="hljs-keyword">return</span> e<br>&#125;<br><br><span class="hljs-comment">// 创建并返回一个 Gin 实例，作为 server02 的路由处理器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">router02</span><span class="hljs-params">()</span></span> http.Handler &#123;<br>e := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 实例</span><br>e.Use(gin.Recovery()) <span class="hljs-comment">// 添加 Recovery 中间件，用于处理请求中的错误</span><br>e.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义根路径的 GET 请求处理函数</span><br>c.JSON(<br>http.StatusOK,<br>gin.H&#123;<br><span class="hljs-string">&quot;code&quot;</span>:  http.StatusOK,<br><span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;Welcome server 02&quot;</span>,<br>&#125;,<br>)<br>&#125;)<br><br><span class="hljs-keyword">return</span> e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>server01 := &amp;http.Server&#123;<br>Addr:         <span class="hljs-string">&quot;:8080&quot;</span>,         <span class="hljs-comment">// server01 监听的地址和端口</span><br>Handler:      router01(),      <span class="hljs-comment">// server01 使用 router01 作为路由处理器</span><br>ReadTimeout:  <span class="hljs-number">5</span> * time.Second, <span class="hljs-comment">// server01 读取超时时间</span><br>WriteTimeout: <span class="hljs-number">10</span> * time.Second, <span class="hljs-comment">// server01 写入超时时间</span><br>&#125;<br><br>server02 := &amp;http.Server&#123;<br>Addr:         <span class="hljs-string">&quot;:8081&quot;</span>,         <span class="hljs-comment">// server02 监听的地址和端口</span><br>Handler:      router02(),      <span class="hljs-comment">// server02 使用 router02 作为路由处理器</span><br>ReadTimeout:  <span class="hljs-number">5</span> * time.Second, <span class="hljs-comment">// server02 读取超时时间</span><br>WriteTimeout: <span class="hljs-number">10</span> * time.Second, <span class="hljs-comment">// server02 写入超时时间</span><br>&#125;<br><br><span class="hljs-comment">// 使用 errgroup 管理多个 Goroutine，分别启动 server01 和 server02</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> server01.ListenAndServe()<br>&#125;)<br><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> server02.ListenAndServe()<br>&#125;)<br><br><span class="hljs-keyword">if</span> err := g.Wait(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 等待两个 Goroutine 结束</span><br>log.Fatal(err) <span class="hljs-comment">// 如果有错误发生，则输出错误日志</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-7"><a href="#（2）代码解释-7" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用 Gin 框架创建了两个独立的 HTTP 服务器，分别监听不同的端口。<code>router01</code> 和 <code>router02</code> 函数分别定义了两个 Gin 路由处理器，分别处理根路径的 GET 请求，并返回不同的 JSON 响应。</p><p>通过 <code>errgroup</code> 包管理两个 Goroutine，分别启动了 <code>server01</code> 和 <code>server02</code> 的监听操作。每个服务器都使用了不同的监听地址和端口，以及不同的路由处理器。</p><p>如果有错误发生，<code>errgroup.Wait()</code> 方法会等待两个 Goroutine 结束，并返回错误。如果返回的错误不为空，则使用 <code>log.Fatal()</code> 输出错误日志并终止程序运行。</p><p>这段代码的主要作用是创建并同时启动两个独立的 HTTP 服务器，它们分别监听不同的端口，并使用 Gin 框架处理路由请求。使用 <code>errgroup</code> 包可以方便地管理多个 Goroutine，并在任何一个 Goroutine 发生错误时及时捕获和处理。这种方式可以有效地提高服务器的可靠性和稳定性。</p></blockquote><h2 id="28、SecureJSON"><a href="#28、SecureJSON" class="headerlink" title="28、SecureJSON"></a>28、SecureJSON</h2><blockquote><p>使用 SecureJSON 防止 json 劫持。如果给定的结构是数组值，则默认预置 <code>&quot;while(1),&quot;</code> 到响应体。</p></blockquote><h4 id="（1）完整代码-26"><a href="#（1）完整代码-26" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()  <span class="hljs-comment">// 创建一个默认的 Gin 实例</span><br><br>    <span class="hljs-comment">// 你也可以使用自己的 SecureJSON 前缀</span><br>    <span class="hljs-comment">// r.SecureJsonPrefix(&quot;)]&#125;&#x27;,\n&quot;)</span><br><br>    r.GET(<span class="hljs-string">&quot;/someJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;  <span class="hljs-comment">// 注册处理路由 &quot;/someJSON&quot; 的 GET 请求的处理函数</span><br>        names := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;lena&quot;</span>, <span class="hljs-string">&quot;austin&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>&#125;  <span class="hljs-comment">// 创建一个字符串切片 names</span><br><br>        <span class="hljs-comment">// 将 names 切片作为 JSON 响应返回给客户端</span><br>        <span class="hljs-comment">// 使用 http.StatusOK 表示 HTTP 响应的状态码为 200 OK</span><br>        <span class="hljs-comment">// 并在返回的 JSON 数据前加上安全前缀，防止 JSON 劫持攻击</span><br>        c.SecureJSON(http.StatusOK, names)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-8"><a href="#（2）代码解释-8" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用 Gin 框架创建一个 HTTP 服务器，并定义了一个路由处理函数。代码的主要逻辑如下：</p><ol><li>使用 <code>gin.Default()</code> 创建一个默认的 Gin 实例 <code>r</code>，它包含了一些常用的中间件，如日志、恢复等。</li><li>注册一个处理路由 <code>/someJSON</code> 的 GET 请求的处理函数。该处理函数接收一个 <code>gin.Context</code> 对象 <code>c</code>，用于处理 HTTP 请求和构建 HTTP 响应。</li><li>在处理函数中，创建一个字符串切片 <code>names</code>，包含了三个字符串元素。</li><li>使用 <code>c.SecureJSON(http.StatusOK, names)</code> 将 <code>names</code> 切片作为 JSON 响应返回给客户端。这里使用了 <code>http.StatusOK</code> 表示 HTTP 响应的状态码为 200 OK，并且在返回的 JSON 数据前加上了安全前缀，防止 JSON 劫持攻击。</li><li>调用 <code>r.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在 0.0.0.0:8080 地址上。</li></ol><p>这段代码的功能是创建一个简单的 HTTP 服务器，当客户端通过 <code>/someJSON</code> 路径发送 GET 请求时，返回一个包含三个字符串元素的 JSON 数组作为响应。服务器监听在 0.0.0.0:8080 地址上，并使用 Gin 框架处理路由和构建 HTTP 响应。</p></blockquote><h2 id="29、从-reader-读取数据"><a href="#29、从-reader-读取数据" class="headerlink" title="29、从 reader 读取数据"></a>29、从 reader 读取数据</h2><h4 id="（1）完整代码-27"><a href="#（1）完整代码-27" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个默认的 Gin 路由引擎</span><br>router := gin.Default()<br><br><span class="hljs-comment">// 定义处理路由 /someDataFromReader 的 GET 请求的处理函数</span><br>router.GET(<span class="hljs-string">&quot;/someDataFromReader&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 发起 HTTP GET 请求获取远程文件</span><br>response, err := http.Get(<span class="hljs-string">&quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> || response.StatusCode != http.StatusOK &#123;<br><span class="hljs-comment">// 如果请求出错或者响应状态码不是 200 OK，则返回 503 Service Unavailable 状态码</span><br>c.Status(http.StatusServiceUnavailable)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 获取响应的 Body、ContentLength 和 ContentType</span><br>reader := response.Body<br>contentLength := response.ContentLength<br>contentType := response.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<br><br><span class="hljs-comment">// 构建额外的响应头</span><br>extraHeaders := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;Content-Disposition&quot;</span>: <span class="hljs-string">`attachment; filename=&quot;gopher.png&quot;`</span>,<br>&#125;<br><br><span class="hljs-comment">// 使用 c.DataFromReader 方法将文件数据作为响应返回给客户端</span><br>c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)<br>&#125;)<br><br><span class="hljs-comment">// 启动 HTTP 服务器并监听在 :8080 地址上</span><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-9"><a href="#（2）代码解释-9" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>这段代码使用了 Gin 框架创建了一个 HTTP 服务器，并注册了一个处理路由 “&#x2F;someDataFromReader” 的 GET 请求的处理函数。</p><ol><li><code>gin.Default()</code> 创建了一个默认的 Gin 路由引擎。</li><li><code>router.GET(&quot;/someDataFromReader&quot;, func(c *gin.Context) &#123; ... &#125;)</code> 定义了处理路由 “&#x2F;someDataFromReader” 的 GET 请求的处理函数。函数体中的代码会在接收到 “&#x2F;someDataFromReader” 的 GET 请求时执行。</li><li><code>http.Get(&quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&quot;)</code> 发起了一个 HTTP GET 请求，获取远程文件的内容。如果请求出错或者响应状态码不是 200 OK，会返回 503 Service Unavailable 状态码给客户端。</li><li><code>c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)</code> 使用 Gin 提供的 <code>c.DataFromReader</code> 方法将文件数据作为响应返回给客户端。<code>http.StatusOK</code> 是响应的状态码，<code>contentLength</code> 是文件的长度，<code>contentType</code> 是文件的 MIME 类型，<code>reader</code> 是文件的内容，<code>extraHeaders</code> 是一些额外的响应头，这里设置了 Content-Disposition 头，指定文件名为 “gopher.png”。</li><li><code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器并监听在 “:8080” 地址上，开始接受客户端的请求。</li></ol><p>总体来说，这段代码实现了一个简单的 HTTP 服务器，通过处理 GET 请求获取远程文件内容，并将文件数据作为响应返回给客户端，同时设置了文件的 Content-Disposition 头，指定文件名为 “gopher.png”。</p></blockquote><h2 id="30、-静态文件服务"><a href="#30、-静态文件服务" class="headerlink" title="30、 静态文件服务"></a>30、 静态文件服务</h2><h4 id="（1）完整代码-28"><a href="#（1）完整代码-28" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br>    <span class="hljs-comment">// 注册静态文件路由，将请求 &quot;/assets&quot; 的静态文件从当前目录下的 &quot;./assets&quot; 目录中返回给客户端</span><br>    router.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;./assets&quot;</span>)<br><br>    <span class="hljs-comment">// 注册基于文件系统的静态文件路由，将请求 &quot;/more_static&quot; 的静态文件从指定的文件系统路径 &quot;my_file_system&quot; 中返回给客户端</span><br>    router.StaticFS(<span class="hljs-string">&quot;/more_static&quot;</span>, http.Dir(<span class="hljs-string">&quot;my_file_system&quot;</span>))<br><br>    <span class="hljs-comment">// 注册单个文件的静态文件路由，将请求 &quot;/favicon.ico&quot; 的静态文件从当前目录下的 &quot;./resources/favicon.ico&quot; 文件返回给客户端</span><br>    router.StaticFile(<span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;./resources/favicon.ico&quot;</span>)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-10"><a href="#（2）代码解释-10" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>以上代码使用 Gin 框架创建了一个简单的静态文件服务器。通过注册静态文件路由，可以将指定目录下的静态文件返回给客户端，例如图片、CSS、JavaScript 等资源文件，以供客户端的浏览器进行访问和加载。这对于构建前端应用或者提供静态资源文件的需求非常有用。在代码中使用了不同的静态文件路由注册方式，包括 <code>router.Static()</code>、<code>router.StaticFS()</code> 和 <code>router.StaticFile()</code>，用于处理不同的静态文件请求。最后，通过调用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听地址为 “0.0.0.0:8080”，并开始接收并处理客户端的请求。</p></blockquote><h2 id="31、-设置和获取-Cookie"><a href="#31、-设置和获取-Cookie" class="headerlink" title="31、 设置和获取 Cookie"></a>31、 设置和获取 Cookie</h2><h4 id="（1）完整代码-29"><a href="#（1）完整代码-29" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br>router.GET(<span class="hljs-string">&quot;/cookie&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 注册 &quot;/cookie&quot; 路由的 GET 方法处理函数</span><br>cookie, err := c.Cookie(<span class="hljs-string">&quot;gin_cookie&quot;</span>) <span class="hljs-comment">// 获取名为 &quot;gin_cookie&quot; 的 Cookie</span><br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果获取 Cookie 发生错误，则设置一个默认值</span><br>cookie = <span class="hljs-string">&quot;NotSet&quot;</span><br>c.SetCookie(<span class="hljs-string">&quot;gin_cookie&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">3600</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 设置名为 &quot;gin_cookie&quot; 的 Cookie 值为 &quot;test&quot;，过期时间为 3600 秒，路径为 &quot;/&quot;，域名为 &quot;localhost&quot;，不限制 HTTPS 连接，允许 JS 访问</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Cookie value: %s \n&quot;</span>, cookie) <span class="hljs-comment">// 在控制台打印 Cookie 的值</span><br>&#125;)<br><br>router.Run() <span class="hljs-comment">// 启动 HTTP 服务器，开始接收并处理客户端的请求</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-11"><a href="#（2）代码解释-11" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>​以上代码使用 Gin 框架创建了一个简单的 HTTP 服务器，并注册了一个 “&#x2F;cookie” 路由的 GET 方法处理函数。在处理函数中，通过 <code>c.Cookie(&quot;gin_cookie&quot;)</code> 获取名为 “gin_cookie” 的 Cookie 值，并在控制台打印出来。如果获取 Cookie 发生错误（例如不存在），则设置一个默认值，并通过 <code>c.SetCookie()</code> 方法设置名为 “gin_cookie” 的 Cookie 值为 “test”，过期时间为 3600 秒，路径为 “&#x2F;“，域名为 “localhost”，不限制 HTTPS 连接，允许 JS 访问。最后，通过调用 <code>router.Run()</code> 启动 HTTP 服务器，监听默认的地址和端口（0.0.0.0:8080），并开始接收并处理客户端的请求。</p></blockquote><h2 id="32、支持-Let’s-Encrypt"><a href="#32、支持-Let’s-Encrypt" class="headerlink" title="32、支持 Let’s Encrypt"></a>32、支持 Let’s Encrypt</h2><h4 id="（1）完整代码-30"><a href="#（1）完整代码-30" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>一行代码支持 LetsEncrypt HTTPS servers 示例。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/autotls&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br><span class="hljs-comment">// 注册 &quot;/ping&quot; 路由的 GET 方法处理函数</span><br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 使用 Autotls 启动 HTTP 服务器并监听域名 &quot;example1.com&quot; 和 &quot;example2.com&quot;</span><br>log.Fatal(autotls.Run(r, <span class="hljs-string">&quot;example1.com&quot;</span>, <span class="hljs-string">&quot;example2.com&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>自定义 autocert manager 示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/autotls&quot;</span><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;golang.org/x/crypto/acme/autocert&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">// 创建一个 Gin 路由引擎实例</span><br><br><span class="hljs-comment">// 注册 &quot;/ping&quot; 路由的 GET 方法处理函数</span><br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 创建一个 Autocert 管理器，用于配置 Let&#x27;s Encrypt 自动证书管理</span><br>m := autocert.Manager&#123;<br>Prompt:     autocert.AcceptTOS,                    <span class="hljs-comment">// 接受服务条款</span><br>HostPolicy: autocert.HostWhitelist(<span class="hljs-string">&quot;example1.com&quot;</span>, <span class="hljs-string">&quot;example2.com&quot;</span>), <span class="hljs-comment">// 允许的域名白名单</span><br>Cache:      autocert.DirCache(<span class="hljs-string">&quot;/var/www/.cache&quot;</span>),   <span class="hljs-comment">// 证书缓存目录</span><br>&#125;<br><br><span class="hljs-comment">// 使用 Autotls 启动 HTTP 服务器并监听域名 &quot;example1.com&quot; 和 &quot;example2.com&quot;，并配置自动证书管理器</span><br>log.Fatal(autotls.RunWithManager(r, &amp;m))<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="（2）代码解释-12"><a href="#（2）代码解释-12" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>以上代码使用 Gin 框架创建了一个简单的 HTTP 服务器，并注册了一个 “&#x2F;ping” 路由的 GET 方法处理函数，用于处理 “&#x2F;ping” 路径的请求，并返回 “pong” 字符串。然后，通过调用 <code>autotls.Run()</code> 方法使用 Autotls 启动 HTTP 服务器并监听域名 “example1.com” 和 “example2.com”，这将自动为这两个域名配置 HTTPS，并使用 Let’s Encrypt 证书进行 TLS 加密。如果启动服务器出现错误，会通过 <code>log.Fatal()</code> 方法记录并输出错误信息，并终止程序的运行。</p></blockquote><blockquote><p>以上代码使用 Gin 框架创建了一个简单的 HTTP 服务器，并注册了一个 “&#x2F;ping” 路由的 GET 方法处理函数，用于处理 “&#x2F;ping” 路径的请求，并返回 “pong” 字符串。然后，通过创建一个 Autocert 管理器来配置 Let’s Encrypt 自动证书管理，包括接受服务条款、允许的域名白名单和证书缓存目录等参数。最后，通过调用 <code>autotls.RunWithManager()</code> 方法使用 Autotls 启动 HTTP 服务器并监听域名 “example1.com” 和 “example2.com”，并配置自动证书管理器。如果启动服务器出现错误，会通过 <code>log.Fatal()</code> 方法记录并输出错误信息，并终止程序的运行。</p></blockquote><h2 id="33、将-request-body-绑定到不同的结构体中"><a href="#33、将-request-body-绑定到不同的结构体中" class="headerlink" title="33、将 request body 绑定到不同的结构体中"></a>33、将 request body 绑定到不同的结构体中</h2><h4 id="（1）完整代码-31"><a href="#（1）完整代码-31" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><blockquote><p>一般通过调用 <code>c.Request.Body</code> 方法绑定数据，但不能多次调用这个方法。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> formA <span class="hljs-keyword">struct</span> &#123;<br>Foo <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;foo&quot; xml:&quot;foo&quot; binding:&quot;required&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> formB <span class="hljs-keyword">struct</span> &#123;<br>Bar <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;bar&quot; xml:&quot;bar&quot; binding:&quot;required&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SomeHandler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>objA := formA&#123;&#125;<br>objB := formB&#123;&#125;<br><br><span class="hljs-comment">// 尝试使用 c.ShouldBind() 方法将请求体绑定到 formA 结构体对象</span><br><span class="hljs-keyword">if</span> errA := c.ShouldBind(&amp;objA); errA == <span class="hljs-literal">nil</span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">`the body should be formA`</span>)<br><span class="hljs-comment">// 如果绑定失败，则尝试将请求体绑定到 formB 结构体对象</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> errB := c.ShouldBind(&amp;objB); errB == <span class="hljs-literal">nil</span> &#123;<br>c.String(http.StatusOK, <span class="hljs-string">`the body should be formB`</span>)<br><span class="hljs-comment">// 如果两次绑定都失败，则执行其他逻辑</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-13"><a href="#（2）代码解释-13" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>以上代码是一个使用 Gin 框架的 HTTP 请求处理函数 SomeHandler，它通过两次调用 c.ShouldBind() 方法尝试将请求体绑定到两个不同的结构体对象 formA 和 formB。首先尝试将请求体绑定到 formA 对象，如果绑定成功，则返回一个字符串 “the body should be formA”。如果绑定失败，则尝试将请求体绑定到 formB 对象，如果绑定成功，则返回一个字符串 “the body should be formB”。如果两次绑定都失败，则执行其他逻辑。需要注意的是，c.ShouldBind() 方法使用了 c.Request.Body，一旦读取，请求体将变为 EOF，无法再次使用，因此在使用该方法时需要注意不可重用的特性。</p></blockquote><h2 id="34、-单文件上传"><a href="#34、-单文件上传" class="headerlink" title="34、 单文件上传"></a>34、 单文件上传</h2><h4 id="（1）完整代码-32"><a href="#（1）完整代码-32" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span><br>    <span class="hljs-comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span><br><br>    <span class="hljs-comment">// 定义上传文件的接口路由为 &quot;/upload&quot;，使用 POST 方法</span><br>    router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 获取上传的文件对象</span><br>        file, _ := c.FormFile(<span class="hljs-string">&quot;file&quot;</span>) <span class="hljs-comment">// 通过 c.FormFile() 方法获取上传的文件，&quot;file&quot; 是上传文件的字段名</span><br>        log.Println(file.Filename) <span class="hljs-comment">// 打印上传文件的文件名</span><br><br>        <span class="hljs-comment">// 上传文件至指定目录</span><br>        <span class="hljs-comment">// c.SaveUploadedFile(file, dst) // 使用 c.SaveUploadedFile() 方法将文件保存到指定的目录</span><br><br>        c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename)) <span class="hljs-comment">// 返回上传成功的信息</span><br>    &#125;)<br><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 Gin 服务器，监听在 8080 端口</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-14"><a href="#（2）代码解释-14" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>首先，创建了一个默认的 Gin 路由引擎 <code>router := gin.Default()</code>。</li><li>设置了一个上传文件的接口路由为 “&#x2F;upload”，并使用 POST 方法处理文件上传请求：<code>router.POST(&quot;/upload&quot;, func(c *gin.Context) &#123;...&#125;)</code>。这里使用了匿名函数作为路由处理函数，接收一个 <code>c *gin.Context</code> 参数，用于处理 HTTP 请求和响应。</li><li>在路由处理函数中，通过 <code>c.FormFile(&quot;file&quot;)</code> 获取上传的文件对象。<code>c.FormFile</code> 方法是 Gin 框架提供的用于获取上传文件的方法，其中 “file” 是上传文件的字段名。如果没有找到对应的文件字段，会返回错误。</li><li>使用 <code>log.Println(file.Filename)</code> 打印上传文件的文件名。这里只是简单地将文件名打印到控制台，实际应用中可能需要根据需求进行文件名的处理。</li><li>可以通过 <code>c.SaveUploadedFile(file, dst)</code> 将文件保存到指定目录。其中 <code>file</code> 是上传的文件对象，<code>dst</code> 是目标保存路径。在实际应用中，需要根据需求设置合适的目标保存路径，并处理文件名重复等情况。</li><li>使用 <code>c.String(http.StatusOK, fmt.Sprintf(&quot;&#39;%s&#39; uploaded!&quot;, file.Filename))</code> 返回上传成功的信息。这里使用了 Gin 框架提供的 <code>c.String</code> 方法，设置 HTTP 响应状态码为 200，返回一个字符串作为响应体，其中包含上传文件的文件名。</li><li>最后，通过 <code>router.Run(&quot;:8080&quot;)</code> 启动 Gin 服务器，监听在 8080 端口，等待接收文件上传请求。</li></ol></blockquote><h2 id="35、-多文件上传"><a href="#35、-多文件上传" class="headerlink" title="35、 多文件上传"></a>35、 多文件上传</h2><h4 id="（1）完整代码-33"><a href="#（1）完整代码-33" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建默认的 Gin 路由引擎</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span><br>    <span class="hljs-comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span><br><br>    <span class="hljs-comment">// 设置文件上传的接口路由为 &quot;/upload&quot;，使用 POST 方法处理文件上传请求</span><br>    router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 获取上传的 multipart form 数据</span><br>        form, _ := c.MultipartForm()<br><br>        <span class="hljs-comment">// 获取上传的文件对象列表</span><br>        files := form.File[<span class="hljs-string">&quot;upload[]&quot;</span>]<br><br>        <span class="hljs-comment">// 遍历文件对象列表</span><br>        <span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>            log.Println(file.Filename)<br>            <span class="hljs-comment">// 这里可以根据需求处理文件，比如保存文件到指定目录、处理文件名重复等情况</span><br>            <span class="hljs-comment">// c.SaveUploadedFile(file, dst)</span><br>        &#125;<br><br>        <span class="hljs-comment">// 返回上传成功的信息，包含上传的文件数量</span><br>        c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;%d files uploaded!&quot;</span>, <span class="hljs-built_in">len</span>(files)))<br>    &#125;)<br><br>    <span class="hljs-comment">// 启动 Gin 服务器，监听在 8080 端口，等待接收文件上传请求</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-15"><a href="#（2）代码解释-15" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>创建 Gin 路由引擎：通过 <code>gin.Default()</code> 创建了一个默认的 Gin 路由引擎，用于处理 HTTP 请求。</li><li>设置文件上传接口：使用 <code>router.POST(&quot;/upload&quot;, ...)</code> 将文件上传接口设置为 “&#x2F;upload”，并指定 HTTP 方法为 POST。这意味着该接口将处理客户端发送的 POST 请求。</li><li>获取上传的 multipart form 数据：在接口的处理函数中，使用 <code>c.MultipartForm()</code> 方法获取上传的 multipart form 数据，其中 <code>c</code> 是 <code>*gin.Context</code> 类型的请求上下文对象。</li><li>获取上传的文件对象列表：从 <code>multipart.Form</code> 结构体中的 <code>File</code> 字段获取上传的文件对象列表。这里使用了 “upload[]” 作为文件字段的名称，表示可以上传多个文件，且字段名为 “upload[]”。</li><li>处理上传的文件：通过遍历文件对象列表，可以对每个文件进行处理，例如获取文件名、保存文件到指定目录、处理文件名重复等。这里的处理逻辑通过注释进行了简单说明，实际应用中需要根据需求进行具体处理。</li><li>返回上传成功的信息：通过 <code>c.String()</code> 方法返回上传成功的信息，包含上传的文件数量。</li><li>启动 HTTP 服务器：使用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在 8080 端口，等待接收文件上传请求。</li></ol><p>需要注意的是，这段代码还有一部分注释掉的代码，包括了设置 <code>router.MaxMultipartMemory</code> 限制内存大小的功能。可以根据实际需求取消注释并设置合适的内存限制。同时，这段代码还没有处理文件上传过程中可能出现的错误情况，如文件大小限制、文件类型限制等，需要根据具体需求进行完善。</p></blockquote><h2 id="36、-使用-BasicAuth-中间件"><a href="#36、-使用-BasicAuth-中间件" class="headerlink" title="36、  使用 BasicAuth 中间件"></a>36、  使用 BasicAuth 中间件</h2><h4 id="（1）完整代码-34"><a href="#（1）完整代码-34" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 模拟一些私人数据</span><br><span class="hljs-keyword">var</span> secrets = gin.H&#123;<br>    <span class="hljs-string">&quot;foo&quot;</span>:    gin.H&#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;foo@bar.com&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;123433&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;austin&quot;</span>: gin.H&#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;austin@example.com&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;666&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;lena&quot;</span>:   gin.H&#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;lena@guapa.com&quot;</span>, <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;523443&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default()<br><br>    <span class="hljs-comment">// 路由组使用 gin.BasicAuth() 中间件</span><br>    <span class="hljs-comment">// gin.Accounts 是 map[string]string 的一种快捷方式</span><br>    authorized := r.Group(<span class="hljs-string">&quot;/admin&quot;</span>, gin.BasicAuth(gin.Accounts&#123;<br>        <span class="hljs-string">&quot;foo&quot;</span>:    <span class="hljs-string">&quot;bar&quot;</span>,<br>        <span class="hljs-string">&quot;austin&quot;</span>: <span class="hljs-string">&quot;1234&quot;</span>,<br>        <span class="hljs-string">&quot;lena&quot;</span>:   <span class="hljs-string">&quot;hello2&quot;</span>,<br>        <span class="hljs-string">&quot;manu&quot;</span>:   <span class="hljs-string">&quot;4321&quot;</span>,<br>    &#125;))<br><br>    <span class="hljs-comment">// /admin/secrets 端点</span><br>    <span class="hljs-comment">// 触发 &quot;localhost:8080/admin/secrets</span><br>    authorized.GET(<span class="hljs-string">&quot;/secrets&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 获取用户，它是由 BasicAuth 中间件设置的</span><br>        <span class="hljs-comment">// 使用 c.MustGet() 方法获取经过 BasicAuth 中间件处理后的用户信息</span><br>        user := c.MustGet(gin.AuthUserKey).(<span class="hljs-type">string</span>)<br>        <span class="hljs-keyword">if</span> secret, ok := secrets[user]; ok &#123;<br>            <span class="hljs-comment">// 根据用户信息获取对应的私人数据</span><br>            c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;user&quot;</span>: user, <span class="hljs-string">&quot;secret&quot;</span>: secret&#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果用户信息不存在于私人数据中，返回默认的信息</span><br>            c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;user&quot;</span>: user, <span class="hljs-string">&quot;secret&quot;</span>: <span class="hljs-string">&quot;NO SECRET :(&quot;</span>&#125;)<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-16"><a href="#（2）代码解释-16" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>定义了一个 <code>secrets</code> 变量，模拟了一些私人数据，使用了 <code>gin.H</code> 来表示 key-value 结构的 map。</li><li>创建了一个默认的 Gin 路由引擎 <code>r</code>。</li><li>使用 <code>r.Group()</code> 方法创建了一个路由组 <code>/admin</code>，并在该路由组上应用了 <code>gin.BasicAuth()</code> 中间件。<code>gin.BasicAuth()</code> 中间件用于进行 HTTP 基本身份验证，需要传入一个 <code>gin.Accounts</code> 类型的参数，其中包含了允许访问的用户名和密码的键值对。</li><li>在路由组中定义了一个 GET 请求的处理函数，处理 <code>/admin/secrets</code> 路径的请求。在该处理函数中，使用 <code>c.MustGet()</code> 方法获取经过 <code>gin.BasicAuth()</code> 中间件处理后的用户信息，其中 <code>gin.AuthUserKey</code> 是 Gin 框架中用于存储经过认证的用户信息的上下文键名。</li><li>根据用户信息从 <code>secrets</code> 变量中获取对应的私人数据，如果存在则返回用户信息和私人数据，否则返回默认的信息。</li><li>使用 <code>r.Run()</code> 方法启动 HTTP 服务器，监听在 0.0.0.0:8080 地址上。</li></ol></blockquote><h2 id="37、-使用-HTTP-方法"><a href="#37、-使用-HTTP-方法" class="headerlink" title="37、   使用 HTTP 方法"></a>37、   使用 HTTP 方法</h2><h4 id="（1）完整代码-35"><a href="#（1）完整代码-35" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 禁用控制台颜色</span><br>    <span class="hljs-comment">// gin.DisableConsoleColor()</span><br><br>    <span class="hljs-comment">// 使用默认中间件（logger 和 recovery 中间件）创建 gin 路由</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 注册不同的 HTTP 方法对应的处理函数</span><br>    router.GET(<span class="hljs-string">&quot;/someGet&quot;</span>, getting)       <span class="hljs-comment">// 处理 HTTP GET 请求</span><br>    router.POST(<span class="hljs-string">&quot;/somePost&quot;</span>, posting)     <span class="hljs-comment">// 处理 HTTP POST 请求</span><br>    router.PUT(<span class="hljs-string">&quot;/somePut&quot;</span>, putting)       <span class="hljs-comment">// 处理 HTTP PUT 请求</span><br>    router.DELETE(<span class="hljs-string">&quot;/someDelete&quot;</span>, deleting) <span class="hljs-comment">// 处理 HTTP DELETE 请求</span><br>    router.PATCH(<span class="hljs-string">&quot;/somePatch&quot;</span>, patching)   <span class="hljs-comment">// 处理 HTTP PATCH 请求</span><br>    router.HEAD(<span class="hljs-string">&quot;/someHead&quot;</span>, head)         <span class="hljs-comment">// 处理 HTTP HEAD 请求</span><br>    router.OPTIONS(<span class="hljs-string">&quot;/someOptions&quot;</span>, options) <span class="hljs-comment">// 处理 HTTP OPTIONS 请求</span><br><br>    <span class="hljs-comment">// 默认在 8080 端口启动服务，除非定义了一个 PORT 的环境变量。</span><br>    router.Run()<br>    <span class="hljs-comment">// router.Run(&quot;:3000&quot;) 可以硬编码指定端口号</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-17"><a href="#（2）代码解释-17" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>以上代码使用 Gin 框架创建了一个 HTTP 服务器，并注册了不同的 HTTP 方法对应的处理函数。每个处理函数在接收到对应的 HTTP 请求时会被调用，从而进行相应的处理逻辑。<code>router.Run()</code> 函数会在默认端口 8080 上启动 HTTP 服务，可以通过设置环境变量 <code>PORT</code> 来修改端口号。如果需要固定端口号，可以通过 <code>router.Run(&quot;:3000&quot;)</code> 来指定特定的端口号</li></ol></blockquote><h2 id="38、使用中间件"><a href="#38、使用中间件" class="headerlink" title="38、使用中间件"></a>38、使用中间件</h2><h4 id="（1）完整代码-36"><a href="#（1）完整代码-36" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 新建一个没有任何默认中间件的路由</span><br>    r := gin.New()<br><br>    <span class="hljs-comment">// 全局中间件</span><br>    <span class="hljs-comment">// Logger 中间件将日志写入 gin.DefaultWriter，即使你将 GIN_MODE 设置为 release。</span><br>    <span class="hljs-comment">// 默认情况下 gin.DefaultWriter = os.Stdout</span><br>    r.Use(gin.Logger())<br><br>    <span class="hljs-comment">// Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500。</span><br>    r.Use(gin.Recovery())<br><br>    <span class="hljs-comment">// 你可以为每个路由添加任意数量的中间件。</span><br>    r.GET(<span class="hljs-string">&quot;/benchmark&quot;</span>, MyBenchLogger(), benchEndpoint)<br><br>    <span class="hljs-comment">// 认证路由组</span><br>    <span class="hljs-comment">// authorized := r.Group(&quot;/&quot;, AuthRequired())</span><br>    <span class="hljs-comment">// 和使用以下两行代码的效果完全一样:</span><br>    authorized := r.Group(<span class="hljs-string">&quot;/&quot;</span>)<br>    <span class="hljs-comment">// 路由组中间件! 在此例中，我们在 &quot;authorized&quot; 路由组中使用自定义创建的 </span><br>    <span class="hljs-comment">// AuthRequired() 中间件</span><br>    authorized.Use(AuthRequired())<br>    &#123;<br>        authorized.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint)<br>        authorized.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint)<br>        authorized.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint)<br><br>        <span class="hljs-comment">// 嵌套路由组</span><br>        testing := authorized.Group(<span class="hljs-string">&quot;testing&quot;</span>)<br>        testing.GET(<span class="hljs-string">&quot;/analytics&quot;</span>, analyticsEndpoint)<br>    &#125;<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-18"><a href="#（2）代码解释-18" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>创建 Gin 路由：代码通过 <code>gin.New()</code> 函数创建了一个新的 Gin 路由实例，并赋值给变量 <code>r</code>。这个路由实例没有任何默认的中间件。</li><li>全局中间件：代码通过 <code>r.Use()</code> 函数注册了两个全局中间件，分别是 <code>gin.Logger()</code> 和 <code>gin.Recovery()</code>。<code>gin.Logger()</code> 用于记录日志，<code>gin.Recovery()</code> 用于恢复从处理函数中的 panic。</li><li>路由和处理函数：代码通过 <code>r.GET()</code>、<code>r.POST()</code> 等方法注册了多个路由，并指定了相应的处理函数。例如，<code>r.GET(&quot;/benchmark&quot;, MyBenchLogger(), benchEndpoint)</code> 注册了一个 GET 请求的路由 “&#x2F;benchmark”，并使用了自定义的中间件 <code>MyBenchLogger()</code> 和处理函数 <code>benchEndpoint()</code>。</li><li>路由组和嵌套路由组：代码通过 <code>r.Group()</code> 方法创建了一个名为 “authorized” 的路由组，并在其中注册了多个路由和处理函数。这些路由和处理函数都位于 “authorized” 路由组下，并且共享路由组中注册的中间件 <code>AuthRequired()</code>，用于认证授权。另外，代码还演示了如何在路由组内创建嵌套的路由组，例如 <code>testing := authorized.Group(&quot;testing&quot;)</code>。</li><li>启动 HTTP 服务：代码通过 <code>r.Run(&quot;:8080&quot;)</code> 启动了一个 HTTP 服务，并监听在 0.0.0.0:8080 上。这将使服务在这个地址上接受来自客户端的请求。</li></ol></blockquote><h2 id="39、-映射查询字符串或表单参数"><a href="#39、-映射查询字符串或表单参数" class="headerlink" title="39、 映射查询字符串或表单参数"></a>39、 映射查询字符串或表单参数</h2><h4 id="（1）完整代码-37"><a href="#（1）完整代码-37" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-19"><a href="#（2）代码解释-19" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote></blockquote><h2 id="40、模型绑定和验证"><a href="#40、模型绑定和验证" class="headerlink" title="40、模型绑定和验证"></a>40、模型绑定和验证</h2><h4 id="（1）完整代码-38"><a href="#（1）完整代码-38" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Login 是一个结构体，用于绑定登录请求的 JSON、XML、HTML 表单数据</span><br><span class="hljs-keyword">type</span> Login <span class="hljs-keyword">struct</span> &#123;<br>    User     <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot;  binding:&quot;required&quot;`</span> <span class="hljs-comment">// User 字段，对应请求中的 &quot;user&quot; 参数，使用 form、json、xml 格式进行绑定，并设置为必需字段</span><br>    Password <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;`</span> <span class="hljs-comment">// Password 字段，对应请求中的 &quot;password&quot; 参数，使用 form、json、xml 格式进行绑定，并设置为必需字段</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    router := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由实例</span><br><br>    <span class="hljs-comment">// 绑定 JSON 请求 (&quot;/loginJSON&quot;)</span><br>    router.POST(<span class="hljs-string">&quot;/loginJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> json Login<br>        <span class="hljs-keyword">if</span> err := c.ShouldBindJSON(&amp;json); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 使用 ShouldBindJSON 方法将请求中的 JSON 数据绑定到 Login 结构体，并检查是否出现错误</span><br>            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;) <span class="hljs-comment">// 若绑定失败，返回错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> json.User != <span class="hljs-string">&quot;manu&quot;</span> || json.Password != <span class="hljs-string">&quot;123&quot;</span> &#123; <span class="hljs-comment">// 检查登录信息是否匹配</span><br>            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;) <span class="hljs-comment">// 若登录信息不匹配，返回未授权状态码和错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;) <span class="hljs-comment">// 登录成功，返回状态码和登录成功信息到客户端</span><br>    &#125;)<br><br>    <span class="hljs-comment">// 绑定 XML 请求 (&quot;/loginXML&quot;)</span><br>    router.POST(<span class="hljs-string">&quot;/loginXML&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> xml Login<br>        <span class="hljs-keyword">if</span> err := c.ShouldBindXML(&amp;xml); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 使用 ShouldBindXML 方法将请求中的 XML 数据绑定到 Login 结构体，并检查是否出现错误</span><br>            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;) <span class="hljs-comment">// 若绑定失败，返回错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> xml.User != <span class="hljs-string">&quot;manu&quot;</span> || xml.Password != <span class="hljs-string">&quot;123&quot;</span> &#123; <span class="hljs-comment">// 检查登录信息是否匹配</span><br>            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;) <span class="hljs-comment">// 若登录信息不匹配，返回未授权状态码和错误信息到客户端</span><br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;) <span class="hljs-comment">// 登录成功，返回状态码和登录成功信息到客户端</span><br>    &#125;)<br><span class="hljs-comment">// 绑定 HTML 表单 (user=manu&amp;password=123)</span><br>    router.POST(<span class="hljs-string">&quot;/loginForm&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-keyword">var</span> form Login<br>        <span class="hljs-comment">// 根据 Content-Type Header 推断使用哪个绑定器。</span><br>        <span class="hljs-keyword">if</span> err := c.ShouldBind(&amp;form); err != <span class="hljs-literal">nil</span> &#123;<br>            c.JSON(http.StatusBadRequest, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: err.Error()&#125;)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> form.User != <span class="hljs-string">&quot;manu&quot;</span> || form.Password != <span class="hljs-string">&quot;123&quot;</span> &#123;<br>            c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;unauthorized&quot;</span>&#125;)<br>            <span class="hljs-keyword">return</span><br>        &#125; <br><br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;you are logged in&quot;</span>&#125;)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-20"><a href="#（2）代码解释-20" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>定义了一个名为 <code>Login</code> 的结构体，其中包含了 <code>User</code> 和 <code>Password</code> 两个字段，用于接收登录请求中的用户和密码信息。结构体中使用了标签（tag）来指定了字段在不同请求中的绑定方式，如 <code>form:&quot;user&quot;</code> 表示在 HTML 表单中使用 <code>user</code> 字段名进行绑定，<code>json:&quot;user&quot;</code> 表示在 JSON 中使用 <code>user</code> 字段名进行绑定，<code>xml:&quot;user&quot;</code> 表示在 XML 中使用 <code>user</code> 字段名进行绑定。</li><li>在 <code>main</code> 函数中，创建了一个默认的 Gin 路由实例，并注册了三个路由处理函数分别处理 <code>/loginJSON</code>、<code>/loginXML</code>、<code>/loginForm</code> 这三个不同的路由。</li><li><code>/loginJSON</code> 路由处理函数通过 <code>c.ShouldBindJSON(&amp;json)</code> 方法将请求体中的 JSON 数据绑定到 <code>json</code> 结构体变量中，如果绑定失败，则返回错误信息；如果绑定成功，则判断 <code>json.User</code> 和 <code>json.Password</code> 是否符合预期的值，如果不符合，则返回未授权的状态码和错误信息，否则返回登录成功的状态码和信息。</li><li><code>/loginXML</code> 路由处理函数通过 <code>c.ShouldBindXML(&amp;xml)</code> 方法将请求体中的 XML 数据绑定到 <code>xml</code> 结构体变量中，如果绑定失败，则返回错误信息；如果绑定成功，则判断 <code>xml.User</code> 和 <code>xml.Password</code> 是否符合预期的值，如果不符合，则返回未授权的状态码和错误信息，否则返回登录成功的状态码和信息。</li><li><code>/loginForm</code> 路由处理函数通过 <code>c.ShouldBind(&amp;form)</code> 方法根据请求头中的 <code>Content-Type</code> 判断请求体中的数据类型，并将数据绑定到 <code>form</code> 结构体变量中，如果绑定失败，则返回错误信息；如果绑定成功，则判断 <code>form.User</code> 和 <code>form.Password</code> 是否符合预期的值，如果不符合，则返回未授权的状态码和错误信息，否则返回登录成功的状态码和信息。</li><li>最后通过 <code>router.Run(&quot;:8080&quot;)</code> 启动了服务，监听在 <code>0.0.0.0:8080</code> 地址上。</li></ol></blockquote><h2 id="41、-路由参数"><a href="#41、-路由参数" class="headerlink" title="41、 路由参数"></a>41、 路由参数</h2><h4 id="（1）完整代码-39"><a href="#（1）完整代码-39" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个默认的 gin 路由引擎</span><br>    router := gin.Default()<br><br>    <span class="hljs-comment">// 注册一个处理器函数，处理匹配到的路由 /user/:name</span><br>    <span class="hljs-comment">// :name 表示该路由段为参数，可以匹配任何字符串，并将其作为参数传递给处理器函数</span><br>    router.GET(<span class="hljs-string">&quot;/user/:name&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 从路由参数中获取名字参数值</span><br>        name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>        <span class="hljs-comment">// 在响应中返回 &quot;Hello &#123;name&#125;&quot; 字符串</span><br>        c.String(http.StatusOK, <span class="hljs-string">&quot;Hello %s&quot;</span>, name)<br>    &#125;)<br><br>    <span class="hljs-comment">// 注册一个处理器函数，处理匹配到的路由 /user/:name/*action</span><br>    <span class="hljs-comment">// :name 和 *action 都表示参数，:name 匹配一个字符串，*action 匹配多个字符串</span><br>    <span class="hljs-comment">// 如果没有其他路由匹配 /user/:name，该处理器函数将处理该请求并进行重定向到 /user/:name/</span><br>    router.GET(<span class="hljs-string">&quot;/user/:name/*action&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 从路由参数中获取名字和动作参数值</span><br>        name := c.Param(<span class="hljs-string">&quot;name&quot;</span>)<br>        action := c.Param(<span class="hljs-string">&quot;action&quot;</span>)<br>        <span class="hljs-comment">// 根据参数值构建消息字符串</span><br>        message := name + <span class="hljs-string">&quot; is &quot;</span> + action<br>        <span class="hljs-comment">// 在响应中返回消息字符串</span><br>        c.String(http.StatusOK, message)<br>    &#125;)<br><br>    <span class="hljs-comment">// 启动 HTTP 服务器并监听在 :8080 上</span><br>    router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-21"><a href="#（2）代码解释-21" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>第一个处理器函数处理了路由 <code>/user/:name</code>。<code>:name</code> 表示该路由段为参数，可以匹配任何字符串，并将其作为参数传递给处理器函数。在处理器函数中，通过 <code>c.Param(&quot;name&quot;)</code> 获取路由参数中的 <code>name</code> 值，并使用 <code>c.String(http.StatusOK, &quot;Hello %s&quot;, name)</code> 在响应中返回 “Hello {name}” 字符串。</li><li>第二个处理器函数处理了路由 <code>/user/:name/*action</code>。<code>:name</code> 和 <code>*action</code> 都表示参数，其中 <code>:name</code> 匹配一个字符串，<code>*action</code> 匹配多个字符串。在处理器函数中，通过 <code>c.Param(&quot;name&quot;)</code> 和 <code>c.Param(&quot;action&quot;)</code> 获取路由参数中的 <code>name</code> 和 <code>action</code> 值，并根据这些参数值构建消息字符串。然后，使用 <code>c.String(http.StatusOK, message)</code> 在响应中返回该消息字符串。需要注意的是，如果没有其他路由匹配 <code>/user/:name</code>，该处理器函数将处理该请求并进行重定向到 <code>/user/:name/</code>。</li></ol><p>最后，通过调用 <code>router.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器并监听在 <code>:8080</code> 端口上。一旦服务器启动成功，它将开始监听来自客户端的 HTTP 请求，并根据注册的路由处理器函数来处理这些请求。Gin 框架提供了很多方便的方法来处理路由、请求和响应，使得构建 HTTP 服务器变得简单和高效。</p></blockquote><h2 id="42、静态资源嵌入"><a href="#42、静态资源嵌入" class="headerlink" title="42、静态资源嵌入"></a>42、静态资源嵌入</h2><h4 id="（1）完整代码-40"><a href="#（1）完整代码-40" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.New() <span class="hljs-comment">// 创建一个新的 Gin 路由实例</span><br><br>    t, err := loadTemplate() <span class="hljs-comment">// 调用 loadTemplate() 函数加载模板</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// 如果加载模板过程中出现错误，则触发 panic</span><br>    &#125;<br>    r.SetHTMLTemplate(t) <span class="hljs-comment">// 将加载好的模板设置到 Gin 路由实例的 HTML 模板中</span><br><br>    r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123; <span class="hljs-comment">// 定义路由处理函数，处理 HTTP GET 请求，路径为 &quot;/&quot;</span><br>        c.HTML(http.StatusOK, <span class="hljs-string">&quot;/html/index.tmpl&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 返回 HTML 响应，使用加载的模板渲染数据，并设置 HTTP 状态码为 200</span><br>    &#125;)<br><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动 HTTP 服务器，监听在端口 8080 上</span><br>&#125;<br><br><span class="hljs-comment">// loadTemplate 加载由 go-assets-builder 嵌入的模板</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadTemplate</span><span class="hljs-params">()</span></span> (*template.Template, <span class="hljs-type">error</span>) &#123;<br>    t := template.New(<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">// 创建一个空的模板</span><br>    <span class="hljs-keyword">for</span> name, file := <span class="hljs-keyword">range</span> Assets.Files &#123; <span class="hljs-comment">// 遍历由 go-assets-builder 嵌入的文件</span><br>        <span class="hljs-keyword">if</span> file.IsDir() || !strings.HasSuffix(name, <span class="hljs-string">&quot;.tmpl&quot;</span>) &#123;<br>            <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 如果文件是目录或者不是以 .tmpl 后缀结尾，则跳过</span><br>        &#125;<br>        h, err := ioutil.ReadAll(file) <span class="hljs-comment">// 读取文件内容</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err <span class="hljs-comment">// 如果读取文件内容过程中出现错误，则返回错误</span><br>        &#125;<br>        t, err = t.New(name).Parse(<span class="hljs-type">string</span>(h)) <span class="hljs-comment">// 将文件内容解析为模板，并将其命名为 name，与之前的模板形成模板链</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err <span class="hljs-comment">// 如果解析过程中出现错误，则返回错误</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t, <span class="hljs-literal">nil</span> <span class="hljs-comment">// 返回加载好的模板和 nil 错误，表示加载模板成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-22"><a href="#（2）代码解释-22" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><p>上述代码是一个简单的 Go 语言程序，使用了 Gin 框架和 go-assets-builder 库来创建一个 HTTP 服务器，并加载嵌入在程序中的模板文件进行渲染。下面对代码进行详细的分析：</p><ol><li><code>func main()</code> 是 Go 语言程序的入口函数，程序从这里开始执行。</li><li><code>gin.New()</code> 创建了一个新的 Gin 路由实例，用于处理 HTTP 请求和定义路由。</li><li><code>loadTemplate()</code> 函数用于加载由 go-assets-builder 嵌入的模板文件，并返回解析后的模板和可能的错误。</li><li><code>r.SetHTMLTemplate(t)</code> 将加载好的模板设置到 Gin 路由实例的 HTML 模板中，以便后续使用模板进行渲染。</li><li><code>r.GET(&quot;/&quot;, func(c *gin.Context) &#123; ... &#125;)</code> 定义了一个路由处理函数，处理根路径的 HTTP GET 请求。当用户访问根路径时，Gin 框架会调用这个处理函数来处理请求。</li><li><code>c.HTML(http.StatusOK, &quot;/html/index.tmpl&quot;, nil)</code> 在路由处理函数中调用 <code>c.HTML()</code> 方法返回一个 HTML 响应。这个方法使用加载的模板渲染数据，并设置 HTTP 状态码为 200（http.StatusOK）。</li><li><code>r.Run(&quot;:8080&quot;)</code> 启动 HTTP 服务器，监听在 8080 端口上，开始接收和处理 HTTP 请求。</li><li><code>loadTemplate()</code> 函数遍历由 go-assets-builder 嵌入的文件，读取文件内容并解析为模板，并将其命名为文件名，形成一个模板链。最终返回加载好的模板和可能的错误。</li></ol><p>总的来说，这段代码通过 Gin 框架创建了一个简单的 HTTP 服务器，加载了由 go-assets-builder 嵌入的模板文件，用于渲染 HTML 响应。这种方式可以将模板文件嵌入到 Go 语言程序中，方便部署和分发，同时避免了外部文件的依赖和管理。</p></blockquote><h2 id="43、不使用默认的中间件"><a href="#43、不使用默认的中间件" class="headerlink" title="43、不使用默认的中间件"></a>43、不使用默认的中间件</h2><h4 id="（1）完整代码-41"><a href="#（1）完整代码-41" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.New()<br>代替<br><span class="hljs-comment">// Default 使用 Logger 和 Recovery 中间件</span><br>r := gin.Default()<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-23"><a href="#（2）代码解释-23" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><h2 id="44、-XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染"><a href="#44、-XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染" class="headerlink" title="44、 XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染"></a>44、 XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染</h2><h4 id="（1）完整代码-42"><a href="#（1）完整代码-42" class="headerlink" title="（1）完整代码"></a>（1）完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := gin.Default() <span class="hljs-comment">// 创建一个默认的 Gin 路由实例</span><br><br>    r.GET(<span class="hljs-string">&quot;/someJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.JSON(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;hey&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: http.StatusOK&#125;)<br>        <span class="hljs-comment">// 处理 &quot;/someJSON&quot; 路由的 GET 请求，返回一个 JSON 响应</span><br>        <span class="hljs-comment">// 使用 gin.H 快捷方式创建一个 map[string]interface&#123;&#125; 类型的数据作为 JSON 数据</span><br>        <span class="hljs-comment">// JSON 数据包含 &quot;message&quot; 和 &quot;status&quot; 两个字段，值分别为 &quot;hey&quot; 和 http.StatusOK</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/moreJSON&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 可以使用结构体来定义 JSON 数据</span><br>        <span class="hljs-keyword">var</span> msg <span class="hljs-keyword">struct</span> &#123;<br>            Name    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;user&quot;`</span> <span class="hljs-comment">// 可以使用 `json:&quot;...&quot;` 标签定义 JSON 字段名</span><br>            Message <span class="hljs-type">string</span><br>            Number  <span class="hljs-type">int</span><br>        &#125;<br>        msg.Name = <span class="hljs-string">&quot;Lena&quot;</span><br>        msg.Message = <span class="hljs-string">&quot;hey&quot;</span><br>        msg.Number = <span class="hljs-number">123</span><br>        <span class="hljs-comment">// 定义一个结构体变量 msg，设置其字段的值</span><br>        <span class="hljs-comment">// 注意 msg.Name 在 JSON 中变成了 &quot;user&quot;</span><br>        <span class="hljs-comment">// 将输出：&#123;&quot;user&quot;: &quot;Lena&quot;, &quot;Message&quot;: &quot;hey&quot;, &quot;Number&quot;: 123&#125;</span><br>        c.JSON(http.StatusOK, msg)<br>        <span class="hljs-comment">// 处理 &quot;/moreJSON&quot; 路由的 GET 请求，返回一个 JSON 响应</span><br>        <span class="hljs-comment">// 使用结构体变量 msg 作为 JSON 数据</span><br>        <span class="hljs-comment">// JSON 数据包含三个字段，分别为 &quot;user&quot;、&quot;Message&quot; 和 &quot;Number&quot;，对应结构体的字段值</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/someXML&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.XML(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;hey&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: http.StatusOK&#125;)<br>        <span class="hljs-comment">// 处理 &quot;/someXML&quot; 路由的 GET 请求，返回一个 XML 响应</span><br>        <span class="hljs-comment">// 使用 gin.H 快捷方式创建一个 map[string]interface&#123;&#125; 类型的数据作为 XML 数据</span><br>        <span class="hljs-comment">// XML 数据包含 &quot;message&quot; 和 &quot;status&quot; 两个字段，值分别为 &quot;hey&quot; 和 http.StatusOK</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/someYAML&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.YAML(http.StatusOK, gin.H&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;hey&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: http.StatusOK&#125;)<br>        <span class="hljs-comment">// 处理 &quot;/someYAML&quot; 路由的 GET 请求，返回一个 YAML 响应</span><br>        <span class="hljs-comment">// 使用 gin.H 快捷方式创建一个 map[string]interface&#123;&#125; 类型的数据作为 YAML 数据</span><br>        <span class="hljs-comment">// YAML 数据包含 &quot;message&quot; 和 &quot;status&quot; 两个字段，值分别为 &quot;hey&quot; 和 http.StatusOK</span><br>        <span class="hljs-comment">// HTTP 状态码设置为 http.StatusOK</span><br>    &#125;)<br><br>    r.GET(<span class="hljs-string">&quot;/someProtoBuf&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        reps := []<span class="hljs-type">int64</span>&#123;<span class="hljs-type">int64</span>(<span class="hljs-number">1</span>), <span class="hljs-type">int64</span>(<span class="hljs-number">2</span>)&#125;<br>        label := <span class="hljs-string">&quot;test&quot;</span><br>        <span class="hljs-comment">// 定义一个切片 reps 和一个字符串 label</span><br>        <span class="hljs-comment">// 用于创建一个 protoexample.Test 结构体变量 data</span><br><br>        data := &amp;protoexample.Test&#123;<br>            Label: &amp;label,<br>            Reps:  reps,<br>        &#125;<br>        <span class="hljs-comment">// 请注意，数据在响应中变为二进制数据</span><br>        <span class="hljs-comment">// 将输出被 protoexample.Test protobuf 序列化了的数据</span><br>        c.ProtoBuf(http.StatusOK, data)<br>    &#125;)<br><br>    <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>    r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）代码解释-24"><a href="#（2）代码解释-24" class="headerlink" title="（2）代码解释"></a>（2）代码解释</h4><blockquote><ol><li>导入了 Gin 框架和 net&#x2F;http 包，以及一个自定义的 Protocol Buffers 文件包 protoexample。</li><li>创建了一个 Gin 的默认引擎实例 r，用于处理 HTTP 请求。</li><li>定义了路由处理函数，通过 r.GET() 方法将路由路径和处理函数绑定起来。</li><li>第一个路由处理函数处理 “&#x2F;someJSON” 路径的 GET 请求，返回一个 JSON 格式的响应，其中包含一个 “message” 字段和一个 “status” 字段，值分别为 “hey” 和 http.StatusOK。</li><li>第二个路由处理函数处理 “&#x2F;moreJSON” 路径的 GET 请求，返回一个 JSON 格式的响应，其中包含一个结构体 msg，结构体有三个字段，分别为 “Name”、”Message” 和 “Number”，通过结构体字面量赋值后作为响应的内容。</li><li>第三个路由处理函数处理 “&#x2F;someXML” 路径的 GET 请求，返回一个 XML 格式的响应，其中包含一个 “message” 字段和一个 “status” 字段，值分别为 “hey” 和 http.StatusOK。</li><li>第四个路由处理函数处理 “&#x2F;someYAML” 路径的 GET 请求，返回一个 YAML 格式的响应，其中包含一个 “message” 字段和一个 “status” 字段，值分别为 “hey” 和 http.StatusOK。</li><li>第五个路由处理函数处理 “&#x2F;someProtoBuf” 路径的 GET 请求，返回一个 Protocol Buffers 格式的响应，其中包含一个自定义的 Test 结构体，结构体有两个字段，分别为 “Label” 和 “Reps”，通过结构体字面量赋值后作为响应的内容。</li><li>最后通过 r.Run() 方法启动 HTTP 服务器，在地址 0.0.0.0:8080 上监听请求。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的HTTP网络编程</title>
      <link href="/2023/04/11/Go/go%E7%9A%84HTTP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/11/Go/go%E7%9A%84HTTP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="go的HTTP网络编程"><a href="#go的HTTP网络编程" class="headerlink" title="go的HTTP网络编程"></a>go的HTTP网络编程<span id="more"></span></h1><h2 id="1、http编程–server示例"><a href="#1、http编程–server示例" class="headerlink" title="1、http编程–server示例"></a>1、http编程–server示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 注册处理函数，定义 URL 路由和对应的处理函数</span><br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, Hello)         <span class="hljs-comment">// 根路径 &quot;/&quot; 的请求交给 Hello 函数处理</span><br>http.HandleFunc(<span class="hljs-string">&quot;/login&quot;</span>, Login)   <span class="hljs-comment">// &quot;/login&quot; 路径的请求交给 Login 函数处理</span><br><br><span class="hljs-comment">// 启动 HTTP 服务器，监听指定的地址和端口</span><br>err := http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, <span class="hljs-literal">nil</span>)   <span class="hljs-comment">// 启动服务器，监听地址 &quot;0.0.0.0:8080&quot;，使用默认的路由器和处理器</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;HTTP 服务器启动失败&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Hello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 处理根路径 &quot;/&quot; 的请求</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World!&quot;</span>)   <span class="hljs-comment">// 将 &quot;Hello, World!&quot; 写入 http.ResponseWriter，作为 HTTP 响应的内容</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Login</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 处理 &quot;/login&quot; 路径的请求</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;Login page&quot;</span>)   <span class="hljs-comment">// 将 &quot;Login page&quot; 写入 http.ResponseWriter，作为 HTTP 响应的内容</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="示例说明："><a href="#示例说明：" class="headerlink" title="示例说明："></a>示例说明：</h3><blockquote><ul><li><code>http.HandleFunc(&quot;/&quot;, Hello)</code>：注册处理函数 <code>Hello</code>，将根路径 “&#x2F;“ 的请求交给 <code>Hello</code> 函数处理。</li><li><code>http.HandleFunc(&quot;/login&quot;, Login)</code>：注册处理函数 <code>Login</code>，将 “&#x2F;login” 路径的请求交给 <code>Login</code> 函数处理。</li><li><code>http.ListenAndServe(&quot;0.0.0.0:8080&quot;, nil)</code>：启动一个 HTTP 服务器，监听地址为 “0.0.0.0:8080”，传入 <code>nil</code> 作为处理器，表示使用默认的路由器和处理器。</li><li><code>Hello</code> 函数和 <code>Login</code> 函数分别是处理根路径和 “&#x2F;login” 路径请求的处理函数，它们接收一个 <code>http.ResponseWriter</code> 和一个 <code>http.Request</code> 参数，分别用于写入响应和读取请求信息。</li><li><code>fmt.Fprintf(w, ...)</code>：使用 <code>Fprintf</code> 函数将字符串写入到 <code>http.ResponseWriter</code> 中，作为 HTTP 响应的内容。</li></ul></blockquote><h2 id="2、http编程–Client示例"><a href="#2、http编程–Client示例" class="headerlink" title="2、http编程–Client示例"></a>2、http编程–Client示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个 HTTP 客户端</span><br>client := http.Client&#123;&#125;<br><br><span class="hljs-comment">// 构建 GET 请求</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建请求失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 发送请求</span><br>res, err := client.Do(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;请求失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> res.Body.Close() <span class="hljs-comment">// 在函数结束时关闭响应的 Body</span><br><br><span class="hljs-comment">// 读取响应的内容</span><br>data, err := ioutil.ReadAll(res.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 输出响应的内容</span><br>fmt.Println(<span class="hljs-type">string</span>(data))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例说明：-1"><a href="#示例说明：-1" class="headerlink" title="示例说明："></a>示例说明：</h3><blockquote><ul><li><code>http.Client&#123;&#125;</code>：创建一个 HTTP 客户端，用于发送 HTTP 请求。</li><li><code>http.NewRequest(&quot;GET&quot;, &quot;https://www.example.com&quot;, nil)</code>：构建一个 GET 请求，并指定请求的 URL、请求方法和请求体。</li><li><code>client.Do(req)</code>：发送请求并获取响应，返回一个 <code>http.Response</code> 对象。</li><li><code>defer res.Body.Close()</code>：在函数结束时关闭响应的 Body，确保资源被正确释放。</li><li><code>ioutil.ReadAll(res.Body)</code>：从响应的 Body 中读取内容，返回一个字节数组。</li><li><code>fmt.Println(string(data))</code>：将读取到的响应内容转换为字符串并输出。</li></ul></blockquote><h2 id="3、常见HTTP请求方法"><a href="#3、常见HTTP请求方法" class="headerlink" title="3、常见HTTP请求方法"></a>3、常见HTTP请求方法</h2><blockquote><ol><li>GET：从服务器获取资源。客户端向服务器请求获取指定 URL 对应的资源，并从服务器返回该资源的内容。GET 请求通常用于获取数据，而不对服务器上的资源进行修改。</li><li>POST：向服务器提交数据。客户端向服务器提交数据，请求服务器对该数据进行处理。POST 请求通常用于向服务器提交数据，如表单数据、上传文件等。</li><li>PUT：更新服务器上的资源。客户端向服务器传送数据，请求服务器更新指定 URL 对应的资源。PUT 请求通常用于更新资源。</li><li>DELETE：删除服务器上的资源。客户端向服务器请求删除指定 URL 对应的资源。DELETE 请求通常用于删除资源。</li><li>HEAD：类似于 GET 请求，但只返回响应头部，不返回响应体。用于获取资源的元信息，如文件大小、文件类型等，而不获取实际的资源内容。</li><li>OPTIONS：请求服务器返回对指定 URL 支持的通信选项。服务器将返回支持的 HTTP 请求方法、头部字段等信息，用于客户端了解服务器的功能和约束。</li><li>PATCH：对服务器上的资源进行部分更新。客户端向服务器传送数据，请求服务器对指定 URL 对应的资源进行部分更新。</li><li>CONNECT：建立网络隧道。通常用于代理服务器，用于在客户端和目标服务器之间建立隧道，用于安全的加密通信。</li><li>TRACE：用于调试，请求服务器返回对请求和响应的诊断信息。不常用于实际生产环境。</li></ol></blockquote><h2 id="4、下面是一个简单的-Go-语言程序，演示了如何使用-HTTP-请求方法进行基本的-HTTP-请求："><a href="#4、下面是一个简单的-Go-语言程序，演示了如何使用-HTTP-请求方法进行基本的-HTTP-请求：" class="headerlink" title="4、下面是一个简单的 Go 语言程序，演示了如何使用 HTTP 请求方法进行基本的 HTTP 请求："></a>4、下面是一个简单的 Go 语言程序，演示了如何使用 HTTP 请求方法进行基本的 HTTP 请求：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// GET 请求示例</span><br>resp, err := http.Get(<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>) <span class="hljs-comment">// 发起 GET 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;GET 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close() <span class="hljs-comment">// 确保在函数退出前关闭响应体</span><br><br>data, err := ioutil.ReadAll(resp.Body) <span class="hljs-comment">// 读取响应体数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;GET 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data)) <span class="hljs-comment">// 打印响应数据</span><br><br><span class="hljs-comment">// POST 请求示例</span><br>resp, err = http.Post(<span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 发起 POST 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;POST 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>data, err = ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;POST 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data))<br><br><span class="hljs-comment">// PUT 请求示例</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 创建 PUT 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建 PUT 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>client := &amp;http.Client&#123;&#125;<br>resp, err = client.Do(req) <span class="hljs-comment">// 发起 PUT 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;PUT 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>data, err = ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;PUT 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data))<br><br><span class="hljs-comment">// DELETE 请求示例</span><br>req, err = http.NewRequest(<span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 创建 DELETE 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建 DELETE 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>resp, err = client.Do(req) <span class="hljs-comment">// 发起 DELETE 请求</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;DELETE 请求错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>data, err = ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取响应数据错误:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;DELETE 请求响应数据:&quot;</span>, <span class="hljs-type">string</span>(data))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录</title>
      <link href="/2023/04/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/04/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">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</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div><script>var onError = function(error) {document.getElementById("enc_error").innerHTML = "password error!"};function decrypt() {var passwd = document.getElementById("enc_pwd_input").value;console.log(passwd);doDecrypt(passwd, onError);}</script></div>]]></content>
      
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP/"/>
      <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP/</url>
      
        <content type="html"><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP<span id="more"></span></h2><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><blockquote><p>​子串的匹配算法。</p></blockquote><h4 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h4><blockquote><p>KMP算法分为两个部分：求next数组 和匹配字符串</p><p>（1）求next数组：<br>    （1.1）先让子串最近一个与其相同的位置，然后继续判断，直至能匹配上或者回到第一个字符位置。<br>    （1.2）回到能匹配到的地方后，继续开始匹配，匹配成功，则j向后移，<br>    （1.3）记录当前子串字符i的能匹配上的位置<br>    （1.4）遍历整个子串，便能找出子串中能匹配上的位置<br>（2）匹配字符串：利用子串的next数组进行匹配，优化，不用每次匹配失败都回到子串的第一个字符<br>    （2.1）匹配不成功，每次匹配前，先让子串回到能与主串匹配的位置<br>    （2.2）然后进行匹配，如果匹配成功，就把子串匹配的位置向后移<br>    （2.3）如果子串j匹配完了，即j &#x3D;&#x3D; n时，说明在主串中找到了子串匹配串，则进行输出该位置，并且将j回到能匹配的位置<br>    （2.4）逐一匹配主串中所有字符即可</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求next数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ ) <span class="hljs-comment">//第一位肯定是0，直接从第二位开始计算</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>])j = ne[j];        <span class="hljs-comment">//当j退到0或者，主串和子串的值对不上的时候，让j回到能对上的位置，直到找到或者无路可退为止</span><br>        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>])j ++;                     <span class="hljs-comment">//if能对上就让子串继续往后对</span><br>        ne[i] = j;                                    <span class="hljs-comment">//记录下该点时的next数组值</span><br>    &#125;<br><br><span class="hljs-comment">//开始匹配</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>])j = ne[j];        <span class="hljs-comment">//当j退到0或者，主串和子串的值对不上的时候，让j回到能对上的位置，直到找到或者无路可退为止</span><br>        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>])j ++;                     <span class="hljs-comment">//if能对上就让子串继续往后对</span><br>        <span class="hljs-keyword">if</span>(j == n)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i - n);                     <span class="hljs-comment">//输出此时的起始下标（该位置减去子串总长度，即子串起始下标）</span><br>            j = ne[j];                                <span class="hljs-comment">//将子串恢复到他下次能够匹配的位置</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表<span id="more"></span></h2><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><blockquote><p>​将较大的数值映射到较小的数组下标里。</p></blockquote><h4 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h4><blockquote><p>1、开放取址法<br>可以怎么去理解呢？<br>每次先找到插入数或者查找数的映射值，然后从该映射值开始找<br>插入的时候往后找空位，如果找到了空位，就停止，返回空位的下标<br>查询的时候，往后找，一个一个对比是否存在查找的数，直至查到空位位置，说明不存在这个数，<br>因为每一个数，一定是存在其映射数后面的，如果找到了空位，说明映射到这个数的后面的数已经找完了，说明不存在该数</p><p>需要注意的是：数组长度最好开到题给的2~3倍<br>实现：<br>（1）映射数： t &#x3D; (x % N + N) % N;<br>（2）这里将查找和插入进行同步操作：<br>while (h !&#x3D; null &amp;&amp; h[t] !&#x3D; x)<br>没有找到需要的东西（插入：空位，查找：相同的值或者空位）就继续查找：t ++;<br>找了数组末尾没有找到，就从数组开头继续查找 if (t &#x3D;&#x3D; N) t &#x3D; 0;<br>（3）最后返回目标下标即可 return t</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">//返回 查找后或者放入后x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = (x % N + N) % N; <span class="hljs-comment">//哈希函数，将大范围的值，全部映射到数组下标内</span><br><br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)   <span class="hljs-comment">//如果当前位置已经有值了，并且不等于那个值</span><br>    &#123;<br>        t ++;   <span class="hljs-comment">//往后找</span><br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>; <span class="hljs-comment">//找到了最后，仍然没有找到，从头开始找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> t;   <span class="hljs-comment">//返回x的位置</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
      <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆<span id="more"></span></h2><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​堆有两个操作：down和up</p></blockquote><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>    <span class="hljs-comment">//down操作，将每个节点与其左右儿子比较，判断其是否需要进行下移</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;  <span class="hljs-comment">//t记录的是该节点以及其左右两个儿子中最小的值</span><br>    <span class="hljs-keyword">while</span> (u * <span class="hljs-number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;  <span class="hljs-comment">//先与左儿子进行比较</span><br>    <span class="hljs-keyword">while</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <span class="hljs-comment">//再与右儿子进行比较</span><br>    <span class="hljs-keyword">if</span> (t != u) <span class="hljs-comment">//若不等于，说明t发生了变化，必须进行下移</span><br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[t], h[u]);   <span class="hljs-comment">//将t位置的值，与u位置的值进行交换位置</span><br>        <span class="hljs-built_in">down</span>(t); <span class="hljs-comment">//递归，直至其不再需要下移为止</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span> <span class="hljs-params">(<span class="hljs-type">int</span> u)</span> <span class="hljs-comment">//up操作， 判断一个节点是否需要根据小根堆的特性进行上移操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])    <span class="hljs-comment">//判断，只要存在父节点，且父节点的值大于该节点的值，则需要进行交换</span><br>    &#123;   <br>        <span class="hljs-built_in">swap</span>(u, u / <span class="hljs-number">2</span>); <span class="hljs-comment">//同样进行所有信息的交换</span><br>        u &gt;&gt;= <span class="hljs-number">1</span>;        <span class="hljs-comment">//交换后，将该节点往上移，while继续判断是否需要上移</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2023/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集<span id="more"></span></h1><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><blockquote><p>​可以快速地做到下列两个操作：（1）将两个集合合并（2）询问两个元素是否在一个集合</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h4><blockquote><p>  find函数的实现</p><p>（1）int find(int x)<br>    {<br>        if(p[x]!&#x3D;x) p[x]&#x3D;find(p[x]); &#x2F;&#x2F;只要没有找到祖宗节点，就一直找，因为只有祖宗节点的p[x] &#x3D; x;<br>        return p[x]&#x3D;x; &#x2F;&#x2F;找到了祖宗节点，便返回祖宗节点的值<br>    }<br>        这个函数既实现了找到祖宗节点的功能，又实现了将所有儿子节点直接指向祖宗节点，即路径压缩<br>（2）合并两个集合，即将其中一个集合的祖宗节点变成另一个祖宗节点的子节点<br>p[find(a)] &#x3D; find(b);<br>（3）判断两个集合是否在同一个集合：则判断其祖宗节点是否为是否为同一个节点即可<br>if(find(a) &#x3D;&#x3D; find(b))printf(“Yes\n”);<br>else printf(“No\n”);</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间合并</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并<span id="more"></span></h2><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​合并所有有交集的区间。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​可以用vector&lt;pair&lt;int, int&gt;&gt; 进行存储所有的区间</p><p>（1）先将所有的区间进行从小到大排序<br>（2）然后用所有的小区间去维护一个大区间<br>    （2.1）依次去遍历每一个小区间<br>    （2.2）如果当前区间和上一个区间没有交集，则进将前一个区间放入答案中，然后开始维护当前区间<br>    （2.3）如果当前区间和上一个区间有交集，就更新右边界为较大的那个值<br>（3）最后特判一个，如果最后一个区间不为空，就将最后一个区间放入到答案中<br>（4）将答案赋值给原集合即可</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        segs.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;); <br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//先将所有区间从小到大排序, 先看第一位，再看第二位，依次推类</span><br><br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;   <span class="hljs-comment">//定义区间的左右边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)    <span class="hljs-comment">//该区间和下一个区间没有交集</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<span class="hljs-comment">//特判没有交集的是不是第一个区间是不是最开始维护空区间</span><br>            st = seg.first, ed = seg.second;    <span class="hljs-comment">//更新区间， 第一次更新区间，直接将第一个区间的左右边界放进来</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ed = <span class="hljs-built_in">max</span>(ed, seg.second);   <span class="hljs-comment">//将区间右边界更新为较大的那个值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);    <span class="hljs-comment">//将最后一个区间加入</span><br><br>    segs = res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）需要先对原区间集合进行排序</p><p>​（2）需要特判没有交集的是不是第一个区间，是不是最开始维护的空区间</p><p>​（3）在将区间集合遍历结束后，需要判断，只要维护的区间被更新过，那么加一定存在一个区间还没有加入答案，因为它还没有遇到一个与他没有交集的区间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化<span id="more"></span></h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​所存的值域大，但个数小，为了避免空间的浪费，可以使用离散化。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）离散后一定要映射到1, 2, 3, … n，故需要在二分查找离散化的值的时候，返回找到的下标 + 1的位置</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算<span id="more"></span></h2><h3 id="1、返回n的最后一位1："><a href="#1、返回n的最后一位1：" class="headerlink" title="1、返回n的最后一位1："></a>1、返回n的最后一位1：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br>       <br>   求一个数x，其二进制表示下<span class="hljs-number">1</span>的个数。<br>       <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x)<br>       &#123;<br>           res ++;<br>           x -= <span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>cout &lt;&lt; res;<br></code></pre></td></tr></table></figure><p>2、求n的第k位数字: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &gt;&gt; k &amp; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针算法</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法<span id="more"></span></h2><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>常见问题分类：<br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p></blockquote><h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与差分</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分<span id="more"></span></h2><h3 id="1、一维前缀和"><a href="#1、一维前缀和" class="headerlink" title="1、一维前缀和"></a>1、一维前缀和</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​可以在O(1)的时间算出一段区间内的所有数的和。</p></blockquote><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];   <span class="hljs-comment">//预处理  计算前缀和数组</span><br><br><span class="hljs-type">int</span> l, r;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//进行每一段的求和</span><br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​前缀和与差分数组下标都必须从1开始。</p></blockquote><h3 id="2、二维前缀和"><a href="#2、二维前缀和" class="headerlink" title="2、二维前缀和"></a>2、二维前缀和</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​能够在O(1)的时间内算出一个矩阵中所有数的和。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）数组下标都从1开始，便于后续的处理<br>（2）遍历二维数组中的每一个点<br>构造：每一个点执行s[i][j] &#x3D; s[i - 1][j] + s[i][j - 1] + a[i][j] - s[i - 1][j - 1];<br>（3）获取(x1, y1)与(x2, y2)之间的子矩阵的所有数的和<br>构造完成后的二维前缀和数组，直接输出<br>s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]，即可获得该子矩阵的所有数的和</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];    <span class="hljs-comment">//求二维前缀和数组</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x2][y1 - <span class="hljs-number">1</span>] - s[x1 - <span class="hljs-number">1</span>][y2] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//想要的矩阵之内的所有数之和</span><br></code></pre></td></tr></table></figure><h3 id="3、一维差分"><a href="#3、一维差分" class="headerlink" title="3、一维差分"></a>3、一维差分</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​用于给某个区间快速地加上或者减去某个数。</p></blockquote><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）构造差分数组<br>    （1.1）将差分数组看作原本都是0，a[i]是原数组，b[i]是差分数组<br>    （1.2）然后将原数组中的每一个数，都插入到差分数组中，<br>        b[l] +&#x3D; c, &#x2F;&#x2F;a[l]后的数都会+c<br>        b[r + 1] -&#x3D; c; &#x2F;&#x2F;a[r + 1]后的数都会-c，【补丁】<br>        最后达到的效果就是a[l] ~a[r]之间的每一个数都加上了c<br>（2）然后根据题目要求在差分数组中指定区间中的每一个数都加上一个数，即在差分数组中的该区域中插入该数<br>（3）将差分数组还原成原数组（前缀和数组）输出即可 b[i] +&#x3D; b[i - 1];</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);   <span class="hljs-comment">//输入原数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">insert</span>(i, i, a[i]);   <span class="hljs-comment">//将原数组变成差分数组，此时原数组为该数组的前缀和数组</span><br><br><span class="hljs-comment">//给区间[l, r]上的数都加上c</span><br><span class="hljs-built_in">insert</span>(l, r, c);    <span class="hljs-comment">//将差分数组的第l个，加上c，后续在还原原数组的时候，后续到r的数，都会加上c</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) b[i] += b[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//将差分数组还原成原数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i]);  <span class="hljs-comment">//输出原数组</span><br></code></pre></td></tr></table></figure><h3 id="4、二维差分"><a href="#4、二维差分" class="headerlink" title="4、二维差分"></a>4、二维差分</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​快速地将一个矩阵中所有数全部加上或者减去一个数，并求出多次操作后的结果。</p></blockquote><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）差分矩阵的构造：<br>    （1.1）将差分数组看作全部都是0，将原数组中的数处理后，一个一个插入到差分数组中<br>    （1.2）先全部上c，再将不需要加上c的地方进行补丁，即减去c<br>        b[x1][y1] +&#x3D; c;  &#x2F;&#x2F;以(x1, y1)为左上角顶点的所有矩阵中的元素全部加上了c这个数<br>        b[x2 + 1][y1] -&#x3D; c; &#x2F;&#x2F;以(x2 + 1, y1)为左上角顶点的所有矩阵中的元素全部减去了c这个数<br>        b[x1][y2 + 1] -&#x3D; c; &#x2F;&#x2F;以(x1, y2 + 1)为左上角顶点的所有矩阵中的元素全部减去了c这个数<br>        b[x2 + 1][y2 + 1] +&#x3D; c; &#x2F;&#x2F;以(x2 + 1, y2 + 1)为左上角顶点的所有矩阵中的元素加上c这个数，前面多减了一次<br>（2）然后根据题目要求在差分数组中指定区间中的每一个数都加上一个数，即在差分数组中的该区域中插入该数<br>（3）将差分数组还原成原数组（前缀和数组）输出即可<br>    b[i][j] +&#x3D; b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1];</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span>  <span class="hljs-comment">//初始化差分数组</span></span><br><span class="hljs-function"></span>&#123;<br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)   <span class="hljs-comment">//读取原数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>     <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);    <span class="hljs-comment">//初始化差分数组</span><br>            <br><span class="hljs-comment">//将点(x1, y1)与点(x2, y2)形成的矩阵的所有数都加上c</span><br><span class="hljs-built_in">insert</span>(x1, y1, x2, y2, c);  <span class="hljs-comment">//进行插入数字的操作 </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            b[i][j] += b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]; <span class="hljs-comment">//将差分数组还原成原数组，即还原成前缀和数组</span><br>            <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i][j]);    <span class="hljs-comment">//输出还原后的数组即可            </span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度算法</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法<span id="more"></span></h2><h3 id="1、高精度加法"><a href="#1、高精度加法" class="headerlink" title="1、高精度加法"></a>1、高精度加法</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>求两个大正整数相加的和。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​（1）用可变长数组vectorA，B存储</p><p>​（2）将输入的大数用字符串a，b读入，并逆序存入A，B</p><p>​（3）进行套用高精度模板</p><p>​（4）最后逆序输出答案即可</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">Add</span>(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, C[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>最后可能会存在一位进位，需要特判，若存在直接push进答案最后即可</p></blockquote><h3 id="2、高精度减法"><a href="#2、高精度减法" class="headerlink" title="2、高精度减法"></a>2、高精度减法</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​求两个大正整数A，B的差。</p></blockquote><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>高精度减法：大数A - 大数B<br>（1）用可变长数组vector存储A，B<br>（2）将字符串a、b逆序存入数组A、B中<br>（3）为了计算方便，我们再计算之前先保证较大的数减去较小的数，即我们要先判读出A、B谁大<br>    （3.1）自定一个比较大小的cmp函数，用于返回若 A &gt; B,返回true，反之返回false<br>    （3.2）cmp函数的构造分为两种情况    位数相同 和  位数不同<br>    （3.3）位数不同：肯定是位数长的数大<br>    （3.4）位数相同，我们就需要从后向前遍历两个数组（因为我们已经逆序存储了），<br>    找到第一个不相同的数进行比较，谁大，说明该数组表示的数大<br>（4）高精度减法的构造<br>    （4.1）定义一个答案数组和临时变量t（存放借位）<br>    （4.2）从前到后遍历较大数组（因为是逆序存储，所以原本低位相减变成了现在的前面的数相减）：<br>    （4.3）每一次遍历，先让较大的数减去借位，然后再减去较小的数中（需要判读较小的数是否还剩于）<br>    （4.4）因为有可能相减为负数，这里利用一个技巧直接将(t + 10) % 10的结果加入答案末尾即可，这里保证了加入的一定是相减结果的绝对值<br>    （4.5）更新借位，<br>        如果t为负数，说明在相减的时候，借位了，让 t &#x3D; 1，表示借了一位，保留到下一次计算进行减去<br>        如果t为正数，说明在相减的时候，没有借位，让借位置零即可<br>    （4.6）最后再进行去前导0即可<br>        如果答案的长度大于1，且答案最后有0，就将0弹出即可<br>（5）最后逆序输出答案即可</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (A[i] != B[i]) <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B, C;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(A, B)) C = <span class="hljs-built_in">sub</span>(A, B);<br>    <span class="hljs-keyword">else</span> C = <span class="hljs-built_in">sub</span>(B, A), cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) cout &lt;&lt; C[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）首先一定要保证是用大于减小数，故需要实现一个cmp函数</p><p>​（2）其次由于保证了是大数减小数，故不存在剩一位的情况，一定能减得下，故一定会被存进答案里</p><p>​（3）由于高位在后，低位在前，故有可能存在前导零，故需要取前导零。</p></blockquote><h3 id="3、高精度乘法"><a href="#3、高精度乘法" class="headerlink" title="3、高精度乘法"></a>3、高精度乘法</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​求一个大正整数与一个数的乘积。</p></blockquote><h5 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）用可变长数组vector存储A</p><p>（2）将字符串a逆序存入数组A中<br>（3）高精度乘法的构造：<br>    （3.1）定义一个答案数组，并且初始化进位t<br>    （3.2）从头到尾遍历大数A，<br>    （3.3）将每一位与b的乘积的计算结果放入t中<br>    （3.4）将t % 10的结果放入答案数组的末尾<br>    （3.5）更新进位t<br>    （3.6）看进位t是否还有数，如果还有，就在答案数组末尾加入该数<br>    （3.7）去前导0<br>（4）逆序输出答案数组即可</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) cout &lt;&lt; C[i];<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）由于可能最后的答案可能为0，故需要去除前导零的情况。</p><p>​（2）由于可能最后一位计算后大于了10，还没有进位，故需要判断是否还有剩位，有则直接放在答案末尾即可。</p></blockquote><h3 id="4、高精度除法"><a href="#4、高精度除法" class="headerlink" title="4、高精度除法"></a>4、高精度除法</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​求一个一个非负大整数A与一个整数b的商和余数。</p></blockquote><h5 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>高精度除法：大数A &#x2F; 小数b<br>（1）用可变长数组vector存储A<br>（2）将字符串a逆序存入数组A中<br>（3）构造高精度除法<br>    （3.1）定义答案数组，以及初始化余数t，由于余数最后要输出， 可以定义成全局变量<br>    （3.2）从后往前遍历大数（大数是逆序存储到数组的，但这里除法需要从高位开始计算，所以从最后一位即大数的高位开始）<br>    （3.3）每一位数 + 余数 * 10 ，进行计算<br>    （3.4）将上一步的结果 除 b 的结果放入答案数组<br>    （3.5）最后更新余数 t %&#x3D; b<br>    （3.6）将答案数组翻转，因为最后的输出是逆序输出的<br>    （3.7）去前导0<br>（4）逆序输出答案数组即可</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    t = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>    &#123;<br>        t = A[i] + t * <span class="hljs-number">10</span>;<br>        C.<span class="hljs-built_in">push_back</span>(t / b);<br>        t %= b;<br>    &#125;<br><br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) cout &lt;&lt; C[i];<br>    cout &lt;&lt; endl &lt;&lt; t;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）由于做除法只能从高位做，且模板都是逆序存，逆序输出，为了统一模板，则在除法模板中写的有些复杂</p><p>​（2）除法模板与其他模板不同，需要逆序逐位除，即高位往低位算</p><p>​（3）算出来之后，由于我们需要逆序输出，故我们要将求出来的答案用reverse进行翻转</p><p>​（4）然后由于可能前几位除不下，故需要进行去前导零。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找<span id="more"></span></h2><h3 id="1、整数二分："><a href="#1、整数二分：" class="headerlink" title="1、整数二分："></a>1、整数二分：</h3><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (l &lt; r)       <span class="hljs-comment">//当l &gt;= r 时，遍历结束，停止循环</span><br>&#123;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;   <span class="hljs-comment">//check函数 当这个点，大于等于x，说明答案在左边，从右边缩小范围</span><br><span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;   <span class="hljs-comment">//反之，答案在右边，从左边缩小范围</span><br>&#125;<br><br> <span class="hljs-keyword">while</span> (l &lt; r)<br>&#123;<br><span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;   <span class="hljs-comment">//check函数，当这个点，小于等于x时，答案在右边，从左边缩小范围</span><br><span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;   <span class="hljs-comment">//反之，答案在左边，从右边缩小范围</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、小数二分"><a href="#2、小数二分" class="headerlink" title="2、小数二分"></a>2、小数二分</h3><h5 id="模板：-1"><a href="#模板：-1" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> eps; <span class="hljs-comment">//一般比题目要求多两位</span><br><br><span class="hljs-keyword">while</span> (r - l &gt; eps)  <span class="hljs-comment">//只要 r - l 不小于该大小，就不断进行二分，找值</span><br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid * mid &gt;= n) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/05/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序<span id="more"></span></h2><h3 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h3><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）定义出口<br>（2）选取一个随机点，以及确定左右边界<br>（3）i，j两个指针从左右两个边界向中间移动<br>    （3.1）左指针找到需要交换的值（大于参考点的值），就停下来<br>    （3.2）右指针找到需要交换的值（小于参考点的值），就停下来<br>    （3.3）当两个指针都停下来，且i指针在j指针左边时，交换两个值<br>（4）递归将每一个部分都进行同样的操作，直至细分到最小时，就满足了整个区间从左到右有序排列</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//边界条件 </span><br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;                         <span class="hljs-comment">//当左指针大于等于右指针说明两指针已经遍历了全部数据 </span><br>    <span class="hljs-comment">//确定分界点 </span><br>    <span class="hljs-type">int</span> x=q[l+r&gt;&gt;<span class="hljs-number">1</span>], i= l - <span class="hljs-number">1</span> ,j = r + <span class="hljs-number">1</span>;        <span class="hljs-comment">//随机选取一个数据中的值作为参考值  用i,j表示左右指针，但注意定义时，需要定义在数据外围外 </span><br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++ ; <span class="hljs-keyword">while</span>(q[i]&lt;x);          <span class="hljs-comment">//直到找到第一个不小于参考值x的值，左指针停止 ， 否则左指针不断后移 </span><br>        <span class="hljs-keyword">do</span> j-- ; <span class="hljs-keyword">while</span>(q[j]&gt;x);          <span class="hljs-comment">//直到找到第一个不大于参考值x的值，右指针停止 ， 否则右指针不断左移 </span><br>        <span class="hljs-keyword">if</span>(i &lt; j)<span class="hljs-built_in">swap</span>(q[i],q[j]);        <span class="hljs-comment">//当左右指针都停下，则说明两指针都找到了需要交换的值，则交换两值 </span><br>    &#125;<br><br>    <span class="hljs-built_in">quick_sort</span>(q, l, j);                 <span class="hljs-comment">//将左边部分作为一个新串传入， </span><br>    <span class="hljs-built_in">quick_sort</span>(q, j+<span class="hljs-number">1</span>, r);               <span class="hljs-comment">//将右边部分作为一个新串传入， </span><br>    <span class="hljs-comment">//经过上面的递归则可以完成整个数据的排序 </span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h3><h5 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>（1）定义出口 l &gt;&#x3D; r<br>（2）先确定中间点，然后进行左右区间的递归，此时返回的序列为两个有序序列<br>（3）定义左右两个序列的开头<br>（4）同时遍历左右两个序列，每次将两个序列中最小的值拿出来，放到答案里（由于此时两个序列都是有序序列，所以只需要比较两个序列的开头就行了）<br>（5）判断两个序列是否还有元素没有加入，有则直接全部加入即可<br>（6）最后将排好序的数组重新赋值给原数组即可</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;     <span class="hljs-comment">//出口</span><br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;     <span class="hljs-comment">//确定分界点</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;  <span class="hljs-comment">//用于计算存到了多少个了</span><br><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);       <span class="hljs-comment">//将序列递归成两个有序序列</span><br><br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>;     <span class="hljs-comment">//定义左右序列的开头</span><br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)  <span class="hljs-comment">//判断两个序列是否有一个序列已经遍历完成</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) temp[k ++] = q[i++];<br>        <span class="hljs-keyword">else</span> temp[k ++] = q[j++];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) temp[k ++] = q[i++];   <span class="hljs-comment">//将剩余序列的元素直接加入</span><br>    <span class="hljs-keyword">while</span> (j &lt;= r) temp[k ++] = q[j++];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) q[i] = temp[j]; <span class="hljs-comment">//将数组复原</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2023/04/05/%E6%9D%82%E7%B1%BB/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/04/05/%E6%9D%82%E7%B1%BB/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="n进制下的数s转换为m"><a href="#n进制下的数s转换为m" class="headerlink" title="n进制下的数s转换为m"></a>n进制下的数s转换为m<span id="more"></span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span> <span class="hljs-comment">//字符转数字</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;B&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;C&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;D&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">13</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-string">&#x27;E&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;F&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(a - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">11</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">14</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;E&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">15</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;F&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">char</span> (a + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, m, p = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;   <span class="hljs-comment">//p为当前位次（百位，千位，万位等。）</span><br>    string s, res = <span class="hljs-string">&quot;&quot;</span>;<br><br>    cin &gt;&gt; n &gt;&gt; s &gt;&gt; m; <span class="hljs-comment">//前进制，数，后进制</span><br><br>    <span class="hljs-comment">//从低位到高位，将字符转换为数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>    &#123;<br>        sum += <span class="hljs-built_in">fun1</span>(s[i]) * p ;   <span class="hljs-comment">//当前位等于转为为数字之后，乘上当前位次</span><br>        p *= n; <span class="hljs-comment">//更新位次</span><br>    &#125;<br>    <span class="hljs-comment">//因为可能存在16进制，将当前数转换为字符串输出</span><br>    <span class="hljs-keyword">while</span> (sum != <span class="hljs-number">0</span>)<br>    &#123;<br>        res = <span class="hljs-built_in">fun2</span>(sum % m) + res;   <span class="hljs-comment">//由低位向高位逐级求出，然后放入答案</span><br>        sum /= m; <span class="hljs-comment">//更新数字</span><br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间DP</title>
      <link href="/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
      <url>/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/</url>
      
        <content type="html"><![CDATA[<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP<span id="more"></span></h2><h3 id="1、石子合并："><a href="#1、石子合并：" class="headerlink" title="1、石子合并："></a>1、石子合并：</h3><blockquote><p>​每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。</p><p>​每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>​问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>核心思路：从小区间逐步扩展区间，最后得到整个区间的最优解</p><p>（1）区间长度从小到大枚举</p><p>（2）每种长度都进行所有起点的枚举<br>（3）将区间(l, r)合并所需要的代价初始化为无穷大<br>（4）然后对该区间进行状态转移，每次都拿出最后一个状态，进行比较</p></blockquote><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; s[i];  <span class="hljs-comment">//读入数组</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] += s[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">//求其前缀和</span><br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++) <span class="hljs-comment">//枚举长度</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i ++) <span class="hljs-comment">//从前到后，枚举不同长度下，给左边区域和右边区域分配不同数量是的代价，求最小值</span><br>       &#123;<br>           <span class="hljs-type">int</span> l = i, r = i + len - <span class="hljs-number">1</span>; <span class="hljs-comment">//以当前位置为左边部分（只有一个数），剩余部分都是右边部分</span><br>           f[l][r] = <span class="hljs-number">1e8</span>;  <span class="hljs-comment">//先将所有从第l堆石子到第r堆石子合并到一堆石子的代价置为无穷</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l; k &lt; r; k ++)    <span class="hljs-comment">//逐渐将右边的数拿给左边求代价，右边至少留一个</span><br>               f[l][r] = <span class="hljs-built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="hljs-number">1</span>][r] + s[r] - s[l - <span class="hljs-number">1</span>]);<br>       &#125;<br><br>   <span class="hljs-comment">//所有将第1堆石子到第n堆石子合并的所有方式的代价最小值</span><br>   cout &lt;&lt; f[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h5 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h5><blockquote><p>​区间合并的问题，通用的一个模板：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len++) &#123;         <span class="hljs-comment">// 区间长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + len - <span class="hljs-number">1</span> &lt;= n; i++) &#123; <span class="hljs-comment">// 枚举起点</span><br>        <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;                 <span class="hljs-comment">// 区间终点</span><br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            dp[i][j] = 初始值<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; k++) &#123;        <span class="hljs-comment">// 枚举分割点，构造状态转移方程</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + w[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性DP</title>
      <link href="/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/"/>
      <url>/2023/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/</url>
      
        <content type="html"><![CDATA[<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP<span id="more"></span></h2><h3 id="1、数字三角形模型"><a href="#1、数字三角形模型" class="headerlink" title="1、数字三角形模型"></a>1、数字三角形模型</h3><h5 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h5><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​从某个顶点出发，走到最底层或者最底层的某个点，求该路径的数字和的最大值。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>状态表示：f[i][j]<br>集合：所有从起点走到(i, j)的路径<br>属性：MAX</p><p>集合划分：以最后一个点是由左上方来的，还是右上方来的进行划分。</p><p>状态转移方程：f[i][j] &#x3D; max(f[i - 1][j - 1], f[i - 1][j]) + g[i][j];</p></blockquote><p><img src="/images/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt="数字三角形"></p><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n + <span class="hljs-number">1</span>; j ++)<br>            f[i][j] = <span class="hljs-number">-2e9</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j]) + g[i][j];<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​在这里DP问题时，初始化需要特别注意。</p><p>​这里的初始化有两种，目的都是为了处理负数的情况：</p><p>​（1）第一种是按照模板那样写</p><p>​（2）第二种是，直接用memset函数，将f数组全部设置为-INF，memset(f, -0x3f, sizeof g);</p><p>​此时需要将特判第一个点，将起点赋值为f[1][1] &#x3D; g[1][1]，并在循环里从第二行开始处理，即跳过已经处理过的起点</p></blockquote><h5 id="拓展1："><a href="#拓展1：" class="headerlink" title="拓展1："></a>拓展1：</h5><blockquote><p>​若地图是一个矩形，且求的是最小值，题目见</p><p>[最低通行费]: <a href="https://www.acwing.com/problem/content/1020/">https://www.acwing.com/problem/content/1020/</a>“ “</p></blockquote><h6 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h6><blockquote><p>​初始化时由于我们发现第一排只能是从左到右更新，第一列只能是从上到下更新，故需要特判，具体见下述代码。但我们发现这样会导致起点无法遍历，故需要直接单独处理起点。</p></blockquote><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + g[i][j], f[i][j]);<br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][j - <span class="hljs-number">1</span>] + g[i][j]);<br>            &#125;<br></code></pre></td></tr></table></figure><h5 id="拓展2："><a href="#拓展2：" class="headerlink" title="拓展2："></a>拓展2：</h5><blockquote><p>​若整个地图走了两遍，该如何处理？例题，见</p><p>[方格取数]: <a href="https://www.acwing.com/problem/content/1029/">https://www.acwing.com/problem/content/1029/</a>“ “</p><p>​题目类似的还有</p><p>[传纸条]: <a href="https://www.acwing.com/problem/content/277/">https://www.acwing.com/problem/content/277/</a>“传纸条”</p></blockquote><h6 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h6><blockquote><p>​只走一次：</p><p>​f[i][j]表示所有从(1,1)走到(i,j)的路径的最大值</p><p>​f[i][j] &#x3D; max(f[i - 1][j], f[i][j - 1]) + w[i][j]；</p><p>​走两次：</p><p>​f[i1,j1,i2,j2]表示所有从(1,1),(1,1)分别走到(i1,j1),(i2,j2)路径的最大值。</p><p>​如何处理“同一个格子不能被重复选择”？<br>​    分析后发现，只有当i1 + j1 &#x3D;&#x3D; i2 + j2时，两条路径的格子才可能重合，<br>​    于是可以根据这条性质将思维优化成三维，</p><p>​集合：f[k,i1,i2]表示所有从(1,1),(1,1)走到(i1,k-i1),(i2,k-i2)的路径的最大值<br>   ​ k表示两条路线当前走到的格子的横纵坐标之和</p><p>​属性：max</p><p>​状态计算：<br>​    以最后一步是从往下走还是往右走进行划分，因为有两次走法，所以被分成了四种情况<br>​        下下、下右、右下、右右</p></blockquote><h6 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt;= n + n; k ++)   <span class="hljs-comment">//枚举横纵坐标之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>; i1 &lt;= n; i1 ++)    <span class="hljs-comment">//枚举第一次走的横坐标</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span>; i2 &lt;= n; i2 ++)    <span class="hljs-comment">//枚举第二次走的横坐标</span><br>            &#123;<br>                <span class="hljs-type">int</span> j1 = k - i1, j2 = k - i2;   <span class="hljs-comment">//计算出两次走的纵坐标</span><br>                <span class="hljs-keyword">if</span> (j1 &gt;= <span class="hljs-number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="hljs-number">1</span> &amp;&amp; j2 &lt;= n)<br>                &#123;<br>                    <span class="hljs-type">int</span> t = g[i1][j1];  <span class="hljs-comment">//如果两个坐标相等，只加一次，因为第二次走这里，已经被拿走清空了</span><br>                    <span class="hljs-keyword">if</span> (i1 != i2) t += g[i2][j2];   <span class="hljs-comment">//坐标不相同，就两个位置全加上</span><br>                    <span class="hljs-type">int</span> &amp;x = f[k][i1][i2];<br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2 - <span class="hljs-number">1</span>] + t);   <span class="hljs-comment">//下 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1 - <span class="hljs-number">1</span>][i2] + t);       <span class="hljs-comment">//下 右</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2 - <span class="hljs-number">1</span>] + t);       <span class="hljs-comment">//右 下</span><br>                    x = <span class="hljs-built_in">max</span>(x, f[k - <span class="hljs-number">1</span>][i1][i2] + t);            <span class="hljs-comment">//右 右</span><br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h6 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h6><blockquote><p>（1）为什么下面四个状态转移方程能代表四种状态？</p><p>​原因是，因为k 变小了1，先不看最后一步，如果i变小1，则j就不用变；如果i没有变，则j就需要变小1；</p><p>​上述两种情况刚好对应了最后一步是向下、右走，的横纵坐标变化情况，又因为是两次一起走，故有四种情况。</p><p>​x &#x3D; max(x, f[k - 1][i1 - 1][i2 - 1] + t);   &#x2F;&#x2F;下 下<br>​x &#x3D; max(x, f[k - 1][i1 - 1][i2] + t);       &#x2F;&#x2F;下 右<br>​x &#x3D; max(x, f[k - 1][i1][i2 - 1] + t);       &#x2F;&#x2F;右 下<br>​x &#x3D; max(x, f[k - 1][i1][i2] + t);            &#x2F;&#x2F;右 右</p><p>​（2）在开数组的时候，第一维即横纵坐标之和一定要开数据范围的两倍</p></blockquote><h3 id="2、最短编辑距离"><a href="#2、最短编辑距离" class="headerlink" title="2、最短编辑距离"></a>2、最短编辑距离</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​对一个字符串A进行和删除、插入、替换的操作，使得A字符串与给定的B字符串相等，求最少的操作次数。</p></blockquote><h5 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​根据最后一步操作的不同进行分析：<br>​（1）删掉ai后，a与b一模一样，则需要满足a的1 ~ i - 1个字母与b的1 ~ j个字母匹配才能满足，所以先去掉最后一步，去找a的1 ~ i - 1变成b的1 ~ j - 1个字母匹配所需要的步数的最小值f[i - 1][j] + 1<br>​（2）增加一个字母，a与b一模一样，则需要满足增加之前，a的1 ~ i个字母与b的 1 ~ j - 1个字母匹配f[i][j - 1] + 1<br>​（3）改掉ai后，a与b一模一样，则需要满足的是a的1 ~ i - 1个字母与b的 1 ~ j - 1个字母匹配才行，这里分为两种情况，<br>​一种是ai与bi一样，不需要改，步数不用增加f[i - 1][j - 1],<br>​一种是ai与bi不一样，需要改，步数需要增加f[i - 1][j - 1] + 1;</p><p>​需要初始化的两种边界情况：<br>​（1）a的前0个字母去匹配b的前j个字母时，只能通过增加的方式，且增加的步数为b的前j个字母的长度<br>​（2）a的前i个字母去匹配b的前0个字母时，只能通过删除的方式，且删除的步数为a的前i个字母的长度</p><p>​集合：f[i][j]，将第一个子串前i个字符与第二个字串前j个字符变成一样的操作方法<br>​属性：min</p><p>​集合划分：删除、插入、替换三种不同操作<br>​状态计算：<br>​（1）删除：需要a[1<del>i - 1] &#x3D; b[1</del>j]<br>​（2）插入：需要a[1<del>i] &#x3D; b[1</del>j-1]<br>​（3）替换：需要a[1<del>i-1] &#x3D; b[1</del>j-1]</p></blockquote><p><img src="/images/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.png" alt="编辑距离"></p><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++) f[<span class="hljs-number">0</span>][i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) f[i][<span class="hljs-number">0</span>] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>        &#123;<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);    <span class="hljs-comment">//删和增</span><br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//改</span><br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​由于做dp需要涉及 i - 1 和 j - 1，故字符串的下标需要从1开始</p></blockquote><h3 id="3、最长上升子序列模型"><a href="#3、最长上升子序列模型" class="headerlink" title="3、最长上升子序列模型"></a>3、最长上升子序列模型</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。</p></blockquote><h5 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>集合：f[i]表示所有以数字i结尾的上升子序列的集合<br>属性：max</p><p>状态划分：以倒数第二个数为1，2，3，4，，，，i - 1进行划分<br>只要倒数第二个数满足条件：a[j] &lt; a[i]，则可以用下面的状态方程进行转移<br>f[i] &#x3D; max(f[i], f[j] + 1);</p></blockquote><p><img src="/images/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="最长上升子序列模型"></p><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j ++)<br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[i]) f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>        res = <span class="hljs-built_in">max</span>(f[i], res);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）if (a[j] &lt; a[i])    &#x2F;&#x2F;用前面已经算好的最长上升序列更新第i个值的最长上升子序列，所以需要满足a[j]&lt;a[i]，只要满足该条件，就说明目前的最长上升子序列为a[j]+1或者f[i]，f[i]指之前算出过的该点的最长上升子序列。</p><p>​（2）关于为什么要初始化f[i] &#x3D; 1？</p><p>​有一个边界，若前面没有比i小的，f[i]为1（自己为结尾）</p></blockquote><p>​</p><h3 id="4、最长公共子序列"><a href="#4、最长公共子序列" class="headerlink" title="4、最长公共子序列"></a>4、最长公共子序列</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B的子序列的字符串长度最长是多少。</p></blockquote><h5 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>集合f[i][j]:表示所有在第一个序列前i个字母中出现，且在第二个序列前j个字母中出现的子序列<br>集合划分：以a[i],b[j]是否出现在子序列中划分<br>（1）00：都没有出现，f[i - 1][j - 1]<br>（2）01：a[i]没有出现，b[j]出现，由于直接求不好求，这里用f[i - 1][j]进行替代<br>（3）10：a[i]出现，b[j]没有出现，由于直接求不好求，这里用f[i][j - 1]进行替代<br>（4）11：a[i]、b[j]都出现，f[i - 1][j - 1] + 1</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>        &#123;<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（2）、（3）步中的替代是不影响最终结果的：（2）中因为f[i - 1][j]表示所有在第一个序列中前i - 1个字母中出现，且在第二个序列前j个字母中出现的子序列，这里包含了a[i]不出现，b[j]出现的情况，虽然有部分重复，但由于我们求的是最大值，即使重复求，也不会影响我们所求的最大值，（3）同理。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推公式</title>
      <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%A8%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%A8%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式<span id="more"></span></h2><h3 id="1、耍杂技的牛"><a href="#1、耍杂技的牛" class="headerlink" title="1、耍杂技的牛"></a>1、耍杂技的牛</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​有N头牛，每头牛都有自己的 重量W 和强壮程度 S，奶牛们站在彼此的身上，形成一个高高的垂直堆叠，一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>​您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​按照wi + si从小到大排序，最大的危险系数一定是最小的。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> w, s;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);<br>        cow[i] = &#123;s + w, w&#125;;<br>    &#125;<br><br><span class="hljs-built_in">sort</span>(cow, cow + n);<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">-2e9</span>, sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br>    <span class="hljs-comment">//取出当前牛的重量和强壮值</span><br>    <span class="hljs-type">int</span> w = cow[i].second, s = cow[i].first - w;<br>    res = <span class="hljs-built_in">max</span>(res, sum - s);    <span class="hljs-comment">//更新最大的危险系数</span><br>    sum += w;   <span class="hljs-comment">//更新后一头牛所需要承担的重量</span><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绝对值不等式</title>
      <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式<span id="more"></span></h2><h3 id="1、货舱选址："><a href="#1、货舱选址：" class="headerlink" title="1、货舱选址："></a>1、货舱选址：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​在数轴上建立一家货仓，每天清晨，从货仓到数轴上每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​仓库建立在所有商家的中间，即数轴的中位数。即只需要进行排序然后分别求出每个店家与所有店家中位数的距离相加即答案。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<br><span class="hljs-built_in">sort</span>(a, a + n);<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) res += <span class="hljs-built_in">abs</span>(a[i] - a[n / <span class="hljs-number">2</span>]);<br><br>cout &lt;&lt; res;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​数组下标从0或者1开始，与其对应的中位数索引不同。</p><p>​（1）下标从0开始：中位数a[n &#x2F; 2 + 1]</p><p>​（2）下标从1开始：中位数a[n &#x2F; 2]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序不等式</title>
      <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式<span id="more"></span></h2><h3 id="1、排队打水："><a href="#1、排队打水：" class="headerlink" title="1、排队打水："></a>1、排队打水：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​有n个人排队到1个水龙头打水，第i个人装满水桶所需要的时间是t，如何安排他们的打水顺序，才能使所有人等待的时间之和最小？</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​按照打水时间从小到大排序即可，总时间最小</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];<span class="hljs-comment">//读入</span><br><br><span class="hljs-built_in">sort</span>(a, a + n);<span class="hljs-comment">//排序</span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span>  res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br>    res += a[i] * (n - i - <span class="hljs-number">1</span>); <span class="hljs-comment">//每次打水，后面都会有 n - i - 1个人等他</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Huffman树</title>
      <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/Huffman%E6%A0%91/"/>
      <url>/2023/04/04/%E8%B4%AA%E5%BF%83/Huffman%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树<span id="more"></span></h2><h3 id="1、合并果子："><a href="#1、合并果子：" class="headerlink" title="1、合并果子："></a>1、合并果子：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​将若干堆果子合并到一堆，每次可以将任意两堆进行合并。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​每次选取最少的两堆进行合并即可，采用优先队列，即小根堆进行存储所有果子。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap; <span class="hljs-comment">//小根堆定义</span><br>    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    heap.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">//入堆</span><br>&#125;<br><br><span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-type">int</span> a = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//取出堆顶并剔除</span><br>    <span class="hljs-type">int</span> b = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>    res += a + b;<br>        <br>    heap.<span class="hljs-built_in">push</span>(a + b);<span class="hljs-comment">//将合并得到的新堆加入堆中</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​很容易忽略的一点是，没有将合并得到的新堆加入堆中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间贪心</title>
      <link href="/2023/04/04/%E8%B4%AA%E5%BF%83/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/"/>
      <url>/2023/04/04/%E8%B4%AA%E5%BF%83/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="四种区间贪心问题"><a href="#四种区间贪心问题" class="headerlink" title="四种区间贪心问题"></a>四种区间贪心问题<span id="more"></span></h2><h3 id="1、区间选点"><a href="#1、区间选点" class="headerlink" title="1、区间选点"></a>1、区间选点</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>   给定 N 个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。<br>   输出选择的点的最小数量。</p></blockquote><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​（1）定义一个pair&lt;int, int&gt;类型的数组，进行所有区间的维护，将所有区间按右端点从小到大进行排序<br>​（2）从前往后遍历所有区间，如果当前区间与后一个区间没有交集（即后一个区间的左端点大于前一个区间的右端点），相当于把有交集的区间用一个点进行替代，然后答案 ++，更新新区间的右端点<br>​（3）有交集则不用进行任何处理，因为右端点是按照从小到大进行排序的，我们正需要保证右端点是最小的，故当前枚举到的区间右端点就是最小的</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//区间维护</span><br>   PII e[N];<br><br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span> <span class="hljs-comment">//自定义右端点排序</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>   &#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<span class="hljs-comment">//输入区间</span><br>   <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n, cmp);<span class="hljs-comment">//排序</span><br>   <br>   <span class="hljs-type">int</span> ed = <span class="hljs-number">-0x3f3f3f3f</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<span class="hljs-comment">//进行枚举</span><br>   &#123;<br>       <span class="hljs-keyword">if</span> (e[i].x &gt; ed) res ++, ed = e[i].y;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​在区间有交集的时候，一定不要更新右端点了，因为我们需要的就是选定区间中的最小右端点，这与我们按照右端点进行从小到大排序是刚好符合的。</p></blockquote><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote><h3 id="2、最大不相交区间数量"><a href="#2、最大不相交区间数量" class="headerlink" title="2、最大不相交区间数量"></a>2、最大不相交区间数量</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定N个区间[a, b]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。输出可选取区间的最大数量。</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​将所有有交集的区间看作一个区间，因为每次只能选择有交集中的一个，故这样假设没有错，即我们在前往后枚举每个区间的时候，遇到有交集的区间就跳过，只需要在每次遇到没有交集的区间的时候进行统计，步骤如下：</p><p>（1）定义一个pair&lt;int, int&gt;类型的数组，进行所有区间的维护，将所有区间按右端点从小到大进行排序<br>（2）从前往后遍历所有区间，如果当前区间与后一个区间没有交集（即后一个区间的左端点大于前一个区间的右端点），相当于把有交集的区间看作一个区间，然后在遇到没有交集的区间时，答案 ++，更新新区间的右端点<br>（3）有交集则不用进行任何处理，因为我们将他们看作一个区间</p></blockquote><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//区间维护</span><br>   PII e[N];<br><br>   <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span> <span class="hljs-comment">//自定义右端点排序</span></span><br><span class="hljs-function">   </span>&#123;<br>       <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>   &#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<span class="hljs-comment">//输入区间</span><br>   <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n, cmp);<span class="hljs-comment">//排序</span><br>   <br>   <span class="hljs-type">int</span> ed = <span class="hljs-number">-0x3f3f3f3f</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<span class="hljs-comment">//进行枚举</span><br>   &#123;<br>       <span class="hljs-keyword">if</span> (e[i].x &gt; ed) res ++, ed = e[i].y;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote><h3 id="3、区间分组"><a href="#3、区间分组" class="headerlink" title="3、区间分组"></a>3、区间分组</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>给定N个闭区间[a, b]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使组数尽可能小。</p></blockquote><h5 id="核心思路：-2"><a href="#核心思路：-2" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​我们需要思考，想要将当前区间加入到已有的集合中，则必选满足当前区间与某个集合中的所有区间都没有交集，即当前区间的左端点要大于某个集合的所有右端点，贪心一下，我们只需要维护一个小根堆，存入每个组的最大右端点，在判断能否加入当前组的时候，就与堆顶元素（所有组里最小的最大右区间）步骤如下：</p><p>​（1）先将所有区间按照左端点从小到大排序</p><p>​（2）从前往后处理每一个区间</p><p>​（3）判断是否能放入当前某一个组内：能放的条件是当前一个组都没有或者现有的组中，存在一个组的最大右区间，可以用小根堆的堆顶元素作为边界，大于则可以放入现有组，小于等于则无法放入</p><p>​（4）存在这样的组，就把该区间放入组中，更新当前组的max_r</p><p>​（5）不存在这样的组，就重新创建一个组，将该区间放入</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br>PII e[N];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<br>    <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n);<br><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">empty</span>() || e[i].x &lt;= heap.<span class="hljs-built_in">top</span>()) heap.<span class="hljs-built_in">push</span>(e[i].y);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            heap.<span class="hljs-built_in">pop</span>();<br>            heap.<span class="hljs-built_in">push</span>(e[i].y);<br>        &#125;<br>    &#125;<br>cout &lt;&lt; heap.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>这里用小根堆（优先队列），进行维护每一个组的所有区间最大右区间，则堆顶就是所有组的最大右区间的最小值，<br>也就是一个新区间想要加入现有组的条件，即新区间的左端点要大于该条件</p></blockquote><h5 id="证明：-2"><a href="#证明：-2" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote><h3 id="4、区间覆盖"><a href="#4、区间覆盖" class="headerlink" title="4、区间覆盖"></a>4、区间覆盖</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>​给定N个闭区间[a, b]以及一个线性区间[s, t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</p></blockquote><h5 id="核心思路：-3"><a href="#核心思路：-3" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​（1）按照左端点进行排序</p><p>​（2）用双指针算法线性扫描一下所有区间，每次扫描 找出 能覆盖还未覆盖的区间 的左端点的 所有区间中，右端点最大的区间，将start更新为其左端点。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br>PII e[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(PII a, PII b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; e[i].x &gt;&gt; e[i].y;<span class="hljs-comment">//输入</span><br>    <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + <span class="hljs-number">1</span> + n, cmp);<span class="hljs-comment">//排序</span><br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">//答案</span><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//标志位</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i, r = <span class="hljs-number">-2e9</span>;<span class="hljs-comment">//获取当前区间，即e[i] ~ ed</span><br>        <span class="hljs-keyword">while</span> (j &lt;= n &amp;&amp; e[j].x &lt;= st)<span class="hljs-comment">//双指针扫描</span><br>        &#123;<br>            r = <span class="hljs-built_in">max</span>(r, e[j].y);<br>            j ++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (r &lt; st) <span class="hljs-comment">//后面区间无法覆盖，提前结束</span><br>        &#123;<br>            res = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        res ++;<span class="hljs-comment">//可以覆盖，所用区间 ++</span><br>        <br>        <span class="hljs-keyword">if</span> (r &gt;= ed) <span class="hljs-comment">//完全覆盖，标志成功，结束扫描</span><br>        &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        st = r;<span class="hljs-comment">//更新未扫描区间</span><br>        <br>        i = j - <span class="hljs-number">1</span>;<span class="hljs-comment">//由于for循环中i ++,故这里i更新为需要扫描的点j的前一个点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!flag) res = <span class="hljs-number">-1</span>;<br>    cout &lt;&lt; res;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）需要注意的点是几个特判：如果更新后r &lt; st说明剩余区间没有一个区间能够覆盖剩余部分，直接结束扫描，反之则所用的区间 ++；<br>​（2）是当前区间的r &gt;&#x3D; ed，说明需要覆盖的区间已经完全覆盖，标志位设置为true，结束遍历即可。<br>​（3）最后根据标志位判断是否覆盖了全部区间。</p><p>（4）避免遍历重复的区间，但为什么是i &#x3D; j - 1，而不是i &#x3D; j，    因为前j个区间我们已经判断过了，需要判断第j个区间，    但由于for循环结束会i++，如果这里i &#x3D; j，再算上循环结束的i++，    下一次循环遍历的就会是第j + 1个区间，而导致跳过了第j个区间</p></blockquote><h5 id="证明：-3"><a href="#证明：-3" class="headerlink" title="证明："></a>证明：</h5><blockquote><p>略</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2023/04/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/04/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="五种背包问题"><a href="#五种背包问题" class="headerlink" title="五种背包问题"></a>五种背包问题<span id="more"></span></h2><h3 id="1、01背包："><a href="#1、01背包：" class="headerlink" title="1、01背包："></a>1、01背包：</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><blockquote><p>从n个物品中选，每个物品只能选一次或者不选，总体积不超过m的情况下，<br>    求总价值最大。</p></blockquote><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​O(nm)</p><h5 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p>​    状态表示：f[i][j]，从前i个物品中选，其总体积不超过j的前提下，所有选法的总价值的最大值<br>​        属性：max<br>​        状态计算：以最后一个物品是否选择进行划分：<br>​        （1）不选：f[i][j] &#x3D; f[i - 1][j];<br>​        （2）选：if (j &gt;&#x3D; v[i]) f[i][j] &#x3D; max(f[i][j], f[i - 1][j - v[i]] + w[i])<br>​    求方案数时，注意是否需要初始化。<br>​        枚举体积一维的时候，注意是从1开始还是0开始，且枚举体积时由于每次用的是上一层的状态，故需要从后往前枚举。</p></blockquote><h5 id="状态转移方程："><a href="#状态转移方程：" class="headerlink" title="状态转移方程："></a>状态转移方程：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">f[i][j] = f[i - <span class="hljs-number">1</span>][j];  <span class="hljs-comment">//不含i的一定存在</span><br>           <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]);<span class="hljs-comment">//只有背包装的下第i个物品时，才存在这种情况</span><br></code></pre></td></tr></table></figure><h3 id="2、完全背包："><a href="#2、完全背包：" class="headerlink" title="2、完全背包："></a>2、完全背包：</h3><h5 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>从n个物品中选，每个物品可以选无数次，总体积不超过m的情况下，求总价值的<br>    最大值。</p></blockquote><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>O(nm)</p></blockquote><h5 id="分析过程：-1"><a href="#分析过程：-1" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p>状态表示：f[i][j]，从前i个物品中选，其总体积不超过j的前提下，所有选法的总价值的最大值。<br>    属性：max<br>    状态计算：以最后一个物品是否选择划分：<br>    （1）不选：f[i][j] &#x3D; f[i - 1][j]<br>    （2）选：if (j &gt;&#x3D; v[i]) f[i][j] &#x3D; max(f[i][j], f[i][j - v[i]] + w[i]);（优化后的状态转移方程）</p><pre><code class="hljs">求方案数时，注意是否需要初始化。枚举体积一维的时候，注意是从1开始还是0开始，枚举体积时，由于每次用的是本层的状态，故需要从前往后枚举。</code></pre></blockquote><h5 id="状态转移方程：-1"><a href="#状态转移方程：-1" class="headerlink" title="状态转移方程："></a>状态转移方程：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - v[i]] + w[i]);<br></code></pre></td></tr></table></figure><h3 id="3、多重背包："><a href="#3、多重背包：" class="headerlink" title="3、多重背包："></a>3、多重背包：</h3><h5 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>从n个物品中选，每个物品只能选若干次，总体积不超过m的情况下，求总价值的<br>    最大值。</p></blockquote><h5 id="分析过程：-2"><a href="#分析过程：-2" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p> 状态表示：从前i个物品中选，其总体积不超过j的前提下，所有选法的总价值的最大值。<br>    属性：max<br>    状态计算：以最后一个物品是否选择划分：<br>    （1）不选：f[i][j] &#x3D; f[i - 1][j]<br>    （2）选：由于每个物品可以选k次，故需要另外加一层循环，枚举每个物品选几个。<br>        for (int k &#x3D; 0; k &lt;&#x3D; s[i]; k ++)  O(n^3)<br>            if (j &gt;&#x3D; k * v[i]) f[i][j] &#x3D; max(f[i][j], f[i - 1][j - k * v[i]] + w[i] * k);</p><pre><code class="hljs">二进制优化：O(nlogsm)    将每种物品的k个物品，根据二进制进行打包成新的物品，全部打包后看作01背包做即可，注意此时的物品数量就不再是n了，而需要重新计算，并且需要注意此时的空间可能会爆掉，需要优化成一维数组，在优化的时候，由于每次用到的是上一层的状态，故不能先更新前面的状态，否则会影响结果，故需要从大到小枚举体积。    这里开数组时，需要多开一些空间，因为重新打包，物品种类就大于了N</code></pre><p>最坏情况，每种物品都有2000个，1000个物品，就需要打包成log2 * 1000 &#x3D; 11000，再加上我们的数组下标是从1开始存的，所以数组空间至少要开11001；</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++">暴力解：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i]; k ++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &gt;= v[i] * k) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i] * k] + w[i] * k);<br>            &#125;<br>二进制优化：     <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">15000</span>;<br><br>    <span class="hljs-type">int</span> v[N], w[N];<br>    <span class="hljs-type">int</span> f[N];<br>    <span class="hljs-type">int</span> n, m;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-comment">//种数和容量</span><br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>        &#123;<br>            <span class="hljs-type">int</span> a, b, s;    <span class="hljs-comment">//体积、价值、数量</span><br>            cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br><br>            <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt;= s)<br>            &#123;<br>                cnt ++;<br>                v[cnt] = a * k;<br>                w[cnt] = b * k;<br>                s -= k;<br>                k *= <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                cnt ++;<br>                v[cnt] = a * s;<br>                w[cnt] = b * s;<br>            &#125;<br>        &#125;<br><br>        n = cnt;        <span class="hljs-comment">//更新种数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)<br>                f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>        cout &lt;&lt; f[m];<br><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4、分组背包："><a href="#4、分组背包：" class="headerlink" title="4、分组背包："></a>4、分组背包：</h3><h5 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>从n组物品中选，每组物品有若干个，同一组的物品只能选择一个，求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p></blockquote><h5 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(nms)</p></blockquote><h5 id="分析过程：-3"><a href="#分析过程：-3" class="headerlink" title="分析过程："></a>分析过程：</h5><blockquote><p>集合：从n组物品中选，每组物品有若干个，同一组的物品只能选择一个，在总体积不超过j的情况下，所有选法的价值的最大值。<br>    属性：max<br>    状态计算：以最后一个组是否选择划分：<br>    （1）不选，f[i][j] &#x3D; f[i - 1][j]<br>    （2）选，由于每组有k个物品，故需要枚举这k个物品<br>        for (int k &#x3D; 1; k &lt;&#x3D; cnt[i]; k ++)<br>            if (j &gt;&#x3D; v[i][k]) f[i][j] &#x3D; max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)   <span class="hljs-comment">//每组物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j --)  <span class="hljs-comment">//容量</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k ++) <span class="hljs-comment">//枚举所有的选择</span><br>                <span class="hljs-keyword">if</span> (v[i][k] &lt;= j)   <span class="hljs-comment">//只有当容量能装得下，才有选的必要</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br></code></pre></td></tr></table></figure><h3 id="5、混合背包："><a href="#5、混合背包：" class="headerlink" title="5、混合背包："></a>5、混合背包：</h3><h5 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h5><blockquote><p>有 N 种物品和一个容量是 V 的背包。物品有三种，分别是01背包，完全背包，多重背包，求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p></blockquote><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><blockquote><p>01背包、完全背包、多重背包三种背包问题放在一起，在计算状态的时候，判断是哪种背包，就用哪种状态转移方程即可。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> v, w, s;<br>        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>)     <span class="hljs-comment">//完全背包</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v; j &lt;= m; j ++) f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v] + w);<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">//01背包是特殊的多重背包可以一起写，01背包是每种物品只有1件的多重背包</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-number">-1</span>) s = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s; k *= <span class="hljs-number">2</span>) <span class="hljs-comment">//二进制优化多重背包，枚举几个物品分成一个新物品</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= k * v; j --)   <span class="hljs-comment">//枚举每个新物品的体积</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - k * v] + k * w);<br>                s -= k;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (s)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= s * v; j --)   <span class="hljs-comment">//将剩余不够分成新物品的物品，分成一组，枚举其体积</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - s * v] + s * w);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2023/04/03/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/03/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序<span id="more"></span>：</h3><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    关键点就是将入度为0的点全部放入队列中，直到遍历完所有的点，如果队列中点的个数等于图中点的个数，<br>​    说明该图存在拓扑序列。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-type">int</span> res[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (d[i] == <span class="hljs-number">0</span>) <br>        &#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        res[ ++ cnt] = t;<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            d[j] --;<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">0</span>) <br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">topsort</span>())<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i ++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, res[i]);<br>    &#125;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​    （1）找到入度为0的点作根节点<br>​    （2）一定要将所有入度为0的点加入队列<br>​    （3）最后需要进行判断是否所有点都入队了，是则存在拓扑序，反之不存在。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>质数 质因数 约数 公约数 快速幂</title>
      <link href="/2023/04/03/%E6%95%B0%E8%AE%BA/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/04/03/%E6%95%B0%E8%AE%BA/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="质数-质因数-约数-公约数-快速幂"><a href="#质数-质因数-约数-公约数-快速幂" class="headerlink" title="质数 质因数 约数 公约数 快速幂"></a>质数 质因数 约数 公约数 快速幂<span id="more"></span></h2><h3 id="1、质数的判定————试除法"><a href="#1、质数的判定————试除法" class="headerlink" title="1、质数的判定————试除法"></a>1、质数的判定————试除法</h3><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(sqrt(n))</p></blockquote><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    优化： | 表示整除，如果d | n，显然n &#x2F; d | n 一定成立，因为d的约数一定是成对出现的，而这一对就是d 和 n &#x2F; d，<br>故我们在枚举的时候，只需要枚举较小的那个就能判定当前这对是不是该数的约数，如下：<br>​    d &lt;&#x3D; n &#x2F; d， d ^ 2 &lt;&#x3D; n， d &lt;&#x3D; 根号n，就把上面的O(n)的复杂度降到了O(根号n)。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>在判断的时候，一定要记得特判小于2的所有数，都不是质数。</p></blockquote><h3 id="2、分解质因数："><a href="#2、分解质因数：" class="headerlink" title="2、分解质因数："></a>2、分解质因数：</h3><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O（sqrt(N)）</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​从小到大枚举所有数，即从小到大尝试n的所有质因数，并求其次数。</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            n /= i;.<br>            s ++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, s);<br>    &#125;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, n, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）、关于枚举时，为什么一定不会枚举到合数？<br>​    答： 当我们枚举到i时，就说明n当中，已经不包含任何2 ~ i - 1的质因子了，<br>​    然后n能整除i，说明i当中也不包含任何2 ~ i - 1的质因子了，因此i一定是一个质数<br>​（2）、n中最多只包含一个大于sqrt(n)的质因子，故在枚举时，可以先把所有小于sqrt(n)的质因子枚举出来，<br>​最后将大于sqrt(n)的质因子特判输出即可。————————这样时间复杂度就从O(n)降到了O(sqrt(n));</p></blockquote><h3 id="3、线性筛法：筛质数"><a href="#3、线性筛法：筛质数" class="headerlink" title="3、线性筛法：筛质数"></a>3、线性筛法：筛质数</h3><h5 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(n)</p></blockquote><h5 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路:"></a>核心思路:</h5><blockquote><p>​    核心：每一个数i，只会被其最小质因子筛掉。<br>​        分析：在筛掉时候，是从小到大枚举所有质数，每次把当前质数和i的乘积筛掉，当 i % primes[j] &#x3D;&#x3D; 0成立时，<br>​        说明primes[j] 一定是i的最小质因子，因为primes[j]是从小到大枚举的，且所有的质数都放在了primes里。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++)<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><blockquote><p>​    1、因为prime中素数是递增的，所以如果i%prime[j]!&#x3D;0代表i的最小质因数还没有找到，<br>​    即i的最小质因数大于prime[j]。也就是说prime[j]就是iprime[j]的最小质因数，于是iprime[j]被它的最小质因数筛掉了。</p><p>​    2、如果当i%prime[j]&#x3D;&#x3D;0时，代表i的最小质因数是prime[j]，<br>​    那么iprimej+k这个合数的最小质因数就不是prime[j+k]而是prime[j]了。<br>​    所以iprime[j+k]应该被prime[j]筛掉，而不是后续的prime[j+k]。于是在此时break。</p><p>​    3、对于一个合数x，假设primes[j]是x的最小质因子，当i枚举到x &#x2F; primes[j]时，i就会被筛掉，且一定是被其最小质因子筛掉的。</p></blockquote><h3 id="4、试除法求约数"><a href="#4、试除法求约数" class="headerlink" title="4、试除法求约数"></a>4、试除法求约数</h3><h5 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(sqrt(n))</p></blockquote><h5 id="核心思路：-2"><a href="#核心思路：-2" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​试除法求约数：<br>（1）i从1开始，遍历到n &#x2F; int<br>（2）每找到一个约数：<br>​    （2.1）就将它约数放入数组中，<br>​    （2.2）判断一个n &#x2F; i &#x3D;&#x3D; i，如果不相等，就把他放入数组中<br>（3）找完之后sort一下，即可获得从小到大的一个数的约数数组<br>​优化同质数，一个数的约数也是成对出现的，故在枚举时，直接枚举较小的约数即可，即i &lt;&#x3D; sqrt(n)</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / i; i ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>                <span class="hljs-keyword">if</span> (i != n / i) res.<span class="hljs-built_in">push_back</span>(n / i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、约数个数："><a href="#5、约数个数：" class="headerlink" title="5、约数个数："></a>5、约数个数：</h3><h5 id="核心思路：-3"><a href="#核心思路：-3" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    N &#x3D; p1 ^ a1 * p2 ^ a2 * … * pk ^ ak<br>​    则约数个数为cnt &#x3D; (a1 + 1)(a2 + 2)…(ak + 1)，证明：<br>​                                    N &#x3D; p1 ^ a1 * p2 ^ a2 * … * pk ^ ak<br>​    因为N的任意一个约数d，都可以写作d &#x3D; p1 ^ b1 * p2 ^ b2 * … * pk ^ bk, 0 &lt;&#x3D; bi &lt;&#x3D; ai，<br>​    pi每一项的指数b如果不同，则构成的约数就不同，故对于每一个pi都有(ai + 1)种情况，故约数个数就有(ai + 1)个。<br>​    而对于N来说，N的每一个约数，都对应了b1 ~ bk的不同取法，则选法种数即为约数个数，<br>​    故约数个数则为cnt &#x3D; (a1 + 1)(a2 + 1)…(ak + 1)</p><p>​    int范围内，约数个数最多的数只有1500~1600个。</p></blockquote><h5 id="代码模板：-4"><a href="#代码模板：-4" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>  mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br>    <span class="hljs-keyword">while</span> (n --)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++;<br>    &#125;<br>    res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> prime : primes) res = res * (prime.second + <span class="hljs-number">1</span> ) % mod;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​约数个数 &#x3D; 分解质因数后，（所有指数 + 1）相乘</p></blockquote><h3 id="6、约数之和"><a href="#6、约数之和" class="headerlink" title="6、约数之和"></a>6、约数之和</h3><h5 id="核心思路：-4"><a href="#核心思路：-4" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    N &#x3D; p1 ^ a1 * p2 ^ a2 * … * pk ^ ak<br>​    则约数之和为sum &#x3D; (p1 ^ 0 + p1 ^ 1 + … + p1 ^ a1) * … *(pk ^ 0 + pk ^ 1 + … + pk ^ ak)，证明：<br>​    用乘法分配律将上式展开，就是一堆乘积（） + 一堆乘积（） + （）…<br>​    而（）则是从上式括号中每一个括号中任取一项组成的，任意一堆乘积（）都是一个约数，<br>​    故这个公式就是将所有约数加在一起了。</p></blockquote><h5 id="代码模板：-5"><a href="#代码模板：-5" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> res;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><br>    <span class="hljs-keyword">while</span> (n --)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++;<br>    &#125;<br><br>    res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> prime : primes)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = prime.first, b = prime.second;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (b --) t = (t * a + <span class="hljs-number">1</span>) % mod;<br>        res = res * t % mod;<br><br>    &#125;<br>    cout &lt;&lt; res;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​约数之和 &#x3D; 因式分解后（所有幂的0~其指数次方之和）的乘积</p></blockquote><h3 id="7、最大公约数："><a href="#7、最大公约数：" class="headerlink" title="7、最大公约数："></a>7、最大公约数：</h3><h5 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路:"></a>核心思路:</h5><blockquote><p>​    d | a, d | b，则d | (a + b) &#x3D; d | ax + by，<br>​    (a, b)的最大公约数 &#x3D; (b, a % b) 的最大公约数。</p><p>​    证明：a mod b &#x3D; a - (a&#x2F;b) * b &#x3D; a - c * b<br>​    (a, b) &#x3D; (b, a - c * b)，d | a, d | b，所以d | (a - c * b)成立<br>​    d | b, d | a - c * b,则d | a - c * b + c * b，即d | a，所以右边的公约数 &#x3D; 左边的公约数，左边的公约数等于右边的公约数<br>​    故，(a, b) &#x3D; (b, a mod b)成立</p></blockquote><h5 id="代码模板：-6"><a href="#代码模板：-6" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、快速幂："><a href="#8、快速幂：" class="headerlink" title="8、快速幂："></a>8、快速幂：</h3><h5 id="核心思路：-5"><a href="#核心思路：-5" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>反复平方法。<br>    预处理出来一些值：a ^ (2 ^ 0) mod p, a ^ (2 ^ 1) mod p,,,a ^ (2 ^ logk) modp的值,共logk个，<br>    用这些值去组合出a ^ k<br>    a ^ k &#x3D; a ^ (2 ^ x1) * a ^ (2 ^ x2) … * a ^ (2 ^ xt)<br>      &#x3D; a ^ (2 ^ x1 + 2 ^ x2 + …2 ^ xt)，即把k拆分成2^x1,2^x2,,,2^xt这logk个数的和。<br>（1）拆k的方式：把k用二进制表示，把二进制数下是1的位，加上其所属幂位即可，<br>    例k的二进制表示为： 110110，k &#x3D; 2^1 + w^2 + 2^4 + 2^5，<br>（2）如何预处理出我们所需要的值：<br>    第一个数a^(2^0) &#x3D; a^1 &#x3D; a,后面每个数都是前面一个数的平方。</p></blockquote><h5 id="代码模板：-7"><a href="#代码模板：-7" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回的就是a^k % p</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = (LL) res * a % p;  <span class="hljs-comment">//当前位是1，则前位更新到答案中</span><br>        k &gt;&gt;= <span class="hljs-number">1</span>;    <span class="hljs-comment">//算过的位删掉</span><br>        a = (LL) a * a % p;<span class="hljs-comment">//把a变成下一个</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​一定一定要注意每个运算的地方都要进行(long long)的转换，以及 取模%p</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树问题</title>
      <link href="/2023/04/01/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
      <url>/2023/04/01/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="两种最小生成树的解决方法"><a href="#两种最小生成树的解决方法" class="headerlink" title="两种最小生成树的解决方法"></a>两种最小生成树的解决方法<span id="more"></span></h2><h3 id="1、Prim算法："><a href="#1、Prim算法：" class="headerlink" title="1、Prim算法："></a>1、Prim算法：</h3><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​稠密图O(n^2）</p><blockquote><p>​（1）朴素版： O(n^2) —– 邻接矩阵<br>​（2）堆优化版：被kruskal完爆（×）</p></blockquote><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    先从某一个点开始，逐渐把所有点与该点连接起来，每次连通的时候，我们是选择当前这个<br>​    点所在的连通块，与外面连的所有边里，选择一条最短的一条边加入连通块中。每次扩展一个<br>   ​ 点进来，扩展n - 1次即可。</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        res += dist[t];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//表示这个点已经加入集合</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Kruskal算法："><a href="#2、Kruskal算法：" class="headerlink" title="2、Kruskal算法："></a>2、Kruskal算法：</h3><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​稀疏图 并查集 + 快排</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​基于并查集，先将所有边从小到大排序，每一次从小到大枚举所有边，当枚举到某一条边时，<br>   ​ 左边的一个点一定在某个连通块中，右边的点也一定在某一个连通块中，当前枚举的这条边<br>   ​ 可以分为几种情况：<br>  ​  （1）当前这条边连接的两个点已经连通了，那么就不用连接<br>  ​  （2）当前这条边连接的两个点不连通，那么久把这条边加到生成树中。<br>  ​  维护连通性可以用并查集。<br>​直接用结构体存下：a, b, w。</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><span class="hljs-comment">//定义结构体和重载小于号</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Edge &amp;W) <br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//并查集模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span><span class="hljs-comment">//kruskal模板</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m); <span class="hljs-comment">//将所有边的权值相加</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) p[i] = i; <span class="hljs-comment">//初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(a) != <span class="hljs-built_in">find</span>(b)) <span class="hljs-comment">//判断两个点是否在同一个集合里，</span><br>        &#123;<br>            p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);   <span class="hljs-comment">//将两个点连上一条线</span><br>            res += w;   <span class="hljs-comment">//累加集合的权重</span><br>            cnt ++;     <span class="hljs-comment">//每加入一条边到集合里，就累加一次</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;    <span class="hljs-comment">//如果加入集合的次数，小于点的个数减一（n个点需要n-1条边连通），说明不连通</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路问题</title>
      <link href="/2023/03/31/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/31/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="五种最短路的解决方法"><a href="#五种最短路的解决方法" class="headerlink" title="五种最短路的解决方法"></a>五种最短路的解决方法<span id="more"></span></h2><h3 id="1、Dijkstra算法："><a href="#1、Dijkstra算法：" class="headerlink" title="1、Dijkstra算法："></a>1、Dijkstra算法：</h3><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​朴素版 O(n^2)，用于无负权边</p><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​    每次找到集合中距离最短的边进行更新，并用这条确定的最短的边去扩展与他相连通的所有点，<br>​    并更新距离，用st[]数组标记已经找到了最短距离。<br>​稀疏图用邻接矩阵存，反之用邻接表存。</p></blockquote><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）邻接矩阵存边时，可以用g[a][b] &#x3D; min(g[a][b], c)，避免重边和自环，但也要先初始化memset(g,0x3f, sizeof g);</p></blockquote><h5 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//第一个的点到起点的距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)    <span class="hljs-comment">//迭代n次，有n个点需要找到最短距离，每次迭代找一个最短距离</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)   <span class="hljs-comment">//遍历所有点</span><br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<span class="hljs-comment">//找到一条没有确定最短距离，且距离起点最近的一个点</span><br>                t = j;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)   <span class="hljs-comment">//利用已经确定的最短距离，去更新他们邻点到起点的最短距离</span><br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、堆优化版Dijkstra算法："><a href="#2、堆优化版Dijkstra算法：" class="headerlink" title="2、堆优化版Dijkstra算法："></a>2、堆优化版Dijkstra算法：</h3><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(mlogn)，用于无负权边。</p></blockquote><h5 id="核心思路：-1"><a href="#核心思路：-1" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​对朴素版 Dijkstra算法的核心进行优化，就是每次取出的是所有边中最短的边，<br>​我们可以利用小根堆去维护需要遍历的所有边，这样每次取出堆顶元素，即最短的边了。</p></blockquote><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）pair类型的优先队列是按照第一个关键词进行排序的，故第一位只能放距离。<br>​（2）邻接表初始化表头memset(h, -1, sizeof h);<br>​（3）初始化距离数组dist为 INF，便于寻找最短路径。</p></blockquote><h5 id="代码模板：-1"><a href="#代码模板：-1" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    <span class="hljs-comment">//初始化起点到所有的点的距离为无穷大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化第一个点到起点的距离为0</span><br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    <span class="hljs-comment">//创建一个PII类型的优先队列，小根堆</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);  <span class="hljs-comment">//将起点1，距离起点距离0，放入堆中</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) <span class="hljs-comment">//只要堆中还有元素，就进行循环</span><br>    &#123;   <br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">//每次取出堆顶，由于是小根堆，堆顶就是最小元素</span><br>        heap.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//将取出的堆顶删除，这里默认取出来之后，就是对该元素进行操作，表示已经求出了起点到堆顶元素的最小值</span><br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;     <span class="hljs-comment">//取出位置，和距离</span><br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//如果该点已经进行过操作，那么就跳过该元素，用于防止遍历已经操作过的元素了</span><br>        st[ver] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//进行到这一步，说明该点还没有找到最短距离，后续会进行查找，这里提前标记已经找到</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])    <span class="hljs-comment">//对邻接表进行遍历，这里遍历的是h[ver]是ver为表头的邻接表的元素</span><br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];   <span class="hljs-comment">//存下当前点的值</span><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) <span class="hljs-comment">//如果当前的点到起点的距离小于原有距离（初始值或之前本次遍历时获得的值）</span><br>            &#123;<br>                dist[j] = dist[ver] + w[i]; <span class="hljs-comment">//更新dist最短距离的值</span><br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);    <span class="hljs-comment">//将该点的距离和位置放入堆中</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Bellman-ford算法："><a href="#3、Bellman-ford算法：" class="headerlink" title="3、Bellman-ford算法："></a>3、Bellman-ford算法：</h3><h5 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p>​O(nm)，用于有数限制的最短路问题。<br>​与其他最短路算法不同是，Bellman-ford算法需要自己定义一个结构体，进行存边。</p><h5 id="核心思路：-2"><a href="#核心思路：-2" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>​（1）初始化dist数组，并初始化起点的距离<br>​（2）迭代k次，表示只能经过k条边<br>​（3）迭代所有边，即迭代m次，每次迭代前备份一下上一次的dist数组(last)，用于后续更新dist距离，<br>​（4）第m次时迭代更新与起点距离m条边及以内的点的最短距离（松弛）</p></blockquote><h5 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>​（1）if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return 0，因为存在负权边。<br>​（2）每次都遍历会遍历所有边，有很多边是无效的，spfa算法针对这一点进行优化。</p></blockquote><h5 id="代码模板：-2"><a href="#代码模板：-2" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);        <span class="hljs-comment">//初始化所有的点到起点的距离都是无穷大</span><br><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化第一个点到起点的距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)    <span class="hljs-comment">//遍历k次， 表示经过k条边</span><br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(last, dist, <span class="hljs-keyword">sizeof</span> dist);    <span class="hljs-comment">//每次遍历备份一下上一次遍历结果的数组，因为可能在更新的时候，会改变dist，导致后续在更新时值不丢</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)   <span class="hljs-comment">//有m个边需要去遍历,每次求出一条件的路径</span><br>        &#123;<br>            <span class="hljs-keyword">auto</span> e = edges[j];  <span class="hljs-comment">//将每一行的数据值（c）和方向（a-&gt;b）取出</span><br>            dist[e.b] = <span class="hljs-built_in">min</span>(dist[e.b], last[e.a] + e.c);    <span class="hljs-comment">//每次取出直接到达该点的距离和原有距离的最小值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、Spfa算法："><a href="#4、Spfa算法：" class="headerlink" title="4、Spfa算法："></a>4、Spfa算法：</h3><h5 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(m)是对bellman_ford算法中松弛一步的优化。不能含有负权回路。</p></blockquote><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><blockquote><p>​（1）初始化dist数组<br>​（2）定义一个循环队列，将需要更新最短距离的点加入队列中，这样就不用每次去寻找需要更新的边了<br>​（3）遍历队列中的元素，只要该元素所在的连通块中，存在新的最短距离，就将其加入队列中，去更新后面的元素距离。</p></blockquote><h5 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>（1）这里的st[]数组意义和Dijkstra算法不同，<br>        Dijkstra算法中st[]数组表示是否求出最短距离；<br>    Spfa算法中st[]数组表示某个点是否在队列中。<br>    （2）Spfa算法能求含负权边的原因，也是因为（1）中的特性，若存在负权边，就会去重新更新与该点连接的边的最短距离。<br>    （3）Spfa最坏情况是O(nm)<br>    （4）循环队列写法：</p><p>​hh &#x3D; 0, tt &#x3D; 0, q[tt ++] &#x3D; 1;<br>​while (hh !&#x3D; tt);<br>​int t &#x3D; q[hh++];<br>​if (tt &#x3D;&#x3D; N) tt &#x3D; 0;<br>​…<br>​q[tt ++] &#x3D; x;<br>​if (tt &#x3D;&#x3D; N) tt &#x3D; 0;</p><p>​(5)spfa算法最后判断的条件是dist[n] &#x3D;&#x3D; INF的原因是，bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但spfa算法不一样，他相当于采用BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p></blockquote><h5 id="代码模板：-3"><a href="#代码模板：-3" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    <span class="hljs-comment">//初始化最初距离为无穷</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">//初始化第一个点到起点的距离</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;   <span class="hljs-comment">//定义一个队列用于存放待更新的值</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//将起点放进去</span><br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//标记起点在队列中</span><br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())    <span class="hljs-comment">//只要队列中还存在需要更新的值，就继续进行循环</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">//取出队头元素</span><br>        q.<span class="hljs-built_in">pop</span>();    <span class="hljs-comment">//就队头元素删除</span><br><br>        st[t] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//标记该元素已经不在队列中了</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])  <span class="hljs-comment">//对邻接表进行遍历</span><br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];   <span class="hljs-comment">//将值存下来</span><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])       <span class="hljs-comment">//如果队头元素的距离+下一个点的权值小于原有距离（初始化的值或者在之前遍历中所赋有的值）</span><br>            &#123;<br>                dist[j] = dist[t] + w[i];       <span class="hljs-comment">//更新距离</span><br>                <span class="hljs-keyword">if</span> (!st[j])                     <span class="hljs-comment">//如果这个点不在队列中，</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);  <span class="hljs-comment">//就将其加入队列中，并进行标记</span><br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[n];<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、spfa算法判负环："><a href="#5、spfa算法判负环：" class="headerlink" title="5、spfa算法判负环："></a>5、spfa算法判负环：</h3><h5 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(m)</p></blockquote><h5 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h5><blockquote><p>若图中存在负环，那么spfa算法就会一直不断地更新最短距离，故只要我们发现更新次数 &gt;&#x3D; n次，<br>就说明有负环，因为n个点只需要n - 1条边连接，故只需要更新n - 1次。<br>    故我们只需要在每次更新最短距离时，更新cnt[j] &#x3D; cnt[t] + 1即可，最后若更新次数 &gt;&#x3D; n次，就结束循环，返回true。<br>    注意：<br>    （1）这里需要注意，可能负环与起点1，不连通，故需要将所有点都加入到队列中，然后开始spfa算法遍历即可。</p></blockquote><h5 id="代码模板：-4"><a href="#代码模板：-4" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];   <span class="hljs-comment">//更新起点到某一个点的最短距离</span><br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;    <span class="hljs-comment">//更新起点到某一个点的最短距离的更新次数</span><br><br>                <span class="hljs-keyword">if</span> (cnt[t] &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//如果更新次数大于n，说明至少走过了n + 1个点，说明存在循环，即负权回路</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、Floyd算法："><a href="#6、Floyd算法：" class="headerlink" title="6、Floyd算法："></a>6、Floyd算法：</h3><h5 id="时间复杂度：-5"><a href="#时间复杂度：-5" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><blockquote><p>​O(n^3)多源最短路问题。</p></blockquote><h5 id="核心思路：-3"><a href="#核心思路：-3" class="headerlink" title="核心思路："></a>核心思路：</h5><blockquote><p>基于DP：<br>    （1）状态表示：f[k][i][j]<br>        所有从i出发，最终走到j，且中间只经过节点编号不超过k的所有路径。<br>    （2）属性：min<br>    （3）状态计算：<br>        以第i个点是否在路径中进行划分：<br>            所有不包含节点k的路径：d[k - 1][i][j]<br>            所有包含节点k的路径：d[k - 1][i][k] + d[k - 1][k][j]<br>    （4）由于每次用的都是上一层的d，故可以把k层优化掉<br>        即d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j])</p></blockquote><h5 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h5><blockquote><p>（1）初始化：自环设置成d[i][j] &#x3D; 0，其他情况设置成INF，便于求min<br>（2）用邻接矩阵存边，直接d[a][b] &#x3D; min(d[a][b], c);</p></blockquote><h5 id="代码模板：-5"><a href="#代码模板：-5" class="headerlink" title="代码模板："></a>代码模板：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">初始化：<br>（<span class="hljs-number">1</span>）i != j，d[i][j] = <span class="hljs-number">0x3f3f3f3f</span>，无穷，便于后续求最短路<br>（<span class="hljs-number">2</span>）i == j，d[i][j] = <span class="hljs-number">0</span>，自环<br>实现：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br><span class="hljs-comment">//i到j的最小距离距离=原有距离与上一个点的距离到起点的距离+上一点到当前点的距离的最小值</span><br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
